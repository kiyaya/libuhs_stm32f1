
usb_host_dock.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001e4  08000000  08000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001dea0  080001e8  080001e8  000081e8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .ramfunc      00000010  0801e088  0801e088  00026088  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00002b64  0801e098  0801e098  00026098  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.extab    00000974  08020bfc  08020bfc  00028bfc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .ARM          00000700  08021570  08021570  00029570  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .init_array   00000008  08021c70  08021c70  00029c70  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08021c78  08021c78  00029c78  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000900  20000000  08021c80  00030000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .jcr          00000004  20000900  08022580  00030900  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .bss          00002d14  20000908  08022588  00030908  2**3
                  ALLOC
 11 ._user_heap_stack 00008000  2000361c  08022584  0003361c  2**0
                  ALLOC
 12 .ARM.attributes 00000027  00000000  00000000  00030904  2**0
                  CONTENTS, READONLY
 13 .comment      00000011  00000000  00000000  0003092b  2**0
                  CONTENTS, READONLY
 14 .debug_line   00016579  00000000  00000000  0003093c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_info   0005b737  00000000  00000000  00046eb5  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_abbrev 00010d9e  00000000  00000000  000a25ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_aranges 00001a48  00000000  00000000  000b3390  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    000205e4  00000000  00000000  000b4dd8  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_ranges 00001f40  00000000  00000000  000d53c0  2**3
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_macro  00015417  00000000  00000000  000d7300  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_str    00064788  00000000  00000000  000ec717  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_frame  00007900  00000000  00000000  00150ea0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001e8 <deregister_tm_clones>:
 80001e8:	b508      	push	{r3, lr}
 80001ea:	4805      	ldr	r0, [pc, #20]	; (8000200 <deregister_tm_clones+0x18>)
 80001ec:	4b05      	ldr	r3, [pc, #20]	; (8000204 <deregister_tm_clones+0x1c>)
 80001ee:	1a1b      	subs	r3, r3, r0
 80001f0:	2b06      	cmp	r3, #6
 80001f2:	d800      	bhi.n	80001f6 <deregister_tm_clones+0xe>
 80001f4:	bd08      	pop	{r3, pc}
 80001f6:	4b04      	ldr	r3, [pc, #16]	; (8000208 <deregister_tm_clones+0x20>)
 80001f8:	2b00      	cmp	r3, #0
 80001fa:	d0fb      	beq.n	80001f4 <deregister_tm_clones+0xc>
 80001fc:	4798      	blx	r3
 80001fe:	e7f9      	b.n	80001f4 <deregister_tm_clones+0xc>
 8000200:	20000904 	.word	0x20000904
 8000204:	20000907 	.word	0x20000907
 8000208:	00000000 	.word	0x00000000

0800020c <register_tm_clones>:
 800020c:	b508      	push	{r3, lr}
 800020e:	4807      	ldr	r0, [pc, #28]	; (800022c <register_tm_clones+0x20>)
 8000210:	4b07      	ldr	r3, [pc, #28]	; (8000230 <register_tm_clones+0x24>)
 8000212:	1a1b      	subs	r3, r3, r0
 8000214:	109b      	asrs	r3, r3, #2
 8000216:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 800021a:	1059      	asrs	r1, r3, #1
 800021c:	d100      	bne.n	8000220 <register_tm_clones+0x14>
 800021e:	bd08      	pop	{r3, pc}
 8000220:	4a04      	ldr	r2, [pc, #16]	; (8000234 <register_tm_clones+0x28>)
 8000222:	2a00      	cmp	r2, #0
 8000224:	d0fb      	beq.n	800021e <register_tm_clones+0x12>
 8000226:	4790      	blx	r2
 8000228:	e7f9      	b.n	800021e <register_tm_clones+0x12>
 800022a:	bf00      	nop
 800022c:	20000904 	.word	0x20000904
 8000230:	20000904 	.word	0x20000904
 8000234:	00000000 	.word	0x00000000

08000238 <__do_global_dtors_aux>:
 8000238:	b510      	push	{r4, lr}
 800023a:	4c06      	ldr	r4, [pc, #24]	; (8000254 <__do_global_dtors_aux+0x1c>)
 800023c:	7823      	ldrb	r3, [r4, #0]
 800023e:	b943      	cbnz	r3, 8000252 <__do_global_dtors_aux+0x1a>
 8000240:	f7ff ffd2 	bl	80001e8 <deregister_tm_clones>
 8000244:	4b04      	ldr	r3, [pc, #16]	; (8000258 <__do_global_dtors_aux+0x20>)
 8000246:	b113      	cbz	r3, 800024e <__do_global_dtors_aux+0x16>
 8000248:	4804      	ldr	r0, [pc, #16]	; (800025c <__do_global_dtors_aux+0x24>)
 800024a:	f3af 8000 	nop.w
 800024e:	2301      	movs	r3, #1
 8000250:	7023      	strb	r3, [r4, #0]
 8000252:	bd10      	pop	{r4, pc}
 8000254:	20000908 	.word	0x20000908
 8000258:	00000000 	.word	0x00000000
 800025c:	0801e06c 	.word	0x0801e06c

08000260 <frame_dummy>:
 8000260:	b508      	push	{r3, lr}
 8000262:	4b08      	ldr	r3, [pc, #32]	; (8000284 <frame_dummy+0x24>)
 8000264:	b11b      	cbz	r3, 800026e <frame_dummy+0xe>
 8000266:	4808      	ldr	r0, [pc, #32]	; (8000288 <frame_dummy+0x28>)
 8000268:	4908      	ldr	r1, [pc, #32]	; (800028c <frame_dummy+0x2c>)
 800026a:	f3af 8000 	nop.w
 800026e:	4808      	ldr	r0, [pc, #32]	; (8000290 <frame_dummy+0x30>)
 8000270:	6803      	ldr	r3, [r0, #0]
 8000272:	b113      	cbz	r3, 800027a <frame_dummy+0x1a>
 8000274:	4b07      	ldr	r3, [pc, #28]	; (8000294 <frame_dummy+0x34>)
 8000276:	b103      	cbz	r3, 800027a <frame_dummy+0x1a>
 8000278:	4798      	blx	r3
 800027a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800027e:	f7ff bfc5 	b.w	800020c <register_tm_clones>
 8000282:	bf00      	nop
 8000284:	00000000 	.word	0x00000000
 8000288:	0801e06c 	.word	0x0801e06c
 800028c:	2000090c 	.word	0x2000090c
 8000290:	20000900 	.word	0x20000900
 8000294:	00000000 	.word	0x00000000

08000298 <_mainCRTStartup>:
 8000298:	4b15      	ldr	r3, [pc, #84]	; (80002f0 <_mainCRTStartup+0x58>)
 800029a:	2b00      	cmp	r3, #0
 800029c:	bf08      	it	eq
 800029e:	4b13      	ldreq	r3, [pc, #76]	; (80002ec <_mainCRTStartup+0x54>)
 80002a0:	469d      	mov	sp, r3
 80002a2:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
 80002a6:	f04f 0100 	mov.w	r1, #0
 80002aa:	468b      	mov	fp, r1
 80002ac:	460f      	mov	r7, r1
 80002ae:	4813      	ldr	r0, [pc, #76]	; (80002fc <_mainCRTStartup+0x64>)
 80002b0:	4a13      	ldr	r2, [pc, #76]	; (8000300 <_mainCRTStartup+0x68>)
 80002b2:	eba2 0200 	sub.w	r2, r2, r0
 80002b6:	f011 fe4d 	bl	8011f54 <memset>
 80002ba:	4b0e      	ldr	r3, [pc, #56]	; (80002f4 <_mainCRTStartup+0x5c>)
 80002bc:	2b00      	cmp	r3, #0
 80002be:	d000      	beq.n	80002c2 <_mainCRTStartup+0x2a>
 80002c0:	4798      	blx	r3
 80002c2:	4b0d      	ldr	r3, [pc, #52]	; (80002f8 <_mainCRTStartup+0x60>)
 80002c4:	2b00      	cmp	r3, #0
 80002c6:	d000      	beq.n	80002ca <_mainCRTStartup+0x32>
 80002c8:	4798      	blx	r3
 80002ca:	f04f 0000 	mov.w	r0, #0
 80002ce:	f04f 0100 	mov.w	r1, #0
 80002d2:	4604      	mov	r4, r0
 80002d4:	460d      	mov	r5, r1
 80002d6:	480b      	ldr	r0, [pc, #44]	; (8000304 <_mainCRTStartup+0x6c>)
 80002d8:	f010 ffd2 	bl	8011280 <atexit>
 80002dc:	f011 fa26 	bl	801172c <__libc_init_array>
 80002e0:	4620      	mov	r0, r4
 80002e2:	4629      	mov	r1, r5
 80002e4:	f013 fc5f 	bl	8013ba6 <main>
 80002e8:	f010 ffd0 	bl	801128c <exit>
 80002ec:	00080000 	.word	0x00080000
	...
 80002fc:	20000908 	.word	0x20000908
 8000300:	2000361c 	.word	0x2000361c
 8000304:	080112ad 	.word	0x080112ad

08000308 <is_attached>:
	return eLibuhsSuccess;
}

int is_attached(void)
{
	return mpUsbDevice->host.ConnSts;
 8000308:	4b01      	ldr	r3, [pc, #4]	; (8000310 <is_attached+0x8>)
 800030a:	f8d3 0310 	ldr.w	r0, [r3, #784]	; 0x310
}
 800030e:	4770      	bx	lr
 8000310:	20001674 	.word	0x20001674

08000314 <is_low_speed>:

int is_low_speed(void)
{
	return eLibuhsSuccess;
}
 8000314:	2000      	movs	r0, #0
 8000316:	4770      	bx	lr

08000318 <need_second_reset>:
 * @brief	: Once a LS device is attached, we may need a 2nd reset.
 */
int need_second_reset(void)
{
	return mpUsbDevice->host.port_need_reset;
}
 8000318:	4b01      	ldr	r3, [pc, #4]	; (8000320 <need_second_reset+0x8>)
 800031a:	f8d3 05ec 	ldr.w	r0, [r3, #1516]	; 0x5ec
 800031e:	4770      	bx	lr
 8000320:	20001674 	.word	0x20001674

08000324 <get_speed_mode>:

int get_speed_mode(void)
{
	USB_OTG_HPRT0_TypeDef hprt0;
	hprt0.d32 = USB_OTG_READ_REG32(mpUsbDevice->regs.HPRT0);
 8000324:	4b03      	ldr	r3, [pc, #12]	; (8000334 <get_speed_mode+0x10>)
 8000326:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 800032a:	6818      	ldr	r0, [r3, #0]
	return hprt0.b.prtspd;
}
 800032c:	f3c0 4041 	ubfx	r0, r0, #17, #2
 8000330:	4770      	bx	lr
 8000332:	bf00      	nop
 8000334:	20001674 	.word	0x20001674

08000338 <get_received_bytes>:
	return HCD_GetURB_State(mpUsbDevice, pipe_num);
}

int get_received_bytes(uint8_t pipe_num)
{
	return mpUsbDevice->host.XferCnt[pipe_num];
 8000338:	4b02      	ldr	r3, [pc, #8]	; (8000344 <get_received_bytes+0xc>)
 800033a:	30d4      	adds	r0, #212	; 0xd4
 800033c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
 8000340:	4770      	bx	lr
 8000342:	bf00      	nop
 8000344:	20001674 	.word	0x20001674

08000348 <get_sof_hits>:

int get_sof_hits(void)
{
	return mpUsbDevice->host.SofHits;
 8000348:	4b01      	ldr	r3, [pc, #4]	; (8000350 <get_sof_hits+0x8>)
 800034a:	f8d3 05e8 	ldr.w	r0, [r3, #1512]	; 0x5e8
}
 800034e:	4770      	bx	lr
 8000350:	20001674 	.word	0x20001674

08000354 <get_nak_count>:

int get_nak_count(uint8_t pipe_num)
{
	return mpUsbDevice->host.hc[pipe_num].nak_count;
 8000354:	4b03      	ldr	r3, [pc, #12]	; (8000364 <get_nak_count+0x10>)
 8000356:	2224      	movs	r2, #36	; 0x24
 8000358:	fb02 3000 	mla	r0, r2, r0, r3
}
 800035c:	f8b0 03c6 	ldrh.w	r0, [r0, #966]	; 0x3c6
 8000360:	4770      	bx	lr
 8000362:	bf00      	nop
 8000364:	20001674 	.word	0x20001674

08000368 <get_toggle>:
int get_toggle(uint8_t pipe_num, uint8_t direction)
{
	if(direction == tokOUT)
 8000368:	2920      	cmp	r1, #32
 800036a:	d106      	bne.n	800037a <get_toggle+0x12>
		return mpUsbDevice->host.hc[pipe_num].toggle_out;
 800036c:	4b08      	ldr	r3, [pc, #32]	; (8000390 <get_toggle+0x28>)
 800036e:	2224      	movs	r2, #36	; 0x24
 8000370:	fb02 3000 	mla	r0, r2, r0, r3
 8000374:	f890 03c5 	ldrb.w	r0, [r0, #965]	; 0x3c5
 8000378:	4770      	bx	lr
	else if(direction == tokIN)
 800037a:	b931      	cbnz	r1, 800038a <get_toggle+0x22>
		return mpUsbDevice->host.hc[pipe_num].toggle_in;
 800037c:	4b04      	ldr	r3, [pc, #16]	; (8000390 <get_toggle+0x28>)
 800037e:	2224      	movs	r2, #36	; 0x24
 8000380:	fb02 3000 	mla	r0, r2, r0, r3
 8000384:	f890 03c4 	ldrb.w	r0, [r0, #964]	; 0x3c4
 8000388:	4770      	bx	lr
	else
		return eLibuhsErrorInvalidParam;
 800038a:	f04f 30ff 	mov.w	r0, #4294967295
}
 800038e:	4770      	bx	lr
 8000390:	20001674 	.word	0x20001674

08000394 <set_toggle>:

int set_toggle(uint8_t pipe_num, uint8_t direction, uint8_t new_toggle)
{
	new_toggle &= 0x1;
	if(direction == tokOUT)
 8000394:	2920      	cmp	r1, #32
	else
		return eLibuhsErrorInvalidParam;
}

int set_toggle(uint8_t pipe_num, uint8_t direction, uint8_t new_toggle)
{
 8000396:	b510      	push	{r4, lr}
	new_toggle &= 0x1;
 8000398:	f002 0201 	and.w	r2, r2, #1
	if(direction == tokOUT)
 800039c:	d107      	bne.n	80003ae <set_toggle+0x1a>
		mpUsbDevice->host.hc[pipe_num].toggle_out = new_toggle;
 800039e:	4b09      	ldr	r3, [pc, #36]	; (80003c4 <set_toggle+0x30>)
 80003a0:	2124      	movs	r1, #36	; 0x24
 80003a2:	fb01 3000 	mla	r0, r1, r0, r3
 80003a6:	f880 23c5 	strb.w	r2, [r0, #965]	; 0x3c5
	else if(direction == tokIN)
		mpUsbDevice->host.hc[pipe_num].toggle_in = new_toggle;
	else
		return eLibuhsErrorInvalidParam;
	return eLibuhsSuccess;
 80003aa:	2000      	movs	r0, #0
 80003ac:	bd10      	pop	{r4, pc}
int set_toggle(uint8_t pipe_num, uint8_t direction, uint8_t new_toggle)
{
	new_toggle &= 0x1;
	if(direction == tokOUT)
		mpUsbDevice->host.hc[pipe_num].toggle_out = new_toggle;
	else if(direction == tokIN)
 80003ae:	b931      	cbnz	r1, 80003be <set_toggle+0x2a>
		mpUsbDevice->host.hc[pipe_num].toggle_in = new_toggle;
 80003b0:	4b04      	ldr	r3, [pc, #16]	; (80003c4 <set_toggle+0x30>)
 80003b2:	2424      	movs	r4, #36	; 0x24
 80003b4:	fb04 3000 	mla	r0, r4, r0, r3
 80003b8:	f880 23c4 	strb.w	r2, [r0, #964]	; 0x3c4
 80003bc:	e7f5      	b.n	80003aa <set_toggle+0x16>
	else
		return eLibuhsErrorInvalidParam;
 80003be:	f04f 30ff 	mov.w	r0, #4294967295
	return eLibuhsSuccess;
}
 80003c2:	bd10      	pop	{r4, pc}
 80003c4:	20001674 	.word	0x20001674

080003c8 <key_released>:
{
    //if(mpKeyDev != NULL) {
    //	if(OemToAscii(mod, key) || isLockingKey(key))
    //		mpKeyDev->SendUSBKeyMessage(key, mod);
    //};
}
 80003c8:	4770      	bx	lr

080003ca <mouse_activated>:

			mpMouseDev->UpdateState(button, mi->dX, mi->dY);
			mpMouseDev->Run();
		}
	#endif
}
 80003ca:	4770      	bx	lr

080003cc <control_in_transfer>:
		return eLibuhsErrorInvalidParam;
	}
}

int control_in_transfer(uint8_t *buf, uint16_t length, uint8_t pipe_num, uint8_t devAddr, uint8_t ep, uint8_t mps)
{
 80003cc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	return USBH_CtlReceiveData(mpUsbDevice, buf, length, pipe_num, devAddr, ep, mps);
 80003ce:	9300      	str	r3, [sp, #0]
 80003d0:	f89d 3020 	ldrb.w	r3, [sp, #32]
		return eLibuhsErrorInvalidParam;
	}
}

int control_in_transfer(uint8_t *buf, uint16_t length, uint8_t pipe_num, uint8_t devAddr, uint8_t ep, uint8_t mps)
{
 80003d4:	4606      	mov	r6, r0
	return USBH_CtlReceiveData(mpUsbDevice, buf, length, pipe_num, devAddr, ep, mps);
 80003d6:	9301      	str	r3, [sp, #4]
 80003d8:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
		return eLibuhsErrorInvalidParam;
	}
}

int control_in_transfer(uint8_t *buf, uint16_t length, uint8_t pipe_num, uint8_t devAddr, uint8_t ep, uint8_t mps)
{
 80003dc:	460d      	mov	r5, r1
 80003de:	4614      	mov	r4, r2
	return USBH_CtlReceiveData(mpUsbDevice, buf, length, pipe_num, devAddr, ep, mps);
 80003e0:	9302      	str	r3, [sp, #8]
 80003e2:	4631      	mov	r1, r6
 80003e4:	462a      	mov	r2, r5
 80003e6:	4623      	mov	r3, r4
 80003e8:	4802      	ldr	r0, [pc, #8]	; (80003f4 <control_in_transfer+0x28>)
 80003ea:	f007 fd2e 	bl	8007e4a <USBH_CtlReceiveData>
}
 80003ee:	b004      	add	sp, #16
 80003f0:	bd70      	pop	{r4, r5, r6, pc}
 80003f2:	bf00      	nop
 80003f4:	20001674 	.word	0x20001674

080003f8 <in_transfer>:
{
	return USBH_BulkSendData(mpUsbDevice, buf, length, pipe_num, ep, mps);
}

int in_transfer(uint8_t *buf, uint16_t length, uint8_t pipe_num, uint8_t devAddr, uint8_t ep, uint8_t mps)
{
 80003f8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	return USBH_BulkReceiveData(mpUsbDevice, buf, length, pipe_num, devAddr, ep, mps);
 80003fa:	9300      	str	r3, [sp, #0]
 80003fc:	f89d 3020 	ldrb.w	r3, [sp, #32]
{
	return USBH_BulkSendData(mpUsbDevice, buf, length, pipe_num, ep, mps);
}

int in_transfer(uint8_t *buf, uint16_t length, uint8_t pipe_num, uint8_t devAddr, uint8_t ep, uint8_t mps)
{
 8000400:	4606      	mov	r6, r0
	return USBH_BulkReceiveData(mpUsbDevice, buf, length, pipe_num, devAddr, ep, mps);
 8000402:	9301      	str	r3, [sp, #4]
 8000404:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
{
	return USBH_BulkSendData(mpUsbDevice, buf, length, pipe_num, ep, mps);
}

int in_transfer(uint8_t *buf, uint16_t length, uint8_t pipe_num, uint8_t devAddr, uint8_t ep, uint8_t mps)
{
 8000408:	460d      	mov	r5, r1
 800040a:	4614      	mov	r4, r2
	return USBH_BulkReceiveData(mpUsbDevice, buf, length, pipe_num, devAddr, ep, mps);
 800040c:	9302      	str	r3, [sp, #8]
 800040e:	4631      	mov	r1, r6
 8000410:	462a      	mov	r2, r5
 8000412:	4623      	mov	r3, r4
 8000414:	4802      	ldr	r0, [pc, #8]	; (8000420 <in_transfer+0x28>)
 8000416:	f007 fd43 	bl	8007ea0 <USBH_BulkReceiveData>
}
 800041a:	b004      	add	sp, #16
 800041c:	bd70      	pop	{r4, r5, r6, pc}
 800041e:	bf00      	nop
 8000420:	20001674 	.word	0x20001674

08000424 <out_transfer>:
		return eLibuhsErrorInvalidParam;
	return eLibuhsSuccess;
}

int out_transfer(const uint8_t *buf, uint16_t length, uint8_t pipe_num, uint8_t ep, uint8_t mps)
{
 8000424:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return USBH_BulkSendData(mpUsbDevice, buf, length, pipe_num, ep, mps);
 8000426:	9300      	str	r3, [sp, #0]
 8000428:	f89d 3018 	ldrb.w	r3, [sp, #24]
		return eLibuhsErrorInvalidParam;
	return eLibuhsSuccess;
}

int out_transfer(const uint8_t *buf, uint16_t length, uint8_t pipe_num, uint8_t ep, uint8_t mps)
{
 800042c:	4606      	mov	r6, r0
 800042e:	460d      	mov	r5, r1
 8000430:	4614      	mov	r4, r2
	return USBH_BulkSendData(mpUsbDevice, buf, length, pipe_num, ep, mps);
 8000432:	9301      	str	r3, [sp, #4]
 8000434:	4631      	mov	r1, r6
 8000436:	462a      	mov	r2, r5
 8000438:	4623      	mov	r3, r4
 800043a:	4802      	ldr	r0, [pc, #8]	; (8000444 <out_transfer+0x20>)
 800043c:	f007 fd18 	bl	8007e70 <USBH_BulkSendData>
}
 8000440:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
 8000442:	bf00      	nop
 8000444:	20001674 	.word	0x20001674

08000448 <get_urb_status>:

	return rcode;
}

int get_urb_status(uint8_t pipe_num)
{
 8000448:	4601      	mov	r1, r0
 800044a:	b508      	push	{r3, lr}
	return HCD_GetURB_State(mpUsbDevice, pipe_num);
 800044c:	4801      	ldr	r0, [pc, #4]	; (8000454 <get_urb_status+0xc>)
 800044e:	f006 f8e0 	bl	8006612 <HCD_GetURB_State>
}
 8000452:	bd08      	pop	{r3, pc}
 8000454:	20001674 	.word	0x20001674

08000458 <get_pipe_status>:
	HCD_ResetPort(mpUsbDevice);
	return eLibuhsSuccess;
}

int get_pipe_status(uint8_t pipe_num)
{
 8000458:	b508      	push	{r3, lr}
 800045a:	4601      	mov	r1, r0
	#define hrCRCERR    0x0B
	#define hrKERR      0x0C
	#define hrJERR      0x0D
	#define hrBUSY
					  */
	uint8_t pipe_status = HCD_GetHCState(mpUsbDevice, pipe_num);
 800045c:	480c      	ldr	r0, [pc, #48]	; (8000490 <get_pipe_status+0x38>)
 800045e:	f006 f8e0 	bl	8006622 <HCD_GetHCState>
	uint8_t rcode = hrSUCCESS;

	switch(pipe_status) {
 8000462:	2808      	cmp	r0, #8
 8000464:	d813      	bhi.n	800048e <get_pipe_status+0x36>
 8000466:	e8df f000 	tbb	[pc, r0]
 800046a:	050d      	.short	0x050d
 800046c:	070d110d 	.word	0x070d110d
 8000470:	090f      	.short	0x090f
 8000472:	0b          	.byte	0x0b
 8000473:	00          	.byte	0x00
		case HC_XFRC:
			rcode = hrSUCCESS;
 8000474:	2000      	movs	r0, #0
 8000476:	bd08      	pop	{r3, pc}
			break;
		case HC_NAK:
			rcode = hrNAK;
			break;
		case HC_STALL:
			rcode = hrSTALL;
 8000478:	2005      	movs	r0, #5
			break;
 800047a:	bd08      	pop	{r3, pc}
		case HC_BBLERR:
			rcode = hrBABBLE;
 800047c:	200f      	movs	r0, #15
			break;
 800047e:	bd08      	pop	{r3, pc}
		case HC_DATATGLERR:
			rcode = hrTOGERR;
 8000480:	2006      	movs	r0, #6
			break;
 8000482:	bd08      	pop	{r3, pc}
		case HC_HALTED:
		case HC_NYET:
		case HC_IDLE:	//todo: what does this mean?
			rcode = hrPKTERR;	// no matching error, so just use pkterr tempxxly
 8000484:	200a      	movs	r0, #10
			break;
 8000486:	bd08      	pop	{r3, pc}
		case HC_XACTERR:
			rcode = hrTIMEOUT;
 8000488:	200e      	movs	r0, #14
			break;
 800048a:	bd08      	pop	{r3, pc}
	switch(pipe_status) {
		case HC_XFRC:
			rcode = hrSUCCESS;
			break;
		case HC_NAK:
			rcode = hrNAK;
 800048c:	2004      	movs	r0, #4
			rcode = pipe_status;
			break;
	}

	return rcode;
}
 800048e:	bd08      	pop	{r3, pc}
 8000490:	20001674 	.word	0x20001674

08000494 <reset_device>:
	return hprt0.b.prtspd;
}

int reset_device(void)
{
	mpUsbDevice->host.port_need_reset = 0;
 8000494:	4805      	ldr	r0, [pc, #20]	; (80004ac <reset_device+0x18>)
	hprt0.d32 = USB_OTG_READ_REG32(mpUsbDevice->regs.HPRT0);
	return hprt0.b.prtspd;
}

int reset_device(void)
{
 8000496:	b510      	push	{r4, lr}
	mpUsbDevice->host.port_need_reset = 0;
 8000498:	2400      	movs	r4, #0
 800049a:	f8c0 45ec 	str.w	r4, [r0, #1516]	; 0x5ec
	mpUsbDevice->host.SofHits = 0;
 800049e:	f8c0 45e8 	str.w	r4, [r0, #1512]	; 0x5e8
	HCD_ResetPort(mpUsbDevice);
 80004a2:	f006 f8aa 	bl	80065fa <HCD_ResetPort>
	return eLibuhsSuccess;
}
 80004a6:	4620      	mov	r0, r4
 80004a8:	bd10      	pop	{r4, pc}
 80004aa:	bf00      	nop
 80004ac:	20001674 	.word	0x20001674

080004b0 <device_removed>:
	}
	return (in_pipe_num | (out_pipe_num << 4));
}

int device_removed(uint8_t pipe_num)
{
 80004b0:	b538      	push	{r3, r4, r5, lr}
	USB_OTG_HC_Halt(mpUsbDevice, pipe_num);
 80004b2:	4d06      	ldr	r5, [pc, #24]	; (80004cc <device_removed+0x1c>)
	}
	return (in_pipe_num | (out_pipe_num << 4));
}

int device_removed(uint8_t pipe_num)
{
 80004b4:	4604      	mov	r4, r0
	USB_OTG_HC_Halt(mpUsbDevice, pipe_num);
 80004b6:	4621      	mov	r1, r4
 80004b8:	4628      	mov	r0, r5
 80004ba:	f006 f818 	bl	80064ee <USB_OTG_HC_Halt>
	USBH_Free_Channel(mpUsbDevice, pipe_num);
 80004be:	4628      	mov	r0, r5
 80004c0:	4621      	mov	r1, r4
 80004c2:	f007 fc51 	bl	8007d68 <USBH_Free_Channel>

	return eLibuhsSuccess;
}
 80004c6:	2000      	movs	r0, #0
 80004c8:	bd38      	pop	{r3, r4, r5, pc}
 80004ca:	bf00      	nop
 80004cc:	20001674 	.word	0x20001674

080004d0 <device_added>:
}

int device_added(uint8_t dev_addr, uint8_t is_low_speed, uint8_t nak_limit,
		uint8_t out_ep_addr, uint8_t out_ep_pkt_size, uint8_t out_ep_type,
		uint8_t in_ep_addr, uint8_t in_ep_pkt_size, uint8_t in_ep_type)
{
 80004d0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 80004d4:	4607      	mov	r7, r0
 80004d6:	460e      	mov	r6, r1
 80004d8:	4690      	mov	r8, r2
 80004da:	f89d 4030 	ldrb.w	r4, [sp, #48]	; 0x30
	uint8_t out_pipe_num = 0, in_pipe_num = 0;

	if(out_ep_addr != 0)
 80004de:	b1b3      	cbz	r3, 800050e <device_added+0x3e>
	{
		out_pipe_num = USBH_Alloc_Channel(mpUsbDevice, out_ep_addr);	//Out, addr = 0x01
 80004e0:	4619      	mov	r1, r3
 80004e2:	4819      	ldr	r0, [pc, #100]	; (8000548 <device_added+0x78>)
 80004e4:	f007 fc27 	bl	8007d36 <USBH_Alloc_Channel>
		USBH_Open_Channel(mpUsbDevice, out_pipe_num, dev_addr,
 80004e8:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
{
	uint8_t out_pipe_num = 0, in_pipe_num = 0;

	if(out_ep_addr != 0)
	{
		out_pipe_num = USBH_Alloc_Channel(mpUsbDevice, out_ep_addr);	//Out, addr = 0x01
 80004ec:	4605      	mov	r5, r0
		USBH_Open_Channel(mpUsbDevice, out_pipe_num, dev_addr,
 80004ee:	9300      	str	r3, [sp, #0]
 80004f0:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 80004f4:	f8cd 8008 	str.w	r8, [sp, #8]
 80004f8:	9301      	str	r3, [sp, #4]
 80004fa:	4629      	mov	r1, r5
 80004fc:	463a      	mov	r2, r7
 80004fe:	2e00      	cmp	r6, #0
 8000500:	bf0c      	ite	eq
 8000502:	2301      	moveq	r3, #1
 8000504:	2302      	movne	r3, #2
 8000506:	4810      	ldr	r0, [pc, #64]	; (8000548 <device_added+0x78>)
 8000508:	f007 fbc2 	bl	8007c90 <USBH_Open_Channel>
 800050c:	e000      	b.n	8000510 <device_added+0x40>

int device_added(uint8_t dev_addr, uint8_t is_low_speed, uint8_t nak_limit,
		uint8_t out_ep_addr, uint8_t out_ep_pkt_size, uint8_t out_ep_type,
		uint8_t in_ep_addr, uint8_t in_ep_pkt_size, uint8_t in_ep_type)
{
	uint8_t out_pipe_num = 0, in_pipe_num = 0;
 800050e:	461d      	mov	r5, r3
	{
		out_pipe_num = USBH_Alloc_Channel(mpUsbDevice, out_ep_addr);	//Out, addr = 0x01
		USBH_Open_Channel(mpUsbDevice, out_pipe_num, dev_addr,
			(is_low_speed) ? bmLOWSPEED : bmFULLSPEED, out_ep_type, out_ep_pkt_size, nak_limit);
	}
	if(in_ep_addr != 0)
 8000510:	b1ac      	cbz	r4, 800053e <device_added+0x6e>
	{
		in_pipe_num = USBH_Alloc_Channel(mpUsbDevice, in_ep_addr);		//In, addr = 0x82
 8000512:	4621      	mov	r1, r4
 8000514:	480c      	ldr	r0, [pc, #48]	; (8000548 <device_added+0x78>)
 8000516:	f007 fc0e 	bl	8007d36 <USBH_Alloc_Channel>
		USBH_Open_Channel(mpUsbDevice, in_pipe_num, dev_addr,
 800051a:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
		USBH_Open_Channel(mpUsbDevice, out_pipe_num, dev_addr,
			(is_low_speed) ? bmLOWSPEED : bmFULLSPEED, out_ep_type, out_ep_pkt_size, nak_limit);
	}
	if(in_ep_addr != 0)
	{
		in_pipe_num = USBH_Alloc_Channel(mpUsbDevice, in_ep_addr);		//In, addr = 0x82
 800051e:	4604      	mov	r4, r0
		USBH_Open_Channel(mpUsbDevice, in_pipe_num, dev_addr,
 8000520:	9300      	str	r3, [sp, #0]
 8000522:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
 8000526:	f8cd 8008 	str.w	r8, [sp, #8]
 800052a:	9301      	str	r3, [sp, #4]
 800052c:	4806      	ldr	r0, [pc, #24]	; (8000548 <device_added+0x78>)
 800052e:	4621      	mov	r1, r4
 8000530:	463a      	mov	r2, r7
 8000532:	2e00      	cmp	r6, #0
 8000534:	bf0c      	ite	eq
 8000536:	2301      	moveq	r3, #1
 8000538:	2302      	movne	r3, #2
 800053a:	f007 fba9 	bl	8007c90 <USBH_Open_Channel>
			(is_low_speed) ? bmLOWSPEED : bmFULLSPEED, in_ep_type, in_ep_pkt_size, nak_limit);
	}
	return (in_pipe_num | (out_pipe_num << 4));
}
 800053e:	ea44 1005 	orr.w	r0, r4, r5, lsl #4
 8000542:	b004      	add	sp, #16
 8000544:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000548:	20001674 	.word	0x20001674

0800054c <device_attached>:

USB_OTG_CORE_HANDLE USB_OTG_Core_dev;
static USB_OTG_CORE_HANDLE *mpUsbDevice = &USB_OTG_Core_dev;

int device_attached(uint8_t is_low_speed, uint8_t nak_limit)
{
 800054c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8000550:	460c      	mov	r4, r1
 8000552:	b085      	sub	sp, #20
	//USBH_Open_Channel(pdev, epInfo.hcNumOut, 0x0, (lowspeed)?bmLOWSPEED:bmFULLSPEED, EP_TYPE_CTRL, 0x8);
	//USBH_Open_Channel(pdev, epInfo.hcNumIn,	0x0, (lowspeed)?bmLOWSPEED:bmFULLSPEED, EP_TYPE_CTRL, 0x8);

	uint8_t out_pipe_num, in_pipe_num;

    USBH_Free_Channel(mpUsbDevice, 0);
 8000554:	2100      	movs	r1, #0

USB_OTG_CORE_HANDLE USB_OTG_Core_dev;
static USB_OTG_CORE_HANDLE *mpUsbDevice = &USB_OTG_Core_dev;

int device_attached(uint8_t is_low_speed, uint8_t nak_limit)
{
 8000556:	4607      	mov	r7, r0
	//USBH_Open_Channel(pdev, epInfo.hcNumOut, 0x0, (lowspeed)?bmLOWSPEED:bmFULLSPEED, EP_TYPE_CTRL, 0x8);
	//USBH_Open_Channel(pdev, epInfo.hcNumIn,	0x0, (lowspeed)?bmLOWSPEED:bmFULLSPEED, EP_TYPE_CTRL, 0x8);

	uint8_t out_pipe_num, in_pipe_num;

    USBH_Free_Channel(mpUsbDevice, 0);
 8000558:	481d      	ldr	r0, [pc, #116]	; (80005d0 <device_attached+0x84>)
 800055a:	f007 fc05 	bl	8007d68 <USBH_Free_Channel>
    USBH_Free_Channel(mpUsbDevice, 1);
 800055e:	2101      	movs	r1, #1
 8000560:	481b      	ldr	r0, [pc, #108]	; (80005d0 <device_attached+0x84>)
 8000562:	f007 fc01 	bl	8007d68 <USBH_Free_Channel>
	out_pipe_num = USBH_Alloc_Channel(mpUsbDevice, 0x00);	// ep_addr = 0
 8000566:	2100      	movs	r1, #0
 8000568:	4819      	ldr	r0, [pc, #100]	; (80005d0 <device_attached+0x84>)
 800056a:	f007 fbe4 	bl	8007d36 <USBH_Alloc_Channel>
	in_pipe_num = USBH_Alloc_Channel(mpUsbDevice, 0x80);
 800056e:	2180      	movs	r1, #128	; 0x80

	uint8_t out_pipe_num, in_pipe_num;

    USBH_Free_Channel(mpUsbDevice, 0);
    USBH_Free_Channel(mpUsbDevice, 1);
	out_pipe_num = USBH_Alloc_Channel(mpUsbDevice, 0x00);	// ep_addr = 0
 8000570:	4606      	mov	r6, r0
	in_pipe_num = USBH_Alloc_Channel(mpUsbDevice, 0x80);
 8000572:	4817      	ldr	r0, [pc, #92]	; (80005d0 <device_attached+0x84>)
 8000574:	f007 fbdf 	bl	8007d36 <USBH_Alloc_Channel>

    nak_limit = (0x0001UL << ((nak_limit > USB_NAK_MAX_POWER) ? USB_NAK_MAX_POWER : nak_limit));
 8000578:	2c0f      	cmp	r4, #15
 800057a:	bf9d      	ittte	ls
 800057c:	f04f 0801 	movls.w	r8, #1
 8000580:	fa08 f404 	lslls.w	r4, r8, r4
 8000584:	b2e4      	uxtbls	r4, r4
 8000586:	2400      	movhi	r4, #0
    nak_limit--;
 8000588:	3c01      	subs	r4, #1
 800058a:	fa5f f884 	uxtb.w	r8, r4

	USBH_Open_Channel(mpUsbDevice, out_pipe_num, 0x0, (is_low_speed)?bmLOWSPEED:bmFULLSPEED, EP_TYPE_CTRL, 0x8, nak_limit);
 800058e:	2f00      	cmp	r7, #0
 8000590:	bf0c      	ite	eq
 8000592:	2701      	moveq	r7, #1
 8000594:	2702      	movne	r7, #2
 8000596:	2400      	movs	r4, #0
 8000598:	f04f 0908 	mov.w	r9, #8
	uint8_t out_pipe_num, in_pipe_num;

    USBH_Free_Channel(mpUsbDevice, 0);
    USBH_Free_Channel(mpUsbDevice, 1);
	out_pipe_num = USBH_Alloc_Channel(mpUsbDevice, 0x00);	// ep_addr = 0
	in_pipe_num = USBH_Alloc_Channel(mpUsbDevice, 0x80);
 800059c:	4605      	mov	r5, r0

    nak_limit = (0x0001UL << ((nak_limit > USB_NAK_MAX_POWER) ? USB_NAK_MAX_POWER : nak_limit));
    nak_limit--;

	USBH_Open_Channel(mpUsbDevice, out_pipe_num, 0x0, (is_low_speed)?bmLOWSPEED:bmFULLSPEED, EP_TYPE_CTRL, 0x8, nak_limit);
 800059e:	4631      	mov	r1, r6
 80005a0:	4622      	mov	r2, r4
 80005a2:	463b      	mov	r3, r7
 80005a4:	e88d 0210 	stmia.w	sp, {r4, r9}
 80005a8:	f8cd 8008 	str.w	r8, [sp, #8]
 80005ac:	4808      	ldr	r0, [pc, #32]	; (80005d0 <device_attached+0x84>)
 80005ae:	f007 fb6f 	bl	8007c90 <USBH_Open_Channel>
	USBH_Open_Channel(mpUsbDevice, in_pipe_num, 0x0, (is_low_speed)?bmLOWSPEED:bmFULLSPEED, EP_TYPE_CTRL, 0x8, nak_limit);
 80005b2:	e88d 0210 	stmia.w	sp, {r4, r9}
 80005b6:	f8cd 8008 	str.w	r8, [sp, #8]
 80005ba:	4629      	mov	r1, r5
 80005bc:	4622      	mov	r2, r4
 80005be:	463b      	mov	r3, r7
 80005c0:	4803      	ldr	r0, [pc, #12]	; (80005d0 <device_attached+0x84>)
 80005c2:	f007 fb65 	bl	8007c90 <USBH_Open_Channel>

	return (in_pipe_num | (out_pipe_num << 4));
}
 80005c6:	ea45 1006 	orr.w	r0, r5, r6, lsl #4
 80005ca:	b005      	add	sp, #20
 80005cc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80005d0:	20001674 	.word	0x20001674

080005d4 <control_out_transfer>:
{
	return USBH_BulkReceiveData(mpUsbDevice, buf, length, pipe_num, devAddr, ep, mps);
}

int control_out_transfer(uint8_t token, const uint8_t *buf, uint8_t pipe_num, uint8_t devAddr, uint8_t ep, uint8_t mps)
{
 80005d4:	b5f0      	push	{r4, r5, r6, r7, lr}
	if(token == tokSETUP)
 80005d6:	2810      	cmp	r0, #16
{
	return USBH_BulkReceiveData(mpUsbDevice, buf, length, pipe_num, devAddr, ep, mps);
}

int control_out_transfer(uint8_t token, const uint8_t *buf, uint8_t pipe_num, uint8_t devAddr, uint8_t ep, uint8_t mps)
{
 80005d8:	b085      	sub	sp, #20
 80005da:	4616      	mov	r6, r2
 80005dc:	461f      	mov	r7, r3
 80005de:	f89d 5028 	ldrb.w	r5, [sp, #40]	; 0x28
 80005e2:	f89d 402c 	ldrb.w	r4, [sp, #44]	; 0x2c
	if(token == tokSETUP)
 80005e6:	d107      	bne.n	80005f8 <control_out_transfer+0x24>
	{
		return USBH_CtlSendSetup(mpUsbDevice, buf, pipe_num, devAddr, ep, mps);
 80005e8:	480b      	ldr	r0, [pc, #44]	; (8000618 <control_out_transfer+0x44>)
 80005ea:	950a      	str	r5, [sp, #40]	; 0x28
 80005ec:	940b      	str	r4, [sp, #44]	; 0x2c
	} else if(token == tokOUTHS) {
		return USBH_CtlSendData(mpUsbDevice, buf, 0, pipe_num, devAddr, ep, mps);
	} else {
		return eLibuhsErrorInvalidParam;
	}
}
 80005ee:	b005      	add	sp, #20
 80005f0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}

int control_out_transfer(uint8_t token, const uint8_t *buf, uint8_t pipe_num, uint8_t devAddr, uint8_t ep, uint8_t mps)
{
	if(token == tokSETUP)
	{
		return USBH_CtlSendSetup(mpUsbDevice, buf, pipe_num, devAddr, ep, mps);
 80005f4:	f007 bbf7 	b.w	8007de6 <USBH_CtlSendSetup>
	} else if(token == tokOUTHS) {
 80005f8:	28a0      	cmp	r0, #160	; 0xa0
 80005fa:	d108      	bne.n	800060e <control_out_transfer+0x3a>
		return USBH_CtlSendData(mpUsbDevice, buf, 0, pipe_num, devAddr, ep, mps);
 80005fc:	9300      	str	r3, [sp, #0]
 80005fe:	9501      	str	r5, [sp, #4]
 8000600:	9402      	str	r4, [sp, #8]
 8000602:	2200      	movs	r2, #0
 8000604:	4633      	mov	r3, r6
 8000606:	4804      	ldr	r0, [pc, #16]	; (8000618 <control_out_transfer+0x44>)
 8000608:	f007 fc01 	bl	8007e0e <USBH_CtlSendData>
 800060c:	e001      	b.n	8000612 <control_out_transfer+0x3e>
	} else {
		return eLibuhsErrorInvalidParam;
 800060e:	f04f 30ff 	mov.w	r0, #4294967295
	}
}
 8000612:	b005      	add	sp, #20
 8000614:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000616:	bf00      	nop
 8000618:	20001674 	.word	0x20001674

0800061c <register_libuhs_callback>:
	.class_key_released_cb = key_released,
	.class_mouse_activated_cb = mouse_activated

};
void register_libuhs_callback(void)
{
 800061c:	b510      	push	{r4, lr}
	register_system_callback(&system_callbacks, 0);
 800061e:	4c08      	ldr	r4, [pc, #32]	; (8000640 <register_libuhs_callback+0x24>)
 8000620:	2100      	movs	r1, #0
 8000622:	4620      	mov	r0, r4
 8000624:	f013 fafa 	bl	8013c1c <register_system_callback>
	register_usb_kernel_callback(&usb_kernel_callbacks, 0);
 8000628:	2100      	movs	r1, #0
 800062a:	f104 0014 	add.w	r0, r4, #20
 800062e:	f013 facb 	bl	8013bc8 <register_usb_kernel_callback>
	register_usb_class_callback(&usb_class_callbacks, 0);
 8000632:	f104 0060 	add.w	r0, r4, #96	; 0x60
 8000636:	2100      	movs	r1, #0
}
 8000638:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
};
void register_libuhs_callback(void)
{
	register_system_callback(&system_callbacks, 0);
	register_usb_kernel_callback(&usb_kernel_callbacks, 0);
	register_usb_class_callback(&usb_class_callbacks, 0);
 800063c:	f013 bb18 	b.w	8013c70 <register_usb_class_callback>
 8000640:	20000004 	.word	0x20000004

08000644 <ff_convert>:
)
{
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
 8000644:	287f      	cmp	r0, #127	; 0x7f

WCHAR ff_convert (	/* Converted character, Returns zero on error */
	WCHAR	src,	/* Character code to be converted */
	UINT	dir		/* 0: Unicode to OEMCP, 1: OEMCP to Unicode */
)
{
 8000646:	b510      	push	{r4, lr}
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
 8000648:	d916      	bls.n	8000678 <ff_convert+0x34>
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
 800064a:	b131      	cbz	r1, 800065a <ff_convert+0x16>
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
 800064c:	28ff      	cmp	r0, #255	; 0xff
 800064e:	d812      	bhi.n	8000676 <ff_convert+0x32>
 8000650:	4b0a      	ldr	r3, [pc, #40]	; (800067c <ff_convert+0x38>)
 8000652:	3880      	subs	r0, #128	; 0x80
 8000654:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
 8000658:	bd10      	pop	{r4, pc}

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
				if (src == Tbl[c]) break;
 800065a:	4a08      	ldr	r2, [pc, #32]	; (800067c <ff_convert+0x38>)
 800065c:	f832 4011 	ldrh.w	r4, [r2, r1, lsl #1]
 8000660:	b28b      	uxth	r3, r1
 8000662:	4284      	cmp	r4, r0
 8000664:	d003      	beq.n	800066e <ff_convert+0x2a>
 8000666:	3101      	adds	r1, #1
	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
 8000668:	2980      	cmp	r1, #128	; 0x80
 800066a:	d1f7      	bne.n	800065c <ff_convert+0x18>
 800066c:	460b      	mov	r3, r1
				if (src == Tbl[c]) break;
			}
			c = (c + 0x80) & 0xFF;
 800066e:	f103 0080 	add.w	r0, r3, #128	; 0x80
 8000672:	b2c0      	uxtb	r0, r0
 8000674:	bd10      	pop	{r4, pc}
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
 8000676:	2000      	movs	r0, #0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
 8000678:	bd10      	pop	{r4, pc}
 800067a:	bf00      	nop
 800067c:	0801e098 	.word	0x0801e098

08000680 <ff_wtoupper>:


WCHAR ff_wtoupper (	/* Upper converted character */
	WCHAR chr		/* Input character */
)
{
 8000680:	b510      	push	{r4, lr}
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
 8000682:	2300      	movs	r3, #0
 8000684:	e000      	b.n	8000688 <ff_wtoupper+0x8>
 8000686:	3301      	adds	r3, #1
 8000688:	4a06      	ldr	r2, [pc, #24]	; (80006a4 <ff_wtoupper+0x24>)

	return c;
}


WCHAR ff_wtoupper (	/* Upper converted character */
 800068a:	005c      	lsls	r4, r3, #1
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
 800068c:	f502 7180 	add.w	r1, r2, #256	; 0x100
 8000690:	f831 1013 	ldrh.w	r1, [r1, r3, lsl #1]
 8000694:	b121      	cbz	r1, 80006a0 <ff_wtoupper+0x20>
 8000696:	4288      	cmp	r0, r1
 8000698:	d1f5      	bne.n	8000686 <ff_wtoupper+0x6>

	return tbl_lower[i] ? tbl_upper[i] : chr;
 800069a:	1912      	adds	r2, r2, r4
 800069c:	f8b2 02e0 	ldrh.w	r0, [r2, #736]	; 0x2e0
}
 80006a0:	bd10      	pop	{r4, pc}
 80006a2:	bf00      	nop
 80006a4:	0801e098 	.word	0x0801e098

080006a8 <get_fattime>:
#include "integer.h"
#include "fattime.h"
#include <bsp/rtc.h>

DWORD get_fattime (void)
{
 80006a8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	DWORD res;
	RTC_t rtc;

	rtc_gettime( &rtc );
 80006aa:	a801      	add	r0, sp, #4
 80006ac:	f007 feb4 	bl	8008418 <rtc_gettime>
	
	res =  (((DWORD)rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
 80006b0:	f89d 2006 	ldrb.w	r2, [sp, #6]
			| ((DWORD)rtc.mday << 16)
 80006b4:	f89d 3007 	ldrb.w	r3, [sp, #7]
	RTC_t rtc;

	rtc_gettime( &rtc );
	
	res =  (((DWORD)rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
 80006b8:	0552      	lsls	r2, r2, #21
 80006ba:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
			| ((DWORD)rtc.mday << 16)
			| (WORD)(rtc.hour << 11)
			| (WORD)(rtc.min << 5)
			| (WORD)(rtc.sec >> 1);
 80006be:	f89d 300b 	ldrb.w	r3, [sp, #11]
	
	res =  (((DWORD)rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
			| (WORD)(rtc.hour << 11)
			| (WORD)(rtc.min << 5)
 80006c2:	f89d 000a 	ldrb.w	r0, [sp, #10]

	rtc_gettime( &rtc );
	
	res =  (((DWORD)rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
 80006c6:	ea42 0253 	orr.w	r2, r2, r3, lsr #1
	DWORD res;
	RTC_t rtc;

	rtc_gettime( &rtc );
	
	res =  (((DWORD)rtc.year - 1980) << 25)
 80006ca:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 80006ce:	f2a3 73bc 	subw	r3, r3, #1980	; 0x7bc
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
			| (WORD)(rtc.hour << 11)
 80006d2:	ea42 6343 	orr.w	r3, r2, r3, lsl #25
 80006d6:	f89d 2009 	ldrb.w	r2, [sp, #9]
 80006da:	02d2      	lsls	r2, r2, #11
 80006dc:	b292      	uxth	r2, r2
			| (WORD)(rtc.min << 5)
 80006de:	4313      	orrs	r3, r2
			| (WORD)(rtc.sec >> 1);

	return res;
}
 80006e0:	ea43 1040 	orr.w	r0, r3, r0, lsl #5
 80006e4:	b005      	add	sp, #20
 80006e6:	bd00      	pop	{pc}

080006e8 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, int cnt) {
 80006e8:	b510      	push	{r4, lr}
	char *d = (char*)dst;
	const char *s = (const char *)src;
	while (cnt--) *d++ = *s++;
 80006ea:	2300      	movs	r3, #0
 80006ec:	e002      	b.n	80006f4 <mem_cpy+0xc>
 80006ee:	5ccc      	ldrb	r4, [r1, r3]
 80006f0:	54c4      	strb	r4, [r0, r3]
 80006f2:	3301      	adds	r3, #1
 80006f4:	4293      	cmp	r3, r2
 80006f6:	d1fa      	bne.n	80006ee <mem_cpy+0x6>
}
 80006f8:	bd10      	pop	{r4, pc}

080006fa <mem_set>:

/* Fill memory */
static
void mem_set (void* dst, int val, int cnt) {
 80006fa:	1882      	adds	r2, r0, r2
	char *d = (char*)dst;
	while (cnt--) *d++ = (char)val;
 80006fc:	e001      	b.n	8000702 <mem_set+0x8>
 80006fe:	f800 1b01 	strb.w	r1, [r0], #1
 8000702:	4290      	cmp	r0, r2
 8000704:	d1fb      	bne.n	80006fe <mem_set+0x4>
}
 8000706:	4770      	bx	lr

08000708 <sum_sfn>:
#if _USE_LFN
static
BYTE sum_sfn (
	const BYTE *dir		/* Ptr to directory entry */
)
{
 8000708:	2300      	movs	r3, #0
 800070a:	b510      	push	{r4, lr}
 800070c:	4604      	mov	r4, r0
	BYTE sum = 0;
 800070e:	4618      	mov	r0, r3
	int n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
 8000710:	0842      	lsrs	r2, r0, #1
 8000712:	5ce1      	ldrb	r1, [r4, r3]
 8000714:	ea42 12c0 	orr.w	r2, r2, r0, lsl #7
 8000718:	3301      	adds	r3, #1
 800071a:	1852      	adds	r2, r2, r1
 800071c:	2b0b      	cmp	r3, #11
 800071e:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 8000722:	d1f5      	bne.n	8000710 <sum_sfn+0x8>
	return sum;
}
 8000724:	bd10      	pop	{r4, pc}

08000726 <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
 8000726:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	BYTE c, nt, *dir;
	char *p;


	p = fno->fname;
	if (dj->sect) {
 8000728:	6903      	ldr	r3, [r0, #16]
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
 800072a:	460d      	mov	r5, r1
	int i;
	BYTE c, nt, *dir;
	char *p;


	p = fno->fname;
 800072c:	f101 0109 	add.w	r1, r1, #9
	if (dj->sect) {
 8000730:	2b00      	cmp	r3, #0
 8000732:	d050      	beq.n	80007d6 <get_fileinfo+0xb0>
		dir = dj->dir;
 8000734:	6943      	ldr	r3, [r0, #20]
 8000736:	460c      	mov	r4, r1
		nt = dir[DIR_NTres];		/* NT flag */
 8000738:	7b1f      	ldrb	r7, [r3, #12]
		for (i = 0; i < 8; i++) {	/* Copy name body */
 800073a:	2600      	movs	r6, #0
			c = dir[i];
			if (c == ' ') break;
			if (c == 0x05) c = 0xE5;
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
 800073c:	f007 0c08 	and.w	ip, r7, #8
 8000740:	fa5f fc8c 	uxtb.w	ip, ip
	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
 8000744:	5d9a      	ldrb	r2, [r3, r6]
 8000746:	4621      	mov	r1, r4
			if (c == ' ') break;
 8000748:	2a20      	cmp	r2, #32
 800074a:	d011      	beq.n	8000770 <get_fileinfo+0x4a>
			if (c == 0x05) c = 0xE5;
 800074c:	2a05      	cmp	r2, #5
 800074e:	bf08      	it	eq
 8000750:	22e5      	moveq	r2, #229	; 0xe5
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
 8000752:	f1bc 0f00 	cmp.w	ip, #0
 8000756:	d005      	beq.n	8000764 <get_fileinfo+0x3e>
 8000758:	f1a2 0141 	sub.w	r1, r2, #65	; 0x41
 800075c:	2919      	cmp	r1, #25
 800075e:	d801      	bhi.n	8000764 <get_fileinfo+0x3e>
 8000760:	3220      	adds	r2, #32
 8000762:	b2d2      	uxtb	r2, r2

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
 8000764:	3601      	adds	r6, #1
			c = dir[i];
			if (c == ' ') break;
			if (c == 0x05) c = 0xE5;
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
			*p++ = c;
 8000766:	f804 2b01 	strb.w	r2, [r4], #1

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
 800076a:	2e08      	cmp	r6, #8
			c = dir[i];
			if (c == ' ') break;
			if (c == 0x05) c = 0xE5;
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
			*p++ = c;
 800076c:	4621      	mov	r1, r4

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
 800076e:	d1e9      	bne.n	8000744 <get_fileinfo+0x1e>
			if (c == ' ') break;
			if (c == 0x05) c = 0xE5;
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
 8000770:	7a1a      	ldrb	r2, [r3, #8]
 8000772:	2a20      	cmp	r2, #32
 8000774:	d018      	beq.n	80007a8 <get_fileinfo+0x82>
			*p++ = '.';
 8000776:	4622      	mov	r2, r4
 8000778:	212e      	movs	r1, #46	; 0x2e
			for (i = 8; i < 11; i++) {
				c = dir[i];
				if (c == ' ') break;
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
 800077a:	f007 0710 	and.w	r7, r7, #16
			if (c == 0x05) c = 0xE5;
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
 800077e:	f802 1b01 	strb.w	r1, [r2], #1
			for (i = 8; i < 11; i++) {
 8000782:	2608      	movs	r6, #8
				c = dir[i];
				if (c == ' ') break;
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
 8000784:	b2ff      	uxtb	r7, r7
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
 8000786:	5d9c      	ldrb	r4, [r3, r6]
 8000788:	4611      	mov	r1, r2
				if (c == ' ') break;
 800078a:	2c20      	cmp	r4, #32
 800078c:	d00c      	beq.n	80007a8 <get_fileinfo+0x82>
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
 800078e:	b12f      	cbz	r7, 800079c <get_fileinfo+0x76>
 8000790:	f1a4 0141 	sub.w	r1, r4, #65	; 0x41
 8000794:	2919      	cmp	r1, #25
 8000796:	d801      	bhi.n	800079c <get_fileinfo+0x76>
 8000798:	3420      	adds	r4, #32
 800079a:	b2e4      	uxtb	r4, r4
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
 800079c:	3601      	adds	r6, #1
				c = dir[i];
				if (c == ' ') break;
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
				*p++ = c;
 800079e:	f802 4b01 	strb.w	r4, [r2], #1
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
 80007a2:	2e0b      	cmp	r6, #11
				c = dir[i];
				if (c == ' ') break;
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
				*p++ = c;
 80007a4:	4611      	mov	r1, r2
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
 80007a6:	d1ee      	bne.n	8000786 <get_fileinfo+0x60>
				if (c == ' ') break;
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
				*p++ = c;
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
 80007a8:	7ada      	ldrb	r2, [r3, #11]
 80007aa:	722a      	strb	r2, [r5, #8]
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
 80007ac:	7f9a      	ldrb	r2, [r3, #30]
 80007ae:	7fdc      	ldrb	r4, [r3, #31]
 80007b0:	0412      	lsls	r2, r2, #16
 80007b2:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
 80007b6:	7f1c      	ldrb	r4, [r3, #28]
 80007b8:	4322      	orrs	r2, r4
 80007ba:	7f5c      	ldrb	r4, [r3, #29]
 80007bc:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
 80007c0:	602a      	str	r2, [r5, #0]
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
 80007c2:	7e5c      	ldrb	r4, [r3, #25]
 80007c4:	7e1a      	ldrb	r2, [r3, #24]
 80007c6:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
 80007ca:	80aa      	strh	r2, [r5, #4]
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
 80007cc:	7dda      	ldrb	r2, [r3, #23]
 80007ce:	7d9b      	ldrb	r3, [r3, #22]
 80007d0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80007d4:	80eb      	strh	r3, [r5, #6]
	}
	*p = 0;
 80007d6:	2400      	movs	r4, #0
 80007d8:	700c      	strb	r4, [r1, #0]

#if _USE_LFN
	if (fno->lfname) {
 80007da:	69ae      	ldr	r6, [r5, #24]
 80007dc:	b1de      	cbz	r6, 8000816 <get_fileinfo+0xf0>
		XCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
 80007de:	6903      	ldr	r3, [r0, #16]
 80007e0:	b90b      	cbnz	r3, 80007e6 <get_fileinfo+0xc0>
#if _USE_LFN
	if (fno->lfname) {
		XCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
 80007e2:	2400      	movs	r4, #0
 80007e4:	e015      	b.n	8000812 <get_fileinfo+0xec>
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
 80007e6:	8c02      	ldrh	r2, [r0, #32]
 80007e8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80007ec:	429a      	cmp	r2, r3
 80007ee:	d0f8      	beq.n	80007e2 <get_fileinfo+0xbc>
			lfn = dj->lfn;
 80007f0:	69c7      	ldr	r7, [r0, #28]
			while ((w = *lfn++) != 0) {			/* Get an LFN char */
 80007f2:	e00a      	b.n	800080a <get_fileinfo+0xe4>
#if !_LFN_UNICODE
				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
 80007f4:	2100      	movs	r1, #0
 80007f6:	f7ff ff25 	bl	8000644 <ff_convert>
				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
 80007fa:	2800      	cmp	r0, #0
 80007fc:	d0f1      	beq.n	80007e2 <get_fileinfo+0xbc>
				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC */
					tp[i++] = (XCHAR)(w >> 8);
#endif
				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overrun, no LFN */
 80007fe:	69eb      	ldr	r3, [r5, #28]
 8000800:	3b01      	subs	r3, #1
 8000802:	429c      	cmp	r4, r3
 8000804:	daed      	bge.n	80007e2 <get_fileinfo+0xbc>
				tp[i++] = (XCHAR)w;
 8000806:	5530      	strb	r0, [r6, r4]
 8000808:	3401      	adds	r4, #1
		WCHAR w, *lfn;

		i = 0;
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
			lfn = dj->lfn;
			while ((w = *lfn++) != 0) {			/* Get an LFN char */
 800080a:	f837 0014 	ldrh.w	r0, [r7, r4, lsl #1]
 800080e:	2800      	cmp	r0, #0
 8000810:	d1f0      	bne.n	80007f4 <get_fileinfo+0xce>
#endif
				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overrun, no LFN */
				tp[i++] = (XCHAR)w;
			}
		}
		tp[i] = 0;	/* Terminator */
 8000812:	2300      	movs	r3, #0
 8000814:	5533      	strb	r3, [r6, r4]
 8000816:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000818 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
 8000818:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	DWORD wsect;


	wsect = fs->winsect;
 800081c:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
 800081e:	4604      	mov	r4, r0
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
 8000820:	428d      	cmp	r5, r1
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
 8000822:	460e      	mov	r6, r1
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
 8000824:	d102      	bne.n	800082c <move_window+0x14>
				return FR_DISK_ERR;
			fs->winsect = sector;
		}
	}

	return FR_OK;
 8000826:	2000      	movs	r0, #0
 8000828:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
 800082c:	7903      	ldrb	r3, [r0, #4]
 800082e:	b913      	cbnz	r3, 8000836 <move_window+0x1e>
					disk_write(fs->drive, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
 8000830:	2e00      	cmp	r6, #0
 8000832:	d0f8      	beq.n	8000826 <move_window+0xe>
 8000834:	e020      	b.n	8000878 <move_window+0x60>

	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
 8000836:	f100 0830 	add.w	r8, r0, #48	; 0x30
 800083a:	4641      	mov	r1, r8
 800083c:	7840      	ldrb	r0, [r0, #1]
 800083e:	462a      	mov	r2, r5
 8000840:	2301      	movs	r3, #1
 8000842:	f002 fce3 	bl	800320c <disk_write>
 8000846:	b110      	cbz	r0, 800084e <move_window+0x36>
				return FR_DISK_ERR;
 8000848:	2001      	movs	r0, #1
 800084a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
 800084e:	69a2      	ldr	r2, [r4, #24]
 8000850:	6a23      	ldr	r3, [r4, #32]
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
 8000852:	7120      	strb	r0, [r4, #4]
			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
 8000854:	18d3      	adds	r3, r2, r3
 8000856:	429d      	cmp	r5, r3
 8000858:	d2ea      	bcs.n	8000830 <move_window+0x18>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
 800085a:	78e7      	ldrb	r7, [r4, #3]
 800085c:	e009      	b.n	8000872 <move_window+0x5a>
					wsect += fs->sects_fat;
 800085e:	69a3      	ldr	r3, [r4, #24]
					disk_write(fs->drive, fs->win, wsect, 1);
 8000860:	7860      	ldrb	r0, [r4, #1]
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
					wsect += fs->sects_fat;
 8000862:	18ed      	adds	r5, r5, r3
					disk_write(fs->drive, fs->win, wsect, 1);
 8000864:	4641      	mov	r1, r8
 8000866:	462a      	mov	r2, r5
 8000868:	2301      	movs	r3, #1
 800086a:	f002 fccf 	bl	800320c <disk_write>
			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
 800086e:	3f01      	subs	r7, #1
 8000870:	b2ff      	uxtb	r7, r7
 8000872:	2f01      	cmp	r7, #1
 8000874:	d8f3      	bhi.n	800085e <move_window+0x46>
 8000876:	e7db      	b.n	8000830 <move_window+0x18>
				}
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)
 8000878:	7860      	ldrb	r0, [r4, #1]
 800087a:	f104 0130 	add.w	r1, r4, #48	; 0x30
 800087e:	4632      	mov	r2, r6
 8000880:	2301      	movs	r3, #1
 8000882:	f002 fc7f 	bl	8003184 <disk_read>
 8000886:	2800      	cmp	r0, #0
 8000888:	d1de      	bne.n	8000848 <move_window+0x30>
				return FR_DISK_ERR;
			fs->winsect = sector;
 800088a:	62e6      	str	r6, [r4, #44]	; 0x2c
		}
	}

	return FR_OK;
}
 800088c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08000890 <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
 8000890:	b570      	push	{r4, r5, r6, lr}
	FRESULT res;


	res = move_window(fs, 0);
 8000892:	2100      	movs	r1, #0
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
 8000894:	4604      	mov	r4, r0
	FRESULT res;


	res = move_window(fs, 0);
 8000896:	f7ff ffbf 	bl	8000818 <move_window>
 800089a:	4605      	mov	r5, r0
	if (res == FR_OK) {
 800089c:	2d00      	cmp	r5, #0
 800089e:	d151      	bne.n	8000944 <sync+0xb4>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
 80008a0:	7823      	ldrb	r3, [r4, #0]
 80008a2:	2b03      	cmp	r3, #3
 80008a4:	d146      	bne.n	8000934 <sync+0xa4>
 80008a6:	7963      	ldrb	r3, [r4, #5]
 80008a8:	2b00      	cmp	r3, #0
 80008aa:	d043      	beq.n	8000934 <sync+0xa4>
			fs->winsect = 0;
			mem_set(fs->win, 0, 512);
 80008ac:	f104 0630 	add.w	r6, r4, #48	; 0x30
 80008b0:	4630      	mov	r0, r6
 80008b2:	4629      	mov	r1, r5
 80008b4:	f44f 7200 	mov.w	r2, #512	; 0x200

	res = move_window(fs, 0);
	if (res == FR_OK) {
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
 80008b8:	62e5      	str	r5, [r4, #44]	; 0x2c
			mem_set(fs->win, 0, 512);
 80008ba:	f7ff ff1e 	bl	80006fa <mem_set>
			ST_WORD(fs->win+BS_55AA, 0xAA55);
 80008be:	2355      	movs	r3, #85	; 0x55
 80008c0:	f884 322e 	strb.w	r3, [r4, #558]	; 0x22e
 80008c4:	23aa      	movs	r3, #170	; 0xaa
 80008c6:	f884 322f 	strb.w	r3, [r4, #559]	; 0x22f
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 80008ca:	2352      	movs	r3, #82	; 0x52
 80008cc:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
 80008d0:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
 80008d4:	2361      	movs	r3, #97	; 0x61
 80008d6:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 80008da:	f884 3217 	strb.w	r3, [r4, #535]	; 0x217
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 80008de:	6923      	ldr	r3, [r4, #16]
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 80008e0:	2241      	movs	r2, #65	; 0x41
 80008e2:	f884 2033 	strb.w	r2, [r4, #51]	; 0x33
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 80008e6:	f884 2216 	strb.w	r2, [r4, #534]	; 0x216
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 80008ea:	f3c3 2207 	ubfx	r2, r3, #8, #8
 80008ee:	f884 3218 	strb.w	r3, [r4, #536]	; 0x218
 80008f2:	f884 2219 	strb.w	r2, [r4, #537]	; 0x219
 80008f6:	0c1a      	lsrs	r2, r3, #16
 80008f8:	0e1b      	lsrs	r3, r3, #24
 80008fa:	f884 321b 	strb.w	r3, [r4, #539]	; 0x21b
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 80008fe:	68e3      	ldr	r3, [r4, #12]
			fs->winsect = 0;
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 8000900:	f884 221a 	strb.w	r2, [r4, #538]	; 0x21a
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 8000904:	f3c3 2207 	ubfx	r2, r3, #8, #8
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 8000908:	2172      	movs	r1, #114	; 0x72
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 800090a:	f884 321c 	strb.w	r3, [r4, #540]	; 0x21c
 800090e:	f884 221d 	strb.w	r2, [r4, #541]	; 0x21d
 8000912:	0c1a      	lsrs	r2, r3, #16
 8000914:	0e1b      	lsrs	r3, r3, #24
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 8000916:	f884 1214 	strb.w	r1, [r4, #532]	; 0x214
 800091a:	f884 1215 	strb.w	r1, [r4, #533]	; 0x215
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 800091e:	f884 221e 	strb.w	r2, [r4, #542]	; 0x21e
 8000922:	f884 321f 	strb.w	r3, [r4, #543]	; 0x21f
			disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
 8000926:	7860      	ldrb	r0, [r4, #1]
 8000928:	4631      	mov	r1, r6
 800092a:	6962      	ldr	r2, [r4, #20]
 800092c:	2301      	movs	r3, #1
 800092e:	f002 fc6d 	bl	800320c <disk_write>
			fs->fsi_flag = 0;
 8000932:	7165      	strb	r5, [r4, #5]
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drive, CTRL_SYNC, (void*)NULL) != RES_OK)
 8000934:	2100      	movs	r1, #0
 8000936:	7860      	ldrb	r0, [r4, #1]
 8000938:	460a      	mov	r2, r1
 800093a:	f002 fccb 	bl	80032d4 <disk_ioctl>
 800093e:	3000      	adds	r0, #0
 8000940:	bf18      	it	ne
 8000942:	2001      	movne	r0, #1
			res = FR_DISK_ERR;
	}

	return res;
}
 8000944:	bd70      	pop	{r4, r5, r6, pc}

08000946 <check_fs>:
static
BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 8000946:	b510      	push	{r4, lr}
 8000948:	4604      	mov	r4, r0
 800094a:	460a      	mov	r2, r1
	if (disk_read(fs->drive, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 800094c:	7840      	ldrb	r0, [r0, #1]
 800094e:	f104 0130 	add.w	r1, r4, #48	; 0x30
 8000952:	2301      	movs	r3, #1
 8000954:	f002 fc16 	bl	8003184 <disk_read>
 8000958:	bb80      	cbnz	r0, 80009bc <check_fs+0x76>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 800095a:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
 800095e:	f894 222f 	ldrb.w	r2, [r4, #559]	; 0x22f
 8000962:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 8000966:	4b17      	ldr	r3, [pc, #92]	; (80009c4 <check_fs+0x7e>)
 8000968:	b212      	sxth	r2, r2
 800096a:	429a      	cmp	r2, r3
 800096c:	d128      	bne.n	80009c0 <check_fs+0x7a>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 800096e:	f894 2068 	ldrb.w	r2, [r4, #104]	; 0x68
 8000972:	f894 3069 	ldrb.w	r3, [r4, #105]	; 0x69
 8000976:	0412      	lsls	r2, r2, #16
 8000978:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 800097c:	f894 3066 	ldrb.w	r3, [r4, #102]	; 0x66
 8000980:	431a      	orrs	r2, r3
 8000982:	f894 3067 	ldrb.w	r3, [r4, #103]	; 0x67
 8000986:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 800098a:	4b0f      	ldr	r3, [pc, #60]	; (80009c8 <check_fs+0x82>)
 800098c:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8000990:	429a      	cmp	r2, r3
 8000992:	d016      	beq.n	80009c2 <check_fs+0x7c>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 8000994:	f894 0084 	ldrb.w	r0, [r4, #132]	; 0x84
 8000998:	f894 2085 	ldrb.w	r2, [r4, #133]	; 0x85
 800099c:	0400      	lsls	r0, r0, #16
 800099e:	ea40 6002 	orr.w	r0, r0, r2, lsl #24
 80009a2:	f894 2082 	ldrb.w	r2, [r4, #130]	; 0x82
 80009a6:	4310      	orrs	r0, r2
 80009a8:	f894 2083 	ldrb.w	r2, [r4, #131]	; 0x83
 80009ac:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
 80009b0:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		return 0;
 80009b4:	1ac0      	subs	r0, r0, r3
 80009b6:	bf18      	it	ne
 80009b8:	2001      	movne	r0, #1
 80009ba:	bd10      	pop	{r4, pc}
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drive, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
 80009bc:	2003      	movs	r0, #3
 80009be:	bd10      	pop	{r4, pc}
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
 80009c0:	2002      	movs	r0, #2
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
 80009c2:	bd10      	pop	{r4, pc}
 80009c4:	ffffaa55 	.word	0xffffaa55
 80009c8:	00544146 	.word	0x00544146

080009cc <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
 80009cc:	b508      	push	{r3, lr}
	if (!fs || !fs->fs_type || fs->id != id)
 80009ce:	b168      	cbz	r0, 80009ec <validate+0x20>
 80009d0:	7803      	ldrb	r3, [r0, #0]
 80009d2:	b15b      	cbz	r3, 80009ec <validate+0x20>
 80009d4:	88c3      	ldrh	r3, [r0, #6]
 80009d6:	428b      	cmp	r3, r1
 80009d8:	d108      	bne.n	80009ec <validate+0x20>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drive) & STA_NOINIT)
 80009da:	7840      	ldrb	r0, [r0, #1]
 80009dc:	f002 fbca 	bl	8003174 <disk_status>
 80009e0:	f010 0f01 	tst.w	r0, #1
		return FR_NOT_READY;
 80009e4:	bf0c      	ite	eq
 80009e6:	2000      	moveq	r0, #0
 80009e8:	2003      	movne	r0, #3
 80009ea:	bd08      	pop	{r3, pc}
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
		return FR_INVALID_OBJECT;
 80009ec:	2009      	movs	r0, #9

	if (disk_status(fs->drive) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
 80009ee:	bd08      	pop	{r3, pc}

080009f0 <get_fat>:
{
	UINT wc, bc;
	DWORD fsect;


	if (clst < 2 || clst >= fs->max_clust)	/* Range check */
 80009f0:	2901      	cmp	r1, #1

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
 80009f2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80009f6:	4605      	mov	r5, r0
 80009f8:	460c      	mov	r4, r1
	UINT wc, bc;
	DWORD fsect;


	if (clst < 2 || clst >= fs->max_clust)	/* Range check */
 80009fa:	d95d      	bls.n	8000ab8 <get_fat+0xc8>
 80009fc:	69c3      	ldr	r3, [r0, #28]
 80009fe:	4299      	cmp	r1, r3
 8000a00:	d25a      	bcs.n	8000ab8 <get_fat+0xc8>
		return 1;

	fsect = fs->fatbase;
	switch (fs->fs_type) {
 8000a02:	7803      	ldrb	r3, [r0, #0]


	if (clst < 2 || clst >= fs->max_clust)	/* Range check */
		return 1;

	fsect = fs->fatbase;
 8000a04:	6a06      	ldr	r6, [r0, #32]
	switch (fs->fs_type) {
 8000a06:	2b02      	cmp	r3, #2
 8000a08:	d028      	beq.n	8000a5c <get_fat+0x6c>
 8000a0a:	2b03      	cmp	r3, #3
 8000a0c:	d036      	beq.n	8000a7c <get_fat+0x8c>
 8000a0e:	2b01      	cmp	r3, #1
 8000a10:	d14e      	bne.n	8000ab0 <get_fat+0xc0>
	case FS_FAT12 :
		bc = clst; bc += bc / 2;
 8000a12:	eb01 0751 	add.w	r7, r1, r1, lsr #1
		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 8000a16:	eb06 2157 	add.w	r1, r6, r7, lsr #9
 8000a1a:	f7ff fefd 	bl	8000818 <move_window>
 8000a1e:	b100      	cbz	r0, 8000a22 <get_fat+0x32>
 8000a20:	e046      	b.n	8000ab0 <get_fat+0xc0>
		wc = fs->win[bc & (SS(fs) - 1)]; bc++;
 8000a22:	05fb      	lsls	r3, r7, #23
 8000a24:	3701      	adds	r7, #1
 8000a26:	eb05 53d3 	add.w	r3, r5, r3, lsr #23
		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 8000a2a:	4628      	mov	r0, r5
 8000a2c:	eb06 2157 	add.w	r1, r6, r7, lsr #9
	fsect = fs->fatbase;
	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = clst; bc += bc / 2;
		if (move_window(fs, fsect + (bc / SS(fs)))) break;
		wc = fs->win[bc & (SS(fs) - 1)]; bc++;
 8000a30:	f893 8030 	ldrb.w	r8, [r3, #48]	; 0x30
		if (move_window(fs, fsect + (bc / SS(fs)))) break;
 8000a34:	f7ff fef0 	bl	8000818 <move_window>
 8000a38:	2800      	cmp	r0, #0
 8000a3a:	d139      	bne.n	8000ab0 <get_fat+0xc0>
		wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
 8000a3c:	05ff      	lsls	r7, r7, #23
 8000a3e:	eb05 55d7 	add.w	r5, r5, r7, lsr #23
 8000a42:	f895 0030 	ldrb.w	r0, [r5, #48]	; 0x30
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8000a46:	07e3      	lsls	r3, r4, #31
	case FS_FAT12 :
		bc = clst; bc += bc / 2;
		if (move_window(fs, fsect + (bc / SS(fs)))) break;
		wc = fs->win[bc & (SS(fs) - 1)]; bc++;
		if (move_window(fs, fsect + (bc / SS(fs)))) break;
		wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
 8000a48:	ea48 2000 	orr.w	r0, r8, r0, lsl #8
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8000a4c:	d502      	bpl.n	8000a54 <get_fat+0x64>
 8000a4e:	0900      	lsrs	r0, r0, #4
 8000a50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000a54:	0500      	lsls	r0, r0, #20
 8000a56:	0d00      	lsrs	r0, r0, #20
 8000a58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	case FS_FAT16 :
		if (move_window(fs, fsect + (clst / (SS(fs) / 2)))) break;
 8000a5c:	eb06 2111 	add.w	r1, r6, r1, lsr #8
 8000a60:	f7ff feda 	bl	8000818 <move_window>
 8000a64:	bb20      	cbnz	r0, 8000ab0 <get_fat+0xc0>
		return LD_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)]);
 8000a66:	0624      	lsls	r4, r4, #24
 8000a68:	eb05 55d4 	add.w	r5, r5, r4, lsr #23
 8000a6c:	f895 0031 	ldrb.w	r0, [r5, #49]	; 0x31
 8000a70:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
 8000a74:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8000a78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	case FS_FAT32 :
		if (move_window(fs, fsect + (clst / (SS(fs) / 4)))) break;
 8000a7c:	eb06 11d1 	add.w	r1, r6, r1, lsr #7
 8000a80:	f7ff feca 	bl	8000818 <move_window>
 8000a84:	b9a0      	cbnz	r0, 8000ab0 <get_fat+0xc0>
		return LD_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
 8000a86:	0664      	lsls	r4, r4, #25
 8000a88:	eb05 55d4 	add.w	r5, r5, r4, lsr #23
 8000a8c:	f895 0032 	ldrb.w	r0, [r5, #50]	; 0x32
 8000a90:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
 8000a94:	0400      	lsls	r0, r0, #16
 8000a96:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
 8000a9a:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
 8000a9e:	4318      	orrs	r0, r3
 8000aa0:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
 8000aa4:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 8000aa8:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
 8000aac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
 8000ab0:	f04f 30ff 	mov.w	r0, #4294967295
 8000ab4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	UINT wc, bc;
	DWORD fsect;


	if (clst < 2 || clst >= fs->max_clust)	/* Range check */
		return 1;
 8000ab8:	2001      	movs	r0, #1
		if (move_window(fs, fsect + (clst / (SS(fs) / 4)))) break;
		return LD_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
}
 8000aba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08000abe <put_fat>:
	BYTE *p;
	DWORD fsect;
	FRESULT res;


	if (clst < 2 || clst >= fs->max_clust) {	/* Range check */
 8000abe:	2901      	cmp	r1, #1
FRESULT put_fat (
	FATFS *fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->max_clust - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
 8000ac0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000ac4:	4604      	mov	r4, r0
 8000ac6:	460d      	mov	r5, r1
 8000ac8:	4616      	mov	r6, r2
	BYTE *p;
	DWORD fsect;
	FRESULT res;


	if (clst < 2 || clst >= fs->max_clust) {	/* Range check */
 8000aca:	d96d      	bls.n	8000ba8 <put_fat+0xea>
 8000acc:	69c3      	ldr	r3, [r0, #28]
 8000ace:	4299      	cmp	r1, r3
 8000ad0:	d26a      	bcs.n	8000ba8 <put_fat+0xea>
		res = FR_INT_ERR;

	} else {
		fsect = fs->fatbase;
		switch (fs->fs_type) {
 8000ad2:	7803      	ldrb	r3, [r0, #0]

	if (clst < 2 || clst >= fs->max_clust) {	/* Range check */
		res = FR_INT_ERR;

	} else {
		fsect = fs->fatbase;
 8000ad4:	6a07      	ldr	r7, [r0, #32]
		switch (fs->fs_type) {
 8000ad6:	2b02      	cmp	r3, #2
 8000ad8:	d03d      	beq.n	8000b56 <put_fat+0x98>
 8000ada:	2b03      	cmp	r3, #3
 8000adc:	d04a      	beq.n	8000b74 <put_fat+0xb6>
 8000ade:	2b01      	cmp	r3, #1
 8000ae0:	d15d      	bne.n	8000b9e <put_fat+0xe0>
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
 8000ae2:	eb01 0851 	add.w	r8, r1, r1, lsr #1
			res = move_window(fs, fsect + (bc / SS(fs)));
 8000ae6:	eb07 2158 	add.w	r1, r7, r8, lsr #9
 8000aea:	f7ff fe95 	bl	8000818 <move_window>
			if (res != FR_OK) break;
 8000aee:	2800      	cmp	r0, #0
 8000af0:	d156      	bne.n	8000ba0 <put_fat+0xe2>
			p = &fs->win[bc & (SS(fs) - 1)];
 8000af2:	ea4f 52c8 	mov.w	r2, r8, lsl #23
 8000af6:	0dd2      	lsrs	r2, r2, #23
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8000af8:	f015 0501 	ands.w	r5, r5, #1
 8000afc:	b2f3      	uxtb	r3, r6
 8000afe:	d007      	beq.n	8000b10 <put_fat+0x52>
 8000b00:	18a1      	adds	r1, r4, r2
 8000b02:	f891 1030 	ldrb.w	r1, [r1, #48]	; 0x30
 8000b06:	f001 010f 	and.w	r1, r1, #15
 8000b0a:	ea41 1303 	orr.w	r3, r1, r3, lsl #4
 8000b0e:	b2db      	uxtb	r3, r3
 8000b10:	18a2      	adds	r2, r4, r2
 8000b12:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
			bc++;
 8000b16:	f108 0801 	add.w	r8, r8, #1
			fs->wflag = 1;
 8000b1a:	2301      	movs	r3, #1
 8000b1c:	7123      	strb	r3, [r4, #4]
			res = move_window(fs, fsect + (bc / SS(fs)));
 8000b1e:	4620      	mov	r0, r4
 8000b20:	eb07 2158 	add.w	r1, r7, r8, lsr #9
 8000b24:	f7ff fe78 	bl	8000818 <move_window>
			if (res != FR_OK) break;
 8000b28:	bbd0      	cbnz	r0, 8000ba0 <put_fat+0xe2>
			p = &fs->win[bc & (SS(fs) - 1)];
 8000b2a:	ea4f 58c8 	mov.w	r8, r8, lsl #23
 8000b2e:	ea4f 58d8 	mov.w	r8, r8, lsr #23
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8000b32:	b115      	cbz	r5, 8000b3a <put_fat+0x7c>
 8000b34:	f3c6 1607 	ubfx	r6, r6, #4, #8
 8000b38:	e008      	b.n	8000b4c <put_fat+0x8e>
 8000b3a:	eb04 0308 	add.w	r3, r4, r8
 8000b3e:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8000b42:	f3c6 2603 	ubfx	r6, r6, #8, #4
 8000b46:	f023 030f 	bic.w	r3, r3, #15
 8000b4a:	431e      	orrs	r6, r3
 8000b4c:	eb04 0308 	add.w	r3, r4, r8
 8000b50:	f883 6030 	strb.w	r6, [r3, #48]	; 0x30
 8000b54:	e024      	b.n	8000ba0 <put_fat+0xe2>
			break;

		case FS_FAT16 :
			res = move_window(fs, fsect + (clst / (SS(fs) / 2)));
 8000b56:	eb07 2111 	add.w	r1, r7, r1, lsr #8
 8000b5a:	f7ff fe5d 	bl	8000818 <move_window>
			if (res != FR_OK) break;
 8000b5e:	b9f8      	cbnz	r0, 8000ba0 <put_fat+0xe2>
			ST_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)], (WORD)val);
 8000b60:	062d      	lsls	r5, r5, #24
 8000b62:	eb04 55d5 	add.w	r5, r4, r5, lsr #23
 8000b66:	f885 6030 	strb.w	r6, [r5, #48]	; 0x30
 8000b6a:	f3c6 2607 	ubfx	r6, r6, #8, #8
 8000b6e:	f885 6031 	strb.w	r6, [r5, #49]	; 0x31
 8000b72:	e015      	b.n	8000ba0 <put_fat+0xe2>
			break;

		case FS_FAT32 :
			res = move_window(fs, fsect + (clst / (SS(fs) / 4)));
 8000b74:	eb07 11d1 	add.w	r1, r7, r1, lsr #7
 8000b78:	f7ff fe4e 	bl	8000818 <move_window>
			if (res != FR_OK) break;
 8000b7c:	b980      	cbnz	r0, 8000ba0 <put_fat+0xe2>
			ST_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)], val);
 8000b7e:	066d      	lsls	r5, r5, #25
 8000b80:	eb04 55d5 	add.w	r5, r4, r5, lsr #23
 8000b84:	f3c6 2307 	ubfx	r3, r6, #8, #8
 8000b88:	f885 6030 	strb.w	r6, [r5, #48]	; 0x30
 8000b8c:	f885 3031 	strb.w	r3, [r5, #49]	; 0x31
 8000b90:	0c33      	lsrs	r3, r6, #16
 8000b92:	0e36      	lsrs	r6, r6, #24
 8000b94:	f885 3032 	strb.w	r3, [r5, #50]	; 0x32
 8000b98:	f885 6033 	strb.w	r6, [r5, #51]	; 0x33
 8000b9c:	e000      	b.n	8000ba0 <put_fat+0xe2>
			break;

		default :
			res = FR_INT_ERR;
 8000b9e:	2002      	movs	r0, #2
		}
		fs->wflag = 1;
 8000ba0:	2301      	movs	r3, #1
 8000ba2:	7123      	strb	r3, [r4, #4]
 8000ba4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	DWORD fsect;
	FRESULT res;


	if (clst < 2 || clst >= fs->max_clust) {	/* Range check */
		res = FR_INT_ERR;
 8000ba8:	2002      	movs	r0, #2
		}
		fs->wflag = 1;
	}

	return res;
}
 8000baa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08000bae <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
 8000bae:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000bb2:	4605      	mov	r5, r0
	DWORD cs, ncl, scl, mcl;


	mcl = fs->max_clust;
 8000bb4:	f8d0 801c 	ldr.w	r8, [r0, #28]
	if (clst == 0) {		/* Create new chain */
 8000bb8:	460f      	mov	r7, r1
 8000bba:	b929      	cbnz	r1, 8000bc8 <create_chain+0x1a>
		scl = fs->last_clust;			/* Get suggested start point */
 8000bbc:	68c6      	ldr	r6, [r0, #12]
		if (scl == 0 || scl >= mcl) scl = 1;
 8000bbe:	b176      	cbz	r6, 8000bde <create_chain+0x30>
 8000bc0:	4546      	cmp	r6, r8
 8000bc2:	bf28      	it	cs
 8000bc4:	2601      	movcs	r6, #1
 8000bc6:	e00b      	b.n	8000be0 <create_chain+0x32>
	}
	else {					/* Stretch existing chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
 8000bc8:	f7ff ff12 	bl	80009f0 <get_fat>
		if (cs < 2) return 1;			/* It is an invalid cluster */
 8000bcc:	2801      	cmp	r0, #1
 8000bce:	d802      	bhi.n	8000bd6 <create_chain+0x28>
 8000bd0:	2001      	movs	r0, #1
 8000bd2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (cs < mcl) return cs;		/* It is already followed by next cluster */
 8000bd6:	4540      	cmp	r0, r8
 8000bd8:	d337      	bcc.n	8000c4a <create_chain+0x9c>
 8000bda:	463e      	mov	r6, r7
 8000bdc:	e000      	b.n	8000be0 <create_chain+0x32>


	mcl = fs->max_clust;
	if (clst == 0) {		/* Create new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (scl == 0 || scl >= mcl) scl = 1;
 8000bde:	2601      	movs	r6, #1
 8000be0:	4634      	mov	r4, r6
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
 8000be2:	3401      	adds	r4, #1
		if (ncl >= mcl) {				/* Wrap around */
 8000be4:	4544      	cmp	r4, r8
 8000be6:	d305      	bcc.n	8000bf4 <create_chain+0x46>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
 8000be8:	2e01      	cmp	r6, #1
 8000bea:	d802      	bhi.n	8000bf2 <create_chain+0x44>
 8000bec:	2000      	movs	r0, #0
 8000bee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= mcl) {				/* Wrap around */
			ncl = 2;
 8000bf2:	2402      	movs	r4, #2
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
 8000bf4:	4628      	mov	r0, r5
 8000bf6:	4621      	mov	r1, r4
 8000bf8:	f7ff fefa 	bl	80009f0 <get_fat>
		if (cs == 0) break;				/* Found a free cluster */
 8000bfc:	b150      	cbz	r0, 8000c14 <create_chain+0x66>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 8000bfe:	1c41      	adds	r1, r0, #1
 8000c00:	d103      	bne.n	8000c0a <create_chain+0x5c>
		if (put_fat(fs, clst, ncl))
			return 0xFFFFFFFF;
	}

	fs->last_clust = ncl;				/* Update FSINFO */
	if (fs->free_clust != 0xFFFFFFFF) {
 8000c02:	f04f 30ff 	mov.w	r0, #4294967295
 8000c06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 8000c0a:	2801      	cmp	r0, #1
 8000c0c:	d0e0      	beq.n	8000bd0 <create_chain+0x22>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
 8000c0e:	42b4      	cmp	r4, r6
 8000c10:	d1e7      	bne.n	8000be2 <create_chain+0x34>
 8000c12:	e7eb      	b.n	8000bec <create_chain+0x3e>
	}

	if (put_fat(fs, ncl, 0x0FFFFFFF))	/* Mark the new cluster "in use" */
 8000c14:	4628      	mov	r0, r5
 8000c16:	4621      	mov	r1, r4
 8000c18:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 8000c1c:	f7ff ff4f 	bl	8000abe <put_fat>
 8000c20:	2800      	cmp	r0, #0
 8000c22:	d1ee      	bne.n	8000c02 <create_chain+0x54>
		return 0xFFFFFFFF;
	if (clst != 0) {					/* Link it to the previous one if needed */
 8000c24:	b927      	cbnz	r7, 8000c30 <create_chain+0x82>
		if (put_fat(fs, clst, ncl))
			return 0xFFFFFFFF;
	}

	fs->last_clust = ncl;				/* Update FSINFO */
	if (fs->free_clust != 0xFFFFFFFF) {
 8000c26:	692b      	ldr	r3, [r5, #16]
	if (clst != 0) {					/* Link it to the previous one if needed */
		if (put_fat(fs, clst, ncl))
			return 0xFFFFFFFF;
	}

	fs->last_clust = ncl;				/* Update FSINFO */
 8000c28:	60ec      	str	r4, [r5, #12]
	if (fs->free_clust != 0xFFFFFFFF) {
 8000c2a:	1c5a      	adds	r2, r3, #1
 8000c2c:	d108      	bne.n	8000c40 <create_chain+0x92>
 8000c2e:	e00b      	b.n	8000c48 <create_chain+0x9a>
	}

	if (put_fat(fs, ncl, 0x0FFFFFFF))	/* Mark the new cluster "in use" */
		return 0xFFFFFFFF;
	if (clst != 0) {					/* Link it to the previous one if needed */
		if (put_fat(fs, clst, ncl))
 8000c30:	4628      	mov	r0, r5
 8000c32:	4639      	mov	r1, r7
 8000c34:	4622      	mov	r2, r4
 8000c36:	f7ff ff42 	bl	8000abe <put_fat>
 8000c3a:	2800      	cmp	r0, #0
 8000c3c:	d1e1      	bne.n	8000c02 <create_chain+0x54>
 8000c3e:	e7f2      	b.n	8000c26 <create_chain+0x78>
			return 0xFFFFFFFF;
	}

	fs->last_clust = ncl;				/* Update FSINFO */
	if (fs->free_clust != 0xFFFFFFFF) {
		fs->free_clust--;
 8000c40:	3b01      	subs	r3, #1
 8000c42:	612b      	str	r3, [r5, #16]
		fs->fsi_flag = 1;
 8000c44:	2301      	movs	r3, #1
 8000c46:	716b      	strb	r3, [r5, #5]
 8000c48:	4620      	mov	r0, r4
	}

	return ncl;		/* Return new cluster number */
}
 8000c4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08000c4e <remove_chain>:
{
	FRESULT res;
	DWORD nxt;


	if (clst < 2 || clst >= fs->max_clust) {	/* Check the range of cluster# */
 8000c4e:	2901      	cmp	r1, #1
static
FRESULT remove_chain (
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
 8000c50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000c52:	4604      	mov	r4, r0
 8000c54:	460d      	mov	r5, r1
	FRESULT res;
	DWORD nxt;


	if (clst < 2 || clst >= fs->max_clust) {	/* Check the range of cluster# */
 8000c56:	d924      	bls.n	8000ca2 <remove_chain+0x54>
 8000c58:	69c3      	ldr	r3, [r0, #28]
 8000c5a:	4299      	cmp	r1, r3
 8000c5c:	d221      	bcs.n	8000ca2 <remove_chain+0x54>
 8000c5e:	e019      	b.n	8000c94 <remove_chain+0x46>
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->max_clust) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
 8000c60:	4620      	mov	r0, r4
 8000c62:	4629      	mov	r1, r5
 8000c64:	f7ff fec4 	bl	80009f0 <get_fat>
			if (nxt == 0) break;				/* Empty cluster? */
 8000c68:	4606      	mov	r6, r0
 8000c6a:	b908      	cbnz	r0, 8000c70 <remove_chain+0x22>
static
FRESULT remove_chain (
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
 8000c6c:	2000      	movs	r0, #0
 8000c6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else {
		res = FR_OK;
		while (clst < fs->max_clust) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 8000c70:	2801      	cmp	r0, #1
 8000c72:	d016      	beq.n	8000ca2 <remove_chain+0x54>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 8000c74:	1c43      	adds	r3, r0, #1
 8000c76:	d012      	beq.n	8000c9e <remove_chain+0x50>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 8000c78:	4620      	mov	r0, r4
 8000c7a:	4629      	mov	r1, r5
 8000c7c:	2200      	movs	r2, #0
 8000c7e:	f7ff ff1e 	bl	8000abe <put_fat>
			if (res != FR_OK) break;
 8000c82:	b978      	cbnz	r0, 8000ca4 <remove_chain+0x56>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
 8000c84:	6923      	ldr	r3, [r4, #16]
 8000c86:	1c58      	adds	r0, r3, #1
 8000c88:	d002      	beq.n	8000c90 <remove_chain+0x42>
				fs->free_clust++;
 8000c8a:	3301      	adds	r3, #1
 8000c8c:	6123      	str	r3, [r4, #16]
				fs->fsi_flag = 1;
 8000c8e:	7167      	strb	r7, [r4, #5]
static
FRESULT remove_chain (
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
 8000c90:	4635      	mov	r5, r6
 8000c92:	e000      	b.n	8000c96 <remove_chain+0x48>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
				fs->free_clust++;
				fs->fsi_flag = 1;
 8000c94:	2701      	movs	r7, #1
	if (clst < 2 || clst >= fs->max_clust) {	/* Check the range of cluster# */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->max_clust) {			/* Not a last link? */
 8000c96:	69e3      	ldr	r3, [r4, #28]
 8000c98:	429d      	cmp	r5, r3
 8000c9a:	d3e1      	bcc.n	8000c60 <remove_chain+0x12>
 8000c9c:	e7e6      	b.n	8000c6c <remove_chain+0x1e>
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 8000c9e:	2001      	movs	r0, #1
 8000ca0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	FRESULT res;
	DWORD nxt;


	if (clst < 2 || clst >= fs->max_clust) {	/* Check the range of cluster# */
		res = FR_INT_ERR;
 8000ca2:	2002      	movs	r0, #2
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
 8000ca4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000ca6 <clust2sect>:
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
 8000ca6:	69c3      	ldr	r3, [r0, #28]
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
 8000ca8:	3902      	subs	r1, #2
	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
 8000caa:	3b02      	subs	r3, #2
 8000cac:	4299      	cmp	r1, r3
 8000cae:	d204      	bcs.n	8000cba <clust2sect+0x14>
	return clst * fs->csize + fs->database;
 8000cb0:	7882      	ldrb	r2, [r0, #2]
 8000cb2:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8000cb4:	fb02 3001 	mla	r0, r2, r1, r3
 8000cb8:	4770      	bx	lr
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
 8000cba:	2000      	movs	r0, #0
	return clst * fs->csize + fs->database;
}
 8000cbc:	4770      	bx	lr

08000cbe <dir_seek>:
static
FRESULT dir_seek (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
 8000cbe:	b570      	push	{r4, r5, r6, lr}
 8000cc0:	4604      	mov	r4, r0
 8000cc2:	460d      	mov	r5, r1
	DWORD clst;
	WORD ic;


	dj->index = idx;
 8000cc4:	80e1      	strh	r1, [r4, #6]
	clst = dj->sclust;
 8000cc6:	6881      	ldr	r1, [r0, #8]
	if (clst == 1 || clst >= dj->fs->max_clust)	/* Check start cluster range */
 8000cc8:	2901      	cmp	r1, #1
 8000cca:	d101      	bne.n	8000cd0 <dir_seek+0x12>
		return FR_INT_ERR;
 8000ccc:	2002      	movs	r0, #2
 8000cce:	bd70      	pop	{r4, r5, r6, pc}
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->max_clust)	/* Check start cluster range */
 8000cd0:	6803      	ldr	r3, [r0, #0]
 8000cd2:	69da      	ldr	r2, [r3, #28]
 8000cd4:	4291      	cmp	r1, r2
 8000cd6:	d2f9      	bcs.n	8000ccc <dir_seek+0xe>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 8000cd8:	b971      	cbnz	r1, 8000cf8 <dir_seek+0x3a>
 8000cda:	781a      	ldrb	r2, [r3, #0]
 8000cdc:	2a03      	cmp	r2, #3
 8000cde:	d101      	bne.n	8000ce4 <dir_seek+0x26>
		clst = dj->fs->dirbase;
 8000ce0:	6a59      	ldr	r1, [r3, #36]	; 0x24

	if (clst == 0) {	/* Static table */
 8000ce2:	b949      	cbnz	r1, 8000cf8 <dir_seek+0x3a>
		dj->clust = clst;
 8000ce4:	2200      	movs	r2, #0
 8000ce6:	60e2      	str	r2, [r4, #12]
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
 8000ce8:	891a      	ldrh	r2, [r3, #8]
 8000cea:	42aa      	cmp	r2, r5
 8000cec:	d9ee      	bls.n	8000ccc <dir_seek+0xe>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);	/* Sector# */
 8000cee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000cf0:	eb03 1315 	add.w	r3, r3, r5, lsr #4
 8000cf4:	6123      	str	r3, [r4, #16]
 8000cf6:	e019      	b.n	8000d2c <dir_seek+0x6e>
	}
	else {				/* Dynamic table */
		ic = SS(dj->fs) / 32 * dj->fs->csize;	/* Entries per cluster */
 8000cf8:	789e      	ldrb	r6, [r3, #2]
 8000cfa:	0136      	lsls	r6, r6, #4
		while (idx >= ic) {	/* Follow cluster chain */
 8000cfc:	e00d      	b.n	8000d1a <dir_seek+0x5c>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
 8000cfe:	6820      	ldr	r0, [r4, #0]
 8000d00:	f7ff fe76 	bl	80009f0 <get_fat>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8000d04:	1c42      	adds	r2, r0, #1
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);	/* Sector# */
	}
	else {				/* Dynamic table */
		ic = SS(dj->fs) / 32 * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
 8000d06:	4601      	mov	r1, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8000d08:	d019      	beq.n	8000d3e <dir_seek+0x80>
			if (clst < 2 || clst >= dj->fs->max_clust)	/* Reached to end of table or int error */
 8000d0a:	2801      	cmp	r0, #1
 8000d0c:	d9de      	bls.n	8000ccc <dir_seek+0xe>
 8000d0e:	6823      	ldr	r3, [r4, #0]
 8000d10:	69db      	ldr	r3, [r3, #28]
 8000d12:	4298      	cmp	r0, r3
 8000d14:	d2da      	bcs.n	8000ccc <dir_seek+0xe>
				return FR_INT_ERR;
			idx -= ic;
 8000d16:	1bad      	subs	r5, r5, r6
 8000d18:	b2ad      	uxth	r5, r5
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);	/* Sector# */
	}
	else {				/* Dynamic table */
		ic = SS(dj->fs) / 32 * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
 8000d1a:	42b5      	cmp	r5, r6
 8000d1c:	d2ef      	bcs.n	8000cfe <dir_seek+0x40>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->max_clust)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
 8000d1e:	60e1      	str	r1, [r4, #12]
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / 32);	/* Sector# */
 8000d20:	6820      	ldr	r0, [r4, #0]
 8000d22:	f7ff ffc0 	bl	8000ca6 <clust2sect>
 8000d26:	eb00 1015 	add.w	r0, r0, r5, lsr #4
 8000d2a:	6120      	str	r0, [r4, #16]
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / 32)) * 32;	/* Ptr to the entry in the sector */
 8000d2c:	f005 050f 	and.w	r5, r5, #15
 8000d30:	016d      	lsls	r5, r5, #5
 8000d32:	6823      	ldr	r3, [r4, #0]
 8000d34:	3530      	adds	r5, #48	; 0x30
 8000d36:	195b      	adds	r3, r3, r5
 8000d38:	6163      	str	r3, [r4, #20]

	return FR_OK;	/* Seek succeeded */
 8000d3a:	2000      	movs	r0, #0
 8000d3c:	bd70      	pop	{r4, r5, r6, pc}
	}
	else {				/* Dynamic table */
		ic = SS(dj->fs) / 32 * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8000d3e:	2001      	movs	r0, #1
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / 32)) * 32;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
 8000d40:	bd70      	pop	{r4, r5, r6, pc}

08000d42 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not streach */
	DIR *dj,		/* Pointer to directory object */
	BOOL streach	/* FALSE: Do not stretch table, TRUE: Stretch table if needed */
)
{
 8000d42:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	DWORD clst;
	WORD i;


	i = dj->index + 1;
 8000d46:	88c6      	ldrh	r6, [r0, #6]
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not streach */
	DIR *dj,		/* Pointer to directory object */
	BOOL streach	/* FALSE: Do not stretch table, TRUE: Stretch table if needed */
)
{
 8000d48:	4604      	mov	r4, r0
	DWORD clst;
	WORD i;


	i = dj->index + 1;
 8000d4a:	3601      	adds	r6, #1
 8000d4c:	b2b6      	uxth	r6, r6
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not streach */
	DIR *dj,		/* Pointer to directory object */
	BOOL streach	/* FALSE: Do not stretch table, TRUE: Stretch table if needed */
)
{
 8000d4e:	460f      	mov	r7, r1
	DWORD clst;
	WORD i;


	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 8000d50:	b916      	cbnz	r6, 8000d58 <dir_next+0x16>
		return FR_NO_FILE;
 8000d52:	2004      	movs	r0, #4
 8000d54:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	DWORD clst;
	WORD i;


	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 8000d58:	6903      	ldr	r3, [r0, #16]
 8000d5a:	2b00      	cmp	r3, #0
 8000d5c:	d0f9      	beq.n	8000d52 <dir_next+0x10>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / 32))) {	/* Sector changed? */
 8000d5e:	f016 080f 	ands.w	r8, r6, #15
 8000d62:	d15e      	bne.n	8000e22 <dir_next+0xe0>
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
 8000d64:	68c1      	ldr	r1, [r0, #12]
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / 32))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */
 8000d66:	3301      	adds	r3, #1
 8000d68:	6103      	str	r3, [r0, #16]
 8000d6a:	6800      	ldr	r0, [r0, #0]

		if (dj->clust == 0) {	/* Static table */
 8000d6c:	b919      	cbnz	r1, 8000d76 <dir_next+0x34>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 8000d6e:	8903      	ldrh	r3, [r0, #8]
 8000d70:	42b3      	cmp	r3, r6
 8000d72:	d9ee      	bls.n	8000d52 <dir_next+0x10>
 8000d74:	e055      	b.n	8000e22 <dir_next+0xe0>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
 8000d76:	7882      	ldrb	r2, [r0, #2]
 8000d78:	3a01      	subs	r2, #1
 8000d7a:	ea12 1216 	ands.w	r2, r2, r6, lsr #4
 8000d7e:	d150      	bne.n	8000e22 <dir_next+0xe0>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
 8000d80:	f7ff fe36 	bl	80009f0 <get_fat>
				if (clst <= 1) return FR_INT_ERR;
 8000d84:	2801      	cmp	r0, #1
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
 8000d86:	4605      	mov	r5, r0
				if (clst <= 1) return FR_INT_ERR;
 8000d88:	d802      	bhi.n	8000d90 <dir_next+0x4e>
 8000d8a:	2002      	movs	r0, #2
 8000d8c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8000d90:	3001      	adds	r0, #1
 8000d92:	d102      	bne.n	8000d9a <dir_next+0x58>
 8000d94:	2001      	movs	r0, #1
 8000d96:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (clst >= dj->fs->max_clust) {				/* When it reached end of dynamic table */
 8000d9a:	6820      	ldr	r0, [r4, #0]
 8000d9c:	69c3      	ldr	r3, [r0, #28]
 8000d9e:	429d      	cmp	r5, r3
 8000da0:	d339      	bcc.n	8000e16 <dir_next+0xd4>
#if !_FS_READONLY
					BYTE c;
					if (!streach) return FR_NO_FILE;			/* When do not stretch, report EOT */
 8000da2:	2f00      	cmp	r7, #0
 8000da4:	d0d5      	beq.n	8000d52 <dir_next+0x10>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
 8000da6:	68e1      	ldr	r1, [r4, #12]
 8000da8:	f7ff ff01 	bl	8000bae <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8000dac:	4605      	mov	r5, r0
 8000dae:	2800      	cmp	r0, #0
 8000db0:	d042      	beq.n	8000e38 <dir_next+0xf6>
					if (clst == 1) return FR_INT_ERR;
 8000db2:	2801      	cmp	r0, #1
 8000db4:	d0e9      	beq.n	8000d8a <dir_next+0x48>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8000db6:	1c41      	adds	r1, r0, #1
 8000db8:	d0ec      	beq.n	8000d94 <dir_next+0x52>
					/* Clean-up streached table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
 8000dba:	6820      	ldr	r0, [r4, #0]
 8000dbc:	2100      	movs	r1, #0
 8000dbe:	f7ff fd2b 	bl	8000818 <move_window>
 8000dc2:	4607      	mov	r7, r0
 8000dc4:	2800      	cmp	r0, #0
 8000dc6:	d1e5      	bne.n	8000d94 <dir_next+0x52>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
 8000dc8:	6820      	ldr	r0, [r4, #0]
 8000dca:	4639      	mov	r1, r7
 8000dcc:	3030      	adds	r0, #48	; 0x30
 8000dce:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000dd2:	f7ff fc92 	bl	80006fa <mem_set>
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
 8000dd6:	f8d4 9000 	ldr.w	r9, [r4]
 8000dda:	4629      	mov	r1, r5
 8000ddc:	4648      	mov	r0, r9
 8000dde:	f7ff ff62 	bl	8000ca6 <clust2sect>
 8000de2:	f8c9 002c 	str.w	r0, [r9, #44]	; 0x2c
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dj->fs->wflag = 1;
 8000de6:	f04f 0901 	mov.w	r9, #1
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up streached table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 8000dea:	e00d      	b.n	8000e08 <dir_next+0xc6>
						dj->fs->wflag = 1;
 8000dec:	f883 9004 	strb.w	r9, [r3, #4]
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
 8000df0:	6820      	ldr	r0, [r4, #0]
 8000df2:	2100      	movs	r1, #0
 8000df4:	f7ff fd10 	bl	8000818 <move_window>
 8000df8:	2800      	cmp	r0, #0
 8000dfa:	d1cb      	bne.n	8000d94 <dir_next+0x52>
						dj->fs->winsect++;
 8000dfc:	6823      	ldr	r3, [r4, #0]
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up streached table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 8000dfe:	3701      	adds	r7, #1
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
 8000e00:	6ada      	ldr	r2, [r3, #44]	; 0x2c
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up streached table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 8000e02:	b2ff      	uxtb	r7, r7
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
 8000e04:	3201      	adds	r2, #1
 8000e06:	62da      	str	r2, [r3, #44]	; 0x2c
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up streached table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 8000e08:	6823      	ldr	r3, [r4, #0]
 8000e0a:	789a      	ldrb	r2, [r3, #2]
 8000e0c:	42ba      	cmp	r2, r7
 8000e0e:	d8ed      	bhi.n	8000dec <dir_next+0xaa>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
 8000e10:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000e12:	1bd7      	subs	r7, r2, r7
 8000e14:	62df      	str	r7, [r3, #44]	; 0x2c
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
 8000e16:	60e5      	str	r5, [r4, #12]
				dj->sect = clust2sect(dj->fs, clst);
 8000e18:	6820      	ldr	r0, [r4, #0]
 8000e1a:	4629      	mov	r1, r5
 8000e1c:	f7ff ff43 	bl	8000ca6 <clust2sect>
 8000e20:	6120      	str	r0, [r4, #16]
			}
		}
	}

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;
 8000e22:	6823      	ldr	r3, [r4, #0]
 8000e24:	ea4f 1848 	mov.w	r8, r8, lsl #5
 8000e28:	f108 0830 	add.w	r8, r8, #48	; 0x30
 8000e2c:	4443      	add	r3, r8
				dj->sect = clust2sect(dj->fs, clst);
			}
		}
	}

	dj->index = i;
 8000e2e:	80e6      	strh	r6, [r4, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;
 8000e30:	6163      	str	r3, [r4, #20]

	return FR_OK;
 8000e32:	2000      	movs	r0, #0
 8000e34:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (clst >= dj->fs->max_clust) {				/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!streach) return FR_NO_FILE;			/* When do not stretch, report EOT */
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8000e38:	2007      	movs	r0, #7

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;

	return FR_OK;
}
 8000e3a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08000e3e <dir_find.part.5>:
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
 8000e3e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000e42:	f04f 09ff 	mov.w	r9, #255	; 0xff
 8000e46:	4606      	mov	r6, r0
 8000e48:	464c      	mov	r4, r9

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
 8000e4a:	6830      	ldr	r0, [r6, #0]
 8000e4c:	6931      	ldr	r1, [r6, #16]
 8000e4e:	f7ff fce3 	bl	8000818 <move_window>
		if (res != FR_OK) break;
 8000e52:	4680      	mov	r8, r0
 8000e54:	2800      	cmp	r0, #0
 8000e56:	f040 8083 	bne.w	8000f60 <dir_find.part.5+0x122>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
 8000e5a:	6975      	ldr	r5, [r6, #20]
		c = dir[DIR_Name];
 8000e5c:	782f      	ldrb	r7, [r5, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8000e5e:	2f00      	cmp	r7, #0
 8000e60:	d078      	beq.n	8000f54 <dir_find.part.5+0x116>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
 8000e62:	7aea      	ldrb	r2, [r5, #11]
		if (c == 0xE5 || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8000e64:	2fe5      	cmp	r7, #229	; 0xe5
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
 8000e66:	f002 033f 	and.w	r3, r2, #63	; 0x3f
		if (c == 0xE5 || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8000e6a:	d069      	beq.n	8000f40 <dir_find.part.5+0x102>
 8000e6c:	f002 0208 	and.w	r2, r2, #8
 8000e70:	b2d2      	uxtb	r2, r2
 8000e72:	b112      	cbz	r2, 8000e7a <dir_find.part.5+0x3c>
 8000e74:	2b0f      	cmp	r3, #15
 8000e76:	d163      	bne.n	8000f40 <dir_find.part.5+0x102>
 8000e78:	e001      	b.n	8000e7e <dir_find.part.5+0x40>
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
 8000e7a:	2b0f      	cmp	r3, #15
 8000e7c:	d14a      	bne.n	8000f14 <dir_find.part.5+0xd6>
				if (dj->lfn) {
 8000e7e:	f8d6 b01c 	ldr.w	fp, [r6, #28]
 8000e82:	f1bb 0f00 	cmp.w	fp, #0
 8000e86:	d05c      	beq.n	8000f42 <dir_find.part.5+0x104>
					if (c & 0x40) {		/* Is it start of LFN sequence? */
 8000e88:	f007 0340 	and.w	r3, r7, #64	; 0x40
 8000e8c:	b2db      	uxtb	r3, r3
 8000e8e:	b133      	cbz	r3, 8000e9e <dir_find.part.5+0x60>
						sum = dir[LDIR_Chksum];
						c &= 0xBF; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
 8000e90:	88f3      	ldrh	r3, [r6, #6]
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
					if (c & 0x40) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
 8000e92:	f895 900d 	ldrb.w	r9, [r5, #13]
						c &= 0xBF; ord = c;	/* LFN start order */
 8000e96:	f007 07bf 	and.w	r7, r7, #191	; 0xbf
						dj->lfn_idx = dj->index;
 8000e9a:	8433      	strh	r3, [r6, #32]
 8000e9c:	e001      	b.n	8000ea2 <dir_find.part.5+0x64>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
 8000e9e:	42a7      	cmp	r7, r4
 8000ea0:	d14e      	bne.n	8000f40 <dir_find.part.5+0x102>
 8000ea2:	7b6b      	ldrb	r3, [r5, #13]
 8000ea4:	454b      	cmp	r3, r9
 8000ea6:	d14b      	bne.n	8000f40 <dir_find.part.5+0x102>
{
	int i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & 0xBF) - 1) * 13;	/* Get offset in the LFN buffer */
 8000ea8:	782c      	ldrb	r4, [r5, #0]
 8000eaa:	230d      	movs	r3, #13
 8000eac:	f004 04bf 	and.w	r4, r4, #191	; 0xbf
 8000eb0:	3c01      	subs	r4, #1
 8000eb2:	435c      	muls	r4, r3
	s = 0; wc = 1;
 8000eb4:	f04f 0801 	mov.w	r8, #1
 8000eb8:	f04f 0a00 	mov.w	sl, #0
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
 8000ebc:	4b2a      	ldr	r3, [pc, #168]	; (8000f68 <dir_find.part.5+0x12a>)
 8000ebe:	f81a 1003 	ldrb.w	r1, [sl, r3]
 8000ec2:	1868      	adds	r0, r5, r1
 8000ec4:	7840      	ldrb	r0, [r0, #1]
 8000ec6:	5c69      	ldrb	r1, [r5, r1]
 8000ec8:	ea41 2000 	orr.w	r0, r1, r0, lsl #8
		if (wc) {	/* Last char has not been processed */
 8000ecc:	f1b8 0f00 	cmp.w	r8, #0
 8000ed0:	d00b      	beq.n	8000eea <dir_find.part.5+0xac>
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
 8000ed2:	f7ff fbd5 	bl	8000680 <ff_wtoupper>
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
 8000ed6:	2cfe      	cmp	r4, #254	; 0xfe
	i = ((dir[LDIR_Ord] & 0xBF) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
 8000ed8:	4680      	mov	r8, r0
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
 8000eda:	dc31      	bgt.n	8000f40 <dir_find.part.5+0x102>
 8000edc:	f83b 0014 	ldrh.w	r0, [fp, r4, lsl #1]
 8000ee0:	f7ff fbce 	bl	8000680 <ff_wtoupper>
 8000ee4:	3401      	adds	r4, #1
 8000ee6:	4580      	cmp	r8, r0
 8000ee8:	e002      	b.n	8000ef0 <dir_find.part.5+0xb2>
				return FALSE;			/* Not matched */
		} else {
			if (uc != 0xFFFF) return FALSE;	/* Check filler */
 8000eea:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8000eee:	4298      	cmp	r0, r3
 8000ef0:	d126      	bne.n	8000f40 <dir_find.part.5+0x102>
		}
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
 8000ef2:	f10a 0a01 	add.w	sl, sl, #1
 8000ef6:	f1ba 0f0d 	cmp.w	sl, #13
 8000efa:	d1df      	bne.n	8000ebc <dir_find.part.5+0x7e>

	if ((dir[LDIR_Ord] & 0x40) && wc && lfnbuf[i])	/* Last segment matched but different length */
 8000efc:	782b      	ldrb	r3, [r5, #0]
 8000efe:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000f02:	b2db      	uxtb	r3, r3
 8000f04:	b34b      	cbz	r3, 8000f5a <dir_find.part.5+0x11c>
 8000f06:	f1b8 0f00 	cmp.w	r8, #0
 8000f0a:	d026      	beq.n	8000f5a <dir_find.part.5+0x11c>
 8000f0c:	f83b 3014 	ldrh.w	r3, [fp, r4, lsl #1]
 8000f10:	b31b      	cbz	r3, 8000f5a <dir_find.part.5+0x11c>
 8000f12:	e015      	b.n	8000f40 <dir_find.part.5+0x102>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
 8000f14:	b924      	cbnz	r4, 8000f20 <dir_find.part.5+0xe2>
 8000f16:	4628      	mov	r0, r5
 8000f18:	f7ff fbf6 	bl	8000708 <sum_sfn>
 8000f1c:	4581      	cmp	r9, r0
 8000f1e:	d01f      	beq.n	8000f60 <dir_find.part.5+0x122>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 8000f20:	f04f 33ff 	mov.w	r3, #4294967295
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
 8000f24:	69b2      	ldr	r2, [r6, #24]
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 8000f26:	8433      	strh	r3, [r6, #32]
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
 8000f28:	7ad3      	ldrb	r3, [r2, #11]
 8000f2a:	f013 0301 	ands.w	r3, r3, #1
 8000f2e:	d002      	beq.n	8000f36 <dir_find.part.5+0xf8>
 8000f30:	e006      	b.n	8000f40 <dir_find.part.5+0x102>
/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, int cnt) {
	const char *d = (const char *)dst, *s = (const char *)src;
	int r = 0;
	while (cnt-- && (r = *d++ - *s++) == 0) ;
 8000f32:	2b0b      	cmp	r3, #11
 8000f34:	d014      	beq.n	8000f60 <dir_find.part.5+0x122>
 8000f36:	5ce8      	ldrb	r0, [r5, r3]
 8000f38:	5cd1      	ldrb	r1, [r2, r3]
 8000f3a:	3301      	adds	r3, #1
 8000f3c:	4288      	cmp	r0, r1
 8000f3e:	d0f8      	beq.n	8000f32 <dir_find.part.5+0xf4>
						sum = dir[LDIR_Chksum];
						c &= 0xBF; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
 8000f40:	24ff      	movs	r4, #255	; 0xff
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, FALSE);		/* Next entry */
 8000f42:	4630      	mov	r0, r6
 8000f44:	2100      	movs	r1, #0
 8000f46:	f7ff fefc 	bl	8000d42 <dir_next>
	} while (res == FR_OK);
 8000f4a:	4680      	mov	r8, r0
 8000f4c:	2800      	cmp	r0, #0
 8000f4e:	f43f af7c 	beq.w	8000e4a <dir_find.part.5+0xc>
 8000f52:	e005      	b.n	8000f60 <dir_find.part.5+0x122>
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8000f54:	f04f 0804 	mov.w	r8, #4
 8000f58:	e002      	b.n	8000f60 <dir_find.part.5+0x122>
						sum = dir[LDIR_Chksum];
						c &= 0xBF; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
 8000f5a:	1e7c      	subs	r4, r7, #1
 8000f5c:	b2e4      	uxtb	r4, r4
 8000f5e:	e7f0      	b.n	8000f42 <dir_find.part.5+0x104>
#endif
		res = dir_next(dj, FALSE);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
 8000f60:	4640      	mov	r0, r8
 8000f62:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000f66:	bf00      	nop
 8000f68:	0801e558 	.word	0x0801e558

08000f6c <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const XCHAR *path	/* Full-path string to find a file or directory */
)
{
 8000f6c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
 8000f70:	780b      	ldrb	r3, [r1, #0]
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const XCHAR *path	/* Full-path string to find a file or directory */
)
{
 8000f72:	4606      	mov	r6, r0
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
 8000f74:	2b2f      	cmp	r3, #47	; 0x2f
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const XCHAR *path	/* Full-path string to find a file or directory */
)
{
 8000f76:	4689      	mov	r9, r1
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
 8000f78:	d001      	beq.n	8000f7e <follow_path+0x12>
 8000f7a:	2b5c      	cmp	r3, #92	; 0x5c
 8000f7c:	d101      	bne.n	8000f82 <follow_path+0x16>
		path++;
 8000f7e:	f109 0901 	add.w	r9, r9, #1
	dj->sclust = 0;						/* Start from the root dir */
 8000f82:	2400      	movs	r4, #0
 8000f84:	60b4      	str	r4, [r6, #8]
#endif

	if ((UINT)*path < ' ') {			/* Null path means the start directory itself */
 8000f86:	f899 3000 	ldrb.w	r3, [r9]
 8000f8a:	2b1f      	cmp	r3, #31
 8000f8c:	d805      	bhi.n	8000f9a <follow_path+0x2e>
		res = dir_seek(dj, 0);
 8000f8e:	4630      	mov	r0, r6
 8000f90:	4621      	mov	r1, r4
 8000f92:	f7ff fe94 	bl	8000cbe <dir_seek>
		dj->dir = NULL;
 8000f96:	6174      	str	r4, [r6, #20]
 8000f98:	e114      	b.n	80011c4 <follow_path+0x258>
	const XCHAR *p;

	/* Create LFN in Unicode */
	si = di = 0;
	p = *path;
	lfn = dj->lfn;
 8000f9a:	f8d6 b01c 	ldr.w	fp, [r6, #28]
	WCHAR w, *lfn;
	int i, ni, si, di;
	const XCHAR *p;

	/* Create LFN in Unicode */
	si = di = 0;
 8000f9e:	2500      	movs	r5, #0
	p = *path;
	lfn = dj->lfn;
	for (;;) {
		w = p[si++];					/* Get a character */
 8000fa0:	f819 0005 	ldrb.w	r0, [r9, r5]
 8000fa4:	1c6c      	adds	r4, r5, #1
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
 8000fa6:	281f      	cmp	r0, #31
 8000fa8:	d91c      	bls.n	8000fe4 <follow_path+0x78>
 8000faa:	282f      	cmp	r0, #47	; 0x2f
 8000fac:	d01a      	beq.n	8000fe4 <follow_path+0x78>
 8000fae:	285c      	cmp	r0, #92	; 0x5c
 8000fb0:	d018      	beq.n	8000fe4 <follow_path+0x78>
		if (di >= _MAX_LFN)				/* Reject too long name */
 8000fb2:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
 8000fb6:	f000 80fe 	beq.w	80011b6 <follow_path+0x24a>
			b = p[si++];				/* Get 2nd byte */
			if (!IsDBCS2(b))			/* Reject invalid code for DBC */
				return FR_INVALID_NAME;
			w = (w << 8) + b;
		}
		w = ff_convert(w, 1);			/* Convert OEM to Unicode */
 8000fba:	2101      	movs	r1, #1
 8000fbc:	f7ff fb42 	bl	8000644 <ff_convert>
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 8000fc0:	2800      	cmp	r0, #0
 8000fc2:	f000 80f8 	beq.w	80011b6 <follow_path+0x24a>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
 8000fc6:	287f      	cmp	r0, #127	; 0x7f
 8000fc8:	d806      	bhi.n	8000fd8 <follow_path+0x6c>
 8000fca:	4a7f      	ldr	r2, [pc, #508]	; (80011c8 <follow_path+0x25c>)
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
 8000fcc:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8000fd0:	b113      	cbz	r3, 8000fd8 <follow_path+0x6c>
 8000fd2:	4283      	cmp	r3, r0
 8000fd4:	d1fa      	bne.n	8000fcc <follow_path+0x60>
 8000fd6:	e0ee      	b.n	80011b6 <follow_path+0x24a>
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
 8000fd8:	eb0b 0344 	add.w	r3, fp, r4, lsl #1
		w = ff_convert(w, 1);			/* Convert OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
 8000fdc:	f823 0c02 	strh.w	r0, [r3, #-2]
 8000fe0:	4625      	mov	r5, r4
 8000fe2:	e7dd      	b.n	8000fa0 <follow_path+0x34>
	}
	*path = &p[si];						/* Return pointer to the next segment */
 8000fe4:	44a1      	add	r9, r4
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
 8000fe6:	eb0b 0345 	add.w	r3, fp, r5, lsl #1
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 8000fea:	281f      	cmp	r0, #31
 8000fec:	bf94      	ite	ls
 8000fee:	2404      	movls	r4, #4
 8000ff0:	2400      	movhi	r4, #0
 8000ff2:	e007      	b.n	8001004 <follow_path+0x98>
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
		w = lfn[di - 1];
 8000ff4:	f833 2d02 	ldrh.w	r2, [r3, #-2]!
		if (w != ' ' && w != '.') break;
 8000ff8:	2a20      	cmp	r2, #32
 8000ffa:	d002      	beq.n	8001002 <follow_path+0x96>
 8000ffc:	2a2e      	cmp	r2, #46	; 0x2e
 8000ffe:	f040 80ca 	bne.w	8001196 <follow_path+0x22a>
		di--;
 8001002:	3d01      	subs	r5, #1
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
 8001004:	2d00      	cmp	r5, #0
 8001006:	d1f5      	bne.n	8000ff4 <follow_path+0x88>
 8001008:	e0d5      	b.n	80011b6 <follow_path+0x24a>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 800100a:	f108 0801 	add.w	r8, r8, #1
 800100e:	f83b 3018 	ldrh.w	r3, [fp, r8, lsl #1]
 8001012:	2b20      	cmp	r3, #32
 8001014:	d0f9      	beq.n	800100a <follow_path+0x9e>
 8001016:	2b2e      	cmp	r3, #46	; 0x2e
 8001018:	d0f7      	beq.n	800100a <follow_path+0x9e>
	if (si) cf |= NS_LOSS | NS_LFN;
 800101a:	f1b8 0f00 	cmp.w	r8, #0
 800101e:	d001      	beq.n	8001024 <follow_path+0xb8>
 8001020:	f044 0403 	orr.w	r4, r4, #3
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
 8001024:	eb0b 0345 	add.w	r3, fp, r5, lsl #1
 8001028:	e008      	b.n	800103c <follow_path+0xd0>

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 800102a:	3d01      	subs	r5, #1
 800102c:	d106      	bne.n	800103c <follow_path+0xd0>
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
 800102e:	f04f 0c00 	mov.w	ip, #0
 8001032:	f04f 0a08 	mov.w	sl, #8
 8001036:	4667      	mov	r7, ip
		}

		if (w >= 0x80) {				/* Non ASCII char */
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = cvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
 8001038:	4a64      	ldr	r2, [pc, #400]	; (80011cc <follow_path+0x260>)
 800103a:	e004      	b.n	8001046 <follow_path+0xda>

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 800103c:	f833 2d02 	ldrh.w	r2, [r3, #-2]!
 8001040:	2a2e      	cmp	r2, #46	; 0x2e
 8001042:	d1f2      	bne.n	800102a <follow_path+0xbe>
 8001044:	e7f3      	b.n	800102e <follow_path+0xc2>

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
 8001046:	f83b 3018 	ldrh.w	r3, [fp, r8, lsl #1]
 800104a:	f108 0801 	add.w	r8, r8, #1
		if (!w) break;					/* Break on end of the LFN */
 800104e:	2b00      	cmp	r3, #0
 8001050:	d052      	beq.n	80010f8 <follow_path+0x18c>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 8001052:	2b20      	cmp	r3, #32
 8001054:	d004      	beq.n	8001060 <follow_path+0xf4>
 8001056:	2b2e      	cmp	r3, #46	; 0x2e
 8001058:	d105      	bne.n	8001066 <follow_path+0xfa>
 800105a:	45a8      	cmp	r8, r5
 800105c:	f000 80ad 	beq.w	80011ba <follow_path+0x24e>
			cf |= NS_LOSS | NS_LFN; continue;
 8001060:	f044 0403 	orr.w	r4, r4, #3
 8001064:	e7ef      	b.n	8001046 <follow_path+0xda>
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
 8001066:	45d4      	cmp	ip, sl
 8001068:	da02      	bge.n	8001070 <follow_path+0x104>
 800106a:	45a8      	cmp	r8, r5
 800106c:	d115      	bne.n	800109a <follow_path+0x12e>
 800106e:	e0a4      	b.n	80011ba <follow_path+0x24e>
			if (ni == 11) {				/* Long extension */
 8001070:	f1ba 0f0b 	cmp.w	sl, #11
 8001074:	d104      	bne.n	8001080 <follow_path+0x114>
				cf |= NS_LOSS | NS_LFN; break;
 8001076:	f044 0403 	orr.w	r4, r4, #3
 800107a:	f04f 0a0b 	mov.w	sl, #11
 800107e:	e03b      	b.n	80010f8 <follow_path+0x18c>
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 8001080:	45a8      	cmp	r8, r5
 8001082:	d002      	beq.n	800108a <follow_path+0x11e>
 8001084:	f044 0403 	orr.w	r4, r4, #3
			if (si > di) break;			/* No extension */
 8001088:	dc36      	bgt.n	80010f8 <follow_path+0x18c>
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
 800108a:	00bf      	lsls	r7, r7, #2
 800108c:	b2ff      	uxtb	r7, r7
 800108e:	46a8      	mov	r8, r5
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
 8001090:	f04f 0a0b 	mov.w	sl, #11
 8001094:	f04f 0c08 	mov.w	ip, #8
 8001098:	e7d5      	b.n	8001046 <follow_path+0xda>
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII char */
 800109a:	2b7f      	cmp	r3, #127	; 0x7f
 800109c:	d90f      	bls.n	80010be <follow_path+0x152>
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
 800109e:	4618      	mov	r0, r3
 80010a0:	2100      	movs	r1, #0
 80010a2:	e88d 1004 	stmia.w	sp, {r2, ip}
 80010a6:	f7ff facd 	bl	8000644 <ff_convert>
			if (w) w = cvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
 80010aa:	e89d 1004 	ldmia.w	sp, {r2, ip}
 80010ae:	4603      	mov	r3, r0
 80010b0:	b110      	cbz	r0, 80010b8 <follow_path+0x14c>
 80010b2:	1813      	adds	r3, r2, r0
 80010b4:	f813 3c73 	ldrb.w	r3, [r3, #-115]
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
 80010b8:	f044 0402 	orr.w	r4, r4, #2
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;[=]", w)) {		/* Replace illegal chars for SFN */
 80010bc:	b133      	cbz	r3, 80010cc <follow_path+0x160>
 80010be:	4844      	ldr	r0, [pc, #272]	; (80011d0 <follow_path+0x264>)
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
 80010c0:	f810 1f01 	ldrb.w	r1, [r0, #1]!
 80010c4:	2900      	cmp	r1, #0
 80010c6:	d070      	beq.n	80011aa <follow_path+0x23e>
 80010c8:	4299      	cmp	r1, r3
 80010ca:	d1f9      	bne.n	80010c0 <follow_path+0x154>
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;[=]", w)) {		/* Replace illegal chars for SFN */
				w = '_'; cf |= NS_LOSS | NS_LFN;	/* Lossy conversion */
 80010cc:	f044 0403 	orr.w	r4, r4, #3
 80010d0:	235f      	movs	r3, #95	; 0x5f
 80010d2:	e00b      	b.n	80010ec <follow_path+0x180>
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
					b |= 2;
 80010d4:	f047 0702 	orr.w	r7, r7, #2
 80010d8:	e008      	b.n	80010ec <follow_path+0x180>
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
 80010da:	f1a3 0161 	sub.w	r1, r3, #97	; 0x61
 80010de:	b289      	uxth	r1, r1
 80010e0:	2919      	cmp	r1, #25
 80010e2:	d803      	bhi.n	80010ec <follow_path+0x180>
						b |= 1; w -= 0x20;
 80010e4:	3b20      	subs	r3, #32
 80010e6:	f047 0701 	orr.w	r7, r7, #1
 80010ea:	b29b      	uxth	r3, r3
					}
				}
			}
		}
		dj->fn[i++] = (BYTE)w;
 80010ec:	69b1      	ldr	r1, [r6, #24]
 80010ee:	f801 300c 	strb.w	r3, [r1, ip]
 80010f2:	f10c 0c01 	add.w	ip, ip, #1
 80010f6:	e7a6      	b.n	8001046 <follow_path+0xda>
	}

	if (dj->fn[0] == 0xE5) dj->fn[0] = 0x05;	/* If the first char collides with deleted mark, replace it with 0x05 */
 80010f8:	69b3      	ldr	r3, [r6, #24]
 80010fa:	781a      	ldrb	r2, [r3, #0]
 80010fc:	2ae5      	cmp	r2, #229	; 0xe5
 80010fe:	d101      	bne.n	8001104 <follow_path+0x198>
 8001100:	2205      	movs	r2, #5
 8001102:	701a      	strb	r2, [r3, #0]

	if (ni == 8) b <<= 2;
 8001104:	f1ba 0f08 	cmp.w	sl, #8
 8001108:	d101      	bne.n	800110e <follow_path+0x1a2>
 800110a:	00bf      	lsls	r7, r7, #2
 800110c:	b2ff      	uxtb	r7, r7
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
 800110e:	f007 030c 	and.w	r3, r7, #12
 8001112:	2b0c      	cmp	r3, #12
 8001114:	d003      	beq.n	800111e <follow_path+0x1b2>
 8001116:	f007 0203 	and.w	r2, r7, #3
 800111a:	2a03      	cmp	r2, #3
 800111c:	d101      	bne.n	8001122 <follow_path+0x1b6>
		cf |= NS_LFN;
 800111e:	f044 0402 	orr.w	r4, r4, #2
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
 8001122:	f004 0202 	and.w	r2, r4, #2
 8001126:	b2d2      	uxtb	r2, r2
 8001128:	b94a      	cbnz	r2, 800113e <follow_path+0x1d2>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 800112a:	f007 0703 	and.w	r7, r7, #3
 800112e:	2f01      	cmp	r7, #1
 8001130:	bf08      	it	eq
 8001132:	f044 0410 	orreq.w	r4, r4, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 8001136:	2b04      	cmp	r3, #4
 8001138:	bf08      	it	eq
 800113a:	f044 0408 	orreq.w	r4, r4, #8
	}

	dj->fn[NS] = cf;	/* SFN is created */
 800113e:	69b3      	ldr	r3, [r6, #24]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_seek(dj, 0);			/* Rewind directory object */
 8001140:	4630      	mov	r0, r6
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
	}

	dj->fn[NS] = cf;	/* SFN is created */
 8001142:	72dc      	strb	r4, [r3, #11]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_seek(dj, 0);			/* Rewind directory object */
 8001144:	2100      	movs	r1, #0
 8001146:	f7ff fdba 	bl	8000cbe <dir_seek>
	if (res != FR_OK) return res;
 800114a:	b910      	cbnz	r0, 8001152 <follow_path+0x1e6>
 800114c:	4630      	mov	r0, r6
 800114e:	f7ff fe76 	bl	8000e3e <dir_find.part.5>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			last = *(dj->fn+NS) & NS_LAST;
 8001152:	69b3      	ldr	r3, [r6, #24]
 8001154:	7adb      	ldrb	r3, [r3, #11]
 8001156:	f003 0304 	and.w	r3, r3, #4
 800115a:	b2db      	uxtb	r3, r3
			if (res != FR_OK) {				/* Could not find the object */
 800115c:	b130      	cbz	r0, 800116c <follow_path+0x200>
				if (res == FR_NO_FILE && !last)
 800115e:	2804      	cmp	r0, #4
 8001160:	d130      	bne.n	80011c4 <follow_path+0x258>
					res = FR_NO_PATH;
 8001162:	2b00      	cmp	r3, #0
 8001164:	bf14      	ite	ne
 8001166:	2004      	movne	r0, #4
 8001168:	2005      	moveq	r0, #5
 800116a:	e02b      	b.n	80011c4 <follow_path+0x258>
				break;
			}
			if (last) break;				/* Last segment match. Function completed. */
 800116c:	bb53      	cbnz	r3, 80011c4 <follow_path+0x258>
			dir = dj->dir;					/* There is next segment. Follow the sub directory */
 800116e:	6973      	ldr	r3, [r6, #20]
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
 8001170:	7ada      	ldrb	r2, [r3, #11]
 8001172:	f002 0210 	and.w	r2, r2, #16
 8001176:	b2d2      	uxtb	r2, r2
 8001178:	b15a      	cbz	r2, 8001192 <follow_path+0x226>
				res = FR_NO_PATH; break;
			}
			dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 800117a:	7d59      	ldrb	r1, [r3, #21]
 800117c:	7d1a      	ldrb	r2, [r3, #20]
 800117e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8001182:	7ed9      	ldrb	r1, [r3, #27]
 8001184:	7e9b      	ldrb	r3, [r3, #26]
 8001186:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800118a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800118e:	60b3      	str	r3, [r6, #8]
		}
 8001190:	e703      	b.n	8000f9a <follow_path+0x2e>
				break;
			}
			if (last) break;				/* Last segment match. Function completed. */
			dir = dj->dir;					/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
 8001192:	2005      	movs	r0, #5
 8001194:	e016      	b.n	80011c4 <follow_path+0x258>
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject null string */

	lfn[di] = 0;						/* LFN is created */
 8001196:	f04f 0800 	mov.w	r8, #0
 800119a:	f82b 8015 	strh.w	r8, [fp, r5, lsl #1]

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
 800119e:	69b0      	ldr	r0, [r6, #24]
 80011a0:	2120      	movs	r1, #32
 80011a2:	220b      	movs	r2, #11
 80011a4:	f7ff faa9 	bl	80006fa <mem_set>
 80011a8:	e731      	b.n	800100e <follow_path+0xa2>
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;[=]", w)) {		/* Replace illegal chars for SFN */
				w = '_'; cf |= NS_LOSS | NS_LFN;	/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
 80011aa:	f1a3 0141 	sub.w	r1, r3, #65	; 0x41
 80011ae:	b289      	uxth	r1, r1
 80011b0:	2919      	cmp	r1, #25
 80011b2:	d98f      	bls.n	80010d4 <follow_path+0x168>
 80011b4:	e791      	b.n	80010da <follow_path+0x16e>
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			last = *(dj->fn+NS) & NS_LAST;
			if (res != FR_OK) {				/* Could not find the object */
 80011b6:	2006      	movs	r0, #6
 80011b8:	e004      	b.n	80011c4 <follow_path+0x258>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
 80011ba:	f1ba 0f0b 	cmp.w	sl, #11
 80011be:	f47f af64 	bne.w	800108a <follow_path+0x11e>
 80011c2:	e758      	b.n	8001076 <follow_path+0x10a>
			dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
		}
	}

	return res;
}
 80011c4:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80011c8:	0801ffb3 	.word	0x0801ffb3
 80011cc:	0801e558 	.word	0x0801e558
 80011d0:	0801ffbc 	.word	0x0801ffbc

080011d4 <dir_remove>:
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR *dj				/* Directory object pointing the entry to be removed */
)
{
 80011d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	FRESULT res;
#if _USE_LFN	/* LFN configuration */
	WORD i;

	i = dj->index;	/* SFN index */
	res = dir_seek(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
 80011d6:	8c01      	ldrh	r1, [r0, #32]
{
	FRESULT res;
#if _USE_LFN	/* LFN configuration */
	WORD i;

	i = dj->index;	/* SFN index */
 80011d8:	88c5      	ldrh	r5, [r0, #6]
	res = dir_seek(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
 80011da:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80011de:	4299      	cmp	r1, r3
 80011e0:	bf08      	it	eq
 80011e2:	4629      	moveq	r1, r5
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR *dj				/* Directory object pointing the entry to be removed */
)
{
 80011e4:	4604      	mov	r4, r0
	FRESULT res;
#if _USE_LFN	/* LFN configuration */
	WORD i;

	i = dj->index;	/* SFN index */
	res = dir_seek(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
 80011e6:	f7ff fd6a 	bl	8000cbe <dir_seek>
	if (res == FR_OK) {
 80011ea:	4601      	mov	r1, r0
 80011ec:	b9b8      	cbnz	r0, 800121e <dir_remove+0x4a>
		do {
			res = move_window(dj->fs, dj->sect);
			if (res != FR_OK) break;
			*dj->dir = 0xE5;			/* Mark the entry "deleted" */
 80011ee:	26e5      	movs	r6, #229	; 0xe5
			dj->fs->wflag = 1;
 80011f0:	2701      	movs	r7, #1

	i = dj->index;	/* SFN index */
	res = dir_seek(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
	if (res == FR_OK) {
		do {
			res = move_window(dj->fs, dj->sect);
 80011f2:	6921      	ldr	r1, [r4, #16]
 80011f4:	6820      	ldr	r0, [r4, #0]
 80011f6:	f7ff fb0f 	bl	8000818 <move_window>
			if (res != FR_OK) break;
 80011fa:	4601      	mov	r1, r0
 80011fc:	b960      	cbnz	r0, 8001218 <dir_remove+0x44>
			*dj->dir = 0xE5;			/* Mark the entry "deleted" */
 80011fe:	6963      	ldr	r3, [r4, #20]
 8001200:	701e      	strb	r6, [r3, #0]
			dj->fs->wflag = 1;
 8001202:	6823      	ldr	r3, [r4, #0]
 8001204:	711f      	strb	r7, [r3, #4]
			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
 8001206:	88e3      	ldrh	r3, [r4, #6]
 8001208:	42ab      	cmp	r3, r5
 800120a:	d208      	bcs.n	800121e <dir_remove+0x4a>
			res = dir_next(dj, FALSE);	/* Next entry */
 800120c:	4620      	mov	r0, r4
 800120e:	f7ff fd98 	bl	8000d42 <dir_next>
		} while (res == FR_OK);
 8001212:	4601      	mov	r1, r0
 8001214:	2800      	cmp	r0, #0
 8001216:	d0ec      	beq.n	80011f2 <dir_remove+0x1e>
		if (res == FR_NO_FILE) res = FR_INT_ERR;
 8001218:	2904      	cmp	r1, #4
 800121a:	bf08      	it	eq
 800121c:	2102      	moveq	r1, #2
		}
	}
#endif

	return res;
}
 800121e:	4608      	mov	r0, r1
 8001220:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001222 <dir_read>:
#if _FS_MINIMIZE <= 1
static
FRESULT dir_read (
	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
)
{
 8001222:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	FRESULT res;
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
 8001226:	27ff      	movs	r7, #255	; 0xff
#if _FS_MINIMIZE <= 1
static
FRESULT dir_read (
	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
)
{
 8001228:	4605      	mov	r5, r0
	FRESULT res;
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
 800122a:	463c      	mov	r4, r7
#endif

	res = FR_NO_FILE;
 800122c:	2604      	movs	r6, #4

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */

	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);			/* Pick an LFN character from the entry */
 800122e:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 8001328 <dir_read+0x106>
		if (wc) {	/* Last char has not been processed */
			if (i >= _MAX_LFN) return FALSE;	/* Buffer overflow? */
			lfnbuf[i++] = wc = uc;				/* Store it */
		} else {
			if (uc != 0xFFFF) return FALSE;		/* Check filler */
 8001232:	f64f 79ff 	movw	r9, #65535	; 0xffff
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
 8001236:	e067      	b.n	8001308 <dir_read+0xe6>
		res = move_window(dj->fs, dj->sect);
 8001238:	6828      	ldr	r0, [r5, #0]
 800123a:	f7ff faed 	bl	8000818 <move_window>
		if (res != FR_OK) break;
 800123e:	4606      	mov	r6, r0
 8001240:	2800      	cmp	r0, #0
 8001242:	d165      	bne.n	8001310 <dir_read+0xee>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
 8001244:	696b      	ldr	r3, [r5, #20]
		c = dir[DIR_Name];
 8001246:	781a      	ldrb	r2, [r3, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8001248:	2a00      	cmp	r2, #0
 800124a:	d067      	beq.n	800131c <dir_read+0xfa>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == 0xE5 || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 800124c:	2ae5      	cmp	r2, #229	; 0xe5
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
 800124e:	7ad8      	ldrb	r0, [r3, #11]
		if (c == 0xE5 || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8001250:	d053      	beq.n	80012fa <dir_read+0xd8>
 8001252:	2a2e      	cmp	r2, #46	; 0x2e
 8001254:	d051      	beq.n	80012fa <dir_read+0xd8>
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
 8001256:	f000 013f 	and.w	r1, r0, #63	; 0x3f
		if (c == 0xE5 || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 800125a:	f000 0008 	and.w	r0, r0, #8
 800125e:	b2c0      	uxtb	r0, r0
 8001260:	b110      	cbz	r0, 8001268 <dir_read+0x46>
 8001262:	290f      	cmp	r1, #15
 8001264:	d149      	bne.n	80012fa <dir_read+0xd8>
 8001266:	e001      	b.n	800126c <dir_read+0x4a>
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
 8001268:	290f      	cmp	r1, #15
 800126a:	d13c      	bne.n	80012e6 <dir_read+0xc4>
				if (c & 0x40) {			/* Is it start of LFN sequence? */
 800126c:	f002 0140 	and.w	r1, r2, #64	; 0x40
 8001270:	b2c9      	uxtb	r1, r1
 8001272:	b129      	cbz	r1, 8001280 <dir_read+0x5e>
					sum = dir[LDIR_Chksum];
					c &= 0xBF; ord = c;
					dj->lfn_idx = dj->index;
 8001274:	88e9      	ldrh	r1, [r5, #6]
		if (c == 0xE5 || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (c & 0x40) {			/* Is it start of LFN sequence? */
					sum = dir[LDIR_Chksum];
 8001276:	7b5f      	ldrb	r7, [r3, #13]
					c &= 0xBF; ord = c;
 8001278:	f002 04bf 	and.w	r4, r2, #191	; 0xbf
					dj->lfn_idx = dj->index;
 800127c:	8429      	strh	r1, [r5, #32]
 800127e:	e001      	b.n	8001284 <dir_read+0x62>
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
 8001280:	42a2      	cmp	r2, r4
 8001282:	d13a      	bne.n	80012fa <dir_read+0xd8>
 8001284:	7b5a      	ldrb	r2, [r3, #13]
 8001286:	42ba      	cmp	r2, r7
 8001288:	d137      	bne.n	80012fa <dir_read+0xd8>
{
	int i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 800128a:	781a      	ldrb	r2, [r3, #0]
 800128c:	210d      	movs	r1, #13
 800128e:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8001292:	3a01      	subs	r2, #1
					sum = dir[LDIR_Chksum];
					c &= 0xBF; ord = c;
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
 8001294:	69ee      	ldr	r6, [r5, #28]
{
	int i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 8001296:	434a      	muls	r2, r1

	s = 0; wc = 1;
 8001298:	f04f 0e01 	mov.w	lr, #1
 800129c:	2100      	movs	r1, #0
	do {
		uc = LD_WORD(dir+LfnOfs[s]);			/* Pick an LFN character from the entry */
 800129e:	f811 c008 	ldrb.w	ip, [r1, r8]
 80012a2:	eb03 000c 	add.w	r0, r3, ip
 80012a6:	f890 a001 	ldrb.w	sl, [r0, #1]
 80012aa:	f813 000c 	ldrb.w	r0, [r3, ip]
 80012ae:	ea40 200a 	orr.w	r0, r0, sl, lsl #8
		if (wc) {	/* Last char has not been processed */
 80012b2:	f1be 0f00 	cmp.w	lr, #0
 80012b6:	d006      	beq.n	80012c6 <dir_read+0xa4>
			if (i >= _MAX_LFN) return FALSE;	/* Buffer overflow? */
 80012b8:	2afe      	cmp	r2, #254	; 0xfe
 80012ba:	dc1e      	bgt.n	80012fa <dir_read+0xd8>
			lfnbuf[i++] = wc = uc;				/* Store it */
 80012bc:	f826 0012 	strh.w	r0, [r6, r2, lsl #1]

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */

	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);			/* Pick an LFN character from the entry */
 80012c0:	4686      	mov	lr, r0
		if (wc) {	/* Last char has not been processed */
			if (i >= _MAX_LFN) return FALSE;	/* Buffer overflow? */
			lfnbuf[i++] = wc = uc;				/* Store it */
 80012c2:	3201      	adds	r2, #1
 80012c4:	e001      	b.n	80012ca <dir_read+0xa8>
		} else {
			if (uc != 0xFFFF) return FALSE;		/* Check filler */
 80012c6:	4548      	cmp	r0, r9
 80012c8:	d117      	bne.n	80012fa <dir_read+0xd8>
		}
	} while (++s < 13);						/* Read all character in the entry */
 80012ca:	3101      	adds	r1, #1
 80012cc:	290d      	cmp	r1, #13
 80012ce:	d1e6      	bne.n	800129e <dir_read+0x7c>

	if (dir[LDIR_Ord] & 0x40) {				/* Put terminator if it is the last LFN part */
 80012d0:	781b      	ldrb	r3, [r3, #0]
 80012d2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80012d6:	b2db      	uxtb	r3, r3
 80012d8:	b1eb      	cbz	r3, 8001316 <dir_read+0xf4>
		if (i >= _MAX_LFN) return FALSE;	/* Buffer overflow? */
 80012da:	2afe      	cmp	r2, #254	; 0xfe
 80012dc:	dc0d      	bgt.n	80012fa <dir_read+0xd8>
		lfnbuf[i] = 0;
 80012de:	2300      	movs	r3, #0
 80012e0:	f826 3012 	strh.w	r3, [r6, r2, lsl #1]
 80012e4:	e017      	b.n	8001316 <dir_read+0xf4>
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
			} else {					/* An SFN entry is found */
				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
 80012e6:	b924      	cbnz	r4, 80012f2 <dir_read+0xd0>
 80012e8:	4618      	mov	r0, r3
 80012ea:	f7ff fa0d 	bl	8000708 <sum_sfn>
 80012ee:	4287      	cmp	r7, r0
 80012f0:	d016      	beq.n	8001320 <dir_read+0xfe>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
 80012f2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80012f6:	842b      	strh	r3, [r5, #32]
 80012f8:	e012      	b.n	8001320 <dir_read+0xfe>
					sum = dir[LDIR_Chksum];
					c &= 0xBF; ord = c;
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
 80012fa:	24ff      	movs	r4, #255	; 0xff
		}
#else		/* Non LFN configuration */
		if (c != 0xE5 && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, FALSE);				/* Next entry */
 80012fc:	4628      	mov	r0, r5
 80012fe:	2100      	movs	r1, #0
 8001300:	f7ff fd1f 	bl	8000d42 <dir_next>
		if (res != FR_OK) break;
 8001304:	4606      	mov	r6, r0
 8001306:	b918      	cbnz	r0, 8001310 <dir_read+0xee>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
 8001308:	6929      	ldr	r1, [r5, #16]
 800130a:	2900      	cmp	r1, #0
 800130c:	d194      	bne.n	8001238 <dir_read+0x16>
#endif
		res = dir_next(dj, FALSE);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
 800130e:	b13e      	cbz	r6, 8001320 <dir_read+0xfe>
 8001310:	2300      	movs	r3, #0
 8001312:	612b      	str	r3, [r5, #16]
 8001314:	e004      	b.n	8001320 <dir_read+0xfe>
					sum = dir[LDIR_Chksum];
					c &= 0xBF; ord = c;
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
 8001316:	3c01      	subs	r4, #1
 8001318:	b2e4      	uxtb	r4, r4
 800131a:	e7ef      	b.n	80012fc <dir_read+0xda>
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 800131c:	2604      	movs	r6, #4
 800131e:	e7f7      	b.n	8001310 <dir_read+0xee>
	}

	if (res != FR_OK) dj->sect = 0;

	return res;
}
 8001320:	4630      	mov	r0, r6
 8001322:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001326:	bf00      	nop
 8001328:	0801e558 	.word	0x0801e558

0800132c <gen_numname>:
	BYTE *dst,			/* Pointer to generated SFN */
	const BYTE *src,	/* Pointer to source SFN to be modified */
	const WCHAR *lfn,	/* Pointer to LFN */
	WORD num			/* Sequence number */
)
{
 800132c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800132e:	461c      	mov	r4, r3
 8001330:	4616      	mov	r6, r2
	char ns[8];
	int i, j;


	mem_cpy(dst, src, 11);
 8001332:	220b      	movs	r2, #11
	BYTE *dst,			/* Pointer to generated SFN */
	const BYTE *src,	/* Pointer to source SFN to be modified */
	const WCHAR *lfn,	/* Pointer to LFN */
	WORD num			/* Sequence number */
)
{
 8001334:	4605      	mov	r5, r0
	char ns[8];
	int i, j;


	mem_cpy(dst, src, 11);
 8001336:	f7ff f9d7 	bl	80006e8 <mem_cpy>

	if (num > 5) {	/* On many collisions, generate a hash number instead of sequential number */
 800133a:	2c05      	cmp	r4, #5
 800133c:	d90a      	bls.n	8001354 <gen_numname+0x28>

/*-----------------------------------------------------------------------*/
/* Create numbered name                                                  */
/*-----------------------------------------------------------------------*/
#if _USE_LFN
void gen_numname (
 800133e:	1eb2      	subs	r2, r6, #2


	mem_cpy(dst, src, 11);

	if (num > 5) {	/* On many collisions, generate a hash number instead of sequential number */
		do num = (num >> 1) + (num << 15) + (WORD)*lfn++; while (*lfn);
 8001340:	0863      	lsrs	r3, r4, #1
 8001342:	ea43 34c4 	orr.w	r4, r3, r4, lsl #15
 8001346:	f832 3f02 	ldrh.w	r3, [r2, #2]!
 800134a:	18e4      	adds	r4, r4, r3
 800134c:	8853      	ldrh	r3, [r2, #2]
 800134e:	b2a4      	uxth	r4, r4
 8001350:	2b00      	cmp	r3, #0
 8001352:	d1f5      	bne.n	8001340 <gen_numname+0x14>
	BYTE *dst,			/* Pointer to generated SFN */
	const BYTE *src,	/* Pointer to source SFN to be modified */
	const WCHAR *lfn,	/* Pointer to LFN */
	WORD num			/* Sequence number */
)
{
 8001354:	2307      	movs	r3, #7
	}

	/* itoa */
	i = 7;
	do {
		ns[i--] = (num % 10) + '0';
 8001356:	210a      	movs	r1, #10
 8001358:	fbb4 f2f1 	udiv	r2, r4, r1
 800135c:	fb01 4412 	mls	r4, r1, r2, r4
 8001360:	3430      	adds	r4, #48	; 0x30
 8001362:	f80d 4003 	strb.w	r4, [sp, r3]
		num /= 10;
 8001366:	b294      	uxth	r4, r2
	}

	/* itoa */
	i = 7;
	do {
		ns[i--] = (num % 10) + '0';
 8001368:	3b01      	subs	r3, #1
		num /= 10;
	} while (num);
 800136a:	2c00      	cmp	r4, #0
 800136c:	d1f4      	bne.n	8001358 <gen_numname+0x2c>
	ns[i] = '~';
 800136e:	a902      	add	r1, sp, #8
 8001370:	18ca      	adds	r2, r1, r3
 8001372:	217e      	movs	r1, #126	; 0x7e
 8001374:	f802 1c08 	strb.w	r1, [r2, #-8]

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
 8001378:	e000      	b.n	800137c <gen_numname+0x50>
 800137a:	3401      	adds	r4, #1
 800137c:	429c      	cmp	r4, r3
 800137e:	da02      	bge.n	8001386 <gen_numname+0x5a>
 8001380:	5d2a      	ldrb	r2, [r5, r4]
 8001382:	2a20      	cmp	r2, #32
 8001384:	d1f9      	bne.n	800137a <gen_numname+0x4e>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 8001386:	2b07      	cmp	r3, #7
 8001388:	dc05      	bgt.n	8001396 <gen_numname+0x6a>
 800138a:	a902      	add	r1, sp, #8
 800138c:	18ca      	adds	r2, r1, r3
 800138e:	f812 2c08 	ldrb.w	r2, [r2, #-8]
 8001392:	3301      	adds	r3, #1
 8001394:	e000      	b.n	8001398 <gen_numname+0x6c>
 8001396:	2220      	movs	r2, #32
 8001398:	552a      	strb	r2, [r5, r4]
 800139a:	3401      	adds	r4, #1
	} while (j < 8);
 800139c:	2c07      	cmp	r4, #7
 800139e:	ddf2      	ble.n	8001386 <gen_numname+0x5a>
}
 80013a0:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}

080013a2 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
 80013a2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	WORD n, ne, is;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dj->fn; lfn = dj->lfn;
 80013a6:	6986      	ldr	r6, [r0, #24]
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
 80013a8:	b085      	sub	sp, #20
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dj->fn; lfn = dj->lfn;
	mem_cpy(sn, fn, 12);
 80013aa:	ad01      	add	r5, sp, #4
	WORD n, ne, is;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dj->fn; lfn = dj->lfn;
 80013ac:	f8d0 801c 	ldr.w	r8, [r0, #28]
	mem_cpy(sn, fn, 12);
 80013b0:	220c      	movs	r2, #12
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
 80013b2:	4604      	mov	r4, r0
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dj->fn; lfn = dj->lfn;
	mem_cpy(sn, fn, 12);
 80013b4:	4631      	mov	r1, r6
 80013b6:	4628      	mov	r0, r5
 80013b8:	f7ff f996 	bl	80006e8 <mem_cpy>

	if (_FS_RPATH && (sn[NS] & NS_DOT)) return FR_INVALID_NAME;	/* Cannot create dot entry */

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 80013bc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80013c0:	07db      	lsls	r3, r3, #31
 80013c2:	d524      	bpl.n	800140e <dir_register+0x6c>
		fn[NS] = 0; dj->lfn = NULL;			/* Find only SFN */
 80013c4:	2300      	movs	r3, #0
 80013c6:	72f3      	strb	r3, [r6, #11]
		for (n = 1; n < 100; n++) {
 80013c8:	2701      	movs	r7, #1
	mem_cpy(sn, fn, 12);

	if (_FS_RPATH && (sn[NS] & NS_DOT)) return FR_INVALID_NAME;	/* Cannot create dot entry */

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = NULL;			/* Find only SFN */
 80013ca:	61e3      	str	r3, [r4, #28]
		for (n = 1; n < 100; n++) {
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
 80013cc:	46a9      	mov	r9, r5
 80013ce:	4630      	mov	r0, r6
 80013d0:	4649      	mov	r1, r9
 80013d2:	4642      	mov	r2, r8
 80013d4:	463b      	mov	r3, r7
 80013d6:	f7ff ffa9 	bl	800132c <gen_numname>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_seek(dj, 0);			/* Rewind directory object */
 80013da:	4620      	mov	r0, r4
 80013dc:	2100      	movs	r1, #0
 80013de:	f7ff fc6e 	bl	8000cbe <dir_seek>
	if (res != FR_OK) return res;
 80013e2:	4605      	mov	r5, r0
 80013e4:	2800      	cmp	r0, #0
 80013e6:	f040 80bd 	bne.w	8001564 <dir_register+0x1c2>
 80013ea:	4620      	mov	r0, r4
 80013ec:	f7ff fd27 	bl	8000e3e <dir_find.part.5>
	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = NULL;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
 80013f0:	4605      	mov	r5, r0
 80013f2:	2800      	cmp	r0, #0
 80013f4:	f040 80b6 	bne.w	8001564 <dir_register+0x1c2>

	if (_FS_RPATH && (sn[NS] & NS_DOT)) return FR_INVALID_NAME;	/* Cannot create dot entry */

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = NULL;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
 80013f8:	3701      	adds	r7, #1
 80013fa:	b2bf      	uxth	r7, r7
 80013fc:	2f64      	cmp	r7, #100	; 0x64
 80013fe:	d1e6      	bne.n	80013ce <dir_register+0x2c>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 8001400:	2507      	movs	r5, #7
 8001402:	e0bb      	b.n	800157c <dir_register+0x1da>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
		fn[NS] = sn[NS]; dj->lfn = lfn;
 8001404:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001408:	72f3      	strb	r3, [r6, #11]
 800140a:	f8c4 801c 	str.w	r8, [r4, #28]
	}

	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve reserve an SFN + LFN entries. */
 800140e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001412:	f003 0302 	and.w	r3, r3, #2
 8001416:	b2db      	uxtb	r3, r3
 8001418:	b92b      	cbnz	r3, 8001426 <dir_register+0x84>
		for (ne = 0; lfn[ne]; ne++) ;
		ne = (ne + 25) / 13;
	} else {						/* Otherwise reserve only an SFN entry. */
		ne = 1;
 800141a:	f04f 0801 	mov.w	r8, #1
 800141e:	e00e      	b.n	800143e <dir_register+0x9c>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
		fn[NS] = sn[NS]; dj->lfn = lfn;
	}

	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve reserve an SFN + LFN entries. */
		for (ne = 0; lfn[ne]; ne++) ;
 8001420:	3301      	adds	r3, #1
 8001422:	b29b      	uxth	r3, r3
 8001424:	e000      	b.n	8001428 <dir_register+0x86>
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
		fn[NS] = sn[NS]; dj->lfn = lfn;
	}

	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve reserve an SFN + LFN entries. */
 8001426:	2300      	movs	r3, #0
		for (ne = 0; lfn[ne]; ne++) ;
 8001428:	f838 2013 	ldrh.w	r2, [r8, r3, lsl #1]
 800142c:	2a00      	cmp	r2, #0
 800142e:	d1f7      	bne.n	8001420 <dir_register+0x7e>
		ne = (ne + 25) / 13;
 8001430:	f103 0819 	add.w	r8, r3, #25
 8001434:	220d      	movs	r2, #13
 8001436:	fb98 f8f2 	sdiv	r8, r8, r2
 800143a:	fa1f f888 	uxth.w	r8, r8
	} else {						/* Otherwise reserve only an SFN entry. */
		ne = 1;
	}

	/* Reserve contiguous entries */
	res = dir_seek(dj, 0);
 800143e:	4620      	mov	r0, r4
 8001440:	2100      	movs	r1, #0
 8001442:	f7ff fc3c 	bl	8000cbe <dir_seek>
	if (res != FR_OK) return res;
 8001446:	4605      	mov	r5, r0
 8001448:	2800      	cmp	r0, #0
 800144a:	f040 8097 	bne.w	800157c <dir_register+0x1da>
 800144e:	4607      	mov	r7, r0
 8001450:	4606      	mov	r6, r0
	n = is = 0;
	do {
		res = move_window(dj->fs, dj->sect);
 8001452:	6820      	ldr	r0, [r4, #0]
 8001454:	6921      	ldr	r1, [r4, #16]
 8001456:	f7ff f9df 	bl	8000818 <move_window>
		if (res != FR_OK) break;
 800145a:	4605      	mov	r5, r0
 800145c:	2800      	cmp	r0, #0
 800145e:	f040 808d 	bne.w	800157c <dir_register+0x1da>
		c = *dj->dir;				/* Check the entry status */
 8001462:	6963      	ldr	r3, [r4, #20]
 8001464:	781b      	ldrb	r3, [r3, #0]
		if (c == 0xE5 || c == 0) {	/* Is it a blank entry? */
 8001466:	2be5      	cmp	r3, #229	; 0xe5
 8001468:	d000      	beq.n	800146c <dir_register+0xca>
 800146a:	b933      	cbnz	r3, 800147a <dir_register+0xd8>
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
 800146c:	b906      	cbnz	r6, 8001470 <dir_register+0xce>
 800146e:	88e7      	ldrh	r7, [r4, #6]
			if (++n == ne) break;	/* A contiguous entry that required count is found */
 8001470:	3601      	adds	r6, #1
 8001472:	b2b6      	uxth	r6, r6
 8001474:	4546      	cmp	r6, r8
 8001476:	d101      	bne.n	800147c <dir_register+0xda>
 8001478:	e077      	b.n	800156a <dir_register+0x1c8>
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
 800147a:	4606      	mov	r6, r0
		}
		res = dir_next(dj, TRUE);	/* Next entry with table stretch */
 800147c:	4620      	mov	r0, r4
 800147e:	2101      	movs	r1, #1
 8001480:	f7ff fc5f 	bl	8000d42 <dir_next>
	} while (res == FR_OK);
 8001484:	4605      	mov	r5, r0
 8001486:	2800      	cmp	r0, #0
 8001488:	d0e3      	beq.n	8001452 <dir_register+0xb0>
 800148a:	e077      	b.n	800157c <dir_register+0x1da>

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
		res = dir_seek(dj, is);
 800148c:	4620      	mov	r0, r4
 800148e:	4639      	mov	r1, r7
 8001490:	f7ff fc15 	bl	8000cbe <dir_seek>
		if (res == FR_OK) {
 8001494:	4605      	mov	r5, r0
 8001496:	2800      	cmp	r0, #0
 8001498:	d170      	bne.n	800157c <dir_register+0x1da>
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
 800149a:	69a0      	ldr	r0, [r4, #24]
 800149c:	f7ff f934 	bl	8000708 <sum_sfn>
			ne--;
 80014a0:	3e01      	subs	r6, #1
 80014a2:	fa1f f986 	uxth.w	r9, r6
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
 80014a6:	f64f 7aff 	movw	sl, #65535	; 0xffff
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 80014aa:	4e36      	ldr	r6, [pc, #216]	; (8001584 <dir_register+0x1e2>)
	} while (res == FR_OK);

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
		res = dir_seek(dj, is);
		if (res == FR_OK) {
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
 80014ac:	4607      	mov	r7, r0
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
 80014ae:	46d0      	mov	r8, sl
		res = dir_seek(dj, is);
		if (res == FR_OK) {
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
 80014b0:	6820      	ldr	r0, [r4, #0]
 80014b2:	6921      	ldr	r1, [r4, #16]
 80014b4:	f7ff f9b0 	bl	8000818 <move_window>
 80014b8:	4603      	mov	r3, r0
 80014ba:	4605      	mov	r5, r0
				if (res != FR_OK) break;
 80014bc:	2800      	cmp	r0, #0
 80014be:	d15d      	bne.n	800157c <dir_register+0x1da>
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
 80014c0:	6962      	ldr	r2, [r4, #20]
	int i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 80014c2:	210f      	movs	r1, #15
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
 80014c4:	fa5f f589 	uxtb.w	r5, r9
 80014c8:	f8d4 e01c 	ldr.w	lr, [r4, #28]
	int i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 80014cc:	72d1      	strb	r1, [r2, #11]
	dir[LDIR_Type] = 0;
 80014ce:	7310      	strb	r0, [r2, #12]
	ST_WORD(dir+LDIR_FstClusLO, 0);
 80014d0:	7690      	strb	r0, [r2, #26]
 80014d2:	76d0      	strb	r0, [r2, #27]

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
 80014d4:	1e69      	subs	r1, r5, #1
 80014d6:	200d      	movs	r0, #13
 80014d8:	4341      	muls	r1, r0
{
	int i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
 80014da:	7357      	strb	r7, [r2, #13]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
 80014dc:	4618      	mov	r0, r3
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
 80014de:	4553      	cmp	r3, sl
 80014e0:	bf18      	it	ne
 80014e2:	f83e 3011 	ldrhne.w	r3, [lr, r1, lsl #1]
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 80014e6:	f810 c006 	ldrb.w	ip, [r0, r6]
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
 80014ea:	bf18      	it	ne
 80014ec:	3101      	addne	r1, #1
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
 80014ee:	3001      	adds	r0, #1

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 80014f0:	f802 300c 	strb.w	r3, [r2, ip]
 80014f4:	ea4f 2b13 	mov.w	fp, r3, lsr #8
 80014f8:	4494      	add	ip, r2
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
 80014fa:	2b00      	cmp	r3, #0
 80014fc:	bf08      	it	eq
 80014fe:	4653      	moveq	r3, sl
	} while (++s < 13);
 8001500:	280d      	cmp	r0, #13

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8001502:	f88c b001 	strb.w	fp, [ip, #1]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
 8001506:	d1ea      	bne.n	80014de <dir_register+0x13c>
	if (wc == 0xFFFF || !lfnbuf[i]) ord |= 0x40;	/* Bottom LFN part is the start of LFN sequence */
 8001508:	4543      	cmp	r3, r8
 800150a:	d002      	beq.n	8001512 <dir_register+0x170>
 800150c:	f83e 3011 	ldrh.w	r3, [lr, r1, lsl #1]
 8001510:	b913      	cbnz	r3, 8001518 <dir_register+0x176>
 8001512:	f049 0540 	orr.w	r5, r9, #64	; 0x40
 8001516:	b2ed      	uxtb	r5, r5
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 8001518:	7015      	strb	r5, [r2, #0]
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
				dj->fs->wflag = 1;
 800151a:	6823      	ldr	r3, [r4, #0]
 800151c:	2201      	movs	r2, #1
 800151e:	711a      	strb	r2, [r3, #4]
				res = dir_next(dj, FALSE);	/* Next entry */
 8001520:	4620      	mov	r0, r4
 8001522:	2100      	movs	r1, #0
 8001524:	f7ff fc0d 	bl	8000d42 <dir_next>
			} while (res == FR_OK && --ne);
 8001528:	4605      	mov	r5, r0
 800152a:	bb38      	cbnz	r0, 800157c <dir_register+0x1da>
 800152c:	f109 39ff 	add.w	r9, r9, #4294967295
 8001530:	fa1f f989 	uxth.w	r9, r9
 8001534:	f1b9 0f00 	cmp.w	r9, #0
 8001538:	d1ba      	bne.n	80014b0 <dir_register+0x10e>
 800153a:	e018      	b.n	800156e <dir_register+0x1cc>
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
 800153c:	6966      	ldr	r6, [r4, #20]
			mem_set(dir, 0, 32);		/* Clean the entry */
 800153e:	4629      	mov	r1, r5
 8001540:	4630      	mov	r0, r6
 8001542:	2220      	movs	r2, #32
 8001544:	f7ff f8d9 	bl	80006fa <mem_set>
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
 8001548:	220b      	movs	r2, #11
 800154a:	4630      	mov	r0, r6
 800154c:	69a1      	ldr	r1, [r4, #24]
 800154e:	f7ff f8cb 	bl	80006e8 <mem_cpy>
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
 8001552:	69a3      	ldr	r3, [r4, #24]
			dj->fs->wflag = 1;
 8001554:	2201      	movs	r2, #1
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
			mem_set(dir, 0, 32);		/* Clean the entry */
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
 8001556:	7adb      	ldrb	r3, [r3, #11]
 8001558:	f003 0318 	and.w	r3, r3, #24
 800155c:	7333      	strb	r3, [r6, #12]
			dj->fs->wflag = 1;
 800155e:	6823      	ldr	r3, [r4, #0]
 8001560:	711a      	strb	r2, [r3, #4]
 8001562:	e00b      	b.n	800157c <dir_register+0x1da>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 8001564:	2d04      	cmp	r5, #4
 8001566:	d109      	bne.n	800157c <dir_register+0x1da>
 8001568:	e74c      	b.n	8001404 <dir_register+0x62>
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, TRUE);	/* Next entry with table stretch */
	} while (res == FR_OK);

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
 800156a:	2e01      	cmp	r6, #1
 800156c:	d18e      	bne.n	800148c <dir_register+0xea>
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
 800156e:	6820      	ldr	r0, [r4, #0]
 8001570:	6921      	ldr	r1, [r4, #16]
 8001572:	f7ff f951 	bl	8000818 <move_window>
		if (res == FR_OK) {
 8001576:	4605      	mov	r5, r0
 8001578:	2800      	cmp	r0, #0
 800157a:	d0df      	beq.n	800153c <dir_register+0x19a>
			dj->fs->wflag = 1;
		}
	}

	return res;
}
 800157c:	4628      	mov	r0, r5
 800157e:	b005      	add	sp, #20
 8001580:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001584:	0801e558 	.word	0x0801e558

08001588 <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const XCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
 8001588:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	BYTE fmt, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fsize, tsect, mclst;
	const XCHAR *p = *path;
 800158a:	6803      	ldr	r3, [r0, #0]
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const XCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
 800158c:	4615      	mov	r5, r2
	DWORD bsect, fsize, tsect, mclst;
	const XCHAR *p = *path;
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';				/* Is there a drive number? */
 800158e:	781a      	ldrb	r2, [r3, #0]
 8001590:	3a30      	subs	r2, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {	/* Found a drive number, get and strip it */
 8001592:	2a09      	cmp	r2, #9
 8001594:	d904      	bls.n	80015a0 <chk_mounted+0x18>
	}

	/* Check if the logical drive is valid or not */
	if (vol >= _DRIVES) 			/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];			/* Return pointer to the corresponding file system object */
 8001596:	4ba0      	ldr	r3, [pc, #640]	; (8001818 <chk_mounted+0x290>)
 8001598:	681c      	ldr	r4, [r3, #0]
 800159a:	600c      	str	r4, [r1, #0]
	if (!fs) return FR_NOT_ENABLED;	/* Is the file system object available? */
 800159c:	b94c      	cbnz	r4, 80015b2 <chk_mounted+0x2a>
 800159e:	e11a      	b.n	80017d6 <chk_mounted+0x24e>
	const XCHAR *p = *path;
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';				/* Is there a drive number? */
	if (vol <= 9 && p[1] == ':') {	/* Found a drive number, get and strip it */
 80015a0:	785c      	ldrb	r4, [r3, #1]
 80015a2:	2c3a      	cmp	r4, #58	; 0x3a
 80015a4:	d1f7      	bne.n	8001596 <chk_mounted+0xe>
		p += 2; *path = p;			/* Return pointer to the path name */
 80015a6:	3302      	adds	r3, #2
 80015a8:	6003      	str	r3, [r0, #0]
		vol = 0;					/* Use drive 0 */
#endif
	}

	/* Check if the logical drive is valid or not */
	if (vol >= _DRIVES) 			/* Is the drive number valid? */
 80015aa:	2a00      	cmp	r2, #0
 80015ac:	f040 8115 	bne.w	80017da <chk_mounted+0x252>
 80015b0:	e7f1      	b.n	8001596 <chk_mounted+0xe>
	*rfs = fs = FatFs[vol];			/* Return pointer to the corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;	/* Is the file system object available? */

	ENTER_FF(fs);					/* Lock file system */

	if (fs->fs_type) {				/* If the logical drive has been mounted */
 80015b2:	7823      	ldrb	r3, [r4, #0]
 80015b4:	b17b      	cbz	r3, 80015d6 <chk_mounted+0x4e>
		stat = disk_status(fs->drive);
 80015b6:	7860      	ldrb	r0, [r4, #1]
 80015b8:	f001 fddc 	bl	8003174 <disk_status>
		if (!(stat & STA_NOINIT)) {	/* and the physical drive is kept initialized (has not been changed), */
 80015bc:	07c1      	lsls	r1, r0, #31
 80015be:	d40a      	bmi.n	80015d6 <chk_mounted+0x4e>
#if !_FS_READONLY
			if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
 80015c0:	2d00      	cmp	r5, #0
 80015c2:	f000 810c 	beq.w	80017de <chk_mounted+0x256>
 80015c6:	f000 0004 	and.w	r0, r0, #4
 80015ca:	b2c0      	uxtb	r0, r0
				return FR_WRITE_PROTECTED;
 80015cc:	2800      	cmp	r0, #0
 80015ce:	bf14      	ite	ne
 80015d0:	200a      	movne	r0, #10
 80015d2:	2000      	moveq	r0, #0
 80015d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		}
	}

	/* The logical drive must be mounted. Following code attempts to mount the volume */

	fs->fs_type = 0;					/* Clear the file system object */
 80015d6:	2000      	movs	r0, #0
 80015d8:	7020      	strb	r0, [r4, #0]
	fs->drive = (BYTE)LD2PD(vol);		/* Bind the logical drive and a physical drive */
 80015da:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->drive);	/* Initialize low level disk I/O layer */
 80015dc:	f001 fd25 	bl	800302a <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the drive is ready */
 80015e0:	07c2      	lsls	r2, r0, #31
 80015e2:	f100 80fe 	bmi.w	80017e2 <chk_mounted+0x25a>
#if _MAX_SS != 512						/* Get disk sector size if needed */
	if (disk_ioctl(fs->drive, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
		return FR_NO_FILESYSTEM;
#endif
#if !_FS_READONLY
	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 80015e6:	b12d      	cbz	r5, 80015f4 <chk_mounted+0x6c>
 80015e8:	f000 0004 	and.w	r0, r0, #4
 80015ec:	b2c0      	uxtb	r0, r0
 80015ee:	2800      	cmp	r0, #0
 80015f0:	f040 80f9 	bne.w	80017e6 <chk_mounted+0x25e>
		return FR_WRITE_PROTECTED;
#endif
	/* Search FAT partition on the drive */
	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 as an SFD format */
 80015f4:	2100      	movs	r1, #0
 80015f6:	4620      	mov	r0, r4
 80015f8:	f7ff f9a5 	bl	8000946 <check_fs>
	if (fmt == 1) {						/* Not an FAT boot record, it may be partitioned */
 80015fc:	2801      	cmp	r0, #1
 80015fe:	d117      	bne.n	8001630 <chk_mounted+0xa8>
		/* Check a partition listed in top of the partition table */
		tbl = &fs->win[MBR_Table + LD2PT(vol) * 16];	/* Partition table */
		if (tbl[4]) {									/* Is the partition existing? */
 8001600:	f894 31f2 	ldrb.w	r3, [r4, #498]	; 0x1f2
 8001604:	b90b      	cbnz	r3, 800160a <chk_mounted+0x82>
			fmt = check_fs(fs, bsect);					/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt || LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))	/* No valid FAT partition is found */
		return FR_NO_FILESYSTEM;
 8001606:	200d      	movs	r0, #13
 8001608:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 as an SFD format */
	if (fmt == 1) {						/* Not an FAT boot record, it may be partitioned */
		/* Check a partition listed in top of the partition table */
		tbl = &fs->win[MBR_Table + LD2PT(vol) * 16];	/* Partition table */
		if (tbl[4]) {									/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
 800160a:	f894 61f8 	ldrb.w	r6, [r4, #504]	; 0x1f8
 800160e:	f894 31f9 	ldrb.w	r3, [r4, #505]	; 0x1f9
 8001612:	0436      	lsls	r6, r6, #16
 8001614:	ea46 6603 	orr.w	r6, r6, r3, lsl #24
 8001618:	f894 31f6 	ldrb.w	r3, [r4, #502]	; 0x1f6
			fmt = check_fs(fs, bsect);					/* Check the partition */
 800161c:	4620      	mov	r0, r4
	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 as an SFD format */
	if (fmt == 1) {						/* Not an FAT boot record, it may be partitioned */
		/* Check a partition listed in top of the partition table */
		tbl = &fs->win[MBR_Table + LD2PT(vol) * 16];	/* Partition table */
		if (tbl[4]) {									/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
 800161e:	431e      	orrs	r6, r3
 8001620:	f894 31f7 	ldrb.w	r3, [r4, #503]	; 0x1f7
 8001624:	ea46 2603 	orr.w	r6, r6, r3, lsl #8
			fmt = check_fs(fs, bsect);					/* Check the partition */
 8001628:	4631      	mov	r1, r6
 800162a:	f7ff f98c 	bl	8000946 <check_fs>
 800162e:	e000      	b.n	8001632 <chk_mounted+0xaa>
#if !_FS_READONLY
	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
#endif
	/* Search FAT partition on the drive */
	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 as an SFD format */
 8001630:	2600      	movs	r6, #0
		if (tbl[4]) {									/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);					/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
 8001632:	2803      	cmp	r0, #3
 8001634:	f000 80d9 	beq.w	80017ea <chk_mounted+0x262>
	if (fmt || LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))	/* No valid FAT partition is found */
 8001638:	2800      	cmp	r0, #0
 800163a:	d1e4      	bne.n	8001606 <chk_mounted+0x7e>
 800163c:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
 8001640:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
 8001644:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001648:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800164c:	d1db      	bne.n	8001606 <chk_mounted+0x7e>
		return FR_NO_FILESYSTEM;

	/* Initialize the file system object */
	fsize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 800164e:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
 8001652:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
	if (!fsize) fsize = LD_DWORD(fs->win+BPB_FATSz32);
 8001656:	ea53 2202 	orrs.w	r2, r3, r2, lsl #8
 800165a:	d10d      	bne.n	8001678 <chk_mounted+0xf0>
 800165c:	f894 2056 	ldrb.w	r2, [r4, #86]	; 0x56
 8001660:	f894 3057 	ldrb.w	r3, [r4, #87]	; 0x57
 8001664:	0412      	lsls	r2, r2, #16
 8001666:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 800166a:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
 800166e:	431a      	orrs	r2, r3
 8001670:	f894 3055 	ldrb.w	r3, [r4, #85]	; 0x55
 8001674:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
	fs->sects_fat = fsize;
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
 8001678:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
	fsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 800167c:	f894 7042 	ldrb.w	r7, [r4, #66]	; 0x42
 8001680:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
		return FR_NO_FILESYSTEM;

	/* Initialize the file system object */
	fsize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fsize) fsize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->sects_fat = fsize;
 8001684:	61a2      	str	r2, [r4, #24]
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
 8001686:	70e3      	strb	r3, [r4, #3]
	fsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
 8001688:	435a      	muls	r2, r3
	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
 800168a:	f894 103f 	ldrb.w	r1, [r4, #63]	; 0x3f
 800168e:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8001692:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 8001696:	f894 c044 	ldrb.w	ip, [r4, #68]	; 0x44
 800169a:	f894 7043 	ldrb.w	r7, [r4, #67]	; 0x43
	fsize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fsize) fsize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->sects_fat = fsize;
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	fsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
 800169e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
 80016a2:	f894 503d 	ldrb.w	r5, [r4, #61]	; 0x3d
	fsize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fsize) fsize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->sects_fat = fsize;
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	fsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
 80016a6:	1873      	adds	r3, r6, r1
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 80016a8:	ea57 270c 	orrs.w	r7, r7, ip, lsl #8
	fsize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fsize) fsize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->sects_fat = fsize;
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	fsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
 80016ac:	6223      	str	r3, [r4, #32]
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
 80016ae:	70a5      	strb	r5, [r4, #2]
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 80016b0:	8120      	strh	r0, [r4, #8]
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 80016b2:	d10e      	bne.n	80016d2 <chk_mounted+0x14a>
 80016b4:	f894 7052 	ldrb.w	r7, [r4, #82]	; 0x52
 80016b8:	f894 c053 	ldrb.w	ip, [r4, #83]	; 0x53
 80016bc:	043f      	lsls	r7, r7, #16
 80016be:	ea47 670c 	orr.w	r7, r7, ip, lsl #24
 80016c2:	f894 c050 	ldrb.w	ip, [r4, #80]	; 0x50
 80016c6:	ea47 070c 	orr.w	r7, r7, ip
 80016ca:	f894 c051 	ldrb.w	ip, [r4, #81]	; 0x51
 80016ce:	ea47 270c 	orr.w	r7, r7, ip, lsl #8
	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 (Number of clusters + 2) */
		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
 80016d2:	1a79      	subs	r1, r7, r1
 80016d4:	0900      	lsrs	r0, r0, #4
 80016d6:	1a89      	subs	r1, r1, r2
 80016d8:	1a09      	subs	r1, r1, r0
		) / fs->csize + 2;
 80016da:	fbb1 f1f5 	udiv	r1, r1, r5
	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 (Number of clusters + 2) */
 80016de:	3102      	adds	r1, #2
		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
		) / fs->csize + 2;

	fmt = FS_FAT12;										/* Determine the FAT sub type */
	if (mclst >= 0xFF7) fmt = FS_FAT16;					/* Number of clusters >= 0xFF5 */
 80016e0:	f640 75f6 	movw	r5, #4086	; 0xff6
 80016e4:	42a9      	cmp	r1, r5
	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 (Number of clusters + 2) */
 80016e6:	61e1      	str	r1, [r4, #28]
		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
		) / fs->csize + 2;

	fmt = FS_FAT12;										/* Determine the FAT sub type */
	if (mclst >= 0xFF7) fmt = FS_FAT16;					/* Number of clusters >= 0xFF5 */
 80016e8:	f240 8092 	bls.w	8001810 <chk_mounted+0x288>
	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */
 80016ec:	f505 4570 	add.w	r5, r5, #61440	; 0xf000
 80016f0:	42a9      	cmp	r1, r5
 80016f2:	d87c      	bhi.n	80017ee <chk_mounted+0x266>
	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 (Number of clusters + 2) */
		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
		) / fs->csize + 2;

	fmt = FS_FAT12;										/* Determine the FAT sub type */
	if (mclst >= 0xFF7) fmt = FS_FAT16;					/* Number of clusters >= 0xFF5 */
 80016f4:	2502      	movs	r5, #2
 80016f6:	e08c      	b.n	8001812 <chk_mounted+0x28a>

	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
	else
		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
	fs->database = fs->fatbase + fsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
 80016f8:	181b      	adds	r3, r3, r0
 80016fa:	189a      	adds	r2, r3, r2

#if !_FS_READONLY
	/* Initialize allocation information */
	fs->free_clust = 0xFFFFFFFF;
 80016fc:	f04f 33ff 	mov.w	r3, #4294967295
 8001700:	6123      	str	r3, [r4, #16]
	fs->wflag = 0;
 8001702:	2300      	movs	r3, #0
	/* Get fsinfo if needed */
	if (fmt == FS_FAT32) {
 8001704:	2d03      	cmp	r5, #3

	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
	else
		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
	fs->database = fs->fatbase + fsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
 8001706:	62a2      	str	r2, [r4, #40]	; 0x28

#if !_FS_READONLY
	/* Initialize allocation information */
	fs->free_clust = 0xFFFFFFFF;
	fs->wflag = 0;
 8001708:	7123      	strb	r3, [r4, #4]
	/* Get fsinfo if needed */
	if (fmt == FS_FAT32) {
 800170a:	d15a      	bne.n	80017c2 <chk_mounted+0x23a>
	 	fs->fsi_flag = 0;
 800170c:	7163      	strb	r3, [r4, #5]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 800170e:	f894 2061 	ldrb.w	r2, [r4, #97]	; 0x61
 8001712:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8001716:	7860      	ldrb	r0, [r4, #1]
	fs->free_clust = 0xFFFFFFFF;
	fs->wflag = 0;
	/* Get fsinfo if needed */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 8001718:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 800171c:	18b2      	adds	r2, r6, r2
 800171e:	6162      	str	r2, [r4, #20]
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
 8001720:	f104 0130 	add.w	r1, r4, #48	; 0x30
 8001724:	2301      	movs	r3, #1
 8001726:	f001 fd2d 	bl	8003184 <disk_read>
 800172a:	2800      	cmp	r0, #0
 800172c:	d149      	bne.n	80017c2 <chk_mounted+0x23a>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 800172e:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
 8001732:	f894 222f 	ldrb.w	r2, [r4, #559]	; 0x22f
 8001736:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
	fs->wflag = 0;
	/* Get fsinfo if needed */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
 800173a:	4b38      	ldr	r3, [pc, #224]	; (800181c <chk_mounted+0x294>)
 800173c:	b212      	sxth	r2, r2
 800173e:	429a      	cmp	r2, r3
 8001740:	d13f      	bne.n	80017c2 <chk_mounted+0x23a>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 8001742:	f894 2032 	ldrb.w	r2, [r4, #50]	; 0x32
 8001746:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
 800174a:	0412      	lsls	r2, r2, #16
 800174c:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8001750:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 8001754:	431a      	orrs	r2, r3
 8001756:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
 800175a:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
	/* Get fsinfo if needed */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 800175e:	4b30      	ldr	r3, [pc, #192]	; (8001820 <chk_mounted+0x298>)
 8001760:	429a      	cmp	r2, r3
 8001762:	d12e      	bne.n	80017c2 <chk_mounted+0x23a>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
 8001764:	f894 2216 	ldrb.w	r2, [r4, #534]	; 0x216
 8001768:	f894 3217 	ldrb.w	r3, [r4, #535]	; 0x217
 800176c:	0412      	lsls	r2, r2, #16
 800176e:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8001772:	f894 3214 	ldrb.w	r3, [r4, #532]	; 0x214
 8001776:	431a      	orrs	r2, r3
 8001778:	f894 3215 	ldrb.w	r3, [r4, #533]	; 0x215
 800177c:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 8001780:	4b28      	ldr	r3, [pc, #160]	; (8001824 <chk_mounted+0x29c>)
 8001782:	429a      	cmp	r2, r3
 8001784:	d11d      	bne.n	80017c2 <chk_mounted+0x23a>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8001786:	f894 321e 	ldrb.w	r3, [r4, #542]	; 0x21e
 800178a:	f894 221f 	ldrb.w	r2, [r4, #543]	; 0x21f
 800178e:	041b      	lsls	r3, r3, #16
 8001790:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001794:	f894 221c 	ldrb.w	r2, [r4, #540]	; 0x21c
 8001798:	4313      	orrs	r3, r2
 800179a:	f894 221d 	ldrb.w	r2, [r4, #541]	; 0x21d
 800179e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80017a2:	60e3      	str	r3, [r4, #12]
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 80017a4:	f894 321a 	ldrb.w	r3, [r4, #538]	; 0x21a
 80017a8:	f894 221b 	ldrb.w	r2, [r4, #539]	; 0x21b
 80017ac:	041b      	lsls	r3, r3, #16
 80017ae:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80017b2:	f894 2218 	ldrb.w	r2, [r4, #536]	; 0x218
 80017b6:	4313      	orrs	r3, r2
 80017b8:	f894 2219 	ldrb.w	r2, [r4, #537]	; 0x219
 80017bc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80017c0:	6123      	str	r3, [r4, #16]
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->winsect = 0;		/* Invalidate sector cache */
#if _FS_RPATH
	fs->cdir = 0;			/* Current directory (root dir) */
#endif
	fs->id = ++Fsid;		/* File system mount ID */
 80017c2:	4a15      	ldr	r2, [pc, #84]	; (8001818 <chk_mounted+0x290>)
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->winsect = 0;		/* Invalidate sector cache */
 80017c4:	2000      	movs	r0, #0
#if _FS_RPATH
	fs->cdir = 0;			/* Current directory (root dir) */
#endif
	fs->id = ++Fsid;		/* File system mount ID */
 80017c6:	8893      	ldrh	r3, [r2, #4]
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
 80017c8:	7025      	strb	r5, [r4, #0]
	fs->winsect = 0;		/* Invalidate sector cache */
#if _FS_RPATH
	fs->cdir = 0;			/* Current directory (root dir) */
#endif
	fs->id = ++Fsid;		/* File system mount ID */
 80017ca:	3301      	adds	r3, #1
 80017cc:	b29b      	uxth	r3, r3
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->winsect = 0;		/* Invalidate sector cache */
 80017ce:	62e0      	str	r0, [r4, #44]	; 0x2c
#if _FS_RPATH
	fs->cdir = 0;			/* Current directory (root dir) */
#endif
	fs->id = ++Fsid;		/* File system mount ID */
 80017d0:	8093      	strh	r3, [r2, #4]
 80017d2:	80e3      	strh	r3, [r4, #6]

	return FR_OK;
 80017d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Check if the logical drive is valid or not */
	if (vol >= _DRIVES) 			/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];			/* Return pointer to the corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;	/* Is the file system object available? */
 80017d6:	200c      	movs	r0, #12
 80017d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
#endif
	}

	/* Check if the logical drive is valid or not */
	if (vol >= _DRIVES) 			/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
 80017da:	200b      	movs	r0, #11
 80017dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (!(stat & STA_NOINIT)) {	/* and the physical drive is kept initialized (has not been changed), */
#if !_FS_READONLY
			if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
#endif
			return FR_OK;			/* The file system object is valid */
 80017de:	4628      	mov	r0, r5
 80017e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drive = (BYTE)LD2PD(vol);		/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drive);	/* Initialize low level disk I/O layer */
	if (stat & STA_NOINIT)				/* Check if the drive is ready */
		return FR_NOT_READY;
 80017e2:	2003      	movs	r0, #3
 80017e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (disk_ioctl(fs->drive, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
		return FR_NO_FILESYSTEM;
#endif
#if !_FS_READONLY
	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
 80017e6:	200a      	movs	r0, #10
 80017e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (tbl[4]) {									/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);					/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
 80017ea:	2001      	movs	r0, #1
 80017ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	fmt = FS_FAT12;										/* Determine the FAT sub type */
	if (mclst >= 0xFF7) fmt = FS_FAT16;					/* Number of clusters >= 0xFF5 */
	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */

	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 80017ee:	f894 105e 	ldrb.w	r1, [r4, #94]	; 0x5e
 80017f2:	f894 505f 	ldrb.w	r5, [r4, #95]	; 0x5f
 80017f6:	0409      	lsls	r1, r1, #16
 80017f8:	ea41 6105 	orr.w	r1, r1, r5, lsl #24
 80017fc:	f894 505c 	ldrb.w	r5, [r4, #92]	; 0x5c
 8001800:	4329      	orrs	r1, r5
 8001802:	f894 505d 	ldrb.w	r5, [r4, #93]	; 0x5d
 8001806:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
 800180a:	6261      	str	r1, [r4, #36]	; 0x24
		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
		) / fs->csize + 2;

	fmt = FS_FAT12;										/* Determine the FAT sub type */
	if (mclst >= 0xFF7) fmt = FS_FAT16;					/* Number of clusters >= 0xFF5 */
	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */
 800180c:	2503      	movs	r5, #3
 800180e:	e773      	b.n	80016f8 <chk_mounted+0x170>
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 (Number of clusters + 2) */
		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
		) / fs->csize + 2;

	fmt = FS_FAT12;										/* Determine the FAT sub type */
 8001810:	2501      	movs	r5, #1
	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */

	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
	else
		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
 8001812:	18d1      	adds	r1, r2, r3
 8001814:	6261      	str	r1, [r4, #36]	; 0x24
 8001816:	e76f      	b.n	80016f8 <chk_mounted+0x170>
 8001818:	20000924 	.word	0x20000924
 800181c:	ffffaa55 	.word	0xffffaa55
 8001820:	41615252 	.word	0x41615252
 8001824:	61417272 	.word	0x61417272

08001828 <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _DRIVES)				/* Check if the drive number is valid */
 8001828:	b948      	cbnz	r0, 800183e <f_mount+0x16>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];				/* Get current fs object */
 800182a:	4a06      	ldr	r2, [pc, #24]	; (8001844 <f_mount+0x1c>)
 800182c:	6813      	ldr	r3, [r2, #0]

	if (rfs) {
 800182e:	b103      	cbz	r3, 8001832 <f_mount+0xa>
#if _FS_REENTRANT					/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;			/* Clear old fs object */
 8001830:	7018      	strb	r0, [r3, #0]
	}

	if (fs) {
 8001832:	b109      	cbz	r1, 8001838 <f_mount+0x10>
		fs->fs_type = 0;			/* Clear new fs object */
 8001834:	2300      	movs	r3, #0
 8001836:	700b      	strb	r3, [r1, #0]
#if _FS_REENTRANT					/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;				/* Register new fs object */
 8001838:	6011      	str	r1, [r2, #0]

	return FR_OK;
 800183a:	2000      	movs	r0, #0
 800183c:	4770      	bx	lr
{
	FATFS *rfs;


	if (vol >= _DRIVES)				/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
 800183e:	200b      	movs	r0, #11
#endif
	}
	FatFs[vol] = fs;				/* Register new fs object */

	return FR_OK;
}
 8001840:	4770      	bx	lr
 8001842:	bf00      	nop
 8001844:	20000924 	.word	0x20000924

08001848 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const XCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 8001848:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800184c:	b08e      	sub	sp, #56	; 0x38
 800184e:	4605      	mov	r5, r0
	DIR dj;
	NAMEBUF(sfn, lfn);
	BYTE *dir;


	fp->fs = NULL;		/* Clear file object */
 8001850:	2300      	movs	r3, #0
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const XCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 8001852:	a80e      	add	r0, sp, #56	; 0x38
 8001854:	f840 1d34 	str.w	r1, [r0, #-52]!
 8001858:	4617      	mov	r7, r2
	DIR dj;
	NAMEBUF(sfn, lfn);
	BYTE *dir;


	fp->fs = NULL;		/* Clear file object */
 800185a:	602b      	str	r3, [r5, #0]
#if !_FS_READONLY
	mode &= (FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW);
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & (FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)));
 800185c:	a905      	add	r1, sp, #20
 800185e:	f002 021e 	and.w	r2, r2, #30
 8001862:	f7ff fe91 	bl	8001588 <chk_mounted>
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res != FR_OK) LEAVE_FF(dj.fs, res);
 8001866:	2800      	cmp	r0, #0
 8001868:	f040 80a2 	bne.w	80019b0 <f_open+0x168>
	INITBUF(dj, sfn, lfn);
 800186c:	ab02      	add	r3, sp, #8
 800186e:	930b      	str	r3, [sp, #44]	; 0x2c
 8001870:	4b51      	ldr	r3, [pc, #324]	; (80019b8 <f_open+0x170>)
	res = follow_path(&dj, path);	/* Follow the file path */
 8001872:	a805      	add	r0, sp, #20
 8001874:	9901      	ldr	r1, [sp, #4]
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res != FR_OK) LEAVE_FF(dj.fs, res);
	INITBUF(dj, sfn, lfn);
 8001876:	930c      	str	r3, [sp, #48]	; 0x30
	res = follow_path(&dj, path);	/* Follow the file path */
 8001878:	f7ff fb78 	bl	8000f6c <follow_path>

#if !_FS_READONLY
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 800187c:	f017 0f1c 	tst.w	r7, #28
	BYTE *dir;


	fp->fs = NULL;		/* Clear file object */
#if !_FS_READONLY
	mode &= (FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW);
 8001880:	f007 061f 	and.w	r6, r7, #31
	INITBUF(dj, sfn, lfn);
	res = follow_path(&dj, path);	/* Follow the file path */

#if !_FS_READONLY
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8001884:	d059      	beq.n	800193a <f_open+0xf2>
		DWORD ps, cl;

		if (res != FR_OK) {			/* No file, create new */
 8001886:	b160      	cbz	r0, 80018a2 <f_open+0x5a>
			if (res == FR_NO_FILE)	/* There is no file to open, create a new entry */
 8001888:	2804      	cmp	r0, #4
 800188a:	f040 8091 	bne.w	80019b0 <f_open+0x168>
				res = dir_register(&dj);
 800188e:	a805      	add	r0, sp, #20
 8001890:	f7ff fd87 	bl	80013a2 <dir_register>
			if (res != FR_OK) LEAVE_FF(dj.fs, res);
 8001894:	2800      	cmp	r0, #0
 8001896:	f040 808b 	bne.w	80019b0 <f_open+0x168>
			mode |= FA_CREATE_ALWAYS;
 800189a:	f046 0608 	orr.w	r6, r6, #8
			dir = dj.dir;			/* Created entry (SFN entry) */
 800189e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80018a0:	e035      	b.n	800190e <f_open+0xc6>
		}
		else {						/* Any object is already existing */
			if (mode & FA_CREATE_NEW)			/* Cannot create new */
 80018a2:	f007 0304 	and.w	r3, r7, #4
 80018a6:	b2db      	uxtb	r3, r3
 80018a8:	2b00      	cmp	r3, #0
 80018aa:	d17c      	bne.n	80019a6 <f_open+0x15e>
				LEAVE_FF(dj.fs, FR_EXIST);
			dir = dj.dir;
 80018ac:	9c0a      	ldr	r4, [sp, #40]	; 0x28
			if (!dir || (dir[DIR_Attr] & (AM_RDO | AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
 80018ae:	2c00      	cmp	r4, #0
 80018b0:	d07d      	beq.n	80019ae <f_open+0x166>
 80018b2:	7ae3      	ldrb	r3, [r4, #11]
 80018b4:	f013 0311 	ands.w	r3, r3, #17
 80018b8:	d179      	bne.n	80019ae <f_open+0x166>
				LEAVE_FF(dj.fs, FR_DENIED);
			if (mode & FA_CREATE_ALWAYS) {		/* Resize it to zero on over write mode */
 80018ba:	f007 0708 	and.w	r7, r7, #8
 80018be:	b2ff      	uxtb	r7, r7
 80018c0:	b32f      	cbz	r7, 800190e <f_open+0xc6>
				cl = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);	/* Get start cluster */
 80018c2:	7d22      	ldrb	r2, [r4, #20]
 80018c4:	7d67      	ldrb	r7, [r4, #21]
 80018c6:	7ee1      	ldrb	r1, [r4, #27]
 80018c8:	ea42 2707 	orr.w	r7, r2, r7, lsl #8
 80018cc:	7ea2      	ldrb	r2, [r4, #26]
				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
				ST_WORD(dir+DIR_FstClusLO, 0);
				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
				dj.fs->wflag = 1;
 80018ce:	9805      	ldr	r0, [sp, #20]
				LEAVE_FF(dj.fs, FR_EXIST);
			dir = dj.dir;
			if (!dir || (dir[DIR_Attr] & (AM_RDO | AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
				LEAVE_FF(dj.fs, FR_DENIED);
			if (mode & FA_CREATE_ALWAYS) {		/* Resize it to zero on over write mode */
				cl = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);	/* Get start cluster */
 80018d0:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
 80018d4:	7523      	strb	r3, [r4, #20]
 80018d6:	7563      	strb	r3, [r4, #21]
				ST_WORD(dir+DIR_FstClusLO, 0);
 80018d8:	76a3      	strb	r3, [r4, #26]
 80018da:	76e3      	strb	r3, [r4, #27]
				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
 80018dc:	7723      	strb	r3, [r4, #28]
 80018de:	7763      	strb	r3, [r4, #29]
 80018e0:	77a3      	strb	r3, [r4, #30]
 80018e2:	77e3      	strb	r3, [r4, #31]
				dj.fs->wflag = 1;
 80018e4:	2301      	movs	r3, #1
				ps = dj.fs->winsect;			/* Remove the cluster chain */
				if (cl) {
 80018e6:	ea52 4707 	orrs.w	r7, r2, r7, lsl #16
			if (mode & FA_CREATE_ALWAYS) {		/* Resize it to zero on over write mode */
				cl = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);	/* Get start cluster */
				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
				ST_WORD(dir+DIR_FstClusLO, 0);
				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
				dj.fs->wflag = 1;
 80018ea:	7103      	strb	r3, [r0, #4]
				ps = dj.fs->winsect;			/* Remove the cluster chain */
 80018ec:	f8d0 802c 	ldr.w	r8, [r0, #44]	; 0x2c
				if (cl) {
 80018f0:	d007      	beq.n	8001902 <f_open+0xba>
					res = remove_chain(dj.fs, cl);
 80018f2:	4639      	mov	r1, r7
 80018f4:	f7ff f9ab 	bl	8000c4e <remove_chain>
					if (res) LEAVE_FF(dj.fs, res);
 80018f8:	2800      	cmp	r0, #0
 80018fa:	d159      	bne.n	80019b0 <f_open+0x168>
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 80018fc:	9b05      	ldr	r3, [sp, #20]
 80018fe:	3f01      	subs	r7, #1
 8001900:	60df      	str	r7, [r3, #12]
				}
				res = move_window(dj.fs, ps);
 8001902:	9805      	ldr	r0, [sp, #20]
 8001904:	4641      	mov	r1, r8
 8001906:	f7fe ff87 	bl	8000818 <move_window>
				if (res != FR_OK) LEAVE_FF(dj.fs, res);
 800190a:	2800      	cmp	r0, #0
 800190c:	d150      	bne.n	80019b0 <f_open+0x168>
			}
		}
		if (mode & FA_CREATE_ALWAYS) {
 800190e:	f006 0308 	and.w	r3, r6, #8
 8001912:	b2db      	uxtb	r3, r3
 8001914:	b313      	cbz	r3, 800195c <f_open+0x114>
			dir[DIR_Attr] = 0;					/* Reset attribute */
 8001916:	2300      	movs	r3, #0
 8001918:	72e3      	strb	r3, [r4, #11]
			ps = get_fattime();
 800191a:	f7fe fec5 	bl	80006a8 <get_fattime>
			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
 800191e:	f3c0 2307 	ubfx	r3, r0, #8, #8
 8001922:	73e3      	strb	r3, [r4, #15]
 8001924:	0c03      	lsrs	r3, r0, #16
 8001926:	7423      	strb	r3, [r4, #16]
			dj.fs->wflag = 1;
 8001928:	9b05      	ldr	r3, [sp, #20]
			}
		}
		if (mode & FA_CREATE_ALWAYS) {
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ps = get_fattime();
			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
 800192a:	73a0      	strb	r0, [r4, #14]
			dj.fs->wflag = 1;
 800192c:	2201      	movs	r2, #1
			}
		}
		if (mode & FA_CREATE_ALWAYS) {
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ps = get_fattime();
			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
 800192e:	0e00      	lsrs	r0, r0, #24
 8001930:	7460      	strb	r0, [r4, #17]
			dj.fs->wflag = 1;
			mode |= FA__WRITTEN;				/* Set file changed flag */
 8001932:	f046 0620 	orr.w	r6, r6, #32
		}
		if (mode & FA_CREATE_ALWAYS) {
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ps = get_fattime();
			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
			dj.fs->wflag = 1;
 8001936:	711a      	strb	r2, [r3, #4]
 8001938:	e010      	b.n	800195c <f_open+0x114>
		}
	}
	/* Open an existing file */
	else {
#endif /* !_FS_READONLY */
		if (res != FR_OK) LEAVE_FF(dj.fs, res);	/* Follow failed */
 800193a:	2800      	cmp	r0, #0
 800193c:	d138      	bne.n	80019b0 <f_open+0x168>
		dir = dj.dir;
 800193e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
		if (!dir || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
 8001940:	2c00      	cmp	r4, #0
 8001942:	d032      	beq.n	80019aa <f_open+0x162>
 8001944:	7ae3      	ldrb	r3, [r4, #11]
 8001946:	f003 0210 	and.w	r2, r3, #16
 800194a:	b2d2      	uxtb	r2, r2
 800194c:	2a00      	cmp	r2, #0
 800194e:	d12c      	bne.n	80019aa <f_open+0x162>
			LEAVE_FF(dj.fs, FR_NO_FILE);
#if !_FS_READONLY
		if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
 8001950:	f007 0702 	and.w	r7, r7, #2
 8001954:	b2ff      	uxtb	r7, r7
 8001956:	b10f      	cbz	r7, 800195c <f_open+0x114>
 8001958:	07d8      	lsls	r0, r3, #31
 800195a:	d428      	bmi.n	80019ae <f_open+0x166>
			LEAVE_FF(dj.fs, FR_DENIED);
	}
	fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
 800195c:	9b05      	ldr	r3, [sp, #20]
 800195e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	fp->dir_ptr = dj.dir;
#endif
	fp->flag = mode;					/* File access mode */
 8001960:	71ae      	strb	r6, [r5, #6]
			LEAVE_FF(dj.fs, FR_NO_FILE);
#if !_FS_READONLY
		if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
			LEAVE_FF(dj.fs, FR_DENIED);
	}
	fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
 8001962:	61ea      	str	r2, [r5, #28]
	fp->dir_ptr = dj.dir;
 8001964:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8001966:	622a      	str	r2, [r5, #32]
#endif
	fp->flag = mode;					/* File access mode */
	fp->org_clust =						/* File start cluster */
		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 8001968:	7d22      	ldrb	r2, [r4, #20]
 800196a:	7d61      	ldrb	r1, [r4, #21]
 800196c:	7ee0      	ldrb	r0, [r4, #27]
 800196e:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
 8001972:	7ea2      	ldrb	r2, [r4, #26]
 8001974:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8001978:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
	}
	fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
	fp->dir_ptr = dj.dir;
#endif
	fp->flag = mode;					/* File access mode */
	fp->org_clust =						/* File start cluster */
 800197c:	612a      	str	r2, [r5, #16]
		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
	fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 800197e:	7fa2      	ldrb	r2, [r4, #30]
 8001980:	7fe1      	ldrb	r1, [r4, #31]
 8001982:	0412      	lsls	r2, r2, #16
 8001984:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 8001988:	7f21      	ldrb	r1, [r4, #28]
	fp->fptr = 0; fp->csect = 255;		/* File pointer */
 800198a:	2000      	movs	r0, #0
	fp->dir_ptr = dj.dir;
#endif
	fp->flag = mode;					/* File access mode */
	fp->org_clust =						/* File start cluster */
		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
	fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 800198c:	430a      	orrs	r2, r1
 800198e:	7f61      	ldrb	r1, [r4, #29]
	fp->fptr = 0; fp->csect = 255;		/* File pointer */
	fp->dsect = 0;
	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */
 8001990:	602b      	str	r3, [r5, #0]
	fp->dir_ptr = dj.dir;
#endif
	fp->flag = mode;					/* File access mode */
	fp->org_clust =						/* File start cluster */
		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
	fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 8001992:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8001996:	60ea      	str	r2, [r5, #12]
	fp->fptr = 0; fp->csect = 255;		/* File pointer */
 8001998:	22ff      	movs	r2, #255	; 0xff
 800199a:	71ea      	strb	r2, [r5, #7]
	fp->dsect = 0;
	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */
 800199c:	88db      	ldrh	r3, [r3, #6]
#endif
	fp->flag = mode;					/* File access mode */
	fp->org_clust =						/* File start cluster */
		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
	fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
	fp->fptr = 0; fp->csect = 255;		/* File pointer */
 800199e:	60a8      	str	r0, [r5, #8]
	fp->dsect = 0;
 80019a0:	61a8      	str	r0, [r5, #24]
	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */
 80019a2:	80ab      	strh	r3, [r5, #4]
 80019a4:	e004      	b.n	80019b0 <f_open+0x168>
			mode |= FA_CREATE_ALWAYS;
			dir = dj.dir;			/* Created entry (SFN entry) */
		}
		else {						/* Any object is already existing */
			if (mode & FA_CREATE_NEW)			/* Cannot create new */
				LEAVE_FF(dj.fs, FR_EXIST);
 80019a6:	2008      	movs	r0, #8
 80019a8:	e002      	b.n	80019b0 <f_open+0x168>
	else {
#endif /* !_FS_READONLY */
		if (res != FR_OK) LEAVE_FF(dj.fs, res);	/* Follow failed */
		dir = dj.dir;
		if (!dir || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
			LEAVE_FF(dj.fs, FR_NO_FILE);
 80019aa:	2004      	movs	r0, #4
 80019ac:	e000      	b.n	80019b0 <f_open+0x168>
		else {						/* Any object is already existing */
			if (mode & FA_CREATE_NEW)			/* Cannot create new */
				LEAVE_FF(dj.fs, FR_EXIST);
			dir = dj.dir;
			if (!dir || (dir[DIR_Attr] & (AM_RDO | AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
				LEAVE_FF(dj.fs, FR_DENIED);
 80019ae:	2007      	movs	r0, #7
	fp->fptr = 0; fp->csect = 255;		/* File pointer */
	fp->dsect = 0;
	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */

	LEAVE_FF(dj.fs, FR_OK);
}
 80019b0:	b00e      	add	sp, #56	; 0x38
 80019b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80019b6:	bf00      	nop
 80019b8:	2000092a 	.word	0x2000092a

080019bc <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
 80019bc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80019c0:	4604      	mov	r4, r0
 80019c2:	4699      	mov	r9, r3
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE *rbuff = buff;


	*br = 0;	/* Initialize bytes read */
 80019c4:	2300      	movs	r3, #0
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
 80019c6:	460f      	mov	r7, r1
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE *rbuff = buff;


	*br = 0;	/* Initialize bytes read */
 80019c8:	f8c9 3000 	str.w	r3, [r9]

	res = validate(fp->fs, fp->id);					/* Check validity of the object */
 80019cc:	6800      	ldr	r0, [r0, #0]
 80019ce:	88a1      	ldrh	r1, [r4, #4]
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
 80019d0:	4690      	mov	r8, r2
	BYTE *rbuff = buff;


	*br = 0;	/* Initialize bytes read */

	res = validate(fp->fs, fp->id);					/* Check validity of the object */
 80019d2:	f7fe fffb 	bl	80009cc <validate>
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 80019d6:	4605      	mov	r5, r0
 80019d8:	2800      	cmp	r0, #0
 80019da:	f040 80a8 	bne.w	8001b2e <f_read+0x172>
	if (fp->flag & FA__ERROR)						/* Check abort flag */
 80019de:	79a3      	ldrb	r3, [r4, #6]
 80019e0:	0619      	lsls	r1, r3, #24
 80019e2:	f100 80a1 	bmi.w	8001b28 <f_read+0x16c>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 						/* Check access mode */
 80019e6:	07da      	lsls	r2, r3, #31
 80019e8:	f140 80a0 	bpl.w	8001b2c <f_read+0x170>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
 80019ec:	68e0      	ldr	r0, [r4, #12]
 80019ee:	68a3      	ldr	r3, [r4, #8]
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			if (fp->dsect != sect) {			/* Fill sector buffer with file data */
				if (disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
 80019f0:	f104 0a24 	add.w	sl, r4, #36	; 0x24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)						/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
 80019f4:	1ac6      	subs	r6, r0, r3
 80019f6:	45b0      	cmp	r8, r6
 80019f8:	bf38      	it	cc
 80019fa:	4646      	movcc	r6, r8
 80019fc:	e090      	b.n	8001b20 <f_read+0x164>
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	for ( ;  btr;									/* Repeat until all data transferred */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 80019fe:	68a3      	ldr	r3, [r4, #8]
 8001a00:	05da      	lsls	r2, r3, #23
 8001a02:	d174      	bne.n	8001aee <f_read+0x132>
			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
 8001a04:	6820      	ldr	r0, [r4, #0]
 8001a06:	79e1      	ldrb	r1, [r4, #7]
 8001a08:	7882      	ldrb	r2, [r0, #2]
 8001a0a:	4291      	cmp	r1, r2
 8001a0c:	d30e      	bcc.n	8001a2c <f_read+0x70>
				clst = (fp->fptr == 0) ?			/* On the top of the file? */
					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
 8001a0e:	b90b      	cbnz	r3, 8001a14 <f_read+0x58>
 8001a10:	6920      	ldr	r0, [r4, #16]
 8001a12:	e002      	b.n	8001a1a <f_read+0x5e>
 8001a14:	6961      	ldr	r1, [r4, #20]
 8001a16:	f7fe ffeb 	bl	80009f0 <get_fat>
				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
 8001a1a:	2801      	cmp	r0, #1
 8001a1c:	d800      	bhi.n	8001a20 <f_read+0x64>
 8001a1e:	e00d      	b.n	8001a3c <f_read+0x80>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 8001a20:	1c43      	adds	r3, r0, #1
 8001a22:	d100      	bne.n	8001a26 <f_read+0x6a>
 8001a24:	e058      	b.n	8001ad8 <f_read+0x11c>
				fp->curr_clust = clst;				/* Update current cluster */
				fp->csect = 0;						/* Reset sector offset in the cluster */
 8001a26:	2300      	movs	r3, #0
			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
				clst = (fp->fptr == 0) ?			/* On the top of the file? */
					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->curr_clust = clst;				/* Update current cluster */
 8001a28:	6160      	str	r0, [r4, #20]
				fp->csect = 0;						/* Reset sector offset in the cluster */
 8001a2a:	71e3      	strb	r3, [r4, #7]
			}
			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
 8001a2c:	6823      	ldr	r3, [r4, #0]
 8001a2e:	6961      	ldr	r1, [r4, #20]
 8001a30:	4618      	mov	r0, r3
 8001a32:	9301      	str	r3, [sp, #4]
 8001a34:	f7ff f937 	bl	8000ca6 <clust2sect>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 8001a38:	9b01      	ldr	r3, [sp, #4]
 8001a3a:	b920      	cbnz	r0, 8001a46 <f_read+0x8a>
 8001a3c:	79a3      	ldrb	r3, [r4, #6]
 8001a3e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8001a42:	71a3      	strb	r3, [r4, #6]
 8001a44:	e070      	b.n	8001b28 <f_read+0x16c>
			sect += fp->csect;
 8001a46:	79e2      	ldrb	r2, [r4, #7]
			cc = btr / SS(fp->fs);					/* When remaining bytes >= sector size, */
			if (cc) {								/* Read maximum contiguous sectors directly */
 8001a48:	ea5f 2b56 	movs.w	fp, r6, lsr #9
				fp->curr_clust = clst;				/* Update current cluster */
				fp->csect = 0;						/* Reset sector offset in the cluster */
			}
			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += fp->csect;
 8001a4c:	eb00 0802 	add.w	r8, r0, r2
			cc = btr / SS(fp->fs);					/* When remaining bytes >= sector size, */
			if (cc) {								/* Read maximum contiguous sectors directly */
 8001a50:	d026      	beq.n	8001aa0 <f_read+0xe4>
				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 8001a52:	7899      	ldrb	r1, [r3, #2]
 8001a54:	eb0b 0002 	add.w	r0, fp, r2
 8001a58:	4288      	cmp	r0, r1
					cc = fp->fs->csize - fp->csect;
 8001a5a:	bf88      	it	hi
 8001a5c:	ebc2 0b01 	rsbhi	fp, r2, r1
				if (disk_read(fp->fs->drive, rbuff, sect, (BYTE)cc) != RES_OK)
 8001a60:	7858      	ldrb	r0, [r3, #1]
 8001a62:	4639      	mov	r1, r7
 8001a64:	fa5f f38b 	uxtb.w	r3, fp
 8001a68:	4642      	mov	r2, r8
 8001a6a:	f001 fb8b 	bl	8003184 <disk_read>
 8001a6e:	79a3      	ldrb	r3, [r4, #6]
 8001a70:	b100      	cbz	r0, 8001a74 <f_read+0xb8>
 8001a72:	e032      	b.n	8001ada <f_read+0x11e>
#if !_FS_READONLY && _FS_MINIMIZE <= 2
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)		/* Replace one of the read sectors with cached data if it contains a dirty sector */
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)	/* Replace one of the read sectors with cached data if it contains a dirty sector */
 8001a74:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8001a78:	b2db      	uxtb	r3, r3
 8001a7a:	b15b      	cbz	r3, 8001a94 <f_read+0xd8>
 8001a7c:	69a0      	ldr	r0, [r4, #24]
 8001a7e:	ebc8 0000 	rsb	r0, r8, r0
 8001a82:	4558      	cmp	r0, fp
 8001a84:	d206      	bcs.n	8001a94 <f_read+0xd8>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
 8001a86:	eb07 2040 	add.w	r0, r7, r0, lsl #9
 8001a8a:	4651      	mov	r1, sl
 8001a8c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8001a90:	f7fe fe2a 	bl	80006e8 <mem_cpy>
#endif
#endif
				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
 8001a94:	79e3      	ldrb	r3, [r4, #7]
				rcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
 8001a96:	ea4f 284b 	mov.w	r8, fp, lsl #9
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)	/* Replace one of the read sectors with cached data if it contains a dirty sector */
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
 8001a9a:	445b      	add	r3, fp
 8001a9c:	71e3      	strb	r3, [r4, #7]
				rcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
				continue;
 8001a9e:	e034      	b.n	8001b0a <f_read+0x14e>
			}
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write sector I/O buffer if needed */
 8001aa0:	79a2      	ldrb	r2, [r4, #6]
 8001aa2:	f002 0240 	and.w	r2, r2, #64	; 0x40
 8001aa6:	b2d2      	uxtb	r2, r2
 8001aa8:	b15a      	cbz	r2, 8001ac2 <f_read+0x106>
				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
 8001aaa:	7858      	ldrb	r0, [r3, #1]
 8001aac:	4651      	mov	r1, sl
 8001aae:	2301      	movs	r3, #1
 8001ab0:	69a2      	ldr	r2, [r4, #24]
 8001ab2:	f001 fbab 	bl	800320c <disk_write>
 8001ab6:	79a3      	ldrb	r3, [r4, #6]
 8001ab8:	b100      	cbz	r0, 8001abc <f_read+0x100>
 8001aba:	e00e      	b.n	8001ada <f_read+0x11e>
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 8001abc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001ac0:	71a3      	strb	r3, [r4, #6]
			}
#endif
			if (fp->dsect != sect) {			/* Fill sector buffer with file data */
 8001ac2:	69a3      	ldr	r3, [r4, #24]
 8001ac4:	4543      	cmp	r3, r8
 8001ac6:	d00d      	beq.n	8001ae4 <f_read+0x128>
				if (disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
 8001ac8:	6823      	ldr	r3, [r4, #0]
 8001aca:	4651      	mov	r1, sl
 8001acc:	7858      	ldrb	r0, [r3, #1]
 8001ace:	4642      	mov	r2, r8
 8001ad0:	2301      	movs	r3, #1
 8001ad2:	f001 fb57 	bl	8003184 <disk_read>
 8001ad6:	b128      	cbz	r0, 8001ae4 <f_read+0x128>
					ABORT(fp->fs, FR_DISK_ERR);
 8001ad8:	79a3      	ldrb	r3, [r4, #6]
 8001ada:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8001ade:	71a3      	strb	r3, [r4, #6]
 8001ae0:	2501      	movs	r5, #1
 8001ae2:	e024      	b.n	8001b2e <f_read+0x172>
			}
#endif
			fp->dsect = sect;
			fp->csect++;							/* Next sector address in the cluster */
 8001ae4:	79e3      	ldrb	r3, [r4, #7]
			if (fp->dsect != sect) {			/* Fill sector buffer with file data */
				if (disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
 8001ae6:	f8c4 8018 	str.w	r8, [r4, #24]
			fp->csect++;							/* Next sector address in the cluster */
 8001aea:	3301      	adds	r3, #1
 8001aec:	71e3      	strb	r3, [r4, #7]
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
 8001aee:	68a1      	ldr	r1, [r4, #8]
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
 8001af0:	4638      	mov	r0, r7
			}
#endif
			fp->dsect = sect;
			fp->csect++;							/* Next sector address in the cluster */
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
 8001af2:	05c9      	lsls	r1, r1, #23
 8001af4:	0dc9      	lsrs	r1, r1, #23
 8001af6:	f5c1 7800 	rsb	r8, r1, #512	; 0x200
 8001afa:	4546      	cmp	r6, r8
 8001afc:	bf38      	it	cc
 8001afe:	46b0      	movcc	r8, r6
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
 8001b00:	1861      	adds	r1, r4, r1
 8001b02:	3124      	adds	r1, #36	; 0x24
 8001b04:	4642      	mov	r2, r8
 8001b06:	f7fe fdef 	bl	80006e8 <mem_cpy>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	for ( ;  btr;									/* Repeat until all data transferred */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 8001b0a:	68a3      	ldr	r3, [r4, #8]
 8001b0c:	4447      	add	r7, r8
 8001b0e:	4443      	add	r3, r8
 8001b10:	60a3      	str	r3, [r4, #8]
 8001b12:	f8d9 3000 	ldr.w	r3, [r9]
 8001b16:	ebc8 0606 	rsb	r6, r8, r6
 8001b1a:	4443      	add	r3, r8
 8001b1c:	f8c9 3000 	str.w	r3, [r9]
	if (!(fp->flag & FA_READ)) 						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */

	for ( ;  btr;									/* Repeat until all data transferred */
 8001b20:	2e00      	cmp	r6, #0
 8001b22:	f47f af6c 	bne.w	80019fe <f_read+0x42>
 8001b26:	e002      	b.n	8001b2e <f_read+0x172>
	*br = 0;	/* Initialize bytes read */

	res = validate(fp->fs, fp->id);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)						/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
 8001b28:	2502      	movs	r5, #2
 8001b2a:	e000      	b.n	8001b2e <f_read+0x172>
	if (!(fp->flag & FA_READ)) 						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
 8001b2c:	2507      	movs	r5, #7
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
 8001b2e:	4628      	mov	r0, r5
 8001b30:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08001b34 <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
 8001b34:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001b38:	4604      	mov	r4, r0
 8001b3a:	4698      	mov	r8, r3
	DWORD clst, sect;
	UINT wcnt, cc;
	const BYTE *wbuff = buff;


	*bw = 0;	/* Initialize bytes written */
 8001b3c:	2300      	movs	r3, #0
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
 8001b3e:	460f      	mov	r7, r1
	DWORD clst, sect;
	UINT wcnt, cc;
	const BYTE *wbuff = buff;


	*bw = 0;	/* Initialize bytes written */
 8001b40:	f8c8 3000 	str.w	r3, [r8]

	res = validate(fp->fs, fp->id);					/* Check validity of the object */
 8001b44:	6800      	ldr	r0, [r0, #0]
 8001b46:	88a1      	ldrh	r1, [r4, #4]
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
 8001b48:	4616      	mov	r6, r2
	const BYTE *wbuff = buff;


	*bw = 0;	/* Initialize bytes written */

	res = validate(fp->fs, fp->id);					/* Check validity of the object */
 8001b4a:	f7fe ff3f 	bl	80009cc <validate>
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 8001b4e:	4605      	mov	r5, r0
 8001b50:	2800      	cmp	r0, #0
 8001b52:	f040 80c3 	bne.w	8001cdc <f_write+0x1a8>
	if (fp->flag & FA__ERROR)						/* Check abort flag */
 8001b56:	79a3      	ldrb	r3, [r4, #6]
 8001b58:	061a      	lsls	r2, r3, #24
 8001b5a:	d450      	bmi.n	8001bfe <f_write+0xca>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))						/* Check access mode */
 8001b5c:	f003 0302 	and.w	r3, r3, #2
 8001b60:	b2db      	uxtb	r3, r3
 8001b62:	2b00      	cmp	r3, #0
 8001b64:	f000 80b9 	beq.w	8001cda <f_write+0x1a6>
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */
 8001b68:	68e3      	ldr	r3, [r4, #12]
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {				/* Fill sector buffer with file data */
				if (fp->fptr < fp->fsize &&
					disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
 8001b6a:	f104 0924 	add.w	r9, r4, #36	; 0x24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)						/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */
 8001b6e:	42de      	cmn	r6, r3
 8001b70:	bf28      	it	cs
 8001b72:	2600      	movcs	r6, #0
 8001b74:	e0a7      	b.n	8001cc6 <f_write+0x192>

	for ( ;  btw;									/* Repeat until all data transferred */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 8001b76:	68a3      	ldr	r3, [r4, #8]
 8001b78:	05da      	lsls	r2, r3, #23
 8001b7a:	f040 8087 	bne.w	8001c8c <f_write+0x158>
			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
 8001b7e:	6820      	ldr	r0, [r4, #0]
 8001b80:	79e1      	ldrb	r1, [r4, #7]
 8001b82:	7882      	ldrb	r2, [r0, #2]
 8001b84:	4291      	cmp	r1, r2
 8001b86:	d31c      	bcc.n	8001bc2 <f_write+0x8e>
				if (fp->fptr == 0) {				/* On the top of the file? */
 8001b88:	b933      	cbnz	r3, 8001b98 <f_write+0x64>
					clst = fp->org_clust;			/* Follow from the origin */
 8001b8a:	6921      	ldr	r1, [r4, #16]
					if (clst == 0)					/* When there is no cluster chain, */
 8001b8c:	b979      	cbnz	r1, 8001bae <f_write+0x7a>
						fp->org_clust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
 8001b8e:	f7ff f80e 	bl	8000bae <create_chain>
 8001b92:	4601      	mov	r1, r0
 8001b94:	6120      	str	r0, [r4, #16]
 8001b96:	e003      	b.n	8001ba0 <f_write+0x6c>
				} else {							/* Middle or end of the file */
					clst = create_chain(fp->fs, fp->curr_clust);			/* Follow or stretch cluster chain */
 8001b98:	6961      	ldr	r1, [r4, #20]
 8001b9a:	f7ff f808 	bl	8000bae <create_chain>
 8001b9e:	4601      	mov	r1, r0
				}
				if (clst == 0) break;				/* Could not allocate a new cluster (disk full) */
 8001ba0:	b929      	cbnz	r1, 8001bae <f_write+0x7a>
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 8001ba2:	68a3      	ldr	r3, [r4, #8]
 8001ba4:	68e2      	ldr	r2, [r4, #12]
 8001ba6:	4293      	cmp	r3, r2
 8001ba8:	f200 8091 	bhi.w	8001cce <f_write+0x19a>
 8001bac:	e090      	b.n	8001cd0 <f_write+0x19c>
						fp->org_clust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
				} else {							/* Middle or end of the file */
					clst = create_chain(fp->fs, fp->curr_clust);			/* Follow or stretch cluster chain */
				}
				if (clst == 0) break;				/* Could not allocate a new cluster (disk full) */
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 8001bae:	2901      	cmp	r1, #1
 8001bb0:	79a3      	ldrb	r3, [r4, #6]
 8001bb2:	d100      	bne.n	8001bb6 <f_write+0x82>
 8001bb4:	e020      	b.n	8001bf8 <f_write+0xc4>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 8001bb6:	1c48      	adds	r0, r1, #1
 8001bb8:	d100      	bne.n	8001bbc <f_write+0x88>
 8001bba:	e05d      	b.n	8001c78 <f_write+0x144>
				fp->curr_clust = clst;				/* Update current cluster */
				fp->csect = 0;						/* Reset sector address in the cluster */
 8001bbc:	2300      	movs	r3, #0
					clst = create_chain(fp->fs, fp->curr_clust);			/* Follow or stretch cluster chain */
				}
				if (clst == 0) break;				/* Could not allocate a new cluster (disk full) */
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->curr_clust = clst;				/* Update current cluster */
 8001bbe:	6161      	str	r1, [r4, #20]
				fp->csect = 0;						/* Reset sector address in the cluster */
 8001bc0:	71e3      	strb	r3, [r4, #7]
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write back data buffer prior to following direct transfer */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write back data buffer prior to following direct transfer */
 8001bc2:	79a3      	ldrb	r3, [r4, #6]
 8001bc4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8001bc8:	b2db      	uxtb	r3, r3
 8001bca:	b163      	cbz	r3, 8001be6 <f_write+0xb2>
				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
 8001bcc:	6823      	ldr	r3, [r4, #0]
 8001bce:	4649      	mov	r1, r9
 8001bd0:	7858      	ldrb	r0, [r3, #1]
 8001bd2:	69a2      	ldr	r2, [r4, #24]
 8001bd4:	2301      	movs	r3, #1
 8001bd6:	f001 fb19 	bl	800320c <disk_write>
 8001bda:	79a3      	ldrb	r3, [r4, #6]
 8001bdc:	b100      	cbz	r0, 8001be0 <f_write+0xac>
 8001bde:	e04b      	b.n	8001c78 <f_write+0x144>
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 8001be0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001be4:	71a3      	strb	r3, [r4, #6]
			}
#endif
			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
 8001be6:	6823      	ldr	r3, [r4, #0]
 8001be8:	6961      	ldr	r1, [r4, #20]
 8001bea:	4618      	mov	r0, r3
 8001bec:	9301      	str	r3, [sp, #4]
 8001bee:	f7ff f85a 	bl	8000ca6 <clust2sect>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 8001bf2:	9b01      	ldr	r3, [sp, #4]
 8001bf4:	b928      	cbnz	r0, 8001c02 <f_write+0xce>
 8001bf6:	79a3      	ldrb	r3, [r4, #6]
 8001bf8:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8001bfc:	71a3      	strb	r3, [r4, #6]
 8001bfe:	2502      	movs	r5, #2
 8001c00:	e06c      	b.n	8001cdc <f_write+0x1a8>
			sect += fp->csect;
 8001c02:	79e2      	ldrb	r2, [r4, #7]
			cc = btw / SS(fp->fs);					/* When remaining bytes >= sector size, */
			if (cc) {								/* Write maximum contiguous sectors directly */
 8001c04:	ea5f 2b56 	movs.w	fp, r6, lsr #9
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += fp->csect;
 8001c08:	eb00 0a02 	add.w	sl, r0, r2
			cc = btw / SS(fp->fs);					/* When remaining bytes >= sector size, */
			if (cc) {								/* Write maximum contiguous sectors directly */
 8001c0c:	d025      	beq.n	8001c5a <f_write+0x126>
				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 8001c0e:	7899      	ldrb	r1, [r3, #2]
 8001c10:	eb0b 0002 	add.w	r0, fp, r2
 8001c14:	4288      	cmp	r0, r1
					cc = fp->fs->csize - fp->csect;
 8001c16:	bf88      	it	hi
 8001c18:	ebc2 0b01 	rsbhi	fp, r2, r1
				if (disk_write(fp->fs->drive, wbuff, sect, (BYTE)cc) != RES_OK)
 8001c1c:	7858      	ldrb	r0, [r3, #1]
 8001c1e:	4639      	mov	r1, r7
 8001c20:	4652      	mov	r2, sl
 8001c22:	fa5f f38b 	uxtb.w	r3, fp
 8001c26:	f001 faf1 	bl	800320c <disk_write>
 8001c2a:	b100      	cbz	r0, 8001c2e <f_write+0xfa>
 8001c2c:	e023      	b.n	8001c76 <f_write+0x142>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets dirty by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) {		/* Refill sector cache if it gets dirty by the direct write */
 8001c2e:	69a1      	ldr	r1, [r4, #24]
 8001c30:	ebca 0101 	rsb	r1, sl, r1
 8001c34:	4559      	cmp	r1, fp
 8001c36:	d20a      	bcs.n	8001c4e <f_write+0x11a>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
 8001c38:	4648      	mov	r0, r9
 8001c3a:	eb07 2141 	add.w	r1, r7, r1, lsl #9
 8001c3e:	f44f 7200 	mov.w	r2, #512	; 0x200
 8001c42:	f7fe fd51 	bl	80006e8 <mem_cpy>
					fp->flag &= ~FA__DIRTY;
 8001c46:	79a3      	ldrb	r3, [r4, #6]
 8001c48:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001c4c:	71a3      	strb	r3, [r4, #6]
				}
#endif
				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
 8001c4e:	79e3      	ldrb	r3, [r4, #7]
 8001c50:	445b      	add	r3, fp
 8001c52:	71e3      	strb	r3, [r4, #7]
				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
 8001c54:	ea4f 2b4b 	mov.w	fp, fp, lsl #9
				continue;
 8001c58:	e02a      	b.n	8001cb0 <f_write+0x17c>
			if (fp->fptr >= fp->fsize) {			/* Avoid silly buffer filling at growing edge */
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {				/* Fill sector buffer with file data */
 8001c5a:	69a2      	ldr	r2, [r4, #24]
 8001c5c:	4552      	cmp	r2, sl
 8001c5e:	d010      	beq.n	8001c82 <f_write+0x14e>
				if (fp->fptr < fp->fsize &&
 8001c60:	68a1      	ldr	r1, [r4, #8]
 8001c62:	68e2      	ldr	r2, [r4, #12]
 8001c64:	4291      	cmp	r1, r2
 8001c66:	d20c      	bcs.n	8001c82 <f_write+0x14e>
					disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
 8001c68:	7858      	ldrb	r0, [r3, #1]
 8001c6a:	4649      	mov	r1, r9
 8001c6c:	4652      	mov	r2, sl
 8001c6e:	2301      	movs	r3, #1
 8001c70:	f001 fa88 	bl	8003184 <disk_read>
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {				/* Fill sector buffer with file data */
				if (fp->fptr < fp->fsize &&
 8001c74:	b128      	cbz	r0, 8001c82 <f_write+0x14e>
					disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
 8001c76:	79a3      	ldrb	r3, [r4, #6]
 8001c78:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8001c7c:	71a3      	strb	r3, [r4, #6]
 8001c7e:	2501      	movs	r5, #1
 8001c80:	e02c      	b.n	8001cdc <f_write+0x1a8>
			}
#endif
			fp->dsect = sect;
			fp->csect++;							/* Next sector address in the cluster */
 8001c82:	79e3      	ldrb	r3, [r4, #7]
				if (fp->fptr < fp->fsize &&
					disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
 8001c84:	f8c4 a018 	str.w	sl, [r4, #24]
			fp->csect++;							/* Next sector address in the cluster */
 8001c88:	3301      	adds	r3, #1
 8001c8a:	71e3      	strb	r3, [r4, #7]
		}
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Put partial sector into file I/O buffer */
 8001c8c:	68a0      	ldr	r0, [r4, #8]
		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 8001c8e:	4639      	mov	r1, r7
			}
#endif
			fp->dsect = sect;
			fp->csect++;							/* Next sector address in the cluster */
		}
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Put partial sector into file I/O buffer */
 8001c90:	05c0      	lsls	r0, r0, #23
 8001c92:	0dc0      	lsrs	r0, r0, #23
 8001c94:	f5c0 7b00 	rsb	fp, r0, #512	; 0x200
 8001c98:	455e      	cmp	r6, fp
 8001c9a:	bf38      	it	cc
 8001c9c:	46b3      	movcc	fp, r6
		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 8001c9e:	1820      	adds	r0, r4, r0
 8001ca0:	3024      	adds	r0, #36	; 0x24
 8001ca2:	465a      	mov	r2, fp
 8001ca4:	f7fe fd20 	bl	80006e8 <mem_cpy>
		fp->flag |= FA__DIRTY;
 8001ca8:	79a3      	ldrb	r3, [r4, #6]
 8001caa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001cae:	71a3      	strb	r3, [r4, #6]
	if (!(fp->flag & FA_WRITE))						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */

	for ( ;  btw;									/* Repeat until all data transferred */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 8001cb0:	68a3      	ldr	r3, [r4, #8]
 8001cb2:	445f      	add	r7, fp
 8001cb4:	445b      	add	r3, fp
 8001cb6:	60a3      	str	r3, [r4, #8]
 8001cb8:	f8d8 3000 	ldr.w	r3, [r8]
 8001cbc:	ebcb 0606 	rsb	r6, fp, r6
 8001cc0:	445b      	add	r3, fp
 8001cc2:	f8c8 3000 	str.w	r3, [r8]
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */

	for ( ;  btw;									/* Repeat until all data transferred */
 8001cc6:	2e00      	cmp	r6, #0
 8001cc8:	f47f af55 	bne.w	8001b76 <f_write+0x42>
 8001ccc:	e769      	b.n	8001ba2 <f_write+0x6e>
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 8001cce:	60e3      	str	r3, [r4, #12]
	fp->flag |= FA__WRITTEN;						/* Set file changed flag */
 8001cd0:	79a3      	ldrb	r3, [r4, #6]
 8001cd2:	f043 0320 	orr.w	r3, r3, #32
 8001cd6:	71a3      	strb	r3, [r4, #6]

	LEAVE_FF(fp->fs, FR_OK);
 8001cd8:	e000      	b.n	8001cdc <f_write+0x1a8>
	res = validate(fp->fs, fp->id);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)						/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))						/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
 8001cda:	2507      	movs	r5, #7

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file changed flag */

	LEAVE_FF(fp->fs, FR_OK);
}
 8001cdc:	4628      	mov	r0, r5
 8001cde:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08001ce2 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
 8001ce2:	b538      	push	{r3, r4, r5, lr}
 8001ce4:	4604      	mov	r4, r0
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
 8001ce6:	88a1      	ldrh	r1, [r4, #4]
 8001ce8:	6800      	ldr	r0, [r0, #0]
 8001cea:	f7fe fe6f 	bl	80009cc <validate>
	if (res == FR_OK) {
 8001cee:	2800      	cmp	r0, #0
 8001cf0:	d14c      	bne.n	8001d8c <f_sync+0xaa>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
 8001cf2:	79a3      	ldrb	r3, [r4, #6]
 8001cf4:	f003 0220 	and.w	r2, r3, #32
 8001cf8:	b2d2      	uxtb	r2, r2
 8001cfa:	2a00      	cmp	r2, #0
 8001cfc:	d046      	beq.n	8001d8c <f_sync+0xaa>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
 8001cfe:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8001d02:	b2db      	uxtb	r3, r3
 8001d04:	b16b      	cbz	r3, 8001d22 <f_sync+0x40>
				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
 8001d06:	4621      	mov	r1, r4
 8001d08:	f851 3b24 	ldr.w	r3, [r1], #36
 8001d0c:	69a2      	ldr	r2, [r4, #24]
 8001d0e:	7858      	ldrb	r0, [r3, #1]
 8001d10:	2301      	movs	r3, #1
 8001d12:	f001 fa7b 	bl	800320c <disk_write>
 8001d16:	2800      	cmp	r0, #0
 8001d18:	d137      	bne.n	8001d8a <f_sync+0xa8>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 8001d1a:	79a3      	ldrb	r3, [r4, #6]
 8001d1c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001d20:	71a3      	strb	r3, [r4, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
 8001d22:	6820      	ldr	r0, [r4, #0]
 8001d24:	69e1      	ldr	r1, [r4, #28]
 8001d26:	f7fe fd77 	bl	8000818 <move_window>
			if (res == FR_OK) {
 8001d2a:	2800      	cmp	r0, #0
 8001d2c:	d12e      	bne.n	8001d8c <f_sync+0xaa>
				dir = fp->dir_ptr;
 8001d2e:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 8001d30:	7aeb      	ldrb	r3, [r5, #11]
 8001d32:	f043 0320 	orr.w	r3, r3, #32
 8001d36:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 8001d38:	68e3      	ldr	r3, [r4, #12]
 8001d3a:	772b      	strb	r3, [r5, #28]
 8001d3c:	89a3      	ldrh	r3, [r4, #12]
 8001d3e:	0a1b      	lsrs	r3, r3, #8
 8001d40:	776b      	strb	r3, [r5, #29]
 8001d42:	89e3      	ldrh	r3, [r4, #14]
 8001d44:	77ab      	strb	r3, [r5, #30]
 8001d46:	7be3      	ldrb	r3, [r4, #15]
 8001d48:	77eb      	strb	r3, [r5, #31]
				ST_WORD(dir+DIR_FstClusLO, fp->org_clust);	/* Update start cluster */
 8001d4a:	6923      	ldr	r3, [r4, #16]
 8001d4c:	76ab      	strb	r3, [r5, #26]
 8001d4e:	8a23      	ldrh	r3, [r4, #16]
 8001d50:	0a1b      	lsrs	r3, r3, #8
 8001d52:	76eb      	strb	r3, [r5, #27]
				ST_WORD(dir+DIR_FstClusHI, fp->org_clust >> 16);
 8001d54:	8a63      	ldrh	r3, [r4, #18]
 8001d56:	752b      	strb	r3, [r5, #20]
 8001d58:	8a63      	ldrh	r3, [r4, #18]
 8001d5a:	0a1b      	lsrs	r3, r3, #8
 8001d5c:	756b      	strb	r3, [r5, #21]
				tim = get_fattime();			/* Updated time */
 8001d5e:	f7fe fca3 	bl	80006a8 <get_fattime>
				ST_DWORD(dir+DIR_WrtTime, tim);
 8001d62:	f3c0 2307 	ubfx	r3, r0, #8, #8
 8001d66:	75a8      	strb	r0, [r5, #22]
 8001d68:	75eb      	strb	r3, [r5, #23]
 8001d6a:	0c03      	lsrs	r3, r0, #16
 8001d6c:	0e00      	lsrs	r0, r0, #24
 8001d6e:	762b      	strb	r3, [r5, #24]
 8001d70:	7668      	strb	r0, [r5, #25]
				fp->flag &= ~FA__WRITTEN;
 8001d72:	79a3      	ldrb	r3, [r4, #6]
				fp->fs->wflag = 1;
 8001d74:	2201      	movs	r2, #1
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_WORD(dir+DIR_FstClusLO, fp->org_clust);	/* Update start cluster */
				ST_WORD(dir+DIR_FstClusHI, fp->org_clust >> 16);
				tim = get_fattime();			/* Updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
				fp->flag &= ~FA__WRITTEN;
 8001d76:	f023 0320 	bic.w	r3, r3, #32
 8001d7a:	71a3      	strb	r3, [r4, #6]
				fp->fs->wflag = 1;
 8001d7c:	6823      	ldr	r3, [r4, #0]
 8001d7e:	711a      	strb	r2, [r3, #4]
				res = sync(fp->fs);
 8001d80:	6820      	ldr	r0, [r4, #0]
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
 8001d82:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				ST_WORD(dir+DIR_FstClusHI, fp->org_clust >> 16);
				tim = get_fattime();			/* Updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
				fp->flag &= ~FA__WRITTEN;
				fp->fs->wflag = 1;
				res = sync(fp->fs);
 8001d86:	f7fe bd83 	b.w	8000890 <sync>
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
 8001d8a:	2001      	movs	r0, #1
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
 8001d8c:	bd38      	pop	{r3, r4, r5, pc}

08001d8e <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
 8001d8e:	b510      	push	{r4, lr}
 8001d90:	4604      	mov	r4, r0
#if _FS_READONLY
	res = validate(fp->fs, fp->id);
	if (res == FR_OK) fp->fs = NULL;
	LEAVE_FF(fp->fs, res);
#else
	res = f_sync(fp);
 8001d92:	f7ff ffa6 	bl	8001ce2 <f_sync>
	if (res == FR_OK) fp->fs = NULL;
 8001d96:	b900      	cbnz	r0, 8001d9a <f_close+0xc>
 8001d98:	6020      	str	r0, [r4, #0]
	return res;
#endif
}
 8001d9a:	bd10      	pop	{r4, pc}

08001d9c <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
 8001d9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001da0:	4604      	mov	r4, r0
 8001da2:	460d      	mov	r5, r1
	FRESULT res;
	DWORD clst, bcs, nsect, ifptr;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
 8001da4:	6800      	ldr	r0, [r0, #0]
 8001da6:	88a1      	ldrh	r1, [r4, #4]
 8001da8:	f7fe fe10 	bl	80009cc <validate>
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 8001dac:	4606      	mov	r6, r0
 8001dae:	2800      	cmp	r0, #0
 8001db0:	f040 80a2 	bne.w	8001ef8 <f_lseek+0x15c>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
 8001db4:	79a2      	ldrb	r2, [r4, #6]
 8001db6:	0611      	lsls	r1, r2, #24
 8001db8:	f100 809d 	bmi.w	8001ef6 <f_lseek+0x15a>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
 8001dbc:	68e3      	ldr	r3, [r4, #12]
 8001dbe:	429d      	cmp	r5, r3
 8001dc0:	d905      	bls.n	8001dce <f_lseek+0x32>
#if !_FS_READONLY
		 && !(fp->flag & FA_WRITE)
 8001dc2:	f002 0202 	and.w	r2, r2, #2
 8001dc6:	b2d2      	uxtb	r2, r2
 8001dc8:	2a00      	cmp	r2, #0
 8001dca:	bf08      	it	eq
 8001dcc:	461d      	moveq	r5, r3
#endif
		) ofs = fp->fsize;

	ifptr = fp->fptr;
	fp->fptr = nsect = 0; fp->csect = 255;
 8001dce:	2200      	movs	r2, #0
#if !_FS_READONLY
		 && !(fp->flag & FA_WRITE)
#endif
		) ofs = fp->fsize;

	ifptr = fp->fptr;
 8001dd0:	68a3      	ldr	r3, [r4, #8]
	fp->fptr = nsect = 0; fp->csect = 255;
 8001dd2:	60a2      	str	r2, [r4, #8]
 8001dd4:	22ff      	movs	r2, #255	; 0xff
 8001dd6:	71e2      	strb	r2, [r4, #7]
	if (ofs > 0) {
 8001dd8:	b90d      	cbnz	r5, 8001dde <f_lseek+0x42>
		 && !(fp->flag & FA_WRITE)
#endif
		) ofs = fp->fsize;

	ifptr = fp->fptr;
	fp->fptr = nsect = 0; fp->csect = 255;
 8001dda:	2500      	movs	r5, #0
 8001ddc:	e059      	b.n	8001e92 <f_lseek+0xf6>
	if (ofs > 0) {
		bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
 8001dde:	6820      	ldr	r0, [r4, #0]
 8001de0:	7887      	ldrb	r7, [r0, #2]
 8001de2:	027f      	lsls	r7, r7, #9
		if (ifptr > 0 &&
 8001de4:	b16b      	cbz	r3, 8001e02 <f_lseek+0x66>
			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 8001de6:	3b01      	subs	r3, #1
 8001de8:	1e69      	subs	r1, r5, #1
 8001dea:	fbb1 f1f7 	udiv	r1, r1, r7
 8001dee:	fbb3 f2f7 	udiv	r2, r3, r7

	ifptr = fp->fptr;
	fp->fptr = nsect = 0; fp->csect = 255;
	if (ofs > 0) {
		bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
		if (ifptr > 0 &&
 8001df2:	4291      	cmp	r1, r2
 8001df4:	d305      	bcc.n	8001e02 <f_lseek+0x66>
			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
			fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
 8001df6:	427a      	negs	r2, r7
 8001df8:	4013      	ands	r3, r2
 8001dfa:	60a3      	str	r3, [r4, #8]
			ofs -= fp->fptr;
 8001dfc:	1aed      	subs	r5, r5, r3
			clst = fp->curr_clust;
 8001dfe:	6961      	ldr	r1, [r4, #20]
 8001e00:	e00c      	b.n	8001e1c <f_lseek+0x80>
		} else {									/* When seek to back cluster, */
			clst = fp->org_clust;					/* start from the first cluster */
 8001e02:	6921      	ldr	r1, [r4, #16]
#if !_FS_READONLY
			if (clst == 0) {						/* If no cluster chain, create a new chain */
 8001e04:	b949      	cbnz	r1, 8001e1a <f_lseek+0x7e>
				clst = create_chain(fp->fs, 0);
 8001e06:	f7fe fed2 	bl	8000bae <create_chain>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 8001e0a:	2801      	cmp	r0, #1
			clst = fp->curr_clust;
		} else {									/* When seek to back cluster, */
			clst = fp->org_clust;					/* start from the first cluster */
#if !_FS_READONLY
			if (clst == 0) {						/* If no cluster chain, create a new chain */
				clst = create_chain(fp->fs, 0);
 8001e0c:	4601      	mov	r1, r0
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 8001e0e:	d100      	bne.n	8001e12 <f_lseek+0x76>
 8001e10:	e036      	b.n	8001e80 <f_lseek+0xe4>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 8001e12:	1c43      	adds	r3, r0, #1
 8001e14:	d100      	bne.n	8001e18 <f_lseek+0x7c>
 8001e16:	e05d      	b.n	8001ed4 <f_lseek+0x138>
				fp->org_clust = clst;
 8001e18:	6120      	str	r0, [r4, #16]
			}
#endif
			fp->curr_clust = clst;
 8001e1a:	6161      	str	r1, [r4, #20]
		}
		if (clst != 0) {
 8001e1c:	2900      	cmp	r1, #0
 8001e1e:	d0dc      	beq.n	8001dda <f_lseek+0x3e>
 8001e20:	e01c      	b.n	8001e5c <f_lseek+0xc0>
			while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
				if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 8001e22:	79a3      	ldrb	r3, [r4, #6]
					clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
 8001e24:	6820      	ldr	r0, [r4, #0]
			fp->curr_clust = clst;
		}
		if (clst != 0) {
			while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
				if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 8001e26:	f003 0302 	and.w	r3, r3, #2
 8001e2a:	b2db      	uxtb	r3, r3
 8001e2c:	b123      	cbz	r3, 8001e38 <f_lseek+0x9c>
					clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
 8001e2e:	f7fe febe 	bl	8000bae <create_chain>
					if (clst == 0) {				/* When disk gets full, clip file size */
 8001e32:	4601      	mov	r1, r0
 8001e34:	b918      	cbnz	r0, 8001e3e <f_lseek+0xa2>
 8001e36:	e014      	b.n	8001e62 <f_lseek+0xc6>
						ofs = bcs; break;
					}
				} else
#endif
					clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
 8001e38:	f7fe fdda 	bl	80009f0 <get_fat>
 8001e3c:	4601      	mov	r1, r0
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 8001e3e:	1c48      	adds	r0, r1, #1
 8001e40:	d100      	bne.n	8001e44 <f_lseek+0xa8>
 8001e42:	e047      	b.n	8001ed4 <f_lseek+0x138>
				if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
 8001e44:	2901      	cmp	r1, #1
 8001e46:	d91b      	bls.n	8001e80 <f_lseek+0xe4>
 8001e48:	6823      	ldr	r3, [r4, #0]
 8001e4a:	69db      	ldr	r3, [r3, #28]
 8001e4c:	4299      	cmp	r1, r3
 8001e4e:	d300      	bcc.n	8001e52 <f_lseek+0xb6>
 8001e50:	e016      	b.n	8001e80 <f_lseek+0xe4>
				fp->curr_clust = clst;
				fp->fptr += bcs;
 8001e52:	68a3      	ldr	r3, [r4, #8]
				} else
#endif
					clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
				fp->curr_clust = clst;
 8001e54:	6161      	str	r1, [r4, #20]
				fp->fptr += bcs;
 8001e56:	19db      	adds	r3, r3, r7
 8001e58:	60a3      	str	r3, [r4, #8]
				ofs -= bcs;
 8001e5a:	1bed      	subs	r5, r5, r7
			}
#endif
			fp->curr_clust = clst;
		}
		if (clst != 0) {
			while (ofs > bcs) {						/* Cluster following loop */
 8001e5c:	42bd      	cmp	r5, r7
 8001e5e:	d8e0      	bhi.n	8001e22 <f_lseek+0x86>
 8001e60:	e000      	b.n	8001e64 <f_lseek+0xc8>
#if !_FS_READONLY
				if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
					clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
					if (clst == 0) {				/* When disk gets full, clip file size */
 8001e62:	463d      	mov	r5, r7
				if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
				fp->curr_clust = clst;
				fp->fptr += bcs;
				ofs -= bcs;
			}
			fp->fptr += ofs;
 8001e64:	68a3      	ldr	r3, [r4, #8]
			fp->csect = (BYTE)(ofs / SS(fp->fs));	/* Sector offset in the cluster */
 8001e66:	ea4f 2855 	mov.w	r8, r5, lsr #9
				if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
				fp->curr_clust = clst;
				fp->fptr += bcs;
				ofs -= bcs;
			}
			fp->fptr += ofs;
 8001e6a:	195b      	adds	r3, r3, r5
			fp->csect = (BYTE)(ofs / SS(fp->fs));	/* Sector offset in the cluster */
 8001e6c:	fa5f f788 	uxtb.w	r7, r8
			if (ofs % SS(fp->fs)) {
 8001e70:	05ed      	lsls	r5, r5, #23
				if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
				fp->curr_clust = clst;
				fp->fptr += bcs;
				ofs -= bcs;
			}
			fp->fptr += ofs;
 8001e72:	60a3      	str	r3, [r4, #8]
			fp->csect = (BYTE)(ofs / SS(fp->fs));	/* Sector offset in the cluster */
 8001e74:	71e7      	strb	r7, [r4, #7]
			if (ofs % SS(fp->fs)) {
 8001e76:	d0b0      	beq.n	8001dda <f_lseek+0x3e>
				nsect = clust2sect(fp->fs, clst);	/* Current sector */
 8001e78:	6820      	ldr	r0, [r4, #0]
 8001e7a:	f7fe ff14 	bl	8000ca6 <clust2sect>
				if (!nsect) ABORT(fp->fs, FR_INT_ERR);
 8001e7e:	b920      	cbnz	r0, 8001e8a <f_lseek+0xee>
 8001e80:	79a3      	ldrb	r3, [r4, #6]
 8001e82:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8001e86:	71a3      	strb	r3, [r4, #6]
 8001e88:	e035      	b.n	8001ef6 <f_lseek+0x15a>
				nsect += fp->csect;
				fp->csect++;
 8001e8a:	3701      	adds	r7, #1
			fp->fptr += ofs;
			fp->csect = (BYTE)(ofs / SS(fp->fs));	/* Sector offset in the cluster */
			if (ofs % SS(fp->fs)) {
				nsect = clust2sect(fp->fs, clst);	/* Current sector */
				if (!nsect) ABORT(fp->fs, FR_INT_ERR);
				nsect += fp->csect;
 8001e8c:	eb00 0508 	add.w	r5, r0, r8
				fp->csect++;
 8001e90:	71e7      	strb	r7, [r4, #7]
			}
		}
	}
	if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {
 8001e92:	68a3      	ldr	r3, [r4, #8]
 8001e94:	05db      	lsls	r3, r3, #23
 8001e96:	d024      	beq.n	8001ee2 <f_lseek+0x146>
 8001e98:	69a2      	ldr	r2, [r4, #24]
 8001e9a:	4295      	cmp	r5, r2
 8001e9c:	d021      	beq.n	8001ee2 <f_lseek+0x146>
#if !_FS_TINY
#if !_FS_READONLY
		if (fp->flag & FA__DIRTY) {			/* Write-back dirty buffer if needed */
 8001e9e:	79a3      	ldrb	r3, [r4, #6]
 8001ea0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8001ea4:	b2db      	uxtb	r3, r3
 8001ea6:	b163      	cbz	r3, 8001ec2 <f_lseek+0x126>
			if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
 8001ea8:	4621      	mov	r1, r4
 8001eaa:	f851 3b24 	ldr.w	r3, [r1], #36
 8001eae:	7858      	ldrb	r0, [r3, #1]
 8001eb0:	2301      	movs	r3, #1
 8001eb2:	f001 f9ab 	bl	800320c <disk_write>
 8001eb6:	79a3      	ldrb	r3, [r4, #6]
 8001eb8:	b100      	cbz	r0, 8001ebc <f_lseek+0x120>
 8001eba:	e00c      	b.n	8001ed6 <f_lseek+0x13a>
				ABORT(fp->fs, FR_DISK_ERR);
			fp->flag &= ~FA__DIRTY;
 8001ebc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001ec0:	71a3      	strb	r3, [r4, #6]
		}
#endif
		if (disk_read(fp->fs->drive, fp->buf, nsect, 1) != RES_OK)
 8001ec2:	4621      	mov	r1, r4
 8001ec4:	f851 3b24 	ldr.w	r3, [r1], #36
 8001ec8:	462a      	mov	r2, r5
 8001eca:	7858      	ldrb	r0, [r3, #1]
 8001ecc:	2301      	movs	r3, #1
 8001ece:	f001 f959 	bl	8003184 <disk_read>
 8001ed2:	b128      	cbz	r0, 8001ee0 <f_lseek+0x144>
			ABORT(fp->fs, FR_DISK_ERR);
 8001ed4:	79a3      	ldrb	r3, [r4, #6]
 8001ed6:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8001eda:	71a3      	strb	r3, [r4, #6]
 8001edc:	2601      	movs	r6, #1
 8001ede:	e00b      	b.n	8001ef8 <f_lseek+0x15c>
#endif
		fp->dsect = nsect;
 8001ee0:	61a5      	str	r5, [r4, #24]
	}
#if !_FS_READONLY
	if (fp->fptr > fp->fsize) {			/* Set changed flag if the file size is extended */
 8001ee2:	68a3      	ldr	r3, [r4, #8]
 8001ee4:	68e2      	ldr	r2, [r4, #12]
 8001ee6:	4293      	cmp	r3, r2
 8001ee8:	d906      	bls.n	8001ef8 <f_lseek+0x15c>
		fp->fsize = fp->fptr;
 8001eea:	60e3      	str	r3, [r4, #12]
		fp->flag |= FA__WRITTEN;
 8001eec:	79a3      	ldrb	r3, [r4, #6]
 8001eee:	f043 0320 	orr.w	r3, r3, #32
 8001ef2:	71a3      	strb	r3, [r4, #6]
 8001ef4:	e000      	b.n	8001ef8 <f_lseek+0x15c>


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
 8001ef6:	2602      	movs	r6, #2
		fp->flag |= FA__WRITTEN;
	}
#endif

	LEAVE_FF(fp->fs, res);
}
 8001ef8:	4630      	mov	r0, r6
 8001efa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001efe <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const XCHAR *path	/* Pointer to the directory path */
)
{
 8001efe:	b510      	push	{r4, lr}
 8001f00:	b086      	sub	sp, #24
 8001f02:	4604      	mov	r4, r0
 8001f04:	a806      	add	r0, sp, #24
 8001f06:	f840 1d14 	str.w	r1, [r0, #-20]!
	FRESULT res;
	NAMEBUF(sfn, lfn);
	BYTE *dir;


	res = chk_mounted(&path, &dj->fs, 0);
 8001f0a:	2200      	movs	r2, #0
 8001f0c:	4621      	mov	r1, r4
 8001f0e:	f7ff fb3b 	bl	8001588 <chk_mounted>
	if (res == FR_OK) {
 8001f12:	bb48      	cbnz	r0, 8001f68 <f_opendir+0x6a>
		INITBUF((*dj), sfn, lfn);
 8001f14:	ab03      	add	r3, sp, #12
 8001f16:	61a3      	str	r3, [r4, #24]
 8001f18:	4b14      	ldr	r3, [pc, #80]	; (8001f6c <f_opendir+0x6e>)
		res = follow_path(dj, path);			/* Follow the path to the directory */
 8001f1a:	4620      	mov	r0, r4
	BYTE *dir;


	res = chk_mounted(&path, &dj->fs, 0);
	if (res == FR_OK) {
		INITBUF((*dj), sfn, lfn);
 8001f1c:	61e3      	str	r3, [r4, #28]
		res = follow_path(dj, path);			/* Follow the path to the directory */
 8001f1e:	9901      	ldr	r1, [sp, #4]
 8001f20:	f7ff f824 	bl	8000f6c <follow_path>
		if (res == FR_OK) {						/* Follow completed */
 8001f24:	b990      	cbnz	r0, 8001f4c <f_opendir+0x4e>
			dir = dj->dir;
 8001f26:	6963      	ldr	r3, [r4, #20]
			if (dir) {							/* It is not the root dir */
 8001f28:	b1b3      	cbz	r3, 8001f58 <f_opendir+0x5a>
				if (dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
 8001f2a:	7ada      	ldrb	r2, [r3, #11]
 8001f2c:	f002 0210 	and.w	r2, r2, #16
 8001f30:	b2d2      	uxtb	r2, r2
 8001f32:	b17a      	cbz	r2, 8001f54 <f_opendir+0x56>
					dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 8001f34:	7d59      	ldrb	r1, [r3, #21]
 8001f36:	7d1a      	ldrb	r2, [r3, #20]
 8001f38:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8001f3c:	7ed9      	ldrb	r1, [r3, #27]
 8001f3e:	7e9b      	ldrb	r3, [r3, #26]
 8001f40:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8001f44:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001f48:	60a3      	str	r3, [r4, #8]
 8001f4a:	e005      	b.n	8001f58 <f_opendir+0x5a>
			if (res == FR_OK) {
				dj->id = dj->fs->id;
				res = dir_seek(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 8001f4c:	2804      	cmp	r0, #4
 8001f4e:	bf08      	it	eq
 8001f50:	2005      	moveq	r0, #5
 8001f52:	e009      	b.n	8001f68 <f_opendir+0x6a>
			dir = dj->dir;
			if (dir) {							/* It is not the root dir */
				if (dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
					dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
 8001f54:	2005      	movs	r0, #5
 8001f56:	e007      	b.n	8001f68 <f_opendir+0x6a>
				}
			}
			if (res == FR_OK) {
				dj->id = dj->fs->id;
 8001f58:	6823      	ldr	r3, [r4, #0]
				res = dir_seek(dj, 0);			/* Rewind dir */
 8001f5a:	4620      	mov	r0, r4
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dj->id = dj->fs->id;
 8001f5c:	88db      	ldrh	r3, [r3, #6]
				res = dir_seek(dj, 0);			/* Rewind dir */
 8001f5e:	2100      	movs	r1, #0
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dj->id = dj->fs->id;
 8001f60:	80a3      	strh	r3, [r4, #4]
				res = dir_seek(dj, 0);			/* Rewind dir */
 8001f62:	f7fe feac 	bl	8000cbe <dir_seek>
 8001f66:	e7f1      	b.n	8001f4c <f_opendir+0x4e>
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}

	LEAVE_FF(dj->fs, res);
}
 8001f68:	b006      	add	sp, #24
 8001f6a:	bd10      	pop	{r4, pc}
 8001f6c:	2000092a 	.word	0x2000092a

08001f70 <f_readdir>:

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
 8001f70:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8001f72:	4604      	mov	r4, r0
 8001f74:	460e      	mov	r6, r1
	FRESULT res;
	NAMEBUF(sfn, lfn);


	res = validate(dj->fs, dj->id);			/* Check validity of the object */
 8001f76:	6800      	ldr	r0, [r0, #0]
 8001f78:	88a1      	ldrh	r1, [r4, #4]
 8001f7a:	f7fe fd27 	bl	80009cc <validate>
	if (res == FR_OK) {
 8001f7e:	4605      	mov	r5, r0
 8001f80:	b9f0      	cbnz	r0, 8001fc0 <f_readdir+0x50>
		INITBUF((*dj), sfn, lfn);
 8001f82:	ab01      	add	r3, sp, #4
 8001f84:	61a3      	str	r3, [r4, #24]
 8001f86:	4b10      	ldr	r3, [pc, #64]	; (8001fc8 <f_readdir+0x58>)
		if (!fno) {
			res = dir_seek(dj, 0);
 8001f88:	4620      	mov	r0, r4
	NAMEBUF(sfn, lfn);


	res = validate(dj->fs, dj->id);			/* Check validity of the object */
	if (res == FR_OK) {
		INITBUF((*dj), sfn, lfn);
 8001f8a:	61e3      	str	r3, [r4, #28]
		if (!fno) {
 8001f8c:	b91e      	cbnz	r6, 8001f96 <f_readdir+0x26>
			res = dir_seek(dj, 0);
 8001f8e:	4629      	mov	r1, r5
 8001f90:	f7fe fe95 	bl	8000cbe <dir_seek>
 8001f94:	e013      	b.n	8001fbe <f_readdir+0x4e>
		} else {
			res = dir_read(dj);
 8001f96:	f7ff f944 	bl	8001222 <dir_read>
			if (res == FR_NO_FILE) {
 8001f9a:	2804      	cmp	r0, #4
 8001f9c:	d101      	bne.n	8001fa2 <f_readdir+0x32>
				dj->sect = 0;
 8001f9e:	6125      	str	r5, [r4, #16]
 8001fa0:	e000      	b.n	8001fa4 <f_readdir+0x34>
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
 8001fa2:	b960      	cbnz	r0, 8001fbe <f_readdir+0x4e>
				get_fileinfo(dj, fno);		/* Get the object information */
 8001fa4:	4620      	mov	r0, r4
 8001fa6:	4631      	mov	r1, r6
 8001fa8:	f7fe fbbd 	bl	8000726 <get_fileinfo>
				res = dir_next(dj, FALSE);	/* Increment index for next */
 8001fac:	2100      	movs	r1, #0
 8001fae:	4620      	mov	r0, r4
 8001fb0:	f7fe fec7 	bl	8000d42 <dir_next>
				if (res == FR_NO_FILE) {
 8001fb4:	2804      	cmp	r0, #4
 8001fb6:	d102      	bne.n	8001fbe <f_readdir+0x4e>
					dj->sect = 0;
 8001fb8:	2300      	movs	r3, #0
 8001fba:	6123      	str	r3, [r4, #16]
 8001fbc:	e000      	b.n	8001fc0 <f_readdir+0x50>
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, FALSE);	/* Increment index for next */
				if (res == FR_NO_FILE) {
 8001fbe:	4605      	mov	r5, r0
			}
		}
	}

	LEAVE_FF(dj->fs, res);
}
 8001fc0:	4628      	mov	r0, r5
 8001fc2:	b004      	add	sp, #16
 8001fc4:	bd70      	pop	{r4, r5, r6, pc}
 8001fc6:	bf00      	nop
 8001fc8:	2000092a 	.word	0x2000092a

08001fcc <f_stat>:

FRESULT f_stat (
	const XCHAR *path,	/* Pointer to the file path */
	FILINFO *fno		/* Pointer to file information to return */
)
{
 8001fcc:	b530      	push	{r4, r5, lr}
 8001fce:	b08f      	sub	sp, #60	; 0x3c
 8001fd0:	ab0e      	add	r3, sp, #56	; 0x38
 8001fd2:	f843 0d34 	str.w	r0, [r3, #-52]!
 8001fd6:	460d      	mov	r5, r1
	FRESULT res;
	DIR dj;
	NAMEBUF(sfn, lfn);


	res = chk_mounted(&path, &dj.fs, 0);
 8001fd8:	4618      	mov	r0, r3
 8001fda:	a905      	add	r1, sp, #20
 8001fdc:	2200      	movs	r2, #0
 8001fde:	f7ff fad3 	bl	8001588 <chk_mounted>
	if (res == FR_OK) {
 8001fe2:	4604      	mov	r4, r0
 8001fe4:	b988      	cbnz	r0, 800200a <f_stat+0x3e>
		INITBUF(dj, sfn, lfn);
 8001fe6:	ab02      	add	r3, sp, #8
 8001fe8:	930b      	str	r3, [sp, #44]	; 0x2c
 8001fea:	4b09      	ldr	r3, [pc, #36]	; (8002010 <f_stat+0x44>)
		res = follow_path(&dj, path);	/* Follow the file path */
 8001fec:	a805      	add	r0, sp, #20
 8001fee:	9901      	ldr	r1, [sp, #4]
	NAMEBUF(sfn, lfn);


	res = chk_mounted(&path, &dj.fs, 0);
	if (res == FR_OK) {
		INITBUF(dj, sfn, lfn);
 8001ff0:	930c      	str	r3, [sp, #48]	; 0x30
		res = follow_path(&dj, path);	/* Follow the file path */
 8001ff2:	f7fe ffbb 	bl	8000f6c <follow_path>
		if (res == FR_OK) {				/* Follow completed */
 8001ff6:	4604      	mov	r4, r0
 8001ff8:	b938      	cbnz	r0, 800200a <f_stat+0x3e>
			if (dj.dir)	/* Found an object */
 8001ffa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001ffc:	b123      	cbz	r3, 8002008 <f_stat+0x3c>
				get_fileinfo(&dj, fno);
 8001ffe:	a805      	add	r0, sp, #20
 8002000:	4629      	mov	r1, r5
 8002002:	f7fe fb90 	bl	8000726 <get_fileinfo>
 8002006:	e000      	b.n	800200a <f_stat+0x3e>
			else		/* It is root dir */
				res = FR_INVALID_NAME;
 8002008:	2406      	movs	r4, #6
		}
	}

	LEAVE_FF(dj.fs, res);
}
 800200a:	4620      	mov	r0, r4
 800200c:	b00f      	add	sp, #60	; 0x3c
 800200e:	bd30      	pop	{r4, r5, pc}
 8002010:	2000092a 	.word	0x2000092a

08002014 <f_getfree>:
FRESULT f_getfree (
	const XCHAR *path,	/* Pointer to the logical drive number (root dir) */
	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
)
{
 8002014:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8002018:	ab02      	add	r3, sp, #8
 800201a:	f843 0d04 	str.w	r0, [r3, #-4]!
 800201e:	4688      	mov	r8, r1
 8002020:	4616      	mov	r6, r2
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
 8002022:	4611      	mov	r1, r2
 8002024:	4618      	mov	r0, r3
 8002026:	2200      	movs	r2, #0
 8002028:	f7ff faae 	bl	8001588 <chk_mounted>
	if (res != FR_OK) LEAVE_FF(*fatfs, res);
 800202c:	4604      	mov	r4, r0
 800202e:	2800      	cmp	r0, #0
 8002030:	d161      	bne.n	80020f6 <f_getfree+0xe2>

	/* If number of free cluster is valid, return it without cluster scan. */
	if ((*fatfs)->free_clust <= (*fatfs)->max_clust - 2) {
 8002032:	6833      	ldr	r3, [r6, #0]
 8002034:	69df      	ldr	r7, [r3, #28]
 8002036:	691a      	ldr	r2, [r3, #16]
 8002038:	1eb9      	subs	r1, r7, #2
 800203a:	428a      	cmp	r2, r1
 800203c:	d802      	bhi.n	8002044 <f_getfree+0x30>
		*nclst = (*fatfs)->free_clust;
 800203e:	f8c8 2000 	str.w	r2, [r8]
		LEAVE_FF(*fatfs, FR_OK);
 8002042:	e058      	b.n	80020f6 <f_getfree+0xe2>
	}

	/* Get number of free clusters */
	fat = (*fatfs)->fs_type;
 8002044:	f893 9000 	ldrb.w	r9, [r3]
	n = 0;
	if (fat == FS_FAT12) {
 8002048:	f1b9 0f01 	cmp.w	r9, #1
 800204c:	d111      	bne.n	8002072 <f_getfree+0x5e>
 800204e:	2702      	movs	r7, #2
 8002050:	4605      	mov	r5, r0
		clst = 2;
		do {
			stat = get_fat(*fatfs, clst);
 8002052:	6830      	ldr	r0, [r6, #0]
 8002054:	4639      	mov	r1, r7
 8002056:	f7fe fccb 	bl	80009f0 <get_fat>
			if (stat == 0xFFFFFFFF) LEAVE_FF(*fatfs, FR_DISK_ERR);
 800205a:	1c43      	adds	r3, r0, #1
 800205c:	d046      	beq.n	80020ec <f_getfree+0xd8>
			if (stat == 1) LEAVE_FF(*fatfs, FR_INT_ERR);
 800205e:	2801      	cmp	r0, #1
 8002060:	d046      	beq.n	80020f0 <f_getfree+0xdc>
			if (stat == 0) n++;
 8002062:	b900      	cbnz	r0, 8002066 <f_getfree+0x52>
 8002064:	3501      	adds	r5, #1
		} while (++clst < (*fatfs)->max_clust);
 8002066:	6833      	ldr	r3, [r6, #0]
 8002068:	3701      	adds	r7, #1
 800206a:	69db      	ldr	r3, [r3, #28]
 800206c:	429f      	cmp	r7, r3
 800206e:	d3f0      	bcc.n	8002052 <f_getfree+0x3e>
 8002070:	e032      	b.n	80020d8 <f_getfree+0xc4>
	} else {
		clst = (*fatfs)->max_clust;
		sect = (*fatfs)->fatbase;
 8002072:	6a19      	ldr	r1, [r3, #32]
		i = 0; p = 0;
 8002074:	4602      	mov	r2, r0
 8002076:	4603      	mov	r3, r0
		LEAVE_FF(*fatfs, FR_OK);
	}

	/* Get number of free clusters */
	fat = (*fatfs)->fs_type;
	n = 0;
 8002078:	4605      	mov	r5, r0
	} else {
		clst = (*fatfs)->max_clust;
		sect = (*fatfs)->fatbase;
		i = 0; p = 0;
		do {
			if (!i) {
 800207a:	b952      	cbnz	r2, 8002092 <f_getfree+0x7e>
				res = move_window(*fatfs, sect++);
 800207c:	6830      	ldr	r0, [r6, #0]
 800207e:	f101 0a01 	add.w	sl, r1, #1
 8002082:	f7fe fbc9 	bl	8000818 <move_window>
				if (res != FR_OK)
 8002086:	bba8      	cbnz	r0, 80020f4 <f_getfree+0xe0>
					LEAVE_FF(*fatfs, res);
				p = (*fatfs)->win;
 8002088:	6833      	ldr	r3, [r6, #0]
		clst = (*fatfs)->max_clust;
		sect = (*fatfs)->fatbase;
		i = 0; p = 0;
		do {
			if (!i) {
				res = move_window(*fatfs, sect++);
 800208a:	4651      	mov	r1, sl
				if (res != FR_OK)
					LEAVE_FF(*fatfs, res);
				p = (*fatfs)->win;
 800208c:	3330      	adds	r3, #48	; 0x30
				i = SS(*fatfs);
 800208e:	f44f 7200 	mov.w	r2, #512	; 0x200
			}
			if (fat == FS_FAT16) {
 8002092:	f1b9 0f02 	cmp.w	r9, #2
 8002096:	d109      	bne.n	80020ac <f_getfree+0x98>
				if (LD_WORD(p) == 0) n++;
 8002098:	f893 c001 	ldrb.w	ip, [r3, #1]
 800209c:	7818      	ldrb	r0, [r3, #0]
 800209e:	ea50 200c 	orrs.w	r0, r0, ip, lsl #8
 80020a2:	bf08      	it	eq
 80020a4:	3501      	addeq	r5, #1
				p += 2; i -= 2;
 80020a6:	3302      	adds	r3, #2
 80020a8:	3a02      	subs	r2, #2
 80020aa:	e013      	b.n	80020d4 <f_getfree+0xc0>
			} else {
				if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
 80020ac:	7898      	ldrb	r0, [r3, #2]
 80020ae:	f893 c003 	ldrb.w	ip, [r3, #3]
 80020b2:	0400      	lsls	r0, r0, #16
 80020b4:	ea40 600c 	orr.w	r0, r0, ip, lsl #24
 80020b8:	f893 c000 	ldrb.w	ip, [r3]
 80020bc:	ea40 000c 	orr.w	r0, r0, ip
 80020c0:	f893 c001 	ldrb.w	ip, [r3, #1]
 80020c4:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
 80020c8:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
 80020cc:	b900      	cbnz	r0, 80020d0 <f_getfree+0xbc>
 80020ce:	3501      	adds	r5, #1
				p += 4; i -= 4;
 80020d0:	3304      	adds	r3, #4
 80020d2:	3a04      	subs	r2, #4
			}
		} while (--clst);
 80020d4:	3f01      	subs	r7, #1
 80020d6:	d1d0      	bne.n	800207a <f_getfree+0x66>
	}
	(*fatfs)->free_clust = n;
 80020d8:	6833      	ldr	r3, [r6, #0]
	if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
 80020da:	f1b9 0f03 	cmp.w	r9, #3
				if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
				p += 4; i -= 4;
			}
		} while (--clst);
	}
	(*fatfs)->free_clust = n;
 80020de:	611d      	str	r5, [r3, #16]
	if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
 80020e0:	d101      	bne.n	80020e6 <f_getfree+0xd2>
 80020e2:	2201      	movs	r2, #1
 80020e4:	715a      	strb	r2, [r3, #5]
	*nclst = n;
 80020e6:	f8c8 5000 	str.w	r5, [r8]

	LEAVE_FF(*fatfs, FR_OK);
 80020ea:	e004      	b.n	80020f6 <f_getfree+0xe2>
	n = 0;
	if (fat == FS_FAT12) {
		clst = 2;
		do {
			stat = get_fat(*fatfs, clst);
			if (stat == 0xFFFFFFFF) LEAVE_FF(*fatfs, FR_DISK_ERR);
 80020ec:	2401      	movs	r4, #1
 80020ee:	e002      	b.n	80020f6 <f_getfree+0xe2>
			if (stat == 1) LEAVE_FF(*fatfs, FR_INT_ERR);
 80020f0:	2402      	movs	r4, #2
 80020f2:	e000      	b.n	80020f6 <f_getfree+0xe2>
		clst = (*fatfs)->max_clust;
		sect = (*fatfs)->fatbase;
		i = 0; p = 0;
		do {
			if (!i) {
				res = move_window(*fatfs, sect++);
 80020f4:	4604      	mov	r4, r0
	(*fatfs)->free_clust = n;
	if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
	*nclst = n;

	LEAVE_FF(*fatfs, FR_OK);
}
 80020f6:	4620      	mov	r0, r4
 80020f8:	e8bd 87fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, pc}

080020fc <f_truncate>:
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
	FIL *fp		/* Pointer to the file object */
)
{
 80020fc:	b570      	push	{r4, r5, r6, lr}
 80020fe:	4604      	mov	r4, r0
	FRESULT res;
	DWORD ncl;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
 8002100:	88a1      	ldrh	r1, [r4, #4]
 8002102:	6800      	ldr	r0, [r0, #0]
 8002104:	f7fe fc62 	bl	80009cc <validate>
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 8002108:	4605      	mov	r5, r0
 800210a:	2800      	cmp	r0, #0
 800210c:	d13d      	bne.n	800218a <f_truncate+0x8e>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
 800210e:	79a3      	ldrb	r3, [r4, #6]
 8002110:	0619      	lsls	r1, r3, #24
 8002112:	d42e      	bmi.n	8002172 <f_truncate+0x76>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))			/* Check access mode */
 8002114:	f003 0202 	and.w	r2, r3, #2
 8002118:	b2d2      	uxtb	r2, r2
 800211a:	b362      	cbz	r2, 8002176 <f_truncate+0x7a>
		LEAVE_FF(fp->fs, FR_DENIED);

	if (fp->fsize > fp->fptr) {
 800211c:	68a6      	ldr	r6, [r4, #8]
 800211e:	68e2      	ldr	r2, [r4, #12]
 8002120:	42b2      	cmp	r2, r6
 8002122:	d932      	bls.n	800218a <f_truncate+0x8e>
		fp->fsize = fp->fptr;	/* Set file size to current R/W point */
		fp->flag |= FA__WRITTEN;
 8002124:	f043 0320 	orr.w	r3, r3, #32
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))			/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);

	if (fp->fsize > fp->fptr) {
		fp->fsize = fp->fptr;	/* Set file size to current R/W point */
 8002128:	60e6      	str	r6, [r4, #12]
		fp->flag |= FA__WRITTEN;
 800212a:	71a3      	strb	r3, [r4, #6]
		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
			res = remove_chain(fp->fs, fp->org_clust);
 800212c:	6820      	ldr	r0, [r4, #0]
		LEAVE_FF(fp->fs, FR_DENIED);

	if (fp->fsize > fp->fptr) {
		fp->fsize = fp->fptr;	/* Set file size to current R/W point */
		fp->flag |= FA__WRITTEN;
		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
 800212e:	b92e      	cbnz	r6, 800213c <f_truncate+0x40>
			res = remove_chain(fp->fs, fp->org_clust);
 8002130:	6921      	ldr	r1, [r4, #16]
 8002132:	f7fe fd8c 	bl	8000c4e <remove_chain>
			fp->org_clust = 0;
 8002136:	6126      	str	r6, [r4, #16]

	if (fp->fsize > fp->fptr) {
		fp->fsize = fp->fptr;	/* Set file size to current R/W point */
		fp->flag |= FA__WRITTEN;
		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
			res = remove_chain(fp->fs, fp->org_clust);
 8002138:	4605      	mov	r5, r0
 800213a:	e014      	b.n	8002166 <f_truncate+0x6a>
			fp->org_clust = 0;
		} else {				/* When truncate a part of the file, remove remaining clusters */
			ncl = get_fat(fp->fs, fp->curr_clust);
 800213c:	6961      	ldr	r1, [r4, #20]
 800213e:	f7fe fc57 	bl	80009f0 <get_fat>
			res = FR_OK;
			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
 8002142:	1c42      	adds	r2, r0, #1
		fp->flag |= FA__WRITTEN;
		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
			res = remove_chain(fp->fs, fp->org_clust);
			fp->org_clust = 0;
		} else {				/* When truncate a part of the file, remove remaining clusters */
			ncl = get_fat(fp->fs, fp->curr_clust);
 8002144:	4606      	mov	r6, r0
			res = FR_OK;
			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
 8002146:	d018      	beq.n	800217a <f_truncate+0x7e>
			if (ncl == 1) res = FR_INT_ERR;
 8002148:	2801      	cmp	r0, #1
 800214a:	d11a      	bne.n	8002182 <f_truncate+0x86>
 800214c:	e017      	b.n	800217e <f_truncate+0x82>
			if (res == FR_OK && ncl < fp->fs->max_clust) {
				res = put_fat(fp->fs, fp->curr_clust, 0x0FFFFFFF);
 800214e:	6961      	ldr	r1, [r4, #20]
 8002150:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 8002154:	f7fe fcb3 	bl	8000abe <put_fat>
				if (res == FR_OK) res = remove_chain(fp->fs, ncl);
 8002158:	4605      	mov	r5, r0
 800215a:	b928      	cbnz	r0, 8002168 <f_truncate+0x6c>
 800215c:	6820      	ldr	r0, [r4, #0]
 800215e:	4631      	mov	r1, r6
 8002160:	f7fe fd75 	bl	8000c4e <remove_chain>
 8002164:	4605      	mov	r5, r0
			}
		}
	}
	if (res != FR_OK) fp->flag |= FA__ERROR;
 8002166:	b185      	cbz	r5, 800218a <f_truncate+0x8e>
 8002168:	79a3      	ldrb	r3, [r4, #6]
 800216a:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800216e:	71a3      	strb	r3, [r4, #6]
 8002170:	e00b      	b.n	800218a <f_truncate+0x8e>


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
 8002172:	2502      	movs	r5, #2
 8002174:	e009      	b.n	800218a <f_truncate+0x8e>
	if (!(fp->flag & FA_WRITE))			/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
 8002176:	2507      	movs	r5, #7
 8002178:	e007      	b.n	800218a <f_truncate+0x8e>
			res = remove_chain(fp->fs, fp->org_clust);
			fp->org_clust = 0;
		} else {				/* When truncate a part of the file, remove remaining clusters */
			ncl = get_fat(fp->fs, fp->curr_clust);
			res = FR_OK;
			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
 800217a:	2501      	movs	r5, #1
 800217c:	e7f4      	b.n	8002168 <f_truncate+0x6c>
			if (ncl == 1) res = FR_INT_ERR;
 800217e:	2502      	movs	r5, #2
 8002180:	e7f2      	b.n	8002168 <f_truncate+0x6c>
			if (res == FR_OK && ncl < fp->fs->max_clust) {
 8002182:	6820      	ldr	r0, [r4, #0]
 8002184:	69c3      	ldr	r3, [r0, #28]
 8002186:	429e      	cmp	r6, r3
 8002188:	d3e1      	bcc.n	800214e <f_truncate+0x52>
		}
	}
	if (res != FR_OK) fp->flag |= FA__ERROR;

	LEAVE_FF(fp->fs, res);
}
 800218a:	4628      	mov	r0, r5
 800218c:	bd70      	pop	{r4, r5, r6, pc}

0800218e <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const XCHAR *path		/* Pointer to the file or directory path */
)
{
 800218e:	b510      	push	{r4, lr}
 8002190:	b098      	sub	sp, #96	; 0x60
 8002192:	ab18      	add	r3, sp, #96	; 0x60
 8002194:	f843 0d5c 	str.w	r0, [r3, #-92]!
	NAMEBUF(sfn, lfn);
	BYTE *dir;
	DWORD dclst;


	res = chk_mounted(&path, &dj.fs, 1);
 8002198:	4618      	mov	r0, r3
 800219a:	a906      	add	r1, sp, #24
 800219c:	2201      	movs	r2, #1
 800219e:	f7ff f9f3 	bl	8001588 <chk_mounted>
	if (res != FR_OK) LEAVE_FF(dj.fs, res);
 80021a2:	2800      	cmp	r0, #0
 80021a4:	d147      	bne.n	8002236 <f_unlink+0xa8>

	INITBUF(dj, sfn, lfn);
 80021a6:	ab03      	add	r3, sp, #12
 80021a8:	930c      	str	r3, [sp, #48]	; 0x30
 80021aa:	4b24      	ldr	r3, [pc, #144]	; (800223c <f_unlink+0xae>)
	res = follow_path(&dj, path);			/* Follow the file path */
 80021ac:	a806      	add	r0, sp, #24
 80021ae:	9901      	ldr	r1, [sp, #4]


	res = chk_mounted(&path, &dj.fs, 1);
	if (res != FR_OK) LEAVE_FF(dj.fs, res);

	INITBUF(dj, sfn, lfn);
 80021b0:	930d      	str	r3, [sp, #52]	; 0x34
	res = follow_path(&dj, path);			/* Follow the file path */
 80021b2:	f7fe fedb 	bl	8000f6c <follow_path>
	if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
		res = FR_INVALID_NAME;
	if (res != FR_OK) LEAVE_FF(dj.fs, res); /* Follow failed */
 80021b6:	2800      	cmp	r0, #0
 80021b8:	d13d      	bne.n	8002236 <f_unlink+0xa8>

	dir = dj.dir;
 80021ba:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	if (!dir)								/* Is it the root directory? */
 80021bc:	2b00      	cmp	r3, #0
 80021be:	d037      	beq.n	8002230 <f_unlink+0xa2>
		LEAVE_FF(dj.fs, FR_INVALID_NAME);
	if (dir[DIR_Attr] & AM_RDO)				/* Is it a R/O object? */
 80021c0:	7ada      	ldrb	r2, [r3, #11]
 80021c2:	07d0      	lsls	r0, r2, #31
 80021c4:	d501      	bpl.n	80021ca <f_unlink+0x3c>
		LEAVE_FF(dj.fs, FR_DENIED);
 80021c6:	2007      	movs	r0, #7
 80021c8:	e035      	b.n	8002236 <f_unlink+0xa8>
	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 80021ca:	7d19      	ldrb	r1, [r3, #20]
 80021cc:	7d5c      	ldrb	r4, [r3, #21]

	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
 80021ce:	f002 0210 	and.w	r2, r2, #16
	dir = dj.dir;
	if (!dir)								/* Is it the root directory? */
		LEAVE_FF(dj.fs, FR_INVALID_NAME);
	if (dir[DIR_Attr] & AM_RDO)				/* Is it a R/O object? */
		LEAVE_FF(dj.fs, FR_DENIED);
	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 80021d2:	ea41 2404 	orr.w	r4, r1, r4, lsl #8
 80021d6:	7ed9      	ldrb	r1, [r3, #27]
 80021d8:	7e9b      	ldrb	r3, [r3, #26]

	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
 80021da:	b2d2      	uxtb	r2, r2
	dir = dj.dir;
	if (!dir)								/* Is it the root directory? */
		LEAVE_FF(dj.fs, FR_INVALID_NAME);
	if (dir[DIR_Attr] & AM_RDO)				/* Is it a R/O object? */
		LEAVE_FF(dj.fs, FR_DENIED);
	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
 80021dc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80021e0:	ea43 4404 	orr.w	r4, r3, r4, lsl #16

	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
 80021e4:	b922      	cbnz	r2, 80021f0 <f_unlink+0x62>
		res = dir_read(&sdj);
		if (res == FR_OK) res = FR_DENIED;	/* Not empty sub-dir */
		if (res != FR_NO_FILE) LEAVE_FF(dj.fs, res);
	}

	res = dir_remove(&dj);					/* Remove directory entry */
 80021e6:	a806      	add	r0, sp, #24
 80021e8:	f7fe fff4 	bl	80011d4 <dir_remove>
	if (res == FR_OK) {
 80021ec:	b1a8      	cbz	r0, 800221a <f_unlink+0x8c>
 80021ee:	e022      	b.n	8002236 <f_unlink+0xa8>
	if (dir[DIR_Attr] & AM_RDO)				/* Is it a R/O object? */
		LEAVE_FF(dj.fs, FR_DENIED);
	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);

	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
		if (dclst < 2) LEAVE_FF(dj.fs, FR_INT_ERR);
 80021f0:	2c01      	cmp	r4, #1
 80021f2:	d91f      	bls.n	8002234 <f_unlink+0xa6>
		mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
 80021f4:	a80f      	add	r0, sp, #60	; 0x3c
 80021f6:	a906      	add	r1, sp, #24
 80021f8:	2224      	movs	r2, #36	; 0x24
 80021fa:	f7fe fa75 	bl	80006e8 <mem_cpy>
		sdj.sclust = dclst;
		res = dir_seek(&sdj, 2);
 80021fe:	a80f      	add	r0, sp, #60	; 0x3c
 8002200:	2102      	movs	r1, #2
	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);

	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
		if (dclst < 2) LEAVE_FF(dj.fs, FR_INT_ERR);
		mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
		sdj.sclust = dclst;
 8002202:	9411      	str	r4, [sp, #68]	; 0x44
		res = dir_seek(&sdj, 2);
 8002204:	f7fe fd5b 	bl	8000cbe <dir_seek>
		if (res != FR_OK) LEAVE_FF(dj.fs, res);
 8002208:	b9a8      	cbnz	r0, 8002236 <f_unlink+0xa8>
		res = dir_read(&sdj);
 800220a:	a80f      	add	r0, sp, #60	; 0x3c
 800220c:	f7ff f809 	bl	8001222 <dir_read>
		if (res == FR_OK) res = FR_DENIED;	/* Not empty sub-dir */
 8002210:	2800      	cmp	r0, #0
 8002212:	d0d8      	beq.n	80021c6 <f_unlink+0x38>
		if (res != FR_NO_FILE) LEAVE_FF(dj.fs, res);
 8002214:	2804      	cmp	r0, #4
 8002216:	d0e6      	beq.n	80021e6 <f_unlink+0x58>
 8002218:	e00d      	b.n	8002236 <f_unlink+0xa8>
	}

	res = dir_remove(&dj);					/* Remove directory entry */
	if (res == FR_OK) {
		if (dclst)
 800221a:	b91c      	cbnz	r4, 8002224 <f_unlink+0x96>
			res = remove_chain(dj.fs, dclst);	/* Remove the cluster chain */
		if (res == FR_OK) res = sync(dj.fs);
 800221c:	9806      	ldr	r0, [sp, #24]
 800221e:	f7fe fb37 	bl	8000890 <sync>
 8002222:	e008      	b.n	8002236 <f_unlink+0xa8>
	}

	res = dir_remove(&dj);					/* Remove directory entry */
	if (res == FR_OK) {
		if (dclst)
			res = remove_chain(dj.fs, dclst);	/* Remove the cluster chain */
 8002224:	9806      	ldr	r0, [sp, #24]
 8002226:	4621      	mov	r1, r4
 8002228:	f7fe fd11 	bl	8000c4e <remove_chain>
		if (res == FR_OK) res = sync(dj.fs);
 800222c:	b918      	cbnz	r0, 8002236 <f_unlink+0xa8>
 800222e:	e7f5      	b.n	800221c <f_unlink+0x8e>
		res = FR_INVALID_NAME;
	if (res != FR_OK) LEAVE_FF(dj.fs, res); /* Follow failed */

	dir = dj.dir;
	if (!dir)								/* Is it the root directory? */
		LEAVE_FF(dj.fs, FR_INVALID_NAME);
 8002230:	2006      	movs	r0, #6
 8002232:	e000      	b.n	8002236 <f_unlink+0xa8>
	if (dir[DIR_Attr] & AM_RDO)				/* Is it a R/O object? */
		LEAVE_FF(dj.fs, FR_DENIED);
	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);

	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
		if (dclst < 2) LEAVE_FF(dj.fs, FR_INT_ERR);
 8002234:	2002      	movs	r0, #2
			res = remove_chain(dj.fs, dclst);	/* Remove the cluster chain */
		if (res == FR_OK) res = sync(dj.fs);
	}

	LEAVE_FF(dj.fs, res);
}
 8002236:	b018      	add	sp, #96	; 0x60
 8002238:	bd10      	pop	{r4, pc}
 800223a:	bf00      	nop
 800223c:	2000092a 	.word	0x2000092a

08002240 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const XCHAR *path		/* Pointer to the directory path */
)
{
 8002240:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002244:	b091      	sub	sp, #68	; 0x44
 8002246:	ab10      	add	r3, sp, #64	; 0x40
 8002248:	f843 0d34 	str.w	r0, [r3, #-52]!
	NAMEBUF(sfn, lfn);
	BYTE *dir, n;
	DWORD dsect, dclst, pclst, tim;


	res = chk_mounted(&path, &dj.fs, 1);
 800224c:	4618      	mov	r0, r3
 800224e:	a907      	add	r1, sp, #28
 8002250:	2201      	movs	r2, #1
 8002252:	f7ff f999 	bl	8001588 <chk_mounted>
 8002256:	4606      	mov	r6, r0
 8002258:	4605      	mov	r5, r0
	if (res != FR_OK) LEAVE_FF(dj.fs, res);
 800225a:	2800      	cmp	r0, #0
 800225c:	f040 80cc 	bne.w	80023f8 <f_mkdir+0x1b8>

	INITBUF(dj, sfn, lfn);
 8002260:	ab04      	add	r3, sp, #16
 8002262:	930d      	str	r3, [sp, #52]	; 0x34
 8002264:	4b66      	ldr	r3, [pc, #408]	; (8002400 <f_mkdir+0x1c0>)
	res = follow_path(&dj, path);			/* Follow the file path */
 8002266:	a807      	add	r0, sp, #28
 8002268:	9903      	ldr	r1, [sp, #12]


	res = chk_mounted(&path, &dj.fs, 1);
	if (res != FR_OK) LEAVE_FF(dj.fs, res);

	INITBUF(dj, sfn, lfn);
 800226a:	930e      	str	r3, [sp, #56]	; 0x38
	res = follow_path(&dj, path);			/* Follow the file path */
 800226c:	f7fe fe7e 	bl	8000f6c <follow_path>
	if (res == FR_OK) res = FR_EXIST;		/* Any file or directory is already existing */
 8002270:	4606      	mov	r6, r0
 8002272:	2800      	cmp	r0, #0
 8002274:	f000 80b0 	beq.w	80023d8 <f_mkdir+0x198>
	if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
		res = FR_INVALID_NAME;
	if (res != FR_NO_FILE)					/* Any error occurred */
 8002278:	2804      	cmp	r0, #4
 800227a:	f040 80bd 	bne.w	80023f8 <f_mkdir+0x1b8>
		LEAVE_FF(dj.fs, res);

	dclst = create_chain(dj.fs, 0);			/* Allocate a new cluster for new directory table */
 800227e:	9807      	ldr	r0, [sp, #28]
 8002280:	4629      	mov	r1, r5
 8002282:	f7fe fc94 	bl	8000bae <create_chain>
	res = FR_OK;
	if (dclst == 0) res = FR_DENIED;
 8002286:	4604      	mov	r4, r0
 8002288:	2800      	cmp	r0, #0
 800228a:	f000 80a7 	beq.w	80023dc <f_mkdir+0x19c>
	if (dclst == 1) res = FR_INT_ERR;
 800228e:	2801      	cmp	r0, #1
 8002290:	f000 80a6 	beq.w	80023e0 <f_mkdir+0x1a0>
	if (dclst == 0xFFFFFFFF) res = FR_DISK_ERR;
 8002294:	1c46      	adds	r6, r0, #1
 8002296:	f000 80a5 	beq.w	80023e4 <f_mkdir+0x1a4>
 800229a:	e0a5      	b.n	80023e8 <f_mkdir+0x1a8>
	if (res == FR_OK)
		res = move_window(dj.fs, 0);
	if (res != FR_OK) LEAVE_FF(dj.fs, res);
	dsect = clust2sect(dj.fs, dclst);
 800229c:	9f07      	ldr	r7, [sp, #28]
 800229e:	4621      	mov	r1, r4
 80022a0:	4638      	mov	r0, r7
 80022a2:	f7fe fd00 	bl	8000ca6 <clust2sect>

	dir = dj.fs->win;						/* Initialize the new directory table */
 80022a6:	f107 0530 	add.w	r5, r7, #48	; 0x30
	mem_set(dir, 0, SS(dj.fs));
 80022aa:	4631      	mov	r1, r6
 80022ac:	f44f 7200 	mov.w	r2, #512	; 0x200
	if (dclst == 1) res = FR_INT_ERR;
	if (dclst == 0xFFFFFFFF) res = FR_DISK_ERR;
	if (res == FR_OK)
		res = move_window(dj.fs, 0);
	if (res != FR_OK) LEAVE_FF(dj.fs, res);
	dsect = clust2sect(dj.fs, dclst);
 80022b0:	4683      	mov	fp, r0

	dir = dj.fs->win;						/* Initialize the new directory table */
	mem_set(dir, 0, SS(dj.fs));
 80022b2:	4628      	mov	r0, r5
 80022b4:	f7fe fa21 	bl	80006fa <mem_set>
	mem_set(dir+DIR_Name, ' ', 8+3);		/* Create "." entry */
 80022b8:	2120      	movs	r1, #32
 80022ba:	220b      	movs	r2, #11
 80022bc:	4628      	mov	r0, r5
 80022be:	f7fe fa1c 	bl	80006fa <mem_set>
	dir[DIR_Name] = '.';
 80022c2:	262e      	movs	r6, #46	; 0x2e
	dir[DIR_Attr] = AM_DIR;
 80022c4:	2210      	movs	r2, #16
 80022c6:	f887 203b 	strb.w	r2, [r7, #59]	; 0x3b
	dsect = clust2sect(dj.fs, dclst);

	dir = dj.fs->win;						/* Initialize the new directory table */
	mem_set(dir, 0, SS(dj.fs));
	mem_set(dir+DIR_Name, ' ', 8+3);		/* Create "." entry */
	dir[DIR_Name] = '.';
 80022ca:	f887 6030 	strb.w	r6, [r7, #48]	; 0x30
	dir[DIR_Attr] = AM_DIR;
	tim = get_fattime();
 80022ce:	f7fe f9eb 	bl	80006a8 <get_fattime>
	ST_DWORD(dir+DIR_WrtTime, tim);
 80022d2:	f3c0 2207 	ubfx	r2, r0, #8, #8
 80022d6:	f88d 2009 	strb.w	r2, [sp, #9]
 80022da:	f887 2047 	strb.w	r2, [r7, #71]	; 0x47
	ST_WORD(dir+DIR_FstClusLO, dclst);
 80022de:	f3c4 2207 	ubfx	r2, r4, #8, #8
 80022e2:	b2e3      	uxtb	r3, r4
 80022e4:	f88d 200a 	strb.w	r2, [sp, #10]
 80022e8:	f887 204b 	strb.w	r2, [r7, #75]	; 0x4b
	ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
 80022ec:	0c22      	lsrs	r2, r4, #16
	mem_set(dir, 0, SS(dj.fs));
	mem_set(dir+DIR_Name, ' ', 8+3);		/* Create "." entry */
	dir[DIR_Name] = '.';
	dir[DIR_Attr] = AM_DIR;
	tim = get_fattime();
	ST_DWORD(dir+DIR_WrtTime, tim);
 80022ee:	fa5f fa80 	uxtb.w	sl, r0
 80022f2:	f3c0 4907 	ubfx	r9, r0, #16, #8
 80022f6:	ea4f 6810 	mov.w	r8, r0, lsr #24
	ST_WORD(dir+DIR_FstClusLO, dclst);
 80022fa:	9300      	str	r3, [sp, #0]
 80022fc:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
	ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
 8002300:	b2d3      	uxtb	r3, r2
 8002302:	0a12      	lsrs	r2, r2, #8
 8002304:	f887 3044 	strb.w	r3, [r7, #68]	; 0x44
 8002308:	f88d 200b 	strb.w	r2, [sp, #11]
 800230c:	f887 2045 	strb.w	r2, [r7, #69]	; 0x45
	mem_cpy(dir+32, dir, 32); 			/* Create ".." entry */
 8002310:	4629      	mov	r1, r5
 8002312:	2220      	movs	r2, #32
	mem_set(dir, 0, SS(dj.fs));
	mem_set(dir+DIR_Name, ' ', 8+3);		/* Create "." entry */
	dir[DIR_Name] = '.';
	dir[DIR_Attr] = AM_DIR;
	tim = get_fattime();
	ST_DWORD(dir+DIR_WrtTime, tim);
 8002314:	f887 a046 	strb.w	sl, [r7, #70]	; 0x46
 8002318:	f887 9048 	strb.w	r9, [r7, #72]	; 0x48
 800231c:	f887 8049 	strb.w	r8, [r7, #73]	; 0x49
	ST_WORD(dir+DIR_FstClusLO, dclst);
	ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
	mem_cpy(dir+32, dir, 32); 			/* Create ".." entry */
 8002320:	f107 0050 	add.w	r0, r7, #80	; 0x50
	dir[DIR_Name] = '.';
	dir[DIR_Attr] = AM_DIR;
	tim = get_fattime();
	ST_DWORD(dir+DIR_WrtTime, tim);
	ST_WORD(dir+DIR_FstClusLO, dclst);
	ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
 8002324:	9301      	str	r3, [sp, #4]
	mem_cpy(dir+32, dir, 32); 			/* Create ".." entry */
 8002326:	f7fe f9df 	bl	80006e8 <mem_cpy>
	dir[33] = '.';
	pclst = dj.sclust;
	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
 800232a:	9a07      	ldr	r2, [sp, #28]
	tim = get_fattime();
	ST_DWORD(dir+DIR_WrtTime, tim);
	ST_WORD(dir+DIR_FstClusLO, dclst);
	ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
	mem_cpy(dir+32, dir, 32); 			/* Create ".." entry */
	dir[33] = '.';
 800232c:	f887 6051 	strb.w	r6, [r7, #81]	; 0x51
	pclst = dj.sclust;
	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
 8002330:	7811      	ldrb	r1, [r2, #0]
	ST_DWORD(dir+DIR_WrtTime, tim);
	ST_WORD(dir+DIR_FstClusLO, dclst);
	ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
	mem_cpy(dir+32, dir, 32); 			/* Create ".." entry */
	dir[33] = '.';
	pclst = dj.sclust;
 8002332:	9b09      	ldr	r3, [sp, #36]	; 0x24
	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
 8002334:	2903      	cmp	r1, #3
 8002336:	d103      	bne.n	8002340 <f_mkdir+0x100>
 8002338:	6a52      	ldr	r2, [r2, #36]	; 0x24
		pclst = 0;
 800233a:	4293      	cmp	r3, r2
 800233c:	bf08      	it	eq
 800233e:	2300      	moveq	r3, #0
	ST_WORD(dir+32+DIR_FstClusLO, pclst);
 8002340:	f887 306a 	strb.w	r3, [r7, #106]	; 0x6a
 8002344:	f3c3 2207 	ubfx	r2, r3, #8, #8
	ST_WORD(dir+32+DIR_FstClusHI, pclst >> 16);
 8002348:	0c1b      	lsrs	r3, r3, #16
 800234a:	f887 3064 	strb.w	r3, [r7, #100]	; 0x64
 800234e:	0a1b      	lsrs	r3, r3, #8
	mem_cpy(dir+32, dir, 32); 			/* Create ".." entry */
	dir[33] = '.';
	pclst = dj.sclust;
	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
		pclst = 0;
	ST_WORD(dir+32+DIR_FstClusLO, pclst);
 8002350:	f887 206b 	strb.w	r2, [r7, #107]	; 0x6b
	ST_WORD(dir+32+DIR_FstClusHI, pclst >> 16);
 8002354:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65
	if (dclst == 1) res = FR_INT_ERR;
	if (dclst == 0xFFFFFFFF) res = FR_DISK_ERR;
	if (res == FR_OK)
		res = move_window(dj.fs, 0);
	if (res != FR_OK) LEAVE_FF(dj.fs, res);
	dsect = clust2sect(dj.fs, dclst);
 8002358:	465f      	mov	r7, fp
	pclst = dj.sclust;
	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
		pclst = 0;
	ST_WORD(dir+32+DIR_FstClusLO, pclst);
	ST_WORD(dir+32+DIR_FstClusHI, pclst >> 16);
	for (n = 0; n < dj.fs->csize; n++) {	/* Write dot entries and clear left sectors */
 800235a:	e00f      	b.n	800237c <f_mkdir+0x13c>
		dj.fs->winsect = dsect++;
		dj.fs->wflag = 1;
 800235c:	2201      	movs	r2, #1
	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
		pclst = 0;
	ST_WORD(dir+32+DIR_FstClusLO, pclst);
	ST_WORD(dir+32+DIR_FstClusHI, pclst >> 16);
	for (n = 0; n < dj.fs->csize; n++) {	/* Write dot entries and clear left sectors */
		dj.fs->winsect = dsect++;
 800235e:	62c7      	str	r7, [r0, #44]	; 0x2c
		dj.fs->wflag = 1;
 8002360:	7102      	strb	r2, [r0, #4]
		res = move_window(dj.fs, 0);
 8002362:	2100      	movs	r1, #0
 8002364:	f7fe fa58 	bl	8000818 <move_window>
	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
		pclst = 0;
	ST_WORD(dir+32+DIR_FstClusLO, pclst);
	ST_WORD(dir+32+DIR_FstClusHI, pclst >> 16);
	for (n = 0; n < dj.fs->csize; n++) {	/* Write dot entries and clear left sectors */
		dj.fs->winsect = dsect++;
 8002368:	3701      	adds	r7, #1
		dj.fs->wflag = 1;
		res = move_window(dj.fs, 0);
		if (res) LEAVE_FF(dj.fs, res);
 800236a:	4606      	mov	r6, r0
 800236c:	2800      	cmp	r0, #0
 800236e:	d143      	bne.n	80023f8 <f_mkdir+0x1b8>
		mem_set(dir, 0, SS(dj.fs));
 8002370:	4628      	mov	r0, r5
 8002372:	4631      	mov	r1, r6
 8002374:	f44f 7200 	mov.w	r2, #512	; 0x200
 8002378:	f7fe f9bf 	bl	80006fa <mem_set>
	pclst = dj.sclust;
	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
		pclst = 0;
	ST_WORD(dir+32+DIR_FstClusLO, pclst);
	ST_WORD(dir+32+DIR_FstClusHI, pclst >> 16);
	for (n = 0; n < dj.fs->csize; n++) {	/* Write dot entries and clear left sectors */
 800237c:	9807      	ldr	r0, [sp, #28]

/*-----------------------------------------------------------------------*/
/* Create a Directory                                                    */
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
 800237e:	ebcb 0307 	rsb	r3, fp, r7
	pclst = dj.sclust;
	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
		pclst = 0;
	ST_WORD(dir+32+DIR_FstClusLO, pclst);
	ST_WORD(dir+32+DIR_FstClusHI, pclst >> 16);
	for (n = 0; n < dj.fs->csize; n++) {	/* Write dot entries and clear left sectors */
 8002382:	7882      	ldrb	r2, [r0, #2]
 8002384:	b2db      	uxtb	r3, r3
 8002386:	429a      	cmp	r2, r3
 8002388:	d8e8      	bhi.n	800235c <f_mkdir+0x11c>
		res = move_window(dj.fs, 0);
		if (res) LEAVE_FF(dj.fs, res);
		mem_set(dir, 0, SS(dj.fs));
	}

	res = dir_register(&dj);
 800238a:	a807      	add	r0, sp, #28
 800238c:	f7ff f809 	bl	80013a2 <dir_register>
	if (res != FR_OK) {
 8002390:	4606      	mov	r6, r0
 8002392:	b120      	cbz	r0, 800239e <f_mkdir+0x15e>
		remove_chain(dj.fs, dclst);
 8002394:	9807      	ldr	r0, [sp, #28]
 8002396:	4621      	mov	r1, r4
 8002398:	f7fe fc59 	bl	8000c4e <remove_chain>
 800239c:	e02c      	b.n	80023f8 <f_mkdir+0x1b8>
	} else {
		dir = dj.dir;
 800239e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
		dir[DIR_Attr] = AM_DIR;					/* Attribute */
 80023a0:	2210      	movs	r2, #16
 80023a2:	72da      	strb	r2, [r3, #11]
		ST_DWORD(dir+DIR_WrtTime, tim);			/* Create time */
 80023a4:	f89d 2009 	ldrb.w	r2, [sp, #9]
		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
		ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
		dj.fs->wflag = 1;
 80023a8:	9807      	ldr	r0, [sp, #28]
	if (res != FR_OK) {
		remove_chain(dj.fs, dclst);
	} else {
		dir = dj.dir;
		dir[DIR_Attr] = AM_DIR;					/* Attribute */
		ST_DWORD(dir+DIR_WrtTime, tim);			/* Create time */
 80023aa:	75da      	strb	r2, [r3, #23]
		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
 80023ac:	9a00      	ldr	r2, [sp, #0]
	if (res != FR_OK) {
		remove_chain(dj.fs, dclst);
	} else {
		dir = dj.dir;
		dir[DIR_Attr] = AM_DIR;					/* Attribute */
		ST_DWORD(dir+DIR_WrtTime, tim);			/* Create time */
 80023ae:	f883 a016 	strb.w	sl, [r3, #22]
		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
 80023b2:	769a      	strb	r2, [r3, #26]
 80023b4:	f89d 200a 	ldrb.w	r2, [sp, #10]
	if (res != FR_OK) {
		remove_chain(dj.fs, dclst);
	} else {
		dir = dj.dir;
		dir[DIR_Attr] = AM_DIR;					/* Attribute */
		ST_DWORD(dir+DIR_WrtTime, tim);			/* Create time */
 80023b8:	f883 9018 	strb.w	r9, [r3, #24]
		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
 80023bc:	76da      	strb	r2, [r3, #27]
		ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
 80023be:	9a01      	ldr	r2, [sp, #4]
	if (res != FR_OK) {
		remove_chain(dj.fs, dclst);
	} else {
		dir = dj.dir;
		dir[DIR_Attr] = AM_DIR;					/* Attribute */
		ST_DWORD(dir+DIR_WrtTime, tim);			/* Create time */
 80023c0:	f883 8019 	strb.w	r8, [r3, #25]
		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
		ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
 80023c4:	751a      	strb	r2, [r3, #20]
 80023c6:	f89d 200b 	ldrb.w	r2, [sp, #11]
 80023ca:	755a      	strb	r2, [r3, #21]
		dj.fs->wflag = 1;
 80023cc:	2301      	movs	r3, #1
 80023ce:	7103      	strb	r3, [r0, #4]
		res = sync(dj.fs);
 80023d0:	f7fe fa5e 	bl	8000890 <sync>
 80023d4:	4606      	mov	r6, r0
 80023d6:	e00f      	b.n	80023f8 <f_mkdir+0x1b8>
	res = chk_mounted(&path, &dj.fs, 1);
	if (res != FR_OK) LEAVE_FF(dj.fs, res);

	INITBUF(dj, sfn, lfn);
	res = follow_path(&dj, path);			/* Follow the file path */
	if (res == FR_OK) res = FR_EXIST;		/* Any file or directory is already existing */
 80023d8:	2608      	movs	r6, #8
 80023da:	e00d      	b.n	80023f8 <f_mkdir+0x1b8>
	if (res != FR_NO_FILE)					/* Any error occurred */
		LEAVE_FF(dj.fs, res);

	dclst = create_chain(dj.fs, 0);			/* Allocate a new cluster for new directory table */
	res = FR_OK;
	if (dclst == 0) res = FR_DENIED;
 80023dc:	2607      	movs	r6, #7
 80023de:	e00b      	b.n	80023f8 <f_mkdir+0x1b8>
	if (dclst == 1) res = FR_INT_ERR;
 80023e0:	2602      	movs	r6, #2
 80023e2:	e009      	b.n	80023f8 <f_mkdir+0x1b8>
	if (dclst == 0xFFFFFFFF) res = FR_DISK_ERR;
 80023e4:	2601      	movs	r6, #1
 80023e6:	e007      	b.n	80023f8 <f_mkdir+0x1b8>
	if (res == FR_OK)
		res = move_window(dj.fs, 0);
 80023e8:	9807      	ldr	r0, [sp, #28]
 80023ea:	4629      	mov	r1, r5
 80023ec:	f7fe fa14 	bl	8000818 <move_window>
	if (res != FR_OK) LEAVE_FF(dj.fs, res);
 80023f0:	4606      	mov	r6, r0
 80023f2:	2800      	cmp	r0, #0
 80023f4:	f43f af52 	beq.w	800229c <f_mkdir+0x5c>
		dj.fs->wflag = 1;
		res = sync(dj.fs);
	}

	LEAVE_FF(dj.fs, res);
}
 80023f8:	4630      	mov	r0, r6
 80023fa:	b011      	add	sp, #68	; 0x44
 80023fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002400:	2000092a 	.word	0x2000092a

08002404 <f_chmod>:
FRESULT f_chmod (
	const XCHAR *path,	/* Pointer to the file path */
	BYTE value,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
 8002404:	b530      	push	{r4, r5, lr}
 8002406:	b08f      	sub	sp, #60	; 0x3c
 8002408:	ab0e      	add	r3, sp, #56	; 0x38
 800240a:	f843 0d34 	str.w	r0, [r3, #-52]!
 800240e:	460c      	mov	r4, r1
 8002410:	4615      	mov	r5, r2
	DIR dj;
	NAMEBUF(sfn, lfn);
	BYTE *dir;


	res = chk_mounted(&path, &dj.fs, 1);
 8002412:	4618      	mov	r0, r3
 8002414:	a905      	add	r1, sp, #20
 8002416:	2201      	movs	r2, #1
 8002418:	f7ff f8b6 	bl	8001588 <chk_mounted>
	if (res == FR_OK) {
 800241c:	b9d0      	cbnz	r0, 8002454 <f_chmod+0x50>
		INITBUF(dj, sfn, lfn);
 800241e:	ab02      	add	r3, sp, #8
 8002420:	930b      	str	r3, [sp, #44]	; 0x2c
 8002422:	4b0d      	ldr	r3, [pc, #52]	; (8002458 <f_chmod+0x54>)
		res = follow_path(&dj, path);		/* Follow the file path */
 8002424:	a805      	add	r0, sp, #20
 8002426:	9901      	ldr	r1, [sp, #4]
	BYTE *dir;


	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INITBUF(dj, sfn, lfn);
 8002428:	930c      	str	r3, [sp, #48]	; 0x30
		res = follow_path(&dj, path);		/* Follow the file path */
 800242a:	f7fe fd9f 	bl	8000f6c <follow_path>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
 800242e:	b988      	cbnz	r0, 8002454 <f_chmod+0x50>
			dir = dj.dir;
 8002430:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			if (!dir) {						/* Is it a root directory? */
 8002432:	b173      	cbz	r3, 8002452 <f_chmod+0x4e>
				res = FR_INVALID_NAME;
			} else {						/* File or sub directory */
				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
 8002434:	7ad9      	ldrb	r1, [r3, #11]
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
			} else {						/* File or sub directory */
				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
 8002436:	f005 0227 	and.w	r2, r5, #39	; 0x27
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
 800243a:	ea21 0102 	bic.w	r1, r1, r2
 800243e:	4014      	ands	r4, r2
 8002440:	ea41 0204 	orr.w	r2, r1, r4
				dj.fs->wflag = 1;
 8002444:	9805      	ldr	r0, [sp, #20]
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
			} else {						/* File or sub directory */
				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
 8002446:	72da      	strb	r2, [r3, #11]
				dj.fs->wflag = 1;
 8002448:	2301      	movs	r3, #1
 800244a:	7103      	strb	r3, [r0, #4]
				res = sync(dj.fs);
 800244c:	f7fe fa20 	bl	8000890 <sync>
 8002450:	e000      	b.n	8002454 <f_chmod+0x50>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
 8002452:	2006      	movs	r0, #6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
 8002454:	b00f      	add	sp, #60	; 0x3c
 8002456:	bd30      	pop	{r4, r5, pc}
 8002458:	2000092a 	.word	0x2000092a

0800245c <f_utime>:

FRESULT f_utime (
	const XCHAR *path,	/* Pointer to the file/directory name */
	const FILINFO *fno	/* Pointer to the time-stamp to be set */
)
{
 800245c:	b510      	push	{r4, lr}
 800245e:	b08e      	sub	sp, #56	; 0x38
 8002460:	ab0e      	add	r3, sp, #56	; 0x38
 8002462:	f843 0d34 	str.w	r0, [r3, #-52]!
 8002466:	460c      	mov	r4, r1
	DIR dj;
	NAMEBUF(sfn, lfn);
	BYTE *dir;


	res = chk_mounted(&path, &dj.fs, 1);
 8002468:	4618      	mov	r0, r3
 800246a:	a905      	add	r1, sp, #20
 800246c:	2201      	movs	r2, #1
 800246e:	f7ff f88b 	bl	8001588 <chk_mounted>
	if (res == FR_OK) {
 8002472:	b9d8      	cbnz	r0, 80024ac <f_utime+0x50>
		INITBUF(dj, sfn, lfn);
 8002474:	ab02      	add	r3, sp, #8
 8002476:	930b      	str	r3, [sp, #44]	; 0x2c
 8002478:	4b0d      	ldr	r3, [pc, #52]	; (80024b0 <f_utime+0x54>)
		res = follow_path(&dj, path);	/* Follow the file path */
 800247a:	a805      	add	r0, sp, #20
 800247c:	9901      	ldr	r1, [sp, #4]
	BYTE *dir;


	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INITBUF(dj, sfn, lfn);
 800247e:	930c      	str	r3, [sp, #48]	; 0x30
		res = follow_path(&dj, path);	/* Follow the file path */
 8002480:	f7fe fd74 	bl	8000f6c <follow_path>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
 8002484:	b990      	cbnz	r0, 80024ac <f_utime+0x50>
			dir = dj.dir;
 8002486:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			if (!dir) {				/* Root directory */
 8002488:	b17b      	cbz	r3, 80024aa <f_utime+0x4e>
				res = FR_INVALID_NAME;
			} else {				/* File or sub-directory */
				ST_WORD(dir+DIR_WrtTime, fno->ftime);
 800248a:	88e2      	ldrh	r2, [r4, #6]
				ST_WORD(dir+DIR_WrtDate, fno->fdate);
				dj.fs->wflag = 1;
 800248c:	9805      	ldr	r0, [sp, #20]
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {				/* Root directory */
				res = FR_INVALID_NAME;
			} else {				/* File or sub-directory */
				ST_WORD(dir+DIR_WrtTime, fno->ftime);
 800248e:	759a      	strb	r2, [r3, #22]
 8002490:	88e2      	ldrh	r2, [r4, #6]
 8002492:	0a12      	lsrs	r2, r2, #8
 8002494:	75da      	strb	r2, [r3, #23]
				ST_WORD(dir+DIR_WrtDate, fno->fdate);
 8002496:	88a2      	ldrh	r2, [r4, #4]
 8002498:	761a      	strb	r2, [r3, #24]
 800249a:	88a2      	ldrh	r2, [r4, #4]
 800249c:	0a12      	lsrs	r2, r2, #8
 800249e:	765a      	strb	r2, [r3, #25]
				dj.fs->wflag = 1;
 80024a0:	2301      	movs	r3, #1
 80024a2:	7103      	strb	r3, [r0, #4]
				res = sync(dj.fs);
 80024a4:	f7fe f9f4 	bl	8000890 <sync>
 80024a8:	e000      	b.n	80024ac <f_utime+0x50>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {				/* Root directory */
				res = FR_INVALID_NAME;
 80024aa:	2006      	movs	r0, #6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
 80024ac:	b00e      	add	sp, #56	; 0x38
 80024ae:	bd10      	pop	{r4, pc}
 80024b0:	2000092a 	.word	0x2000092a

080024b4 <f_rename>:

FRESULT f_rename (
	const XCHAR *path_old,	/* Pointer to the old name */
	const XCHAR *path_new	/* Pointer to the new name */
)
{
 80024b4:	b530      	push	{r4, r5, lr}
 80024b6:	b09f      	sub	sp, #124	; 0x7c
	NAMEBUF(sfn, lfn);
	BYTE buf[21], *dir;
	DWORD dw;


	INITBUF(dj_old, sfn, lfn);
 80024b8:	ab03      	add	r3, sp, #12
 80024ba:	9312      	str	r3, [sp, #72]	; 0x48
 80024bc:	4b41      	ldr	r3, [pc, #260]	; (80025c4 <f_rename+0x110>)

FRESULT f_rename (
	const XCHAR *path_old,	/* Pointer to the old name */
	const XCHAR *path_new	/* Pointer to the new name */
)
{
 80024be:	9001      	str	r0, [sp, #4]
 80024c0:	460c      	mov	r4, r1
	BYTE buf[21], *dir;
	DWORD dw;


	INITBUF(dj_old, sfn, lfn);
	res = chk_mounted(&path_old, &dj_old.fs, 1);
 80024c2:	a801      	add	r0, sp, #4
 80024c4:	a90c      	add	r1, sp, #48	; 0x30
 80024c6:	2201      	movs	r2, #1
	NAMEBUF(sfn, lfn);
	BYTE buf[21], *dir;
	DWORD dw;


	INITBUF(dj_old, sfn, lfn);
 80024c8:	9313      	str	r3, [sp, #76]	; 0x4c
	res = chk_mounted(&path_old, &dj_old.fs, 1);
 80024ca:	f7ff f85d 	bl	8001588 <chk_mounted>
	if (res == FR_OK) {
 80024ce:	2800      	cmp	r0, #0
 80024d0:	d176      	bne.n	80025c0 <f_rename+0x10c>
		dj_new.fs = dj_old.fs;
 80024d2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
		res = follow_path(&dj_old, path_old);	/* Check old object */
 80024d4:	a80c      	add	r0, sp, #48	; 0x30
 80024d6:	9901      	ldr	r1, [sp, #4]


	INITBUF(dj_old, sfn, lfn);
	res = chk_mounted(&path_old, &dj_old.fs, 1);
	if (res == FR_OK) {
		dj_new.fs = dj_old.fs;
 80024d8:	9315      	str	r3, [sp, #84]	; 0x54
		res = follow_path(&dj_old, path_old);	/* Check old object */
 80024da:	f7fe fd47 	bl	8000f6c <follow_path>
		if (_FS_RPATH && res == FR_OK && (dj_old.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
	}
	if (res != FR_OK) LEAVE_FF(dj_old.fs, res);	/* The old object is not found */
 80024de:	2800      	cmp	r0, #0
 80024e0:	d16e      	bne.n	80025c0 <f_rename+0x10c>

	if (!dj_old.dir) LEAVE_FF(dj_old.fs, FR_NO_FILE);	/* Is root dir? */
 80024e2:	9911      	ldr	r1, [sp, #68]	; 0x44
 80024e4:	2900      	cmp	r1, #0
 80024e6:	d060      	beq.n	80025aa <f_rename+0xf6>
	mem_cpy(buf, dj_old.dir+DIR_Attr, 21);		/* Save the object information */
 80024e8:	a806      	add	r0, sp, #24
 80024ea:	310b      	adds	r1, #11
 80024ec:	2215      	movs	r2, #21
 80024ee:	f7fe f8fb 	bl	80006e8 <mem_cpy>

	mem_cpy(&dj_new, &dj_old, sizeof(DIR));
 80024f2:	a815      	add	r0, sp, #84	; 0x54
 80024f4:	a90c      	add	r1, sp, #48	; 0x30
 80024f6:	2224      	movs	r2, #36	; 0x24
 80024f8:	f7fe f8f6 	bl	80006e8 <mem_cpy>
	res = follow_path(&dj_new, path_new);		/* Check new object */
 80024fc:	a815      	add	r0, sp, #84	; 0x54
 80024fe:	4621      	mov	r1, r4
 8002500:	f7fe fd34 	bl	8000f6c <follow_path>
	if (res == FR_OK) res = FR_EXIST;			/* The new object name is already existing */
 8002504:	2800      	cmp	r0, #0
 8002506:	d052      	beq.n	80025ae <f_rename+0xfa>
	if (res == FR_NO_FILE) { 					/* Is it a valid path and no name collision? */
 8002508:	2804      	cmp	r0, #4
 800250a:	d159      	bne.n	80025c0 <f_rename+0x10c>
		res = dir_register(&dj_new);			/* Register the new object */
 800250c:	a815      	add	r0, sp, #84	; 0x54
 800250e:	f7fe ff48 	bl	80013a2 <dir_register>
		if (res == FR_OK) {
 8002512:	2800      	cmp	r0, #0
 8002514:	d154      	bne.n	80025c0 <f_rename+0x10c>
			dir = dj_new.dir;					/* Copy object information into new entry */
 8002516:	9c1a      	ldr	r4, [sp, #104]	; 0x68
			mem_cpy(dir+13, buf+2, 19);
 8002518:	2213      	movs	r2, #19
 800251a:	f104 000d 	add.w	r0, r4, #13
 800251e:	f10d 011a 	add.w	r1, sp, #26
 8002522:	f7fe f8e1 	bl	80006e8 <mem_cpy>
			dir[DIR_Attr] = buf[0] | AM_ARC;
 8002526:	f89d 3018 	ldrb.w	r3, [sp, #24]
			dj_old.fs->wflag = 1;
 800252a:	2201      	movs	r2, #1
	if (res == FR_NO_FILE) { 					/* Is it a valid path and no name collision? */
		res = dir_register(&dj_new);			/* Register the new object */
		if (res == FR_OK) {
			dir = dj_new.dir;					/* Copy object information into new entry */
			mem_cpy(dir+13, buf+2, 19);
			dir[DIR_Attr] = buf[0] | AM_ARC;
 800252c:	f043 0320 	orr.w	r3, r3, #32
 8002530:	72e3      	strb	r3, [r4, #11]
			dj_old.fs->wflag = 1;
 8002532:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8002534:	711a      	strb	r2, [r3, #4]
			if (dir[DIR_Attr] & AM_DIR) {		/* Update .. entry in the directory if needed */
 8002536:	7ae3      	ldrb	r3, [r4, #11]
 8002538:	f003 0310 	and.w	r3, r3, #16
 800253c:	b2db      	uxtb	r3, r3
 800253e:	2b00      	cmp	r3, #0
 8002540:	d039      	beq.n	80025b6 <f_rename+0x102>
				dw = clust2sect(dj_new.fs, (DWORD)LD_WORD(dir+DIR_FstClusHI) | LD_WORD(dir+DIR_FstClusLO));
 8002542:	7ee3      	ldrb	r3, [r4, #27]
 8002544:	7d61      	ldrb	r1, [r4, #21]
 8002546:	7ea2      	ldrb	r2, [r4, #26]
 8002548:	4319      	orrs	r1, r3
 800254a:	9d15      	ldr	r5, [sp, #84]	; 0x54
 800254c:	7d23      	ldrb	r3, [r4, #20]
 800254e:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
 8002552:	4319      	orrs	r1, r3
 8002554:	4628      	mov	r0, r5
 8002556:	f7fe fba6 	bl	8000ca6 <clust2sect>
				if (!dw) {
 800255a:	4601      	mov	r1, r0
 800255c:	b348      	cbz	r0, 80025b2 <f_rename+0xfe>
					res = FR_INT_ERR;
				} else {
					res = move_window(dj_new.fs, dw);
 800255e:	4628      	mov	r0, r5
 8002560:	f7fe f95a 	bl	8000818 <move_window>
					dir = dj_new.fs->win+32;
 8002564:	9b15      	ldr	r3, [sp, #84]	; 0x54
					if (res == FR_OK && dir[1] == '.') {
 8002566:	bb58      	cbnz	r0, 80025c0 <f_rename+0x10c>
 8002568:	f893 2051 	ldrb.w	r2, [r3, #81]	; 0x51
 800256c:	2a2e      	cmp	r2, #46	; 0x2e
 800256e:	d122      	bne.n	80025b6 <f_rename+0x102>
						dw = (dj_new.fs->fs_type == FS_FAT32 && dj_new.sclust == dj_new.fs->dirbase) ? 0 : dj_new.sclust;
 8002570:	781a      	ldrb	r2, [r3, #0]
 8002572:	2a03      	cmp	r2, #3
 8002574:	d103      	bne.n	800257e <f_rename+0xca>
 8002576:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002578:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800257a:	4291      	cmp	r1, r2
 800257c:	d001      	beq.n	8002582 <f_rename+0xce>
 800257e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8002580:	e000      	b.n	8002584 <f_rename+0xd0>
 8002582:	2200      	movs	r2, #0
						ST_WORD(dir+DIR_FstClusLO, dw);
 8002584:	f3c2 2107 	ubfx	r1, r2, #8, #8
 8002588:	f883 206a 	strb.w	r2, [r3, #106]	; 0x6a
						ST_WORD(dir+DIR_FstClusHI, dw >> 16);
 800258c:	0c12      	lsrs	r2, r2, #16
 800258e:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
 8002592:	0a12      	lsrs	r2, r2, #8
 8002594:	f883 2065 	strb.w	r2, [r3, #101]	; 0x65
						dj_new.fs->wflag = 1;
 8002598:	2201      	movs	r2, #1
				} else {
					res = move_window(dj_new.fs, dw);
					dir = dj_new.fs->win+32;
					if (res == FR_OK && dir[1] == '.') {
						dw = (dj_new.fs->fs_type == FS_FAT32 && dj_new.sclust == dj_new.fs->dirbase) ? 0 : dj_new.sclust;
						ST_WORD(dir+DIR_FstClusLO, dw);
 800259a:	f883 106b 	strb.w	r1, [r3, #107]	; 0x6b
						ST_WORD(dir+DIR_FstClusHI, dw >> 16);
						dj_new.fs->wflag = 1;
 800259e:	711a      	strb	r2, [r3, #4]
 80025a0:	e009      	b.n	80025b6 <f_rename+0x102>
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj_old);			/* Remove old entry */
				if (res == FR_OK)
					res = sync(dj_old.fs);
 80025a2:	980c      	ldr	r0, [sp, #48]	; 0x30
 80025a4:	f7fe f974 	bl	8000890 <sync>
 80025a8:	e00a      	b.n	80025c0 <f_rename+0x10c>
		if (_FS_RPATH && res == FR_OK && (dj_old.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
	}
	if (res != FR_OK) LEAVE_FF(dj_old.fs, res);	/* The old object is not found */

	if (!dj_old.dir) LEAVE_FF(dj_old.fs, FR_NO_FILE);	/* Is root dir? */
 80025aa:	2004      	movs	r0, #4
 80025ac:	e008      	b.n	80025c0 <f_rename+0x10c>
	mem_cpy(buf, dj_old.dir+DIR_Attr, 21);		/* Save the object information */

	mem_cpy(&dj_new, &dj_old, sizeof(DIR));
	res = follow_path(&dj_new, path_new);		/* Check new object */
	if (res == FR_OK) res = FR_EXIST;			/* The new object name is already existing */
 80025ae:	2008      	movs	r0, #8
 80025b0:	e006      	b.n	80025c0 <f_rename+0x10c>
			dir[DIR_Attr] = buf[0] | AM_ARC;
			dj_old.fs->wflag = 1;
			if (dir[DIR_Attr] & AM_DIR) {		/* Update .. entry in the directory if needed */
				dw = clust2sect(dj_new.fs, (DWORD)LD_WORD(dir+DIR_FstClusHI) | LD_WORD(dir+DIR_FstClusLO));
				if (!dw) {
					res = FR_INT_ERR;
 80025b2:	2002      	movs	r0, #2
 80025b4:	e004      	b.n	80025c0 <f_rename+0x10c>
						dj_new.fs->wflag = 1;
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj_old);			/* Remove old entry */
 80025b6:	a80c      	add	r0, sp, #48	; 0x30
 80025b8:	f7fe fe0c 	bl	80011d4 <dir_remove>
				if (res == FR_OK)
 80025bc:	2800      	cmp	r0, #0
 80025be:	d0f0      	beq.n	80025a2 <f_rename+0xee>
			}
		}
	}

	LEAVE_FF(dj_old.fs, res);
}
 80025c0:	b01f      	add	sp, #124	; 0x7c
 80025c2:	bd30      	pop	{r4, r5, pc}
 80025c4:	2000092a 	.word	0x2000092a

080025c8 <f_mkfs>:
FRESULT f_mkfs (
	BYTE drv,			/* Logical drive number */
	BYTE partition,		/* Partitioning rule 0:FDISK, 1:SFD */
	WORD allocsize		/* Allocation unit size [bytes] */
)
{
 80025c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80025cc:	460d      	mov	r5, r1
 80025ce:	b087      	sub	sp, #28
 80025d0:	4614      	mov	r4, r2
	FATFS *fs;
	DSTATUS stat;


	/* Check validity of the parameters */
	if (drv >= _DRIVES) return FR_INVALID_DRIVE;
 80025d2:	2800      	cmp	r0, #0
 80025d4:	f040 828f 	bne.w	8002af6 <f_mkfs+0x52e>
	if (partition >= 2) return FR_MKFS_ABORTED;
 80025d8:	2901      	cmp	r1, #1
 80025da:	d901      	bls.n	80025e0 <f_mkfs+0x18>
 80025dc:	200e      	movs	r0, #14
 80025de:	e2b0      	b.n	8002b42 <f_mkfs+0x57a>

	/* Check mounted drive and clear work area */
	fs = FatFs[drv];
 80025e0:	4aba      	ldr	r2, [pc, #744]	; (80028cc <f_mkfs+0x304>)
 80025e2:	6816      	ldr	r6, [r2, #0]
	if (!fs) return FR_NOT_ENABLED;
 80025e4:	2e00      	cmp	r6, #0
 80025e6:	f000 8288 	beq.w	8002afa <f_mkfs+0x532>
	fs->fs_type = 0;
 80025ea:	7030      	strb	r0, [r6, #0]
	drv = LD2PD(drv);

	/* Get disk statics */
	stat = disk_initialize(drv);
 80025ec:	f000 fd1d 	bl	800302a <disk_initialize>
	if (stat & STA_NOINIT) return FR_NOT_READY;
 80025f0:	07c3      	lsls	r3, r0, #31
 80025f2:	f100 8284 	bmi.w	8002afe <f_mkfs+0x536>
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
 80025f6:	f000 0004 	and.w	r0, r0, #4
 80025fa:	b2c0      	uxtb	r0, r0
 80025fc:	2800      	cmp	r0, #0
 80025fe:	f040 8280 	bne.w	8002b02 <f_mkfs+0x53a>
#if _MAX_SS != 512						/* Get disk sector size */
	if (disk_ioctl(drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) > _MAX_SS)
		return FR_MKFS_ABORTED;
#endif
	if (disk_ioctl(drv, GET_SECTOR_COUNT, &n_part) != RES_OK || n_part < MIN_SECTOR)
 8002602:	2101      	movs	r1, #1
 8002604:	aa04      	add	r2, sp, #16
 8002606:	f000 fe65 	bl	80032d4 <disk_ioctl>
 800260a:	2800      	cmp	r0, #0
 800260c:	d1e6      	bne.n	80025dc <f_mkfs+0x14>
 800260e:	9b04      	ldr	r3, [sp, #16]
 8002610:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8002614:	d3e2      	bcc.n	80025dc <f_mkfs+0x14>
		return FR_MKFS_ABORTED;
	if (n_part > MAX_SECTOR) n_part = MAX_SECTOR;
 8002616:	f1b3 6ffa 	cmp.w	r3, #131072000	; 0x7d00000
 800261a:	bf84      	itt	hi
 800261c:	f04f 63fa 	movhi.w	r3, #131072000	; 0x7d00000
 8002620:	9304      	strhi	r3, [sp, #16]
	b_part = (!partition) ? 63 : 0;		/* Boot sector */
	n_part -= b_part;
 8002622:	9b04      	ldr	r3, [sp, #16]
		return FR_MKFS_ABORTED;
#endif
	if (disk_ioctl(drv, GET_SECTOR_COUNT, &n_part) != RES_OK || n_part < MIN_SECTOR)
		return FR_MKFS_ABORTED;
	if (n_part > MAX_SECTOR) n_part = MAX_SECTOR;
	b_part = (!partition) ? 63 : 0;		/* Boot sector */
 8002624:	2d00      	cmp	r5, #0
 8002626:	bf0c      	ite	eq
 8002628:	213f      	moveq	r1, #63	; 0x3f
 800262a:	2100      	movne	r1, #0
	n_part -= b_part;
 800262c:	1a5b      	subs	r3, r3, r1
		return FR_MKFS_ABORTED;
#endif
	if (disk_ioctl(drv, GET_SECTOR_COUNT, &n_part) != RES_OK || n_part < MIN_SECTOR)
		return FR_MKFS_ABORTED;
	if (n_part > MAX_SECTOR) n_part = MAX_SECTOR;
	b_part = (!partition) ? 63 : 0;		/* Boot sector */
 800262e:	9101      	str	r1, [sp, #4]
	n_part -= b_part;
 8002630:	9304      	str	r3, [sp, #16]
 8002632:	f04f 0a07 	mov.w	sl, #7
	for (d = 512; d <= 32768U && d != allocsize; d <<= 1) ;	/* Check validity of the allocation unit size */
 8002636:	f44f 7200 	mov.w	r2, #512	; 0x200
 800263a:	e006      	b.n	800264a <f_mkfs+0x82>
 800263c:	0052      	lsls	r2, r2, #1
 800263e:	f1ba 0a01 	subs.w	sl, sl, #1
 8002642:	d102      	bne.n	800264a <f_mkfs+0x82>
	if (d != allocsize) allocsize = 0;
 8002644:	42a2      	cmp	r2, r4
 8002646:	d104      	bne.n	8002652 <f_mkfs+0x8a>
 8002648:	e001      	b.n	800264e <f_mkfs+0x86>
	if (disk_ioctl(drv, GET_SECTOR_COUNT, &n_part) != RES_OK || n_part < MIN_SECTOR)
		return FR_MKFS_ABORTED;
	if (n_part > MAX_SECTOR) n_part = MAX_SECTOR;
	b_part = (!partition) ? 63 : 0;		/* Boot sector */
	n_part -= b_part;
	for (d = 512; d <= 32768U && d != allocsize; d <<= 1) ;	/* Check validity of the allocation unit size */
 800264a:	42a2      	cmp	r2, r4
 800264c:	d1f6      	bne.n	800263c <f_mkfs+0x74>
	if (d != allocsize) allocsize = 0;
	if (!allocsize) {					/* Auto selection of cluster size */
 800264e:	b984      	cbnz	r4, 8002672 <f_mkfs+0xaa>
 8002650:	e003      	b.n	800265a <f_mkfs+0x92>
		return FR_MKFS_ABORTED;
	if (n_part > MAX_SECTOR) n_part = MAX_SECTOR;
	b_part = (!partition) ? 63 : 0;		/* Boot sector */
	n_part -= b_part;
	for (d = 512; d <= 32768U && d != allocsize; d <<= 1) ;	/* Check validity of the allocation unit size */
	if (d != allocsize) allocsize = 0;
 8002652:	4654      	mov	r4, sl
 8002654:	e001      	b.n	800265a <f_mkfs+0x92>
	if (!allocsize) {					/* Auto selection of cluster size */
		d = n_part;
		for (as = SS(fs); as > 512U; as >>= 1) d >>= 1;
		for (n = 0; d < sstbl[n]; n++) ;
 8002656:	4604      	mov	r4, r0
 8002658:	e000      	b.n	800265c <f_mkfs+0x94>
#define N_FATS		1			/* 1 or 2 */
#define MAX_SECTOR	131072000UL	/* Maximum partition size */
#define MIN_SECTOR	2000UL		/* Minimum partition size */


FRESULT f_mkfs (
 800265a:	499d      	ldr	r1, [pc, #628]	; (80028d0 <f_mkfs+0x308>)
	for (d = 512; d <= 32768U && d != allocsize; d <<= 1) ;	/* Check validity of the allocation unit size */
	if (d != allocsize) allocsize = 0;
	if (!allocsize) {					/* Auto selection of cluster size */
		d = n_part;
		for (as = SS(fs); as > 512U; as >>= 1) d >>= 1;
		for (n = 0; d < sstbl[n]; n++) ;
 800265c:	f851 2024 	ldr.w	r2, [r1, r4, lsl #2]
#define N_FATS		1			/* 1 or 2 */
#define MAX_SECTOR	131072000UL	/* Maximum partition size */
#define MIN_SECTOR	2000UL		/* Minimum partition size */


FRESULT f_mkfs (
 8002660:	1c60      	adds	r0, r4, #1
	for (d = 512; d <= 32768U && d != allocsize; d <<= 1) ;	/* Check validity of the allocation unit size */
	if (d != allocsize) allocsize = 0;
	if (!allocsize) {					/* Auto selection of cluster size */
		d = n_part;
		for (as = SS(fs); as > 512U; as >>= 1) d >>= 1;
		for (n = 0; d < sstbl[n]; n++) ;
 8002662:	4293      	cmp	r3, r2
 8002664:	d3f7      	bcc.n	8002656 <f_mkfs+0x8e>
		allocsize = cstbl[n];
 8002666:	4a9b      	ldr	r2, [pc, #620]	; (80028d4 <f_mkfs+0x30c>)
 8002668:	9405      	str	r4, [sp, #20]
 800266a:	eb02 0444 	add.w	r4, r2, r4, lsl #1
 800266e:	f8b4 40bc 	ldrh.w	r4, [r4, #188]	; 0xbc
	}
	if (allocsize < SS(fs)) allocsize = SS(fs);
 8002672:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
 8002676:	bf38      	it	cc
 8002678:	f44f 7400 	movcc.w	r4, #512	; 0x200

	allocsize /= SS(fs);		/* Number of sectors per cluster */
 800267c:	f3c4 2a4f 	ubfx	sl, r4, #9, #16

	/* Pre-compute number of clusters and FAT type */
	n_clst = n_part / allocsize;
 8002680:	fbb3 f3fa 	udiv	r3, r3, sl
	fmt = FS_FAT12;
	if (n_clst >= 0xFF5) fmt = FS_FAT16;
 8002684:	f640 72f4 	movw	r2, #4084	; 0xff4
 8002688:	4293      	cmp	r3, r2
 800268a:	f240 8248 	bls.w	8002b1e <f_mkfs+0x556>
	if (n_clst >= 0xFFF5) fmt = FS_FAT32;
 800268e:	f502 4270 	add.w	r2, r2, #61440	; 0xf000
 8002692:	4293      	cmp	r3, r2
 8002694:	f240 8237 	bls.w	8002b06 <f_mkfs+0x53e>
		n_fat = ((n_clst * 2) + 4 + SS(fs) - 1) / SS(fs);
		n_rsv = 1 + partition;
		n_dir = N_ROOTDIR * 32 / SS(fs);
		break;
	default:
		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
 8002698:	f103 0b82 	add.w	fp, r3, #130	; 0x82
 800269c:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 80026a0:	f10b 3bff 	add.w	fp, fp, #4294967295
 80026a4:	ea4f 2b5b 	mov.w	fp, fp, lsr #9
		n_rsv = 33 - partition;
 80026a8:	f1c5 0921 	rsb	r9, r5, #33	; 0x21
 80026ac:	2403      	movs	r4, #3
		n_dir = 0;
 80026ae:	f04f 0800 	mov.w	r8, #0
	b_fat = b_part + n_rsv;			/* FATs start sector */
	b_dir = b_fat + n_fat * N_FATS;	/* Directory start sector */
	b_data = b_dir + n_dir;			/* Data start sector */

	/* Align data start sector to erase block boundary (for flash memory media) */
	if (disk_ioctl(drv, GET_BLOCK_SIZE, &n) != RES_OK) return FR_MKFS_ABORTED;
 80026b2:	2000      	movs	r0, #0
 80026b4:	2103      	movs	r1, #3
 80026b6:	aa05      	add	r2, sp, #20
 80026b8:	f000 fe0c 	bl	80032d4 <disk_ioctl>
 80026bc:	2800      	cmp	r0, #0
 80026be:	d18d      	bne.n	80025dc <f_mkfs+0x14>
	default:
		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
		n_rsv = 33 - partition;
		n_dir = 0;
	}
	b_fat = b_part + n_rsv;			/* FATs start sector */
 80026c0:	9a01      	ldr	r2, [sp, #4]
	b_dir = b_fat + n_fat * N_FATS;	/* Directory start sector */
	b_data = b_dir + n_dir;			/* Data start sector */

	/* Align data start sector to erase block boundary (for flash memory media) */
	if (disk_ioctl(drv, GET_BLOCK_SIZE, &n) != RES_OK) return FR_MKFS_ABORTED;
	n = (b_data + n - 1) & ~(n - 1);
 80026c2:	9905      	ldr	r1, [sp, #20]
	default:
		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
		n_rsv = 33 - partition;
		n_dir = 0;
	}
	b_fat = b_part + n_rsv;			/* FATs start sector */
 80026c4:	444a      	add	r2, r9
 80026c6:	9202      	str	r2, [sp, #8]
	b_dir = b_fat + n_fat * N_FATS;	/* Directory start sector */
	b_data = b_dir + n_dir;			/* Data start sector */
 80026c8:	9b02      	ldr	r3, [sp, #8]
		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
		n_rsv = 33 - partition;
		n_dir = 0;
	}
	b_fat = b_part + n_rsv;			/* FATs start sector */
	b_dir = b_fat + n_fat * N_FATS;	/* Directory start sector */
 80026ca:	eb08 020b 	add.w	r2, r8, fp
	b_data = b_dir + n_dir;			/* Data start sector */
 80026ce:	18d2      	adds	r2, r2, r3

	/* Align data start sector to erase block boundary (for flash memory media) */
	if (disk_ioctl(drv, GET_BLOCK_SIZE, &n) != RES_OK) return FR_MKFS_ABORTED;
	n = (b_data + n - 1) & ~(n - 1);
 80026d0:	1e4b      	subs	r3, r1, #1
 80026d2:	189b      	adds	r3, r3, r2
 80026d4:	4249      	negs	r1, r1
 80026d6:	400b      	ands	r3, r1
	n_fat += (n - b_data) / N_FATS;
 80026d8:	ebc2 070b 	rsb	r7, r2, fp
 80026dc:	18ff      	adds	r7, r7, r3
	b_dir = b_fat + n_fat * N_FATS;	/* Directory start sector */
	b_data = b_dir + n_dir;			/* Data start sector */

	/* Align data start sector to erase block boundary (for flash memory media) */
	if (disk_ioctl(drv, GET_BLOCK_SIZE, &n) != RES_OK) return FR_MKFS_ABORTED;
	n = (b_data + n - 1) & ~(n - 1);
 80026de:	9305      	str	r3, [sp, #20]
	n_fat += (n - b_data) / N_FATS;
	/* b_dir and b_data are no longer used below */

	/* Determine number of cluster and final check of validity of the FAT type */
	n_clst = (n_part - n_rsv - n_fat * N_FATS - n_dir) / allocsize;
 80026e0:	9b04      	ldr	r3, [sp, #16]
	if (   (fmt == FS_FAT16 && n_clst < 0xFF5)
 80026e2:	2c02      	cmp	r4, #2
	n = (b_data + n - 1) & ~(n - 1);
	n_fat += (n - b_data) / N_FATS;
	/* b_dir and b_data are no longer used below */

	/* Determine number of cluster and final check of validity of the FAT type */
	n_clst = (n_part - n_rsv - n_fat * N_FATS - n_dir) / allocsize;
 80026e4:	ebc9 0203 	rsb	r2, r9, r3
 80026e8:	ebc7 0202 	rsb	r2, r7, r2
 80026ec:	ebc8 0202 	rsb	r2, r8, r2
 80026f0:	fbb2 f2fa 	udiv	r2, r2, sl
 80026f4:	9203      	str	r2, [sp, #12]
	if (   (fmt == FS_FAT16 && n_clst < 0xFF5)
 80026f6:	d102      	bne.n	80026fe <f_mkfs+0x136>
 80026f8:	f640 72f4 	movw	r2, #4084	; 0xff4
 80026fc:	e003      	b.n	8002706 <f_mkfs+0x13e>
		|| (fmt == FS_FAT32 && n_clst < 0xFFF5))
 80026fe:	2c03      	cmp	r4, #3
 8002700:	d105      	bne.n	800270e <f_mkfs+0x146>
 8002702:	f64f 72f4 	movw	r2, #65524	; 0xfff4
 8002706:	9903      	ldr	r1, [sp, #12]
 8002708:	4291      	cmp	r1, r2
 800270a:	f67f af67 	bls.w	80025dc <f_mkfs+0x14>
		return FR_MKFS_ABORTED;

	/* Create partition table if needed */
	if (!partition) {
 800270e:	2d00      	cmp	r5, #0
 8002710:	d15d      	bne.n	80027ce <f_mkfs+0x206>
		DWORD n_disk = b_part + n_part;
 8002712:	9a01      	ldr	r2, [sp, #4]

		mem_set(fs->win, 0, SS(fs));
 8002714:	f106 0b30 	add.w	fp, r6, #48	; 0x30
		|| (fmt == FS_FAT32 && n_clst < 0xFFF5))
		return FR_MKFS_ABORTED;

	/* Create partition table if needed */
	if (!partition) {
		DWORD n_disk = b_part + n_part;
 8002718:	18d3      	adds	r3, r2, r3

		mem_set(fs->win, 0, SS(fs));
 800271a:	4658      	mov	r0, fp
 800271c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8002720:	4629      	mov	r1, r5
 8002722:	9300      	str	r3, [sp, #0]
 8002724:	f7fd ffe9 	bl	80006fa <mem_set>
		tbl = fs->win+MBR_Table;
		ST_DWORD(tbl, 0x00010180);		/* Partition start in CHS */
 8002728:	2280      	movs	r2, #128	; 0x80
 800272a:	f886 21ee 	strb.w	r2, [r6, #494]	; 0x1ee
 800272e:	2201      	movs	r2, #1
 8002730:	f886 21ef 	strb.w	r2, [r6, #495]	; 0x1ef
 8002734:	f886 21f0 	strb.w	r2, [r6, #496]	; 0x1f0
 8002738:	f886 51f1 	strb.w	r5, [r6, #497]	; 0x1f1
		if (n_disk < 63UL * 255 * 1024) {	/* Partition end in CHS */
 800273c:	4a66      	ldr	r2, [pc, #408]	; (80028d8 <f_mkfs+0x310>)
 800273e:	9b00      	ldr	r3, [sp, #0]
 8002740:	4293      	cmp	r3, r2
 8002742:	d80b      	bhi.n	800275c <f_mkfs+0x194>
			n_disk = n_disk / 63 / 255;
 8002744:	f643 62c1 	movw	r2, #16065	; 0x3ec1
 8002748:	fbb3 f3f2 	udiv	r3, r3, r2
			tbl[7] = (BYTE)n_disk;
 800274c:	f886 31f5 	strb.w	r3, [r6, #501]	; 0x1f5
			tbl[6] = (BYTE)((n_disk >> 2) | 63);
 8002750:	089b      	lsrs	r3, r3, #2
 8002752:	f043 033f 	orr.w	r3, r3, #63	; 0x3f
 8002756:	f886 31f4 	strb.w	r3, [r6, #500]	; 0x1f4
 800275a:	e004      	b.n	8002766 <f_mkfs+0x19e>
		} else {
			ST_WORD(&tbl[6], 0xFFFF);
 800275c:	23ff      	movs	r3, #255	; 0xff
 800275e:	f886 31f4 	strb.w	r3, [r6, #500]	; 0x1f4
 8002762:	f886 31f5 	strb.w	r3, [r6, #501]	; 0x1f5
		}
		tbl[5] = 254;
 8002766:	23fe      	movs	r3, #254	; 0xfe
		if (fmt != FS_FAT32)			/* System ID */
 8002768:	2c03      	cmp	r4, #3
			tbl[7] = (BYTE)n_disk;
			tbl[6] = (BYTE)((n_disk >> 2) | 63);
		} else {
			ST_WORD(&tbl[6], 0xFFFF);
		}
		tbl[5] = 254;
 800276a:	f886 31f3 	strb.w	r3, [r6, #499]	; 0x1f3
		if (fmt != FS_FAT32)			/* System ID */
 800276e:	d006      	beq.n	800277e <f_mkfs+0x1b6>
			tbl[4] = (n_part < 0x10000) ? 0x04 : 0x06;
 8002770:	9b04      	ldr	r3, [sp, #16]
 8002772:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002776:	bf2c      	ite	cs
 8002778:	2306      	movcs	r3, #6
 800277a:	2304      	movcc	r3, #4
 800277c:	e000      	b.n	8002780 <f_mkfs+0x1b8>
		else
			tbl[4] = 0x0c;
 800277e:	230c      	movs	r3, #12
 8002780:	f886 31f2 	strb.w	r3, [r6, #498]	; 0x1f2
		ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
 8002784:	233f      	movs	r3, #63	; 0x3f
 8002786:	f886 31f6 	strb.w	r3, [r6, #502]	; 0x1f6
		ST_DWORD(tbl+12, n_part);		/* Partition size in LBA */
 800278a:	9b04      	ldr	r3, [sp, #16]
		tbl[5] = 254;
		if (fmt != FS_FAT32)			/* System ID */
			tbl[4] = (n_part < 0x10000) ? 0x04 : 0x06;
		else
			tbl[4] = 0x0c;
		ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
 800278c:	2000      	movs	r0, #0
		ST_DWORD(tbl+12, n_part);		/* Partition size in LBA */
 800278e:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8002792:	f886 31fa 	strb.w	r3, [r6, #506]	; 0x1fa
 8002796:	f886 21fb 	strb.w	r2, [r6, #507]	; 0x1fb
 800279a:	0c1a      	lsrs	r2, r3, #16
 800279c:	0e1b      	lsrs	r3, r3, #24
 800279e:	f886 31fd 	strb.w	r3, [r6, #509]	; 0x1fd
		ST_WORD(tbl+64, 0xAA55);		/* Signature */
 80027a2:	2355      	movs	r3, #85	; 0x55
 80027a4:	f886 322e 	strb.w	r3, [r6, #558]	; 0x22e
 80027a8:	23aa      	movs	r3, #170	; 0xaa
		if (fmt != FS_FAT32)			/* System ID */
			tbl[4] = (n_part < 0x10000) ? 0x04 : 0x06;
		else
			tbl[4] = 0x0c;
		ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
		ST_DWORD(tbl+12, n_part);		/* Partition size in LBA */
 80027aa:	f886 21fc 	strb.w	r2, [r6, #508]	; 0x1fc
		ST_WORD(tbl+64, 0xAA55);		/* Signature */
 80027ae:	f886 322f 	strb.w	r3, [r6, #559]	; 0x22f
		tbl[5] = 254;
		if (fmt != FS_FAT32)			/* System ID */
			tbl[4] = (n_part < 0x10000) ? 0x04 : 0x06;
		else
			tbl[4] = 0x0c;
		ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
 80027b2:	f886 01f7 	strb.w	r0, [r6, #503]	; 0x1f7
 80027b6:	f886 01f8 	strb.w	r0, [r6, #504]	; 0x1f8
 80027ba:	f886 01f9 	strb.w	r0, [r6, #505]	; 0x1f9
		ST_DWORD(tbl+12, n_part);		/* Partition size in LBA */
		ST_WORD(tbl+64, 0xAA55);		/* Signature */
		if (disk_write(drv, fs->win, 0, 1) != RES_OK)
 80027be:	4659      	mov	r1, fp
 80027c0:	4602      	mov	r2, r0
 80027c2:	2301      	movs	r3, #1
 80027c4:	f000 fd22 	bl	800320c <disk_write>
 80027c8:	b120      	cbz	r0, 80027d4 <f_mkfs+0x20c>
			return FR_DISK_ERR;
 80027ca:	2001      	movs	r0, #1
 80027cc:	e1b9      	b.n	8002b42 <f_mkfs+0x57a>
		partition = 0xF8;
	} else {
		partition = 0xF0;
 80027ce:	f04f 0bf0 	mov.w	fp, #240	; 0xf0
 80027d2:	e001      	b.n	80027d8 <f_mkfs+0x210>
		ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
		ST_DWORD(tbl+12, n_part);		/* Partition size in LBA */
		ST_WORD(tbl+64, 0xAA55);		/* Signature */
		if (disk_write(drv, fs->win, 0, 1) != RES_OK)
			return FR_DISK_ERR;
		partition = 0xF8;
 80027d4:	f04f 0bf8 	mov.w	fp, #248	; 0xf8
	} else {
		partition = 0xF0;
	}

	/* Create boot record */
	tbl = fs->win;								/* Clear buffer */
 80027d8:	f106 0530 	add.w	r5, r6, #48	; 0x30
	mem_set(tbl, 0, SS(fs));
 80027dc:	2100      	movs	r1, #0
 80027de:	f44f 7200 	mov.w	r2, #512	; 0x200
 80027e2:	4628      	mov	r0, r5
 80027e4:	f7fd ff89 	bl	80006fa <mem_set>
	ST_DWORD(tbl+BS_jmpBoot, 0x90FEEB);			/* Boot code (jmp $, nop) */
 80027e8:	23eb      	movs	r3, #235	; 0xeb
 80027ea:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
 80027ee:	23fe      	movs	r3, #254	; 0xfe
 80027f0:	f886 3031 	strb.w	r3, [r6, #49]	; 0x31
 80027f4:	2390      	movs	r3, #144	; 0x90
 80027f6:	f886 3032 	strb.w	r3, [r6, #50]	; 0x32
 80027fa:	2300      	movs	r3, #0
 80027fc:	f886 3033 	strb.w	r3, [r6, #51]	; 0x33
	ST_WORD(tbl+BPB_BytsPerSec, SS(fs));		/* Sector size */
 8002800:	f886 303b 	strb.w	r3, [r6, #59]	; 0x3b
	tbl[BPB_SecPerClus] = (BYTE)allocsize;		/* Sectors per cluster */
	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);			/* Reserved sectors */
 8002804:	f886 303f 	strb.w	r3, [r6, #63]	; 0x3f
	tbl[BPB_NumFATs] = N_FATS;					/* Number of FATs */
	ST_WORD(tbl+BPB_RootEntCnt, SS(fs) / 32 * n_dir); /* Number of rootdir entries */
 8002808:	f886 3041 	strb.w	r3, [r6, #65]	; 0x41
 800280c:	4598      	cmp	r8, r3
 800280e:	bf18      	it	ne
 8002810:	2302      	movne	r3, #2
 8002812:	f886 3042 	strb.w	r3, [r6, #66]	; 0x42
	if (n_part < 0x10000) {						/* Number of total sectors */
 8002816:	9b04      	ldr	r3, [sp, #16]

	/* Create boot record */
	tbl = fs->win;								/* Clear buffer */
	mem_set(tbl, 0, SS(fs));
	ST_DWORD(tbl+BS_jmpBoot, 0x90FEEB);			/* Boot code (jmp $, nop) */
	ST_WORD(tbl+BPB_BytsPerSec, SS(fs));		/* Sector size */
 8002818:	2202      	movs	r2, #2
 800281a:	f886 203c 	strb.w	r2, [r6, #60]	; 0x3c
	tbl[BPB_SecPerClus] = (BYTE)allocsize;		/* Sectors per cluster */
 800281e:	fa5f fa8a 	uxtb.w	sl, sl
	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);			/* Reserved sectors */
	tbl[BPB_NumFATs] = N_FATS;					/* Number of FATs */
 8002822:	2201      	movs	r2, #1
	ST_WORD(tbl+BPB_RootEntCnt, SS(fs) / 32 * n_dir); /* Number of rootdir entries */
	if (n_part < 0x10000) {						/* Number of total sectors */
 8002824:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
	mem_set(tbl, 0, SS(fs));
	ST_DWORD(tbl+BS_jmpBoot, 0x90FEEB);			/* Boot code (jmp $, nop) */
	ST_WORD(tbl+BPB_BytsPerSec, SS(fs));		/* Sector size */
	tbl[BPB_SecPerClus] = (BYTE)allocsize;		/* Sectors per cluster */
	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);			/* Reserved sectors */
	tbl[BPB_NumFATs] = N_FATS;					/* Number of FATs */
 8002828:	f886 2040 	strb.w	r2, [r6, #64]	; 0x40
	/* Create boot record */
	tbl = fs->win;								/* Clear buffer */
	mem_set(tbl, 0, SS(fs));
	ST_DWORD(tbl+BS_jmpBoot, 0x90FEEB);			/* Boot code (jmp $, nop) */
	ST_WORD(tbl+BPB_BytsPerSec, SS(fs));		/* Sector size */
	tbl[BPB_SecPerClus] = (BYTE)allocsize;		/* Sectors per cluster */
 800282c:	f886 a03d 	strb.w	sl, [r6, #61]	; 0x3d
	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);			/* Reserved sectors */
 8002830:	f886 903e 	strb.w	r9, [r6, #62]	; 0x3e
 8002834:	b29a      	uxth	r2, r3
	tbl[BPB_NumFATs] = N_FATS;					/* Number of FATs */
	ST_WORD(tbl+BPB_RootEntCnt, SS(fs) / 32 * n_dir); /* Number of rootdir entries */
	if (n_part < 0x10000) {						/* Number of total sectors */
 8002836:	d205      	bcs.n	8002844 <f_mkfs+0x27c>
		ST_WORD(tbl+BPB_TotSec16, n_part);
 8002838:	0a12      	lsrs	r2, r2, #8
 800283a:	f886 3043 	strb.w	r3, [r6, #67]	; 0x43
 800283e:	f886 2044 	strb.w	r2, [r6, #68]	; 0x44
 8002842:	e00a      	b.n	800285a <f_mkfs+0x292>
	} else {
		ST_DWORD(tbl+BPB_TotSec32, n_part);
 8002844:	0a12      	lsrs	r2, r2, #8
 8002846:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
 800284a:	f886 2051 	strb.w	r2, [r6, #81]	; 0x51
 800284e:	0c1a      	lsrs	r2, r3, #16
 8002850:	0e1b      	lsrs	r3, r3, #24
 8002852:	f886 2052 	strb.w	r2, [r6, #82]	; 0x52
 8002856:	f886 3053 	strb.w	r3, [r6, #83]	; 0x53
	}
	tbl[BPB_Media] = partition;					/* Media descriptor */
	ST_WORD(tbl+BPB_SecPerTrk, 63);				/* Number of sectors per track */
 800285a:	233f      	movs	r3, #63	; 0x3f
 800285c:	f886 3048 	strb.w	r3, [r6, #72]	; 0x48
	ST_WORD(tbl+BPB_NumHeads, 255);				/* Number of heads */
 8002860:	23ff      	movs	r3, #255	; 0xff
 8002862:	f886 304a 	strb.w	r3, [r6, #74]	; 0x4a
	ST_DWORD(tbl+BPB_HiddSec, b_part);			/* Hidden sectors */
 8002866:	9b01      	ldr	r3, [sp, #4]
		ST_WORD(tbl+BPB_TotSec16, n_part);
	} else {
		ST_DWORD(tbl+BPB_TotSec32, n_part);
	}
	tbl[BPB_Media] = partition;					/* Media descriptor */
	ST_WORD(tbl+BPB_SecPerTrk, 63);				/* Number of sectors per track */
 8002868:	f04f 0900 	mov.w	r9, #0
	ST_WORD(tbl+BPB_NumHeads, 255);				/* Number of heads */
	ST_DWORD(tbl+BPB_HiddSec, b_part);			/* Hidden sectors */
 800286c:	f886 304c 	strb.w	r3, [r6, #76]	; 0x4c
	if (n_part < 0x10000) {						/* Number of total sectors */
		ST_WORD(tbl+BPB_TotSec16, n_part);
	} else {
		ST_DWORD(tbl+BPB_TotSec32, n_part);
	}
	tbl[BPB_Media] = partition;					/* Media descriptor */
 8002870:	f886 b045 	strb.w	fp, [r6, #69]	; 0x45
	ST_WORD(tbl+BPB_SecPerTrk, 63);				/* Number of sectors per track */
 8002874:	f886 9049 	strb.w	r9, [r6, #73]	; 0x49
	ST_WORD(tbl+BPB_NumHeads, 255);				/* Number of heads */
 8002878:	f886 904b 	strb.w	r9, [r6, #75]	; 0x4b
	ST_DWORD(tbl+BPB_HiddSec, b_part);			/* Hidden sectors */
 800287c:	f886 904d 	strb.w	r9, [r6, #77]	; 0x4d
 8002880:	f886 904e 	strb.w	r9, [r6, #78]	; 0x4e
 8002884:	f886 904f 	strb.w	r9, [r6, #79]	; 0x4f
	n = get_fattime();							/* Use current time as a VSN */
 8002888:	f7fd ff0e 	bl	80006a8 <get_fattime>
	if (fmt != FS_FAT32) {
 800288c:	2c03      	cmp	r4, #3
	}
	tbl[BPB_Media] = partition;					/* Media descriptor */
	ST_WORD(tbl+BPB_SecPerTrk, 63);				/* Number of sectors per track */
	ST_WORD(tbl+BPB_NumHeads, 255);				/* Number of heads */
	ST_DWORD(tbl+BPB_HiddSec, b_part);			/* Hidden sectors */
	n = get_fattime();							/* Use current time as a VSN */
 800288e:	9005      	str	r0, [sp, #20]
 8002890:	b283      	uxth	r3, r0
	if (fmt != FS_FAT32) {
 8002892:	d025      	beq.n	80028e0 <f_mkfs+0x318>
		ST_DWORD(tbl+BS_VolID, n);				/* Volume serial number */
 8002894:	0a1b      	lsrs	r3, r3, #8
 8002896:	f886 3058 	strb.w	r3, [r6, #88]	; 0x58
 800289a:	0c03      	lsrs	r3, r0, #16
 800289c:	f886 3059 	strb.w	r3, [r6, #89]	; 0x59
		ST_WORD(tbl+BPB_FATSz16, n_fat);		/* Number of sectors per FAT */
 80028a0:	f3c7 2307 	ubfx	r3, r7, #8, #8
 80028a4:	f886 3047 	strb.w	r3, [r6, #71]	; 0x47
		tbl[BS_DrvNum] = 0x80;					/* Drive number */
 80028a8:	2380      	movs	r3, #128	; 0x80
	ST_WORD(tbl+BPB_SecPerTrk, 63);				/* Number of sectors per track */
	ST_WORD(tbl+BPB_NumHeads, 255);				/* Number of heads */
	ST_DWORD(tbl+BPB_HiddSec, b_part);			/* Hidden sectors */
	n = get_fattime();							/* Use current time as a VSN */
	if (fmt != FS_FAT32) {
		ST_DWORD(tbl+BS_VolID, n);				/* Volume serial number */
 80028aa:	f886 0057 	strb.w	r0, [r6, #87]	; 0x57
		ST_WORD(tbl+BPB_FATSz16, n_fat);		/* Number of sectors per FAT */
		tbl[BS_DrvNum] = 0x80;					/* Drive number */
 80028ae:	f886 3054 	strb.w	r3, [r6, #84]	; 0x54
	ST_WORD(tbl+BPB_SecPerTrk, 63);				/* Number of sectors per track */
	ST_WORD(tbl+BPB_NumHeads, 255);				/* Number of heads */
	ST_DWORD(tbl+BPB_HiddSec, b_part);			/* Hidden sectors */
	n = get_fattime();							/* Use current time as a VSN */
	if (fmt != FS_FAT32) {
		ST_DWORD(tbl+BS_VolID, n);				/* Volume serial number */
 80028b2:	0e00      	lsrs	r0, r0, #24
		ST_WORD(tbl+BPB_FATSz16, n_fat);		/* Number of sectors per FAT */
		tbl[BS_DrvNum] = 0x80;					/* Drive number */
		tbl[BS_BootSig] = 0x29;					/* Extended boot signature */
 80028b4:	2329      	movs	r3, #41	; 0x29
	ST_WORD(tbl+BPB_SecPerTrk, 63);				/* Number of sectors per track */
	ST_WORD(tbl+BPB_NumHeads, 255);				/* Number of heads */
	ST_DWORD(tbl+BPB_HiddSec, b_part);			/* Hidden sectors */
	n = get_fattime();							/* Use current time as a VSN */
	if (fmt != FS_FAT32) {
		ST_DWORD(tbl+BS_VolID, n);				/* Volume serial number */
 80028b6:	f886 005a 	strb.w	r0, [r6, #90]	; 0x5a
		ST_WORD(tbl+BPB_FATSz16, n_fat);		/* Number of sectors per FAT */
 80028ba:	f886 7046 	strb.w	r7, [r6, #70]	; 0x46
		tbl[BS_DrvNum] = 0x80;					/* Drive number */
		tbl[BS_BootSig] = 0x29;					/* Extended boot signature */
 80028be:	f886 3056 	strb.w	r3, [r6, #86]	; 0x56
		mem_cpy(tbl+BS_VolLab, "NO NAME    FAT     ", 19);	/* Volume label, FAT signature */
 80028c2:	f106 005b 	add.w	r0, r6, #91	; 0x5b
 80028c6:	4905      	ldr	r1, [pc, #20]	; (80028dc <f_mkfs+0x314>)
 80028c8:	e03d      	b.n	8002946 <f_mkfs+0x37e>
 80028ca:	bf00      	nop
 80028cc:	20000924 	.word	0x20000924
 80028d0:	0801e5e8 	.word	0x0801e5e8
 80028d4:	0801e558 	.word	0x0801e558
 80028d8:	00fb03ff 	.word	0x00fb03ff
 80028dc:	0801ffc4 	.word	0x0801ffc4
	} else {
		ST_DWORD(tbl+BS_VolID32, n);			/* Volume serial number */
 80028e0:	0a1b      	lsrs	r3, r3, #8
 80028e2:	f886 3074 	strb.w	r3, [r6, #116]	; 0x74
 80028e6:	0c03      	lsrs	r3, r0, #16
 80028e8:	f886 3075 	strb.w	r3, [r6, #117]	; 0x75
		ST_DWORD(tbl+BPB_FATSz32, n_fat);		/* Number of sectors per FAT */
 80028ec:	f3c7 2307 	ubfx	r3, r7, #8, #8
 80028f0:	f886 3055 	strb.w	r3, [r6, #85]	; 0x55
 80028f4:	0c3b      	lsrs	r3, r7, #16
 80028f6:	f886 3056 	strb.w	r3, [r6, #86]	; 0x56
 80028fa:	0e3b      	lsrs	r3, r7, #24
 80028fc:	f886 3057 	strb.w	r3, [r6, #87]	; 0x57
		ST_DWORD(tbl+BPB_RootClus, 2);			/* Root directory cluster (2) */
 8002900:	2302      	movs	r3, #2
 8002902:	f886 305c 	strb.w	r3, [r6, #92]	; 0x5c
		ST_WORD(tbl+BPB_FSInfo, 1);				/* FSInfo record offset (bs+1) */
 8002906:	2301      	movs	r3, #1
 8002908:	f886 3060 	strb.w	r3, [r6, #96]	; 0x60
		ST_WORD(tbl+BPB_BkBootSec, 6);			/* Backup boot record offset (bs+6) */
 800290c:	2306      	movs	r3, #6
 800290e:	f886 3062 	strb.w	r3, [r6, #98]	; 0x62
		tbl[BS_DrvNum32] = 0x80;				/* Drive number */
 8002912:	2380      	movs	r3, #128	; 0x80
		ST_WORD(tbl+BPB_FATSz16, n_fat);		/* Number of sectors per FAT */
		tbl[BS_DrvNum] = 0x80;					/* Drive number */
		tbl[BS_BootSig] = 0x29;					/* Extended boot signature */
		mem_cpy(tbl+BS_VolLab, "NO NAME    FAT     ", 19);	/* Volume label, FAT signature */
	} else {
		ST_DWORD(tbl+BS_VolID32, n);			/* Volume serial number */
 8002914:	f886 0073 	strb.w	r0, [r6, #115]	; 0x73
		ST_DWORD(tbl+BPB_FATSz32, n_fat);		/* Number of sectors per FAT */
		ST_DWORD(tbl+BPB_RootClus, 2);			/* Root directory cluster (2) */
		ST_WORD(tbl+BPB_FSInfo, 1);				/* FSInfo record offset (bs+1) */
		ST_WORD(tbl+BPB_BkBootSec, 6);			/* Backup boot record offset (bs+6) */
		tbl[BS_DrvNum32] = 0x80;				/* Drive number */
 8002918:	f886 3070 	strb.w	r3, [r6, #112]	; 0x70
		ST_WORD(tbl+BPB_FATSz16, n_fat);		/* Number of sectors per FAT */
		tbl[BS_DrvNum] = 0x80;					/* Drive number */
		tbl[BS_BootSig] = 0x29;					/* Extended boot signature */
		mem_cpy(tbl+BS_VolLab, "NO NAME    FAT     ", 19);	/* Volume label, FAT signature */
	} else {
		ST_DWORD(tbl+BS_VolID32, n);			/* Volume serial number */
 800291c:	0e00      	lsrs	r0, r0, #24
		ST_DWORD(tbl+BPB_FATSz32, n_fat);		/* Number of sectors per FAT */
		ST_DWORD(tbl+BPB_RootClus, 2);			/* Root directory cluster (2) */
		ST_WORD(tbl+BPB_FSInfo, 1);				/* FSInfo record offset (bs+1) */
		ST_WORD(tbl+BPB_BkBootSec, 6);			/* Backup boot record offset (bs+6) */
		tbl[BS_DrvNum32] = 0x80;				/* Drive number */
		tbl[BS_BootSig32] = 0x29;				/* Extended boot signature */
 800291e:	2329      	movs	r3, #41	; 0x29
		mem_cpy(tbl+BS_VolLab32, "NO NAME    FAT32   ", 19);	/* Volume label, FAT signature */
 8002920:	4989      	ldr	r1, [pc, #548]	; (8002b48 <f_mkfs+0x580>)
		ST_WORD(tbl+BPB_FATSz16, n_fat);		/* Number of sectors per FAT */
		tbl[BS_DrvNum] = 0x80;					/* Drive number */
		tbl[BS_BootSig] = 0x29;					/* Extended boot signature */
		mem_cpy(tbl+BS_VolLab, "NO NAME    FAT     ", 19);	/* Volume label, FAT signature */
	} else {
		ST_DWORD(tbl+BS_VolID32, n);			/* Volume serial number */
 8002922:	f886 0076 	strb.w	r0, [r6, #118]	; 0x76
		ST_DWORD(tbl+BPB_FATSz32, n_fat);		/* Number of sectors per FAT */
 8002926:	f886 7054 	strb.w	r7, [r6, #84]	; 0x54
		ST_DWORD(tbl+BPB_RootClus, 2);			/* Root directory cluster (2) */
 800292a:	f886 905d 	strb.w	r9, [r6, #93]	; 0x5d
 800292e:	f886 905e 	strb.w	r9, [r6, #94]	; 0x5e
 8002932:	f886 905f 	strb.w	r9, [r6, #95]	; 0x5f
		ST_WORD(tbl+BPB_FSInfo, 1);				/* FSInfo record offset (bs+1) */
 8002936:	f886 9061 	strb.w	r9, [r6, #97]	; 0x61
		ST_WORD(tbl+BPB_BkBootSec, 6);			/* Backup boot record offset (bs+6) */
 800293a:	f886 9063 	strb.w	r9, [r6, #99]	; 0x63
		tbl[BS_DrvNum32] = 0x80;				/* Drive number */
		tbl[BS_BootSig32] = 0x29;				/* Extended boot signature */
 800293e:	f886 3072 	strb.w	r3, [r6, #114]	; 0x72
		mem_cpy(tbl+BS_VolLab32, "NO NAME    FAT32   ", 19);	/* Volume label, FAT signature */
 8002942:	f106 0077 	add.w	r0, r6, #119	; 0x77
 8002946:	2213      	movs	r2, #19
 8002948:	f7fd fece 	bl	80006e8 <mem_cpy>
	}
	ST_WORD(tbl+BS_55AA, 0xAA55);				/* Signature */
 800294c:	2355      	movs	r3, #85	; 0x55
 800294e:	f886 322e 	strb.w	r3, [r6, #558]	; 0x22e
 8002952:	23aa      	movs	r3, #170	; 0xaa
 8002954:	f886 322f 	strb.w	r3, [r6, #559]	; 0x22f
	if (SS(fs) > 512U) {
		ST_WORD(tbl+SS(fs)-2, 0xAA55);
	}
	if (disk_write(drv, tbl, b_part+0, 1) != RES_OK)
 8002958:	2000      	movs	r0, #0
 800295a:	4629      	mov	r1, r5
 800295c:	9a01      	ldr	r2, [sp, #4]
 800295e:	2301      	movs	r3, #1
 8002960:	f000 fc54 	bl	800320c <disk_write>
 8002964:	2800      	cmp	r0, #0
 8002966:	f47f af30 	bne.w	80027ca <f_mkfs+0x202>
		return FR_DISK_ERR;
	if (fmt == FS_FAT32)
 800296a:	2c03      	cmp	r4, #3
 800296c:	d105      	bne.n	800297a <f_mkfs+0x3b2>
		disk_write(drv, tbl, b_part+6, 1);
 800296e:	9b01      	ldr	r3, [sp, #4]
 8002970:	4629      	mov	r1, r5
 8002972:	1d9a      	adds	r2, r3, #6
 8002974:	2301      	movs	r3, #1
 8002976:	f000 fc49 	bl	800320c <disk_write>

	/* Initialize FAT area */
	for (m = 0; m < N_FATS; m++) {
		mem_set(tbl, 0, SS(fs));		/* 1st sector of the FAT  */
 800297a:	2100      	movs	r1, #0
 800297c:	4628      	mov	r0, r5
 800297e:	f44f 7200 	mov.w	r2, #512	; 0x200
 8002982:	f7fd feba 	bl	80006fa <mem_set>
		if (fmt != FS_FAT32) {
 8002986:	2c03      	cmp	r4, #3
 8002988:	d012      	beq.n	80029b0 <f_mkfs+0x3e8>
			n = (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
 800298a:	4b70      	ldr	r3, [pc, #448]	; (8002b4c <f_mkfs+0x584>)
 800298c:	2c01      	cmp	r4, #1
 800298e:	bf18      	it	ne
 8002990:	f06f 03ff 	mvnne.w	r3, #255	; 0xff
			n |= partition;
 8002994:	ea43 030b 	orr.w	r3, r3, fp
			ST_DWORD(tbl, n);				/* Reserve cluster #0-1 (FAT12/16) */
 8002998:	22ff      	movs	r2, #255	; 0xff
	/* Initialize FAT area */
	for (m = 0; m < N_FATS; m++) {
		mem_set(tbl, 0, SS(fs));		/* 1st sector of the FAT  */
		if (fmt != FS_FAT32) {
			n = (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
			n |= partition;
 800299a:	9305      	str	r3, [sp, #20]
			ST_DWORD(tbl, n);				/* Reserve cluster #0-1 (FAT12/16) */
 800299c:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
 80029a0:	0e1b      	lsrs	r3, r3, #24
 80029a2:	f886 2031 	strb.w	r2, [r6, #49]	; 0x31
 80029a6:	f886 2032 	strb.w	r2, [r6, #50]	; 0x32
 80029aa:	f886 3033 	strb.w	r3, [r6, #51]	; 0x33
 80029ae:	e01a      	b.n	80029e6 <f_mkfs+0x41e>
		} else {
			ST_DWORD(tbl+0, 0xFFFFFFF8);	/* Reserve cluster #0-1 (FAT32) */
 80029b0:	23f8      	movs	r3, #248	; 0xf8
 80029b2:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
 80029b6:	23ff      	movs	r3, #255	; 0xff
 80029b8:	f886 3031 	strb.w	r3, [r6, #49]	; 0x31
 80029bc:	f886 3032 	strb.w	r3, [r6, #50]	; 0x32
 80029c0:	f886 3033 	strb.w	r3, [r6, #51]	; 0x33
			ST_DWORD(tbl+4, 0xFFFFFFFF);
 80029c4:	f886 3034 	strb.w	r3, [r6, #52]	; 0x34
 80029c8:	f886 3035 	strb.w	r3, [r6, #53]	; 0x35
 80029cc:	f886 3036 	strb.w	r3, [r6, #54]	; 0x36
 80029d0:	f886 3037 	strb.w	r3, [r6, #55]	; 0x37
			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
 80029d4:	f886 3038 	strb.w	r3, [r6, #56]	; 0x38
 80029d8:	f886 3039 	strb.w	r3, [r6, #57]	; 0x39
 80029dc:	f886 303a 	strb.w	r3, [r6, #58]	; 0x3a
 80029e0:	230f      	movs	r3, #15
 80029e2:	f886 303b 	strb.w	r3, [r6, #59]	; 0x3b
		}
		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
 80029e6:	9902      	ldr	r1, [sp, #8]
 80029e8:	2000      	movs	r0, #0
 80029ea:	f101 0901 	add.w	r9, r1, #1
 80029ee:	9a02      	ldr	r2, [sp, #8]
 80029f0:	4629      	mov	r1, r5
 80029f2:	2301      	movs	r3, #1
 80029f4:	f000 fc0a 	bl	800320c <disk_write>
 80029f8:	4601      	mov	r1, r0
 80029fa:	2800      	cmp	r0, #0
 80029fc:	f47f aee5 	bne.w	80027ca <f_mkfs+0x202>
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));		/* Following FAT entries are filled by zero */
 8002a00:	4628      	mov	r0, r5
 8002a02:	f44f 7200 	mov.w	r2, #512	; 0x200
 8002a06:	f7fd fe78 	bl	80006fa <mem_set>
		for (n = 1; n < n_fat; n++) {
 8002a0a:	2301      	movs	r3, #1
 8002a0c:	9305      	str	r3, [sp, #20]
 8002a0e:	e00e      	b.n	8002a2e <f_mkfs+0x466>
			if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
 8002a10:	2000      	movs	r0, #0
 8002a12:	4629      	mov	r1, r5
 8002a14:	464a      	mov	r2, r9
 8002a16:	2301      	movs	r3, #1
 8002a18:	f109 0b01 	add.w	fp, r9, #1
 8002a1c:	f000 fbf6 	bl	800320c <disk_write>
 8002a20:	2800      	cmp	r0, #0
 8002a22:	f47f aed2 	bne.w	80027ca <f_mkfs+0x202>
			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
		}
		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));		/* Following FAT entries are filled by zero */
		for (n = 1; n < n_fat; n++) {
 8002a26:	9b05      	ldr	r3, [sp, #20]
			if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
 8002a28:	46d9      	mov	r9, fp
			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
		}
		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));		/* Following FAT entries are filled by zero */
		for (n = 1; n < n_fat; n++) {
 8002a2a:	3301      	adds	r3, #1
 8002a2c:	9305      	str	r3, [sp, #20]
 8002a2e:	9b05      	ldr	r3, [sp, #20]
 8002a30:	42bb      	cmp	r3, r7
 8002a32:	d3ed      	bcc.n	8002a10 <f_mkfs+0x448>
				return FR_DISK_ERR;
		}
	}

	/* Initialize Root directory */
	m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);
 8002a34:	2c03      	cmp	r4, #3
 8002a36:	bf18      	it	ne
 8002a38:	fa5f fa88 	uxtbne.w	sl, r8
#define N_FATS		1			/* 1 or 2 */
#define MAX_SECTOR	131072000UL	/* Maximum partition size */
#define MIN_SECTOR	2000UL		/* Minimum partition size */


FRESULT f_mkfs (
 8002a3c:	44ca      	add	sl, r9
	/* Initialize Root directory */
	m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);
	do {
		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
			return FR_DISK_ERR;
	} while (--m);
 8002a3e:	fa5f fa8a 	uxtb.w	sl, sl
	}

	/* Initialize Root directory */
	m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);
	do {
		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
 8002a42:	2000      	movs	r0, #0
 8002a44:	4629      	mov	r1, r5
 8002a46:	464a      	mov	r2, r9
 8002a48:	2301      	movs	r3, #1
 8002a4a:	f000 fbdf 	bl	800320c <disk_write>
 8002a4e:	f109 0801 	add.w	r8, r9, #1
 8002a52:	4607      	mov	r7, r0
 8002a54:	2800      	cmp	r0, #0
 8002a56:	f47f aeb8 	bne.w	80027ca <f_mkfs+0x202>
			return FR_DISK_ERR;
	} while (--m);
 8002a5a:	fa5f f388 	uxtb.w	r3, r8
 8002a5e:	459a      	cmp	sl, r3
	}

	/* Initialize Root directory */
	m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);
	do {
		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
 8002a60:	46c1      	mov	r9, r8
			return FR_DISK_ERR;
	} while (--m);
 8002a62:	d1ee      	bne.n	8002a42 <f_mkfs+0x47a>

	/* Create FSInfo record if needed */
	if (fmt == FS_FAT32) {
 8002a64:	2c03      	cmp	r4, #3
 8002a66:	d13d      	bne.n	8002ae4 <f_mkfs+0x51c>
		ST_WORD(tbl+BS_55AA, 0xAA55);
 8002a68:	2355      	movs	r3, #85	; 0x55
		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
 8002a6a:	2241      	movs	r2, #65	; 0x41
			return FR_DISK_ERR;
	} while (--m);

	/* Create FSInfo record if needed */
	if (fmt == FS_FAT32) {
		ST_WORD(tbl+BS_55AA, 0xAA55);
 8002a6c:	f886 322e 	strb.w	r3, [r6, #558]	; 0x22e
 8002a70:	23aa      	movs	r3, #170	; 0xaa
 8002a72:	f886 322f 	strb.w	r3, [r6, #559]	; 0x22f
		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
 8002a76:	f886 2033 	strb.w	r2, [r6, #51]	; 0x33
 8002a7a:	2352      	movs	r3, #82	; 0x52
		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
 8002a7c:	f886 2216 	strb.w	r2, [r6, #534]	; 0x216
		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);
 8002a80:	9a03      	ldr	r2, [sp, #12]
	} while (--m);

	/* Create FSInfo record if needed */
	if (fmt == FS_FAT32) {
		ST_WORD(tbl+BS_55AA, 0xAA55);
		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
 8002a82:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
 8002a86:	f886 3031 	strb.w	r3, [r6, #49]	; 0x31
 8002a8a:	2361      	movs	r3, #97	; 0x61
 8002a8c:	f886 3032 	strb.w	r3, [r6, #50]	; 0x32
		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
 8002a90:	f886 3217 	strb.w	r3, [r6, #535]	; 0x217
		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);
 8002a94:	1e53      	subs	r3, r2, #1
 8002a96:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8002a9a:	f886 3218 	strb.w	r3, [r6, #536]	; 0x218
 8002a9e:	f886 2219 	strb.w	r2, [r6, #537]	; 0x219
 8002aa2:	0c1a      	lsrs	r2, r3, #16
 8002aa4:	0e1b      	lsrs	r3, r3, #24
 8002aa6:	f886 321b 	strb.w	r3, [r6, #539]	; 0x21b
		ST_DWORD(tbl+FSI_Nxt_Free, 0xFFFFFFFF);
 8002aaa:	23ff      	movs	r3, #255	; 0xff
 8002aac:	f886 321c 	strb.w	r3, [r6, #540]	; 0x21c
 8002ab0:	f886 321d 	strb.w	r3, [r6, #541]	; 0x21d
 8002ab4:	f886 321e 	strb.w	r3, [r6, #542]	; 0x21e
 8002ab8:	f886 321f 	strb.w	r3, [r6, #543]	; 0x21f
		disk_write(drv, tbl, b_part+1, 1);
 8002abc:	9b01      	ldr	r3, [sp, #4]

	/* Create FSInfo record if needed */
	if (fmt == FS_FAT32) {
		ST_WORD(tbl+BS_55AA, 0xAA55);
		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
 8002abe:	2172      	movs	r1, #114	; 0x72
 8002ac0:	f886 1214 	strb.w	r1, [r6, #532]	; 0x214
 8002ac4:	f886 1215 	strb.w	r1, [r6, #533]	; 0x215
		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);
 8002ac8:	f886 221a 	strb.w	r2, [r6, #538]	; 0x21a
		ST_DWORD(tbl+FSI_Nxt_Free, 0xFFFFFFFF);
		disk_write(drv, tbl, b_part+1, 1);
 8002acc:	4629      	mov	r1, r5
 8002ace:	1c5a      	adds	r2, r3, #1
 8002ad0:	2301      	movs	r3, #1
 8002ad2:	f000 fb9b 	bl	800320c <disk_write>
		disk_write(drv, tbl, b_part+7, 1);
 8002ad6:	9b01      	ldr	r3, [sp, #4]
 8002ad8:	4638      	mov	r0, r7
 8002ada:	1dda      	adds	r2, r3, #7
 8002adc:	4629      	mov	r1, r5
 8002ade:	2301      	movs	r3, #1
 8002ae0:	f000 fb94 	bl	800320c <disk_write>
	}

	return (disk_ioctl(drv, CTRL_SYNC, (void*)NULL) == RES_OK) ? FR_OK : FR_DISK_ERR;
 8002ae4:	2000      	movs	r0, #0
 8002ae6:	4601      	mov	r1, r0
 8002ae8:	4602      	mov	r2, r0
 8002aea:	f000 fbf3 	bl	80032d4 <disk_ioctl>
 8002aee:	3000      	adds	r0, #0
 8002af0:	bf18      	it	ne
 8002af2:	2001      	movne	r0, #1
 8002af4:	e025      	b.n	8002b42 <f_mkfs+0x57a>
	FATFS *fs;
	DSTATUS stat;


	/* Check validity of the parameters */
	if (drv >= _DRIVES) return FR_INVALID_DRIVE;
 8002af6:	200b      	movs	r0, #11
 8002af8:	e023      	b.n	8002b42 <f_mkfs+0x57a>
	if (partition >= 2) return FR_MKFS_ABORTED;

	/* Check mounted drive and clear work area */
	fs = FatFs[drv];
	if (!fs) return FR_NOT_ENABLED;
 8002afa:	200c      	movs	r0, #12
 8002afc:	e021      	b.n	8002b42 <f_mkfs+0x57a>
	fs->fs_type = 0;
	drv = LD2PD(drv);

	/* Get disk statics */
	stat = disk_initialize(drv);
	if (stat & STA_NOINIT) return FR_NOT_READY;
 8002afe:	2003      	movs	r0, #3
 8002b00:	e01f      	b.n	8002b42 <f_mkfs+0x57a>
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
 8002b02:	200a      	movs	r0, #10
 8002b04:	e01d      	b.n	8002b42 <f_mkfs+0x57a>
		n_fat = ((n_clst * 3 + 1) / 2 + 3 + SS(fs) - 1) / SS(fs);
		n_rsv = 1 + partition;
		n_dir = N_ROOTDIR * 32 / SS(fs);
		break;
	case FS_FAT16:
		n_fat = ((n_clst * 2) + 4 + SS(fs) - 1) / SS(fs);
 8002b06:	f503 7b81 	add.w	fp, r3, #258	; 0x102
 8002b0a:	ea4f 0b4b 	mov.w	fp, fp, lsl #1
 8002b0e:	f10b 3bff 	add.w	fp, fp, #4294967295
 8002b12:	ea4f 2b5b 	mov.w	fp, fp, lsr #9
		n_rsv = 1 + partition;
 8002b16:	f105 0901 	add.w	r9, r5, #1
		n_dir = N_ROOTDIR * 32 / SS(fs);
		break;
 8002b1a:	2402      	movs	r4, #2
 8002b1c:	e00e      	b.n	8002b3c <f_mkfs+0x574>
	if (n_clst >= 0xFFF5) fmt = FS_FAT32;

	/* Determine offset and size of FAT structure */
	switch (fmt) {
	case FS_FAT12:
		n_fat = ((n_clst * 3 + 1) / 2 + 3 + SS(fs) - 1) / SS(fs);
 8002b1e:	f04f 0b03 	mov.w	fp, #3
 8002b22:	fb0b fb03 	mul.w	fp, fp, r3
 8002b26:	f10b 0b01 	add.w	fp, fp, #1
 8002b2a:	ea4f 0b5b 	mov.w	fp, fp, lsr #1
 8002b2e:	f20b 2b02 	addw	fp, fp, #514	; 0x202
 8002b32:	ea4f 2b5b 	mov.w	fp, fp, lsr #9
		n_rsv = 1 + partition;
 8002b36:	f105 0901 	add.w	r9, r5, #1
		n_dir = N_ROOTDIR * 32 / SS(fs);
		break;
 8002b3a:	2401      	movs	r4, #1
	/* Determine offset and size of FAT structure */
	switch (fmt) {
	case FS_FAT12:
		n_fat = ((n_clst * 3 + 1) / 2 + 3 + SS(fs) - 1) / SS(fs);
		n_rsv = 1 + partition;
		n_dir = N_ROOTDIR * 32 / SS(fs);
 8002b3c:	f04f 0820 	mov.w	r8, #32
		break;
 8002b40:	e5b7      	b.n	80026b2 <f_mkfs+0xea>
		disk_write(drv, tbl, b_part+1, 1);
		disk_write(drv, tbl, b_part+7, 1);
	}

	return (disk_ioctl(drv, CTRL_SYNC, (void*)NULL) == RES_OK) ? FR_OK : FR_DISK_ERR;
}
 8002b42:	b007      	add	sp, #28
 8002b44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002b48:	0801ffd8 	.word	0x0801ffd8
 8002b4c:	00ffff00 	.word	0x00ffff00

08002b50 <f_gets>:
char* f_gets (
	char* buff,	/* Pointer to the string buffer to read */
	int len,	/* Size of string buffer */
	FIL* fil	/* Pointer to the file object */
)
{
 8002b50:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8002b54:	4606      	mov	r6, r0
 8002b56:	4690      	mov	r8, r2
	int i = 0;
	char *p = buff;
 8002b58:	4604      	mov	r4, r0
	char* buff,	/* Pointer to the string buffer to read */
	int len,	/* Size of string buffer */
	FIL* fil	/* Pointer to the file object */
)
{
	int i = 0;
 8002b5a:	2500      	movs	r5, #0
	char *p = buff;
	UINT rc;


	while (i < len - 1) {			/* Read bytes until buffer gets filled */
 8002b5c:	1e4f      	subs	r7, r1, #1
 8002b5e:	e00f      	b.n	8002b80 <f_gets+0x30>
		f_read(fil, p, 1, &rc);
 8002b60:	2201      	movs	r2, #1
 8002b62:	ab01      	add	r3, sp, #4
 8002b64:	4640      	mov	r0, r8
 8002b66:	4621      	mov	r1, r4
 8002b68:	f7fe ff28 	bl	80019bc <f_read>
		if (rc != 1) break;			/* Break when no data to read */
 8002b6c:	9b01      	ldr	r3, [sp, #4]
 8002b6e:	2b01      	cmp	r3, #1
 8002b70:	d108      	bne.n	8002b84 <f_gets+0x34>
#if _USE_STRFUNC >= 2
		if (*p == '\r') continue;	/* Strip '\r' */
 8002b72:	7823      	ldrb	r3, [r4, #0]
 8002b74:	2b0d      	cmp	r3, #13
 8002b76:	d003      	beq.n	8002b80 <f_gets+0x30>
#endif
		i++;
 8002b78:	3501      	adds	r5, #1
		if (*p++ == '\n') break;	/* Break when reached end of line */
 8002b7a:	3401      	adds	r4, #1
 8002b7c:	2b0a      	cmp	r3, #10
 8002b7e:	d001      	beq.n	8002b84 <f_gets+0x34>
	int i = 0;
	char *p = buff;
	UINT rc;


	while (i < len - 1) {			/* Read bytes until buffer gets filled */
 8002b80:	42bd      	cmp	r5, r7
 8002b82:	dbed      	blt.n	8002b60 <f_gets+0x10>
		if (*p == '\r') continue;	/* Strip '\r' */
#endif
		i++;
		if (*p++ == '\n') break;	/* Break when reached end of line */
	}
	*p = 0;
 8002b84:	2300      	movs	r3, #0
 8002b86:	7023      	strb	r3, [r4, #0]
	return i ? buff : NULL;			/* When no data read (eof or error), return with error. */
}
 8002b88:	429d      	cmp	r5, r3
 8002b8a:	bf14      	ite	ne
 8002b8c:	4630      	movne	r0, r6
 8002b8e:	4618      	moveq	r0, r3
 8002b90:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}

08002b94 <f_putc>:
	UINT bw;
	char c;


#if _USE_STRFUNC >= 2
	if (chr == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
 8002b94:	280a      	cmp	r0, #10
/*-----------------------------------------------------------------------*/
int f_putc (
	int chr,	/* A character to be output */
	FIL* fil	/* Pointer to the file object */
)
{
 8002b96:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8002b98:	4604      	mov	r4, r0
 8002b9a:	460d      	mov	r5, r1
	UINT bw;
	char c;


#if _USE_STRFUNC >= 2
	if (chr == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
 8002b9c:	d102      	bne.n	8002ba4 <f_putc+0x10>
 8002b9e:	200d      	movs	r0, #13
 8002ba0:	f7ff fff8 	bl	8002b94 <f_putc>
#endif
	if (!fil) {	/* Special value may be used to switch the destination to any other device */
 8002ba4:	b165      	cbz	r5, 8002bc0 <f_putc+0x2c>
	/*	put_console(chr);	*/
		return chr;
	}
	c = (char)chr;
 8002ba6:	a902      	add	r1, sp, #8
 8002ba8:	f801 4d05 	strb.w	r4, [r1, #-5]!
	f_write(fil, &c, 1, &bw);	/* Write a byte to the file */
 8002bac:	ab01      	add	r3, sp, #4
 8002bae:	4628      	mov	r0, r5
 8002bb0:	2201      	movs	r2, #1
 8002bb2:	f7fe ffbf 	bl	8001b34 <f_write>
	return bw ? chr : EOF;		/* Return the result */
 8002bb6:	9b01      	ldr	r3, [sp, #4]
 8002bb8:	2b00      	cmp	r3, #0
 8002bba:	bf08      	it	eq
 8002bbc:	f04f 34ff 	moveq.w	r4, #4294967295
}
 8002bc0:	4620      	mov	r0, r4
 8002bc2:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

08002bc4 <f_puts>:
/*-----------------------------------------------------------------------*/
int f_puts (
	const char* str,	/* Pointer to the string to be output */
	FIL* fil			/* Pointer to the file object */
)
{
 8002bc4:	b570      	push	{r4, r5, r6, lr}
 8002bc6:	4605      	mov	r5, r0
 8002bc8:	460e      	mov	r6, r1
	int n;


	for (n = 0; *str; str++, n++) {
 8002bca:	2400      	movs	r4, #0
 8002bcc:	e005      	b.n	8002bda <f_puts+0x16>
		if (f_putc(*str, fil) == EOF) return EOF;
 8002bce:	4631      	mov	r1, r6
 8002bd0:	f7ff ffe0 	bl	8002b94 <f_putc>
 8002bd4:	1c42      	adds	r2, r0, #1
 8002bd6:	d004      	beq.n	8002be2 <f_puts+0x1e>
)
{
	int n;


	for (n = 0; *str; str++, n++) {
 8002bd8:	3401      	adds	r4, #1
 8002bda:	5d28      	ldrb	r0, [r5, r4]
 8002bdc:	2800      	cmp	r0, #0
 8002bde:	d1f6      	bne.n	8002bce <f_puts+0xa>
 8002be0:	e000      	b.n	8002be4 <f_puts+0x20>
		if (f_putc(*str, fil) == EOF) return EOF;
 8002be2:	4604      	mov	r4, r0
	}
	return n;
}
 8002be4:	4620      	mov	r0, r4
 8002be6:	bd70      	pop	{r4, r5, r6, pc}

08002be8 <f_printf>:
int f_printf (
	FIL* fil,			/* Pointer to the file object */
	const char* str,	/* Pointer to the format string */
	...					/* Optional arguments... */
)
{
 8002be8:	b40e      	push	{r1, r2, r3}
 8002bea:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002bee:	b086      	sub	sp, #24
 8002bf0:	ab0d      	add	r3, sp, #52	; 0x34
 8002bf2:	f853 2b04 	ldr.w	r2, [r3], #4
 8002bf6:	4605      	mov	r5, r0
	int i, w, res, cc;


	va_start(arp, str);

	for (cc = res = 0; cc != EOF; res += cc) {
 8002bf8:	2000      	movs	r0, #0
	ULONG val;
	char s[16];
	int i, w, res, cc;


	va_start(arp, str);
 8002bfa:	9301      	str	r3, [sp, #4]

	for (cc = res = 0; cc != EOF; res += cc) {
 8002bfc:	4606      	mov	r6, r0
		if (c != '%') {				/* Non escape character */
			cc = f_putc(c, fil);
			if (cc != EOF) cc = 1;
			continue;
		}
		w = f = 0;
 8002bfe:	4607      	mov	r7, r0
		c = *str++;
		if (c == '0') {				/* Flag: '0' padding */
			f = 1; c = *str++;
		}
		while (c >= '0' && c <= '9') {	/* Precision */
			w = w * 10 + (c - '0');
 8002c00:	f04f 080a 	mov.w	r8, #10
 8002c04:	e000      	b.n	8002c08 <f_printf+0x20>
	int i, w, res, cc;


	va_start(arp, str);

	for (cc = res = 0; cc != EOF; res += cc) {
 8002c06:	4622      	mov	r2, r4
		c = *str++;
 8002c08:	4614      	mov	r4, r2
 8002c0a:	f814 3b01 	ldrb.w	r3, [r4], #1
		if (c == 0) break;			/* End of string */
 8002c0e:	2b00      	cmp	r3, #0
 8002c10:	f000 8099 	beq.w	8002d46 <f_printf+0x15e>
		if (c != '%') {				/* Non escape character */
 8002c14:	2b25      	cmp	r3, #37	; 0x25
 8002c16:	d001      	beq.n	8002c1c <f_printf+0x34>
			cc = f_putc(c, fil);
 8002c18:	4618      	mov	r0, r3
 8002c1a:	e029      	b.n	8002c70 <f_printf+0x88>
			if (cc != EOF) cc = 1;
			continue;
		}
		w = f = 0;
		c = *str++;
 8002c1c:	7853      	ldrb	r3, [r2, #1]
		if (c == '0') {				/* Flag: '0' padding */
 8002c1e:	2b30      	cmp	r3, #48	; 0x30
 8002c20:	d002      	beq.n	8002c28 <f_printf+0x40>
			cc = f_putc(c, fil);
			if (cc != EOF) cc = 1;
			continue;
		}
		w = f = 0;
		c = *str++;
 8002c22:	1c94      	adds	r4, r2, #2
		if (c != '%') {				/* Non escape character */
			cc = f_putc(c, fil);
			if (cc != EOF) cc = 1;
			continue;
		}
		w = f = 0;
 8002c24:	2200      	movs	r2, #0
 8002c26:	e002      	b.n	8002c2e <f_printf+0x46>
		c = *str++;
		if (c == '0') {				/* Flag: '0' padding */
			f = 1; c = *str++;
 8002c28:	7893      	ldrb	r3, [r2, #2]
 8002c2a:	1cd4      	adds	r4, r2, #3
 8002c2c:	2201      	movs	r2, #1
		if (c != '%') {				/* Non escape character */
			cc = f_putc(c, fil);
			if (cc != EOF) cc = 1;
			continue;
		}
		w = f = 0;
 8002c2e:	f04f 0c00 	mov.w	ip, #0
 8002c32:	e003      	b.n	8002c3c <f_printf+0x54>
		c = *str++;
		if (c == '0') {				/* Flag: '0' padding */
			f = 1; c = *str++;
		}
		while (c >= '0' && c <= '9') {	/* Precision */
			w = w * 10 + (c - '0');
 8002c34:	fb08 1c0c 	mla	ip, r8, ip, r1
			c = *str++;
 8002c38:	f814 3b01 	ldrb.w	r3, [r4], #1
		w = f = 0;
		c = *str++;
		if (c == '0') {				/* Flag: '0' padding */
			f = 1; c = *str++;
		}
		while (c >= '0' && c <= '9') {	/* Precision */
 8002c3c:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8002c40:	fa5f f981 	uxtb.w	r9, r1
 8002c44:	f1b9 0f09 	cmp.w	r9, #9
 8002c48:	d9f4      	bls.n	8002c34 <f_printf+0x4c>
			w = w * 10 + (c - '0');
			c = *str++;
		}
		if (c == 'l') {				/* Prefix: Size is long int */
 8002c4a:	2b6c      	cmp	r3, #108	; 0x6c
			f |= 2; c = *str++;
 8002c4c:	bf04      	itt	eq
 8002c4e:	f814 3b01 	ldrbeq.w	r3, [r4], #1
 8002c52:	f042 0202 	orreq.w	r2, r2, #2
		}
		if (c == 's') {				/* Type is string */
 8002c56:	2b73      	cmp	r3, #115	; 0x73
 8002c58:	d104      	bne.n	8002c64 <f_printf+0x7c>
			cc = f_puts(va_arg(arp, char*), fil);
 8002c5a:	9b01      	ldr	r3, [sp, #4]
 8002c5c:	1d1a      	adds	r2, r3, #4
 8002c5e:	9201      	str	r2, [sp, #4]
 8002c60:	6818      	ldr	r0, [r3, #0]
 8002c62:	e068      	b.n	8002d36 <f_printf+0x14e>
			continue;
		}
		if (c == 'c') {				/* Type is character */
 8002c64:	2b63      	cmp	r3, #99	; 0x63
 8002c66:	d10d      	bne.n	8002c84 <f_printf+0x9c>
			cc = f_putc(va_arg(arp, int), fil);
 8002c68:	9b01      	ldr	r3, [sp, #4]
 8002c6a:	1d1a      	adds	r2, r3, #4
 8002c6c:	6818      	ldr	r0, [r3, #0]
 8002c6e:	9201      	str	r2, [sp, #4]
 8002c70:	4629      	mov	r1, r5
 8002c72:	f7ff ff8f 	bl	8002b94 <f_putc>
			if (cc != EOF) cc = 1;
 8002c76:	f1b0 3fff 	cmp.w	r0, #4294967295
 8002c7a:	bf0c      	ite	eq
 8002c7c:	f04f 30ff 	moveq.w	r0, #4294967295
 8002c80:	2001      	movne	r0, #1
 8002c82:	e05b      	b.n	8002d3c <f_printf+0x154>
			continue;
		}
		r = 0;
		if (c == 'd') r = 10;		/* Type is signed decimal */
 8002c84:	2b64      	cmp	r3, #100	; 0x64
 8002c86:	d005      	beq.n	8002c94 <f_printf+0xac>
		if (c == 'u') r = 10;		/* Type is unsigned decimal */
 8002c88:	2b75      	cmp	r3, #117	; 0x75
 8002c8a:	d003      	beq.n	8002c94 <f_printf+0xac>
		if (c == 'X') r = 16;		/* Type is unsigned hexdecimal */
 8002c8c:	2b58      	cmp	r3, #88	; 0x58
 8002c8e:	d15a      	bne.n	8002d46 <f_printf+0x15e>
 8002c90:	2010      	movs	r0, #16
 8002c92:	e000      	b.n	8002c96 <f_printf+0xae>
			if (cc != EOF) cc = 1;
			continue;
		}
		r = 0;
		if (c == 'd') r = 10;		/* Type is signed decimal */
		if (c == 'u') r = 10;		/* Type is unsigned decimal */
 8002c94:	200a      	movs	r0, #10
		if (c == 'X') r = 16;		/* Type is unsigned hexdecimal */
		if (r == 0) break;			/* Unknown type */
		if (f & 2) {				/* Get the value */
 8002c96:	f002 0e02 	and.w	lr, r2, #2
 8002c9a:	fa5f fe8e 	uxtb.w	lr, lr
 8002c9e:	9901      	ldr	r1, [sp, #4]
 8002ca0:	f1be 0f00 	cmp.w	lr, #0
 8002ca4:	d006      	beq.n	8002cb4 <f_printf+0xcc>
			val = (ULONG)va_arg(arp, long);
 8002ca6:	f101 0e04 	add.w	lr, r1, #4
 8002caa:	f8cd e004 	str.w	lr, [sp, #4]
 8002cae:	6809      	ldr	r1, [r1, #0]
		} else {
			val = (c == 'd') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int);
		}
		/* Put numeral string */
		if (c == 'd') {
 8002cb0:	2b64      	cmp	r3, #100	; 0x64
 8002cb2:	e004      	b.n	8002cbe <f_printf+0xd6>
		if (c == 'X') r = 16;		/* Type is unsigned hexdecimal */
		if (r == 0) break;			/* Unknown type */
		if (f & 2) {				/* Get the value */
			val = (ULONG)va_arg(arp, long);
		} else {
			val = (c == 'd') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int);
 8002cb4:	2b64      	cmp	r3, #100	; 0x64
 8002cb6:	f101 0304 	add.w	r3, r1, #4
 8002cba:	6809      	ldr	r1, [r1, #0]
 8002cbc:	9301      	str	r3, [sp, #4]
 8002cbe:	d104      	bne.n	8002cca <f_printf+0xe2>
		}
		/* Put numeral string */
		if (c == 'd') {
			if (val & 0x80000000) {
 8002cc0:	2900      	cmp	r1, #0
 8002cc2:	da02      	bge.n	8002cca <f_printf+0xe2>
				val = 0 - val;
 8002cc4:	4249      	negs	r1, r1
				f |= 4;
 8002cc6:	f042 0204 	orr.w	r2, r2, #4
			}
		}
		i = sizeof(s) - 1; s[i] = 0;
 8002cca:	f88d 7017 	strb.w	r7, [sp, #23]
 8002cce:	230f      	movs	r3, #15
		do {
			c = (UCHAR)(val % r + '0');
 8002cd0:	fbb1 fef0 	udiv	lr, r1, r0
 8002cd4:	fb00 111e 	mls	r1, r0, lr, r1
 8002cd8:	b2c9      	uxtb	r1, r1
 8002cda:	f101 0930 	add.w	r9, r1, #48	; 0x30
 8002cde:	fa5f f989 	uxtb.w	r9, r9
			if (c > '9') c += 7;
 8002ce2:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
 8002ce6:	d902      	bls.n	8002cee <f_printf+0x106>
 8002ce8:	3137      	adds	r1, #55	; 0x37
 8002cea:	fa5f f981 	uxtb.w	r9, r1
			s[--i] = c;
 8002cee:	a902      	add	r1, sp, #8
 8002cf0:	3b01      	subs	r3, #1
 8002cf2:	f803 9001 	strb.w	r9, [r3, r1]
			val /= r;
 8002cf6:	4671      	mov	r1, lr
		} while (i && val);
 8002cf8:	b163      	cbz	r3, 8002d14 <f_printf+0x12c>
 8002cfa:	f1be 0f00 	cmp.w	lr, #0
 8002cfe:	d1e7      	bne.n	8002cd0 <f_printf+0xe8>
		if (i && (f & 4)) s[--i] = '-';
 8002d00:	f002 0104 	and.w	r1, r2, #4
 8002d04:	b2c9      	uxtb	r1, r1
 8002d06:	b129      	cbz	r1, 8002d14 <f_printf+0x12c>
 8002d08:	a806      	add	r0, sp, #24
 8002d0a:	3b01      	subs	r3, #1
 8002d0c:	18c1      	adds	r1, r0, r3
 8002d0e:	202d      	movs	r0, #45	; 0x2d
 8002d10:	f801 0c10 	strb.w	r0, [r1, #-16]
		w = sizeof(s) - 1 - w;
 8002d14:	f1cc 0c0f 	rsb	ip, ip, #15
		while (i && i > w) s[--i] = (f & 1) ? '0' : ' ';
 8002d18:	f002 0201 	and.w	r2, r2, #1
 8002d1c:	e006      	b.n	8002d2c <f_printf+0x144>
 8002d1e:	3b01      	subs	r3, #1
 8002d20:	2a00      	cmp	r2, #0
 8002d22:	bf0c      	ite	eq
 8002d24:	2020      	moveq	r0, #32
 8002d26:	2030      	movne	r0, #48	; 0x30
 8002d28:	a902      	add	r1, sp, #8
 8002d2a:	5458      	strb	r0, [r3, r1]
 8002d2c:	b10b      	cbz	r3, 8002d32 <f_printf+0x14a>
 8002d2e:	4563      	cmp	r3, ip
 8002d30:	dcf5      	bgt.n	8002d1e <f_printf+0x136>
		cc = f_puts(&s[i], fil);
 8002d32:	aa02      	add	r2, sp, #8
 8002d34:	18d0      	adds	r0, r2, r3
 8002d36:	4629      	mov	r1, r5
 8002d38:	f7ff ff44 	bl	8002bc4 <f_puts>
	int i, w, res, cc;


	va_start(arp, str);

	for (cc = res = 0; cc != EOF; res += cc) {
 8002d3c:	1c41      	adds	r1, r0, #1
 8002d3e:	4406      	add	r6, r0
 8002d40:	f47f af61 	bne.w	8002c06 <f_printf+0x1e>
 8002d44:	e005      	b.n	8002d52 <f_printf+0x16a>
		while (i && i > w) s[--i] = (f & 1) ? '0' : ' ';
		cc = f_puts(&s[i], fil);
	}

	va_end(arp);
	return (cc == EOF) ? cc : res;
 8002d46:	f1b0 3fff 	cmp.w	r0, #4294967295
 8002d4a:	bf14      	ite	ne
 8002d4c:	4630      	movne	r0, r6
 8002d4e:	f04f 30ff 	moveq.w	r0, #4294967295
}
 8002d52:	b006      	add	sp, #24
 8002d54:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002d58:	b003      	add	sp, #12
 8002d5a:	4770      	bx	lr

08002d5c <power_on>:
/* Power Control and interface-initialization (Platform dependent)       */
/*-----------------------------------------------------------------------*/

static
void power_on (void)
{
 8002d5c:	b570      	push	{r4, r5, r6, lr}
	SPI_InitTypeDef  SPI_InitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;
	volatile BYTE dummyread;

	/* Enable GPIO clock for CS */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_CS, ENABLE);
 8002d5e:	2004      	movs	r0, #4
/* Power Control and interface-initialization (Platform dependent)       */
/*-----------------------------------------------------------------------*/

static
void power_on (void)
{
 8002d60:	b088      	sub	sp, #32
	SPI_InitTypeDef  SPI_InitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;
	volatile BYTE dummyread;

	/* Enable GPIO clock for CS */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_CS, ENABLE);
 8002d62:	2101      	movs	r1, #1
 8002d64:	f001 fc84 	bl	8004670 <RCC_APB2PeriphClockCmd>
	/* Enable SPI clock, SPI1: APB2, SPI2: APB1 */
	RCC_APBPeriphClockCmd_SPI_SD(RCC_APBPeriph_SPI_SD, ENABLE);
 8002d68:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8002d6c:	2101      	movs	r1, #1
 8002d6e:	f001 fc7f 	bl	8004670 <RCC_APB2PeriphClockCmd>

	card_power(1);
	socket_wp_cp_init();

	for (Timer1 = 25; Timer1; );	/* Wait for 250ms */
 8002d72:	4b2f      	ldr	r3, [pc, #188]	; (8002e30 <power_on+0xd4>)
 8002d74:	2219      	movs	r2, #25
 8002d76:	601a      	str	r2, [r3, #0]
 8002d78:	681c      	ldr	r4, [r3, #0]
 8002d7a:	2c00      	cmp	r4, #0
 8002d7c:	d1fc      	bne.n	8002d78 <power_on+0x1c>

	/* Configure I/O for Flash Chip select */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_CS;
 8002d7e:	2510      	movs	r5, #16
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002d80:	2603      	movs	r6, #3
	GPIO_Init(GPIO_CS, &GPIO_InitStructure);
 8002d82:	482c      	ldr	r0, [pc, #176]	; (8002e34 <power_on+0xd8>)
 8002d84:	a902      	add	r1, sp, #8
	socket_wp_cp_init();

	for (Timer1 = 25; Timer1; );	/* Wait for 250ms */

	/* Configure I/O for Flash Chip select */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_CS;
 8002d86:	f8ad 5008 	strh.w	r5, [sp, #8]
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
 8002d8a:	f88d 500b 	strb.w	r5, [sp, #11]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002d8e:	f88d 600a 	strb.w	r6, [sp, #10]
	GPIO_Init(GPIO_CS, &GPIO_InitStructure);
 8002d92:	f000 ff98 	bl	8003cc6 <GPIO_Init>

	/* Deselect the Card: Chip Select high */
	DESELECT();
 8002d96:	4827      	ldr	r0, [pc, #156]	; (8002e34 <power_on+0xd8>)
 8002d98:	4629      	mov	r1, r5
 8002d9a:	f001 f802 	bl	8003da2 <GPIO_SetBits>

	/* Configure SPI pins: SCK and MOSI with default alternate function (not remapped) push-pull */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_SPI_SD_SCK | GPIO_Pin_SPI_SD_MOSI;
 8002d9e:	23a0      	movs	r3, #160	; 0xa0
 8002da0:	f8ad 3008 	strh.w	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
	GPIO_Init(GPIO_SPI_SD, &GPIO_InitStructure);
 8002da4:	4823      	ldr	r0, [pc, #140]	; (8002e34 <power_on+0xd8>)
	DESELECT();

	/* Configure SPI pins: SCK and MOSI with default alternate function (not remapped) push-pull */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_SPI_SD_SCK | GPIO_Pin_SPI_SD_MOSI;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
 8002da6:	2318      	movs	r3, #24
	GPIO_Init(GPIO_SPI_SD, &GPIO_InitStructure);
 8002da8:	a902      	add	r1, sp, #8
	DESELECT();

	/* Configure SPI pins: SCK and MOSI with default alternate function (not remapped) push-pull */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_SPI_SD_SCK | GPIO_Pin_SPI_SD_MOSI;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
 8002daa:	f88d 300b 	strb.w	r3, [sp, #11]
	/* Deselect the Card: Chip Select high */
	DESELECT();

	/* Configure SPI pins: SCK and MOSI with default alternate function (not remapped) push-pull */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_SPI_SD_SCK | GPIO_Pin_SPI_SD_MOSI;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002dae:	f88d 600a 	strb.w	r6, [sp, #10]
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
	GPIO_Init(GPIO_SPI_SD, &GPIO_InitStructure);
 8002db2:	f000 ff88 	bl	8003cc6 <GPIO_Init>
	/* Configure MISO as Input with internal pull-up */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_SPI_SD_MISO;
 8002db6:	2340      	movs	r3, #64	; 0x40
 8002db8:	f8ad 3008 	strh.w	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
	GPIO_Init(GPIO_SPI_SD, &GPIO_InitStructure);
 8002dbc:	481d      	ldr	r0, [pc, #116]	; (8002e34 <power_on+0xd8>)
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
	GPIO_Init(GPIO_SPI_SD, &GPIO_InitStructure);
	/* Configure MISO as Input with internal pull-up */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_SPI_SD_MISO;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
 8002dbe:	2348      	movs	r3, #72	; 0x48
	GPIO_Init(GPIO_SPI_SD, &GPIO_InitStructure);
 8002dc0:	a902      	add	r1, sp, #8
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
	GPIO_Init(GPIO_SPI_SD, &GPIO_InitStructure);
	/* Configure MISO as Input with internal pull-up */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_SPI_SD_MISO;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
 8002dc2:	f88d 300b 	strb.w	r3, [sp, #11]
	GPIO_Init(GPIO_SPI_SD, &GPIO_InitStructure);
 8002dc6:	f000 ff7e 	bl	8003cc6 <GPIO_Init>

	/* SPI configuration */
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 8002dca:	f44f 7382 	mov.w	r3, #260	; 0x104
 8002dce:	f8ad 300e 	strh.w	r3, [sp, #14]
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 8002dd2:	f44f 7300 	mov.w	r3, #512	; 0x200
 8002dd6:	f8ad 3016 	strh.w	r3, [sp, #22]
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256; // 72000kHz/256=281kHz < 400kHz
 8002dda:	2338      	movs	r3, #56	; 0x38
 8002ddc:	f8ad 3018 	strh.w	r3, [sp, #24]
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;

	SPI_Init(SPI_SD, &SPI_InitStructure);
 8002de0:	4815      	ldr	r0, [pc, #84]	; (8002e38 <power_on+0xdc>)
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256; // 72000kHz/256=281kHz < 400kHz
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
 8002de2:	2307      	movs	r3, #7

	SPI_Init(SPI_SD, &SPI_InitStructure);
 8002de4:	a903      	add	r1, sp, #12
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256; // 72000kHz/256=281kHz < 400kHz
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
 8002de6:	f8ad 301c 	strh.w	r3, [sp, #28]
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_SPI_SD_MISO;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
	GPIO_Init(GPIO_SPI_SD, &GPIO_InitStructure);

	/* SPI configuration */
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 8002dea:	f8ad 400c 	strh.w	r4, [sp, #12]
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 8002dee:	f8ad 4010 	strh.w	r4, [sp, #16]
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 8002df2:	f8ad 4012 	strh.w	r4, [sp, #18]
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 8002df6:	f8ad 4014 	strh.w	r4, [sp, #20]
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256; // 72000kHz/256=281kHz < 400kHz
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
 8002dfa:	f8ad 401a 	strh.w	r4, [sp, #26]
	SPI_InitStructure.SPI_CRCPolynomial = 7;

	SPI_Init(SPI_SD, &SPI_InitStructure);
 8002dfe:	f001 fdb3 	bl	8004968 <SPI_Init>
	SPI_CalculateCRC(SPI_SD, DISABLE);
 8002e02:	480d      	ldr	r0, [pc, #52]	; (8002e38 <power_on+0xdc>)
 8002e04:	4621      	mov	r1, r4
 8002e06:	f001 febe 	bl	8004b86 <SPI_CalculateCRC>
	SPI_Cmd(SPI_SD, ENABLE);
 8002e0a:	480b      	ldr	r0, [pc, #44]	; (8002e38 <power_on+0xdc>)
 8002e0c:	2101      	movs	r1, #1
 8002e0e:	f001 fe58 	bl	8004ac2 <SPI_Cmd>

	/* drain SPI */
	while (SPI_I2S_GetFlagStatus(SPI_SD, SPI_I2S_FLAG_TXE) == RESET) { ; }
 8002e12:	4809      	ldr	r0, [pc, #36]	; (8002e38 <power_on+0xdc>)
 8002e14:	2102      	movs	r1, #2
 8002e16:	f001 fed9 	bl	8004bcc <SPI_I2S_GetFlagStatus>
 8002e1a:	2800      	cmp	r0, #0
 8002e1c:	d0f9      	beq.n	8002e12 <power_on+0xb6>
	dummyread = SPI_I2S_ReceiveData(SPI_SD);
 8002e1e:	4806      	ldr	r0, [pc, #24]	; (8002e38 <power_on+0xdc>)
 8002e20:	f001 fe82 	bl	8004b28 <SPI_I2S_ReceiveData>
 8002e24:	b2c0      	uxtb	r0, r0
 8002e26:	f88d 0007 	strb.w	r0, [sp, #7]

#ifdef STM32_SD_USE_DMA
	/* enable DMA clock */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
#endif
}
 8002e2a:	b008      	add	sp, #32
 8002e2c:	bd70      	pop	{r4, r5, r6, pc}
 8002e2e:	bf00      	nop
 8002e30:	20000b2c 	.word	0x20000b2c
 8002e34:	40010800 	.word	0x40010800
 8002e38:	40013000 	.word	0x40013000

08002e3c <stm32_spi_rw>:

/*-----------------------------------------------------------------------*/
/* Transmit/Receive a byte to MMC via SPI  (Platform dependent)          */
/*-----------------------------------------------------------------------*/
static BYTE stm32_spi_rw( BYTE out )
{
 8002e3c:	4601      	mov	r1, r0
 8002e3e:	b508      	push	{r3, lr}
	/* Loop while DR register in not empty */
	/// not needed: while (SPI_I2S_GetFlagStatus(SPI_SD, SPI_I2S_FLAG_TXE) == RESET) { ; }

	/* Send byte through the SPI peripheral */
	SPI_I2S_SendData(SPI_SD, out);
 8002e40:	4806      	ldr	r0, [pc, #24]	; (8002e5c <stm32_spi_rw+0x20>)
 8002e42:	f001 fe6f 	bl	8004b24 <SPI_I2S_SendData>

	/* Wait to receive a byte */
	while (SPI_I2S_GetFlagStatus(SPI_SD, SPI_I2S_FLAG_RXNE) == RESET) { ; }
 8002e46:	4805      	ldr	r0, [pc, #20]	; (8002e5c <stm32_spi_rw+0x20>)
 8002e48:	2101      	movs	r1, #1
 8002e4a:	f001 febf 	bl	8004bcc <SPI_I2S_GetFlagStatus>
 8002e4e:	2800      	cmp	r0, #0
 8002e50:	d0f9      	beq.n	8002e46 <stm32_spi_rw+0xa>

	/* Return the byte read from the SPI bus */
	return SPI_I2S_ReceiveData(SPI_SD);
 8002e52:	4802      	ldr	r0, [pc, #8]	; (8002e5c <stm32_spi_rw+0x20>)
 8002e54:	f001 fe68 	bl	8004b28 <SPI_I2S_ReceiveData>
}
 8002e58:	b2c0      	uxtb	r0, r0
 8002e5a:	bd08      	pop	{r3, pc}
 8002e5c:	40013000 	.word	0x40013000

08002e60 <rcvr_spi>:
/*-----------------------------------------------------------------------*/

static
BYTE rcvr_spi (void)
{
	return stm32_spi_rw(0xff);
 8002e60:	20ff      	movs	r0, #255	; 0xff
 8002e62:	f7ff bfeb 	b.w	8002e3c <stm32_spi_rw>

08002e66 <wait_ready>:
/* Wait for card ready                                                   */
/*-----------------------------------------------------------------------*/

static
BYTE wait_ready (void)
{
 8002e66:	b510      	push	{r4, lr}
	BYTE res;


	Timer2 = 50;	/* Wait for ready in timeout of 500ms */
 8002e68:	4c06      	ldr	r4, [pc, #24]	; (8002e84 <wait_ready+0x1e>)
 8002e6a:	2332      	movs	r3, #50	; 0x32
 8002e6c:	6063      	str	r3, [r4, #4]
	rcvr_spi();
 8002e6e:	f7ff fff7 	bl	8002e60 <rcvr_spi>
	do
		res = rcvr_spi();
 8002e72:	f7ff fff5 	bl	8002e60 <rcvr_spi>
	while ((res != 0xFF) && Timer2);
 8002e76:	28ff      	cmp	r0, #255	; 0xff
 8002e78:	d002      	beq.n	8002e80 <wait_ready+0x1a>
 8002e7a:	6863      	ldr	r3, [r4, #4]
 8002e7c:	2b00      	cmp	r3, #0
 8002e7e:	d1f8      	bne.n	8002e72 <wait_ready+0xc>

	return res;
}
 8002e80:	bd10      	pop	{r4, pc}
 8002e82:	bf00      	nop
 8002e84:	20000b2c 	.word	0x20000b2c

08002e88 <release_spi>:
/* Deselect the card and release SPI bus                                 */
/*-----------------------------------------------------------------------*/

static
void release_spi (void)
{
 8002e88:	b508      	push	{r3, lr}
	DESELECT();
 8002e8a:	4804      	ldr	r0, [pc, #16]	; (8002e9c <release_spi+0x14>)
 8002e8c:	2110      	movs	r1, #16
 8002e8e:	f000 ff88 	bl	8003da2 <GPIO_SetBits>
	rcvr_spi();
}
 8002e92:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

static
void release_spi (void)
{
	DESELECT();
	rcvr_spi();
 8002e96:	f7ff bfe3 	b.w	8002e60 <rcvr_spi>
 8002e9a:	bf00      	nop
 8002e9c:	40010800 	.word	0x40010800

08002ea0 <power_off>:
#endif
}

static
void power_off (void)
{
 8002ea0:	b507      	push	{r0, r1, r2, lr}
	GPIO_InitTypeDef GPIO_InitStructure;

	if (!(Stat & STA_NOINIT)) {
 8002ea2:	4b14      	ldr	r3, [pc, #80]	; (8002ef4 <power_off+0x54>)
 8002ea4:	781b      	ldrb	r3, [r3, #0]
 8002ea6:	07db      	lsls	r3, r3, #31
 8002ea8:	d407      	bmi.n	8002eba <power_off+0x1a>
		SELECT();
 8002eaa:	2110      	movs	r1, #16
 8002eac:	4812      	ldr	r0, [pc, #72]	; (8002ef8 <power_off+0x58>)
 8002eae:	f000 ff7a 	bl	8003da6 <GPIO_ResetBits>
		wait_ready();
 8002eb2:	f7ff ffd8 	bl	8002e66 <wait_ready>
		release_spi();
 8002eb6:	f7ff ffe7 	bl	8002e88 <release_spi>
	}

	SPI_I2S_DeInit(SPI_SD);
 8002eba:	4810      	ldr	r0, [pc, #64]	; (8002efc <power_off+0x5c>)
 8002ebc:	f001 fd22 	bl	8004904 <SPI_I2S_DeInit>
	SPI_Cmd(SPI_SD, DISABLE);
 8002ec0:	480e      	ldr	r0, [pc, #56]	; (8002efc <power_off+0x5c>)
 8002ec2:	2100      	movs	r1, #0
 8002ec4:	f001 fdfd 	bl	8004ac2 <SPI_Cmd>
	RCC_APBPeriphClockCmd_SPI_SD(RCC_APBPeriph_SPI_SD, DISABLE);
 8002ec8:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8002ecc:	2100      	movs	r1, #0
 8002ece:	f001 fbcf 	bl	8004670 <RCC_APB2PeriphClockCmd>

	/* All SPI-Pins to input with weak internal pull-downs */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_SPI_SD_SCK | GPIO_Pin_SPI_SD_MISO | GPIO_Pin_SPI_SD_MOSI;
 8002ed2:	23e0      	movs	r3, #224	; 0xe0
 8002ed4:	f8ad 3004 	strh.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPD;
	GPIO_Init(GPIO_SPI_SD, &GPIO_InitStructure);
 8002ed8:	4807      	ldr	r0, [pc, #28]	; (8002ef8 <power_off+0x58>)
	SPI_Cmd(SPI_SD, DISABLE);
	RCC_APBPeriphClockCmd_SPI_SD(RCC_APBPeriph_SPI_SD, DISABLE);

	/* All SPI-Pins to input with weak internal pull-downs */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_SPI_SD_SCK | GPIO_Pin_SPI_SD_MISO | GPIO_Pin_SPI_SD_MOSI;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPD;
 8002eda:	2328      	movs	r3, #40	; 0x28
	GPIO_Init(GPIO_SPI_SD, &GPIO_InitStructure);
 8002edc:	a901      	add	r1, sp, #4
	SPI_Cmd(SPI_SD, DISABLE);
	RCC_APBPeriphClockCmd_SPI_SD(RCC_APBPeriph_SPI_SD, DISABLE);

	/* All SPI-Pins to input with weak internal pull-downs */
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_SPI_SD_SCK | GPIO_Pin_SPI_SD_MISO | GPIO_Pin_SPI_SD_MOSI;
	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPD;
 8002ede:	f88d 3007 	strb.w	r3, [sp, #7]
	GPIO_Init(GPIO_SPI_SD, &GPIO_InitStructure);
 8002ee2:	f000 fef0 	bl	8003cc6 <GPIO_Init>

	card_power(0);

	Stat |= STA_NOINIT;		/* Set STA_NOINIT */
 8002ee6:	4b03      	ldr	r3, [pc, #12]	; (8002ef4 <power_off+0x54>)
 8002ee8:	781a      	ldrb	r2, [r3, #0]
 8002eea:	f042 0201 	orr.w	r2, r2, #1
 8002eee:	701a      	strb	r2, [r3, #0]
}
 8002ef0:	bd0e      	pop	{r1, r2, r3, pc}
 8002ef2:	bf00      	nop
 8002ef4:	2000006c 	.word	0x2000006c
 8002ef8:	40010800 	.word	0x40010800
 8002efc:	40013000 	.word	0x40013000

08002f00 <send_cmd>:
static
BYTE send_cmd (
	BYTE cmd,		/* Command byte */
	DWORD arg		/* Argument */
)
{
 8002f00:	b538      	push	{r3, r4, r5, lr}
 8002f02:	460d      	mov	r5, r1
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequence of CMD55-CMD<n> */
 8002f04:	0601      	lsls	r1, r0, #24
static
BYTE send_cmd (
	BYTE cmd,		/* Command byte */
	DWORD arg		/* Argument */
)
{
 8002f06:	4604      	mov	r4, r0
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequence of CMD55-CMD<n> */
 8002f08:	d507      	bpl.n	8002f1a <send_cmd+0x1a>
		cmd &= 0x7F;
		res = send_cmd(CMD55, 0);
 8002f0a:	2077      	movs	r0, #119	; 0x77
 8002f0c:	2100      	movs	r1, #0
 8002f0e:	f7ff fff7 	bl	8002f00 <send_cmd>
		if (res > 1) return res;
 8002f12:	2801      	cmp	r0, #1
 8002f14:	d837      	bhi.n	8002f86 <send_cmd+0x86>
{
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequence of CMD55-CMD<n> */
		cmd &= 0x7F;
 8002f16:	f004 047f 	and.w	r4, r4, #127	; 0x7f
		res = send_cmd(CMD55, 0);
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	DESELECT();
 8002f1a:	2110      	movs	r1, #16
 8002f1c:	481a      	ldr	r0, [pc, #104]	; (8002f88 <send_cmd+0x88>)
 8002f1e:	f000 ff40 	bl	8003da2 <GPIO_SetBits>
	SELECT();
 8002f22:	2110      	movs	r1, #16
 8002f24:	4818      	ldr	r0, [pc, #96]	; (8002f88 <send_cmd+0x88>)
 8002f26:	f000 ff3e 	bl	8003da6 <GPIO_ResetBits>
	if (wait_ready() != 0xFF) {
 8002f2a:	f7ff ff9c 	bl	8002e66 <wait_ready>
 8002f2e:	28ff      	cmp	r0, #255	; 0xff
 8002f30:	d128      	bne.n	8002f84 <send_cmd+0x84>
		return 0xFF;
	}

	/* Send command packet */
	xmit_spi(cmd);						/* Start + Command index */
 8002f32:	4620      	mov	r0, r4
 8002f34:	f7ff ff82 	bl	8002e3c <stm32_spi_rw>
	xmit_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
 8002f38:	0e28      	lsrs	r0, r5, #24
 8002f3a:	f7ff ff7f 	bl	8002e3c <stm32_spi_rw>
	xmit_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
 8002f3e:	f3c5 4007 	ubfx	r0, r5, #16, #8
 8002f42:	f7ff ff7b 	bl	8002e3c <stm32_spi_rw>
	xmit_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
 8002f46:	f3c5 2007 	ubfx	r0, r5, #8, #8
 8002f4a:	f7ff ff77 	bl	8002e3c <stm32_spi_rw>
	xmit_spi((BYTE)arg);				/* Argument[7..0] */
 8002f4e:	b2e8      	uxtb	r0, r5
 8002f50:	f7ff ff74 	bl	8002e3c <stm32_spi_rw>
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
 8002f54:	2c40      	cmp	r4, #64	; 0x40
 8002f56:	d004      	beq.n	8002f62 <send_cmd+0x62>
	xmit_spi(cmd);						/* Start + Command index */
	xmit_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
	xmit_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xmit_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
 8002f58:	2c48      	cmp	r4, #72	; 0x48
 8002f5a:	bf0c      	ite	eq
 8002f5c:	2087      	moveq	r0, #135	; 0x87
 8002f5e:	2001      	movne	r0, #1
 8002f60:	e000      	b.n	8002f64 <send_cmd+0x64>
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
 8002f62:	2095      	movs	r0, #149	; 0x95
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
	xmit_spi(n);
 8002f64:	f7ff ff6a 	bl	8002e3c <stm32_spi_rw>

	/* Receive command response */
	if (cmd == CMD12) rcvr_spi();		/* Skip a stuff byte when stop reading */
 8002f68:	2c4c      	cmp	r4, #76	; 0x4c
 8002f6a:	d101      	bne.n	8002f70 <send_cmd+0x70>
 8002f6c:	f7ff ff78 	bl	8002e60 <rcvr_spi>
	xmit_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xmit_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
 8002f70:	240a      	movs	r4, #10
	/* Receive command response */
	if (cmd == CMD12) rcvr_spi();		/* Skip a stuff byte when stop reading */

	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do
		res = rcvr_spi();
 8002f72:	f7ff ff75 	bl	8002e60 <rcvr_spi>
	while ((res & 0x80) && --n);
 8002f76:	0602      	lsls	r2, r0, #24
 8002f78:	d505      	bpl.n	8002f86 <send_cmd+0x86>
 8002f7a:	3c01      	subs	r4, #1
 8002f7c:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 8002f80:	d1f7      	bne.n	8002f72 <send_cmd+0x72>
 8002f82:	bd38      	pop	{r3, r4, r5, pc}

	/* Select the card and wait for ready */
	DESELECT();
	SELECT();
	if (wait_ready() != 0xFF) {
		return 0xFF;
 8002f84:	20ff      	movs	r0, #255	; 0xff
	do
		res = rcvr_spi();
	while ((res & 0x80) && --n);

	return res;			/* Return with the response value */
}
 8002f86:	bd38      	pop	{r3, r4, r5, pc}
 8002f88:	40010800 	.word	0x40010800

08002f8c <rcvr_datablock>:
)
{
	BYTE token;


	Timer1 = 10;
 8002f8c:	4b16      	ldr	r3, [pc, #88]	; (8002fe8 <rcvr_datablock+0x5c>)
 8002f8e:	220a      	movs	r2, #10
static
BOOL rcvr_datablock (
	BYTE *buff,			/* Data buffer to store received data */
	UINT btr			/* Byte count (must be multiple of 4) */
)
{
 8002f90:	b570      	push	{r4, r5, r6, lr}
 8002f92:	4604      	mov	r4, r0
 8002f94:	460e      	mov	r6, r1
	BYTE token;


	Timer1 = 10;
 8002f96:	601a      	str	r2, [r3, #0]
	do {							/* Wait for data packet in timeout of 100ms */
		token = rcvr_spi();
	} while ((token == 0xFF) && Timer1);
 8002f98:	461d      	mov	r5, r3
	BYTE token;


	Timer1 = 10;
	do {							/* Wait for data packet in timeout of 100ms */
		token = rcvr_spi();
 8002f9a:	f7ff ff61 	bl	8002e60 <rcvr_spi>
	} while ((token == 0xFF) && Timer1);
 8002f9e:	28ff      	cmp	r0, #255	; 0xff
 8002fa0:	d103      	bne.n	8002faa <rcvr_datablock+0x1e>
 8002fa2:	682b      	ldr	r3, [r5, #0]
 8002fa4:	2b00      	cmp	r3, #0
 8002fa6:	d1f8      	bne.n	8002f9a <rcvr_datablock+0xe>
 8002fa8:	e01b      	b.n	8002fe2 <rcvr_datablock+0x56>
	if(token != 0xFE) return FALSE;	/* If not valid data token, return with error */
 8002faa:	28fe      	cmp	r0, #254	; 0xfe
 8002fac:	d119      	bne.n	8002fe2 <rcvr_datablock+0x56>
/*-----------------------------------------------------------------------*/
/* Receive a data packet from MMC                                        */
/*-----------------------------------------------------------------------*/

static
BOOL rcvr_datablock (
 8002fae:	19a5      	adds	r5, r4, r6

#ifdef STM32_SD_USE_DMA
	stm32_dma_transfer( TRUE, buff, btr );
#else
	do {							/* Receive the data block into buffer */
		rcvr_spi_m(buff++);
 8002fb0:	20ff      	movs	r0, #255	; 0xff
 8002fb2:	f7ff ff43 	bl	8002e3c <stm32_spi_rw>
 8002fb6:	7020      	strb	r0, [r4, #0]
		rcvr_spi_m(buff++);
 8002fb8:	20ff      	movs	r0, #255	; 0xff
 8002fba:	f7ff ff3f 	bl	8002e3c <stm32_spi_rw>
 8002fbe:	7060      	strb	r0, [r4, #1]
		rcvr_spi_m(buff++);
 8002fc0:	20ff      	movs	r0, #255	; 0xff
 8002fc2:	f7ff ff3b 	bl	8002e3c <stm32_spi_rw>
 8002fc6:	70a0      	strb	r0, [r4, #2]
		rcvr_spi_m(buff++);
 8002fc8:	20ff      	movs	r0, #255	; 0xff
 8002fca:	f7ff ff37 	bl	8002e3c <stm32_spi_rw>
 8002fce:	70e0      	strb	r0, [r4, #3]
/*-----------------------------------------------------------------------*/
/* Receive a data packet from MMC                                        */
/*-----------------------------------------------------------------------*/

static
BOOL rcvr_datablock (
 8002fd0:	3404      	adds	r4, #4
	do {							/* Receive the data block into buffer */
		rcvr_spi_m(buff++);
		rcvr_spi_m(buff++);
		rcvr_spi_m(buff++);
		rcvr_spi_m(buff++);
	} while (btr -= 4);
 8002fd2:	42a5      	cmp	r5, r4
 8002fd4:	d1ec      	bne.n	8002fb0 <rcvr_datablock+0x24>
#endif /* STM32_SD_USE_DMA */

	rcvr_spi();						/* Discard CRC */
 8002fd6:	f7ff ff43 	bl	8002e60 <rcvr_spi>
	rcvr_spi();
 8002fda:	f7ff ff41 	bl	8002e60 <rcvr_spi>
 8002fde:	2001      	movs	r0, #1
 8002fe0:	bd70      	pop	{r4, r5, r6, pc}

	Timer1 = 10;
	do {							/* Wait for data packet in timeout of 100ms */
		token = rcvr_spi();
	} while ((token == 0xFF) && Timer1);
	if(token != 0xFE) return FALSE;	/* If not valid data token, return with error */
 8002fe2:	2000      	movs	r0, #0

	rcvr_spi();						/* Discard CRC */
	rcvr_spi();

	return TRUE;					/* Return with success */
}
 8002fe4:	bd70      	pop	{r4, r5, r6, pc}
 8002fe6:	bf00      	nop
 8002fe8:	20000b2c 	.word	0x20000b2c

08002fec <xmit_datablock.part.4>:
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

#if _FS_READONLY == 0
static
BOOL xmit_datablock (
 8002fec:	b538      	push	{r3, r4, r5, lr}
 8002fee:	4605      	mov	r5, r0
 8002ff0:	2400      	movs	r4, #0
#ifdef STM32_SD_USE_DMA
		stm32_dma_transfer( FALSE, buff, 512 );
#else
		wc = 0;
		do {							/* Xmit the 512 byte data block to MMC */
			xmit_spi(*buff++);
 8002ff2:	5d28      	ldrb	r0, [r5, r4]
 8002ff4:	f7ff ff22 	bl	8002e3c <stm32_spi_rw>
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

#if _FS_READONLY == 0
static
BOOL xmit_datablock (
 8002ff8:	192b      	adds	r3, r5, r4
		stm32_dma_transfer( FALSE, buff, 512 );
#else
		wc = 0;
		do {							/* Xmit the 512 byte data block to MMC */
			xmit_spi(*buff++);
			xmit_spi(*buff++);
 8002ffa:	7858      	ldrb	r0, [r3, #1]
 8002ffc:	3402      	adds	r4, #2
 8002ffe:	f7ff ff1d 	bl	8002e3c <stm32_spi_rw>
		} while (--wc);
 8003002:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
 8003006:	d1f4      	bne.n	8002ff2 <xmit_datablock.part.4+0x6>
#endif /* STM32_SD_USE_DMA */

		xmit_spi(0xFF);					/* CRC (Dummy) */
 8003008:	20ff      	movs	r0, #255	; 0xff
 800300a:	f7ff ff17 	bl	8002e3c <stm32_spi_rw>
		xmit_spi(0xFF);
 800300e:	20ff      	movs	r0, #255	; 0xff
 8003010:	f7ff ff14 	bl	8002e3c <stm32_spi_rw>
		resp = rcvr_spi();				/* Receive data response */
 8003014:	f7ff ff24 	bl	8002e60 <rcvr_spi>
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
 8003018:	f000 001f 	and.w	r0, r0, #31
			return FALSE;
	}

	return TRUE;
}
 800301c:	f1b0 0e05 	subs.w	lr, r0, #5
 8003020:	f1de 0000 	rsbs	r0, lr, #0
 8003024:	eb50 000e 	adcs.w	r0, r0, lr
 8003028:	bd38      	pop	{r3, r4, r5, pc}

0800302a <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive number (0) */
)
{
 800302a:	b573      	push	{r0, r1, r4, r5, r6, lr}
	BYTE n, cmd, ty, ocr[4];

	if (drv) return STA_NOINIT;			/* Supports only single drive */
 800302c:	2800      	cmp	r0, #0
 800302e:	f040 8098 	bne.w	8003162 <disk_initialize+0x138>
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
 8003032:	4b4d      	ldr	r3, [pc, #308]	; (8003168 <disk_initialize+0x13e>)
 8003034:	781a      	ldrb	r2, [r3, #0]
 8003036:	f002 0202 	and.w	r2, r2, #2
 800303a:	b2d2      	uxtb	r2, r2
 800303c:	b102      	cbz	r2, 8003040 <disk_initialize+0x16>
 800303e:	e08e      	b.n	800315e <disk_initialize+0x134>

	power_on();							/* Force socket power on and initialize interface */
 8003040:	f7ff fe8c 	bl	8002d5c <power_on>

static void interface_speed( enum speed_setting speed )
{
	DWORD tmp;

	tmp = SPI_SD->CR1;
 8003044:	4b49      	ldr	r3, [pc, #292]	; (800316c <disk_initialize+0x142>)
		tmp = ( tmp | SPI_BaudRatePrescaler_256 );
	} else {
		/* Set fast clock (depends on the CSD) */
		tmp = ( tmp & ~SPI_BaudRatePrescaler_256 ) | SPI_BaudRatePrescaler_SPI_SD;
	}
	SPI_SD->CR1 = tmp;
 8003046:	240a      	movs	r4, #10

static void interface_speed( enum speed_setting speed )
{
	DWORD tmp;

	tmp = SPI_SD->CR1;
 8003048:	881a      	ldrh	r2, [r3, #0]
 800304a:	b292      	uxth	r2, r2
	if ( speed == INTERFACE_SLOW ) {
		/* Set slow clock (100k-400k) */
		tmp = ( tmp | SPI_BaudRatePrescaler_256 );
 800304c:	f042 0238 	orr.w	r2, r2, #56	; 0x38
	} else {
		/* Set fast clock (depends on the CSD) */
		tmp = ( tmp & ~SPI_BaudRatePrescaler_256 ) | SPI_BaudRatePrescaler_SPI_SD;
	}
	SPI_SD->CR1 = tmp;
 8003050:	801a      	strh	r2, [r3, #0]
 8003052:	3c01      	subs	r4, #1
	if (drv) return STA_NOINIT;			/* Supports only single drive */
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */

	power_on();							/* Force socket power on and initialize interface */
	interface_speed(INTERFACE_SLOW);
	for (n = 10; n; n--) rcvr_spi();	/* 80 dummy clocks */
 8003054:	f7ff ff04 	bl	8002e60 <rcvr_spi>
 8003058:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 800305c:	d1f9      	bne.n	8003052 <disk_initialize+0x28>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
 800305e:	2040      	movs	r0, #64	; 0x40
 8003060:	4621      	mov	r1, r4
 8003062:	f7ff ff4d 	bl	8002f00 <send_cmd>
 8003066:	2801      	cmp	r0, #1
 8003068:	d001      	beq.n	800306e <disk_initialize+0x44>

	power_on();							/* Force socket power on and initialize interface */
	interface_speed(INTERFACE_SLOW);
	for (n = 10; n; n--) rcvr_spi();	/* 80 dummy clocks */

	ty = 0;
 800306a:	2400      	movs	r4, #0
 800306c:	e061      	b.n	8003132 <disk_initialize+0x108>
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		Timer1 = 100;						/* Initialization timeout of 1000 milliseconds */
 800306e:	4d40      	ldr	r5, [pc, #256]	; (8003170 <disk_initialize+0x146>)
 8003070:	2364      	movs	r3, #100	; 0x64
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDHC */
 8003072:	2048      	movs	r0, #72	; 0x48
 8003074:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
	interface_speed(INTERFACE_SLOW);
	for (n = 10; n; n--) rcvr_spi();	/* 80 dummy clocks */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		Timer1 = 100;						/* Initialization timeout of 1000 milliseconds */
 8003078:	602b      	str	r3, [r5, #0]
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDHC */
 800307a:	f7ff ff41 	bl	8002f00 <send_cmd>
 800307e:	2801      	cmp	r0, #1
 8003080:	d136      	bne.n	80030f0 <disk_initialize+0xc6>
			for (n = 0; n < 4; n++) ocr[n] = rcvr_spi();		/* Get trailing return value of R7 response */
 8003082:	f7ff feed 	bl	8002e60 <rcvr_spi>
 8003086:	ab01      	add	r3, sp, #4
 8003088:	5518      	strb	r0, [r3, r4]
 800308a:	3401      	adds	r4, #1
 800308c:	2c04      	cmp	r4, #4
 800308e:	d1f8      	bne.n	8003082 <disk_initialize+0x58>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at VDD range of 2.7-3.6V */
 8003090:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8003094:	2b01      	cmp	r3, #1
 8003096:	d1e8      	bne.n	800306a <disk_initialize+0x40>
 8003098:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800309c:	2baa      	cmp	r3, #170	; 0xaa
 800309e:	d1e4      	bne.n	800306a <disk_initialize+0x40>
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
 80030a0:	4c33      	ldr	r4, [pc, #204]	; (8003170 <disk_initialize+0x146>)
 80030a2:	6823      	ldr	r3, [r4, #0]
 80030a4:	b923      	cbnz	r3, 80030b0 <disk_initialize+0x86>
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
 80030a6:	4b32      	ldr	r3, [pc, #200]	; (8003170 <disk_initialize+0x146>)
 80030a8:	681b      	ldr	r3, [r3, #0]
 80030aa:	2b00      	cmp	r3, #0
 80030ac:	d0dd      	beq.n	800306a <disk_initialize+0x40>
 80030ae:	e007      	b.n	80030c0 <disk_initialize+0x96>
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		Timer1 = 100;						/* Initialization timeout of 1000 milliseconds */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDHC */
			for (n = 0; n < 4; n++) ocr[n] = rcvr_spi();		/* Get trailing return value of R7 response */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at VDD range of 2.7-3.6V */
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
 80030b0:	20e9      	movs	r0, #233	; 0xe9
 80030b2:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 80030b6:	f7ff ff23 	bl	8002f00 <send_cmd>
 80030ba:	2800      	cmp	r0, #0
 80030bc:	d1f1      	bne.n	80030a2 <disk_initialize+0x78>
 80030be:	e7f2      	b.n	80030a6 <disk_initialize+0x7c>
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
 80030c0:	207a      	movs	r0, #122	; 0x7a
 80030c2:	2100      	movs	r1, #0
 80030c4:	f7ff ff1c 	bl	8002f00 <send_cmd>
 80030c8:	2800      	cmp	r0, #0
 80030ca:	d1ce      	bne.n	800306a <disk_initialize+0x40>
 80030cc:	4604      	mov	r4, r0
					for (n = 0; n < 4; n++) ocr[n] = rcvr_spi();
 80030ce:	f7ff fec7 	bl	8002e60 <rcvr_spi>
 80030d2:	ab01      	add	r3, sp, #4
 80030d4:	5518      	strb	r0, [r3, r4]
 80030d6:	3401      	adds	r4, #1
 80030d8:	2c04      	cmp	r4, #4
 80030da:	d1f8      	bne.n	80030ce <disk_initialize+0xa4>
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;
 80030dc:	f89d 4004 	ldrb.w	r4, [sp, #4]
 80030e0:	f004 0440 	and.w	r4, r4, #64	; 0x40
 80030e4:	b2e4      	uxtb	r4, r4
 80030e6:	2c00      	cmp	r4, #0
 80030e8:	bf0c      	ite	eq
 80030ea:	2404      	moveq	r4, #4
 80030ec:	240c      	movne	r4, #12
 80030ee:	e020      	b.n	8003132 <disk_initialize+0x108>
				}
			}
		} else {							/* SDSC or MMC */
			if (send_cmd(ACMD41, 0) <= 1) 	{
 80030f0:	20e9      	movs	r0, #233	; 0xe9
 80030f2:	4621      	mov	r1, r4
 80030f4:	f7ff ff04 	bl	8002f00 <send_cmd>
				ty = CT_SD1; cmd = ACMD41;	/* SDSC */
 80030f8:	2801      	cmp	r0, #1
 80030fa:	bf8c      	ite	hi
 80030fc:	2401      	movhi	r4, #1
 80030fe:	2402      	movls	r4, #2
 8003100:	bf8c      	ite	hi
 8003102:	2641      	movhi	r6, #65	; 0x41
 8003104:	26e9      	movls	r6, #233	; 0xe9
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMC */
			}
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
 8003106:	682b      	ldr	r3, [r5, #0]
 8003108:	b923      	cbnz	r3, 8003114 <disk_initialize+0xea>
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
 800310a:	4b19      	ldr	r3, [pc, #100]	; (8003170 <disk_initialize+0x146>)
 800310c:	681b      	ldr	r3, [r3, #0]
 800310e:	2b00      	cmp	r3, #0
 8003110:	d0ab      	beq.n	800306a <disk_initialize+0x40>
 8003112:	e006      	b.n	8003122 <disk_initialize+0xf8>
			if (send_cmd(ACMD41, 0) <= 1) 	{
				ty = CT_SD1; cmd = ACMD41;	/* SDSC */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMC */
			}
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
 8003114:	4630      	mov	r0, r6
 8003116:	2100      	movs	r1, #0
 8003118:	f7ff fef2 	bl	8002f00 <send_cmd>
 800311c:	2800      	cmp	r0, #0
 800311e:	d1f2      	bne.n	8003106 <disk_initialize+0xdc>
 8003120:	e7f3      	b.n	800310a <disk_initialize+0xe0>
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
 8003122:	2050      	movs	r0, #80	; 0x50
 8003124:	f44f 7100 	mov.w	r1, #512	; 0x200
 8003128:	f7ff feea 	bl	8002f00 <send_cmd>
				ty = 0;
 800312c:	2800      	cmp	r0, #0
 800312e:	bf18      	it	ne
 8003130:	2400      	movne	r4, #0
		}
	}
	CardType = ty;
 8003132:	4b0f      	ldr	r3, [pc, #60]	; (8003170 <disk_initialize+0x146>)
 8003134:	721c      	strb	r4, [r3, #8]
	release_spi();
 8003136:	f7ff fea7 	bl	8002e88 <release_spi>

	if (ty) {			/* Initialization succeeded */
 800313a:	b16c      	cbz	r4, 8003158 <disk_initialize+0x12e>
		Stat &= ~STA_NOINIT;		/* Clear STA_NOINIT */
 800313c:	4b0a      	ldr	r3, [pc, #40]	; (8003168 <disk_initialize+0x13e>)
 800313e:	781a      	ldrb	r2, [r3, #0]
 8003140:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 8003144:	701a      	strb	r2, [r3, #0]

static void interface_speed( enum speed_setting speed )
{
	DWORD tmp;

	tmp = SPI_SD->CR1;
 8003146:	4b09      	ldr	r3, [pc, #36]	; (800316c <disk_initialize+0x142>)
 8003148:	881a      	ldrh	r2, [r3, #0]
 800314a:	b292      	uxth	r2, r2
	if ( speed == INTERFACE_SLOW ) {
		/* Set slow clock (100k-400k) */
		tmp = ( tmp | SPI_BaudRatePrescaler_256 );
	} else {
		/* Set fast clock (depends on the CSD) */
		tmp = ( tmp & ~SPI_BaudRatePrescaler_256 ) | SPI_BaudRatePrescaler_SPI_SD;
 800314c:	f022 0238 	bic.w	r2, r2, #56	; 0x38
	}
	SPI_SD->CR1 = tmp;
 8003150:	f042 0208 	orr.w	r2, r2, #8
 8003154:	801a      	strh	r2, [r3, #0]
 8003156:	e001      	b.n	800315c <disk_initialize+0x132>

	if (ty) {			/* Initialization succeeded */
		Stat &= ~STA_NOINIT;		/* Clear STA_NOINIT */
		interface_speed(INTERFACE_FAST);
	} else {			/* Initialization failed */
		power_off();
 8003158:	f7ff fea2 	bl	8002ea0 <power_off>
	}

	return Stat;
 800315c:	4b02      	ldr	r3, [pc, #8]	; (8003168 <disk_initialize+0x13e>)
 800315e:	7818      	ldrb	r0, [r3, #0]
 8003160:	e000      	b.n	8003164 <disk_initialize+0x13a>
	BYTE drv		/* Physical drive number (0) */
)
{
	BYTE n, cmd, ty, ocr[4];

	if (drv) return STA_NOINIT;			/* Supports only single drive */
 8003162:	2001      	movs	r0, #1
	} else {			/* Initialization failed */
		power_off();
	}

	return Stat;
}
 8003164:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
 8003166:	bf00      	nop
 8003168:	2000006c 	.word	0x2000006c
 800316c:	40013000 	.word	0x40013000
 8003170:	20000b2c 	.word	0x20000b2c

08003174 <disk_status>:

DSTATUS disk_status (
	BYTE drv		/* Physical drive number (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
 8003174:	b910      	cbnz	r0, 800317c <disk_status+0x8>
	return Stat;
 8003176:	4b02      	ldr	r3, [pc, #8]	; (8003180 <disk_status+0xc>)
 8003178:	7818      	ldrb	r0, [r3, #0]
 800317a:	4770      	bx	lr

DSTATUS disk_status (
	BYTE drv		/* Physical drive number (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
 800317c:	2001      	movs	r0, #1
	return Stat;
}
 800317e:	4770      	bx	lr
 8003180:	2000006c 	.word	0x2000006c

08003184 <disk_read>:
	BYTE drv,			/* Physical drive number (0) */
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
 8003184:	b538      	push	{r3, r4, r5, lr}
 8003186:	460d      	mov	r5, r1
 8003188:	461c      	mov	r4, r3
 800318a:	4611      	mov	r1, r2
	if (drv || !count) return RES_PARERR;
 800318c:	2800      	cmp	r0, #0
 800318e:	d135      	bne.n	80031fc <disk_read+0x78>
 8003190:	2b00      	cmp	r3, #0
 8003192:	d033      	beq.n	80031fc <disk_read+0x78>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
 8003194:	4b1b      	ldr	r3, [pc, #108]	; (8003204 <disk_read+0x80>)
 8003196:	781b      	ldrb	r3, [r3, #0]
 8003198:	07db      	lsls	r3, r3, #31
 800319a:	d431      	bmi.n	8003200 <disk_read+0x7c>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
 800319c:	4b1a      	ldr	r3, [pc, #104]	; (8003208 <disk_read+0x84>)
 800319e:	7a1b      	ldrb	r3, [r3, #8]
 80031a0:	f003 0308 	and.w	r3, r3, #8
 80031a4:	b2db      	uxtb	r3, r3
 80031a6:	b903      	cbnz	r3, 80031aa <disk_read+0x26>
 80031a8:	0251      	lsls	r1, r2, #9

	if (count == 1) {	/* Single block read */
 80031aa:	2c01      	cmp	r4, #1
 80031ac:	d10c      	bne.n	80031c8 <disk_read+0x44>
		if (send_cmd(CMD17, sector) == 0)	{ /* READ_SINGLE_BLOCK */
 80031ae:	2051      	movs	r0, #81	; 0x51
 80031b0:	f7ff fea6 	bl	8002f00 <send_cmd>
 80031b4:	b9e0      	cbnz	r0, 80031f0 <disk_read+0x6c>
			if (rcvr_datablock(buff, 512)) {
 80031b6:	4628      	mov	r0, r5
 80031b8:	f44f 7100 	mov.w	r1, #512	; 0x200
 80031bc:	f7ff fee6 	bl	8002f8c <rcvr_datablock>
 80031c0:	f080 0001 	eor.w	r0, r0, #1
 80031c4:	b2c4      	uxtb	r4, r0
 80031c6:	e013      	b.n	80031f0 <disk_read+0x6c>
				count = 0;
			}
		}
	}
	else {				/* Multiple block read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
 80031c8:	2052      	movs	r0, #82	; 0x52
 80031ca:	f7ff fe99 	bl	8002f00 <send_cmd>
 80031ce:	b978      	cbnz	r0, 80031f0 <disk_read+0x6c>
			do {
				if (!rcvr_datablock(buff, 512)) {
 80031d0:	4628      	mov	r0, r5
 80031d2:	f44f 7100 	mov.w	r1, #512	; 0x200
 80031d6:	f7ff fed9 	bl	8002f8c <rcvr_datablock>
 80031da:	b128      	cbz	r0, 80031e8 <disk_read+0x64>
					break;
				}
				buff += 512;
			} while (--count);
 80031dc:	3c01      	subs	r4, #1
 80031de:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
			do {
				if (!rcvr_datablock(buff, 512)) {
					break;
				}
				buff += 512;
 80031e2:	f505 7500 	add.w	r5, r5, #512	; 0x200
			} while (--count);
 80031e6:	d1f3      	bne.n	80031d0 <disk_read+0x4c>
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
 80031e8:	204c      	movs	r0, #76	; 0x4c
 80031ea:	2100      	movs	r1, #0
 80031ec:	f7ff fe88 	bl	8002f00 <send_cmd>
		}
	}
	release_spi();
 80031f0:	f7ff fe4a 	bl	8002e88 <release_spi>

	return count ? RES_ERROR : RES_OK;
 80031f4:	1c20      	adds	r0, r4, #0
 80031f6:	bf18      	it	ne
 80031f8:	2001      	movne	r0, #1
 80031fa:	bd38      	pop	{r3, r4, r5, pc}
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
 80031fc:	2004      	movs	r0, #4
 80031fe:	bd38      	pop	{r3, r4, r5, pc}
	if (Stat & STA_NOINIT) return RES_NOTRDY;
 8003200:	2003      	movs	r0, #3
		}
	}
	release_spi();

	return count ? RES_ERROR : RES_OK;
}
 8003202:	bd38      	pop	{r3, r4, r5, pc}
 8003204:	2000006c 	.word	0x2000006c
 8003208:	20000b2c 	.word	0x20000b2c

0800320c <disk_write>:
	BYTE drv,			/* Physical drive number (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
 800320c:	b570      	push	{r4, r5, r6, lr}
 800320e:	460d      	mov	r5, r1
 8003210:	4616      	mov	r6, r2
 8003212:	461c      	mov	r4, r3
	if (drv || !count) return RES_PARERR;
 8003214:	2800      	cmp	r0, #0
 8003216:	d153      	bne.n	80032c0 <disk_write+0xb4>
 8003218:	2b00      	cmp	r3, #0
 800321a:	d051      	beq.n	80032c0 <disk_write+0xb4>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
 800321c:	4b2b      	ldr	r3, [pc, #172]	; (80032cc <disk_write+0xc0>)
 800321e:	781a      	ldrb	r2, [r3, #0]
 8003220:	07d2      	lsls	r2, r2, #31
 8003222:	d44f      	bmi.n	80032c4 <disk_write+0xb8>
	if (Stat & STA_PROTECT) return RES_WRPRT;
 8003224:	781b      	ldrb	r3, [r3, #0]
 8003226:	f003 0304 	and.w	r3, r3, #4
 800322a:	b2db      	uxtb	r3, r3
 800322c:	2b00      	cmp	r3, #0
 800322e:	d14b      	bne.n	80032c8 <disk_write+0xbc>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
 8003230:	4b27      	ldr	r3, [pc, #156]	; (80032d0 <disk_write+0xc4>)
 8003232:	7a1b      	ldrb	r3, [r3, #8]
 8003234:	f003 0208 	and.w	r2, r3, #8
 8003238:	b2d2      	uxtb	r2, r2
 800323a:	b902      	cbnz	r2, 800323e <disk_write+0x32>
 800323c:	0276      	lsls	r6, r6, #9

	if (count == 1) {	/* Single block write */
 800323e:	2c01      	cmp	r4, #1
 8003240:	d114      	bne.n	800326c <disk_write+0x60>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
 8003242:	2058      	movs	r0, #88	; 0x58
 8003244:	4631      	mov	r1, r6
 8003246:	f7ff fe5b 	bl	8002f00 <send_cmd>
 800324a:	b108      	cbz	r0, 8003250 <disk_write+0x44>
	BYTE drv,			/* Physical drive number (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
 800324c:	2401      	movs	r4, #1
 800324e:	e031      	b.n	80032b4 <disk_write+0xa8>
	BYTE resp;
#ifndef STM32_SD_USE_DMA
	BYTE wc;
#endif

	if (wait_ready() != 0xFF) return FALSE;
 8003250:	f7ff fe09 	bl	8002e66 <wait_ready>
 8003254:	28ff      	cmp	r0, #255	; 0xff
 8003256:	d1f9      	bne.n	800324c <disk_write+0x40>

	xmit_spi(token);					/* Xmit data token */
 8003258:	20fe      	movs	r0, #254	; 0xfe
 800325a:	f7ff fdef 	bl	8002e3c <stm32_spi_rw>
 800325e:	4628      	mov	r0, r5
 8003260:	f7ff fec4 	bl	8002fec <xmit_datablock.part.4>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	if (count == 1) {	/* Single block write */
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
			&& xmit_datablock(buff, 0xFE))
 8003264:	f080 0001 	eor.w	r0, r0, #1
 8003268:	b2c4      	uxtb	r4, r0
 800326a:	e023      	b.n	80032b4 <disk_write+0xa8>
			count = 0;
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
 800326c:	f013 0f06 	tst.w	r3, #6
 8003270:	d003      	beq.n	800327a <disk_write+0x6e>
 8003272:	20d7      	movs	r0, #215	; 0xd7
 8003274:	4621      	mov	r1, r4
 8003276:	f7ff fe43 	bl	8002f00 <send_cmd>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
 800327a:	2059      	movs	r0, #89	; 0x59
 800327c:	4631      	mov	r1, r6
 800327e:	f7ff fe3f 	bl	8002f00 <send_cmd>
 8003282:	b9b8      	cbnz	r0, 80032b4 <disk_write+0xa8>
	BYTE resp;
#ifndef STM32_SD_USE_DMA
	BYTE wc;
#endif

	if (wait_ready() != 0xFF) return FALSE;
 8003284:	f7ff fdef 	bl	8002e66 <wait_ready>
 8003288:	28ff      	cmp	r0, #255	; 0xff
 800328a:	d10c      	bne.n	80032a6 <disk_write+0x9a>

	xmit_spi(token);					/* Xmit data token */
 800328c:	20fc      	movs	r0, #252	; 0xfc
 800328e:	f7ff fdd5 	bl	8002e3c <stm32_spi_rw>
 8003292:	4628      	mov	r0, r5
 8003294:	f7ff feaa 	bl	8002fec <xmit_datablock.part.4>
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
 8003298:	b128      	cbz	r0, 80032a6 <disk_write+0x9a>
				buff += 512;
			} while (--count);
 800329a:	3c01      	subs	r4, #1
 800329c:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
				buff += 512;
 80032a0:	f505 7500 	add.w	r5, r5, #512	; 0x200
			} while (--count);
 80032a4:	d1ee      	bne.n	8003284 <disk_write+0x78>
	BYTE resp;
#ifndef STM32_SD_USE_DMA
	BYTE wc;
#endif

	if (wait_ready() != 0xFF) return FALSE;
 80032a6:	f7ff fdde 	bl	8002e66 <wait_ready>
 80032aa:	28ff      	cmp	r0, #255	; 0xff
 80032ac:	d1ce      	bne.n	800324c <disk_write+0x40>

	xmit_spi(token);					/* Xmit data token */
 80032ae:	20fd      	movs	r0, #253	; 0xfd
 80032b0:	f7ff fdc4 	bl	8002e3c <stm32_spi_rw>
			} while (--count);
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
				count = 1;
		}
	}
	release_spi();
 80032b4:	f7ff fde8 	bl	8002e88 <release_spi>

	return count ? RES_ERROR : RES_OK;
 80032b8:	1c20      	adds	r0, r4, #0
 80032ba:	bf18      	it	ne
 80032bc:	2001      	movne	r0, #1
 80032be:	bd70      	pop	{r4, r5, r6, pc}
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
 80032c0:	2004      	movs	r0, #4
 80032c2:	bd70      	pop	{r4, r5, r6, pc}
	if (Stat & STA_NOINIT) return RES_NOTRDY;
 80032c4:	2003      	movs	r0, #3
 80032c6:	bd70      	pop	{r4, r5, r6, pc}
	if (Stat & STA_PROTECT) return RES_WRPRT;
 80032c8:	2002      	movs	r0, #2
		}
	}
	release_spi();

	return count ? RES_ERROR : RES_OK;
}
 80032ca:	bd70      	pop	{r4, r5, r6, pc}
 80032cc:	2000006c 	.word	0x2000006c
 80032d0:	20000b2c 	.word	0x20000b2c

080032d4 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive number (0) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
 80032d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80032d6:	4615      	mov	r5, r2
 80032d8:	b085      	sub	sp, #20
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	WORD csize;

	if (drv) return RES_PARERR;
 80032da:	4604      	mov	r4, r0
 80032dc:	2800      	cmp	r0, #0
 80032de:	f040 8100 	bne.w	80034e2 <disk_ioctl+0x20e>

	res = RES_ERROR;

	if (ctrl == CTRL_POWER) {
 80032e2:	2904      	cmp	r1, #4
 80032e4:	d110      	bne.n	8003308 <disk_ioctl+0x34>
		switch (*ptr) {
 80032e6:	7813      	ldrb	r3, [r2, #0]
 80032e8:	2b01      	cmp	r3, #1
 80032ea:	d007      	beq.n	80032fc <disk_ioctl+0x28>
 80032ec:	d303      	bcc.n	80032f6 <disk_ioctl+0x22>
 80032ee:	2b02      	cmp	r3, #2
 80032f0:	f040 80f9 	bne.w	80034e6 <disk_ioctl+0x212>
 80032f4:	e005      	b.n	8003302 <disk_ioctl+0x2e>
		case 0:		/* Sub control code == 0 (POWER_OFF) */
			if (chk_power())
				power_off();		/* Power off */
 80032f6:	f7ff fdd3 	bl	8002ea0 <power_off>
			res = RES_OK;
			break;
 80032fa:	e0f7      	b.n	80034ec <disk_ioctl+0x218>
		case 1:		/* Sub control code == 1 (POWER_ON) */
			power_on();				/* Power on */
 80032fc:	f7ff fd2e 	bl	8002d5c <power_on>
			res = RES_OK;
			break;
 8003300:	e0f4      	b.n	80034ec <disk_ioctl+0x218>
		case 2:		/* Sub control code == 2 (POWER_GET) */
			*(ptr+1) = (BYTE)chk_power();
 8003302:	2301      	movs	r3, #1
 8003304:	7053      	strb	r3, [r2, #1]
			res = RES_OK;
			break;
 8003306:	e0f1      	b.n	80034ec <disk_ioctl+0x218>
		default :
			res = RES_PARERR;
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
 8003308:	4b7a      	ldr	r3, [pc, #488]	; (80034f4 <disk_ioctl+0x220>)
 800330a:	781b      	ldrb	r3, [r3, #0]
 800330c:	07d8      	lsls	r0, r3, #31
 800330e:	f100 80ec 	bmi.w	80034ea <disk_ioctl+0x216>

		switch (ctrl) {
 8003312:	290e      	cmp	r1, #14
 8003314:	f200 80e1 	bhi.w	80034da <disk_ioctl+0x206>
 8003318:	e8df f011 	tbh	[pc, r1, lsl #1]
 800331c:	001a000f 	.word	0x001a000f
 8003320:	00590055 	.word	0x00590055
 8003324:	00df00df 	.word	0x00df00df
 8003328:	00df00df 	.word	0x00df00df
 800332c:	00df00df 	.word	0x00df00df
 8003330:	00b300ae 	.word	0x00b300ae
 8003334:	00bf00b5 	.word	0x00bf00b5
 8003338:	00ce      	.short	0x00ce
		case CTRL_SYNC :		/* Make sure that no pending write process */
			SELECT();
 800333a:	2110      	movs	r1, #16
 800333c:	486e      	ldr	r0, [pc, #440]	; (80034f8 <disk_ioctl+0x224>)
 800333e:	f000 fd32 	bl	8003da6 <GPIO_ResetBits>
			if (wait_ready() == 0xFF)
 8003342:	f7ff fd90 	bl	8002e66 <wait_ready>
				res = RES_OK;
 8003346:	f1b0 04ff 	subs.w	r4, r0, #255	; 0xff
 800334a:	bf18      	it	ne
 800334c:	2401      	movne	r4, #1
 800334e:	e0c5      	b.n	80034dc <disk_ioctl+0x208>
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
 8003350:	2049      	movs	r0, #73	; 0x49
 8003352:	2100      	movs	r1, #0
 8003354:	f7ff fdd4 	bl	8002f00 <send_cmd>
 8003358:	4604      	mov	r4, r0
 800335a:	b108      	cbz	r0, 8003360 <disk_ioctl+0x8c>
	BYTE n, csd[16], *ptr = buff;
	WORD csize;

	if (drv) return RES_PARERR;

	res = RES_ERROR;
 800335c:	2401      	movs	r4, #1
 800335e:	e0bd      	b.n	80034dc <disk_ioctl+0x208>
			if (wait_ready() == 0xFF)
				res = RES_OK;
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
 8003360:	4668      	mov	r0, sp
 8003362:	2110      	movs	r1, #16
 8003364:	f7ff fe12 	bl	8002f8c <rcvr_datablock>
 8003368:	2800      	cmp	r0, #0
 800336a:	d0f7      	beq.n	800335c <disk_ioctl+0x88>
				if ((csd[0] >> 6) == 1) {	/* SDC version 2.00 */
 800336c:	f89d 3000 	ldrb.w	r3, [sp]
 8003370:	099b      	lsrs	r3, r3, #6
 8003372:	2b01      	cmp	r3, #1
 8003374:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8003378:	d107      	bne.n	800338a <disk_ioctl+0xb6>
					csize = csd[9] + ((WORD)csd[8] << 8) + 1;
 800337a:	f89d 2009 	ldrb.w	r2, [sp, #9]
 800337e:	3201      	adds	r2, #1
 8003380:	eb02 2303 	add.w	r3, r2, r3, lsl #8
					*(DWORD*)buff = (DWORD)csize << 10;
 8003384:	b29b      	uxth	r3, r3
 8003386:	029b      	lsls	r3, r3, #10
 8003388:	e042      	b.n	8003410 <disk_ioctl+0x13c>
				} else {					/* SDC version 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
 800338a:	f89d 2007 	ldrb.w	r2, [sp, #7]
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
				if ((csd[0] >> 6) == 1) {	/* SDC version 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + 1;
					*(DWORD*)buff = (DWORD)csize << 10;
				} else {					/* SDC version 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
 800338e:	f89d 1005 	ldrb.w	r1, [sp, #5]
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
 8003392:	0092      	lsls	r2, r2, #2
 8003394:	eb02 1393 	add.w	r3, r2, r3, lsr #6
 8003398:	1c5a      	adds	r2, r3, #1
 800339a:	f89d 3006 	ldrb.w	r3, [sp, #6]
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
				if ((csd[0] >> 6) == 1) {	/* SDC version 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + 1;
					*(DWORD*)buff = (DWORD)csize << 10;
				} else {					/* SDC version 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
 800339e:	f001 010f 	and.w	r1, r1, #15
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
 80033a2:	f003 0303 	and.w	r3, r3, #3
					*(DWORD*)buff = (DWORD)csize << (n - 9);
 80033a6:	eb02 2383 	add.w	r3, r2, r3, lsl #10
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
				if ((csd[0] >> 6) == 1) {	/* SDC version 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + 1;
					*(DWORD*)buff = (DWORD)csize << 10;
				} else {					/* SDC version 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
 80033aa:	f89d 200a 	ldrb.w	r2, [sp, #10]
 80033ae:	eb01 11d2 	add.w	r1, r1, r2, lsr #7
 80033b2:	f89d 2009 	ldrb.w	r2, [sp, #9]
 80033b6:	f002 0203 	and.w	r2, r2, #3
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = (DWORD)csize << (n - 9);
 80033ba:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 80033be:	3a07      	subs	r2, #7
 80033c0:	fa03 f302 	lsl.w	r3, r3, r2
 80033c4:	e024      	b.n	8003410 <disk_ioctl+0x13c>
				res = RES_OK;
			}
			break;

		case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
			*(WORD*)buff = 512;
 80033c6:	f44f 7300 	mov.w	r3, #512	; 0x200
 80033ca:	8013      	strh	r3, [r2, #0]
 80033cc:	e057      	b.n	800347e <disk_ioctl+0x1aa>
			res = RES_OK;
			break;

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			if (CardType & CT_SD2) {	/* SDC ver 2.00 */
 80033ce:	4e4b      	ldr	r6, [pc, #300]	; (80034fc <disk_ioctl+0x228>)
 80033d0:	7a31      	ldrb	r1, [r6, #8]
 80033d2:	f001 0104 	and.w	r1, r1, #4
 80033d6:	b2c9      	uxtb	r1, r1
 80033d8:	b1e1      	cbz	r1, 8003414 <disk_ioctl+0x140>
				if (send_cmd(ACMD13, 0) == 0) {	/* Read SD status */
 80033da:	20cd      	movs	r0, #205	; 0xcd
 80033dc:	2100      	movs	r1, #0
 80033de:	f7ff fd8f 	bl	8002f00 <send_cmd>
 80033e2:	2800      	cmp	r0, #0
 80033e4:	d1ba      	bne.n	800335c <disk_ioctl+0x88>
					rcvr_spi();
 80033e6:	f7ff fd3b 	bl	8002e60 <rcvr_spi>
					if (rcvr_datablock(csd, 16)) {				/* Read partial block */
 80033ea:	4668      	mov	r0, sp
 80033ec:	2110      	movs	r1, #16
 80033ee:	f7ff fdcd 	bl	8002f8c <rcvr_datablock>
 80033f2:	2800      	cmp	r0, #0
 80033f4:	d0b2      	beq.n	800335c <disk_ioctl+0x88>
 80033f6:	2430      	movs	r4, #48	; 0x30
 80033f8:	3c01      	subs	r4, #1
						for (n = 64 - 16; n; n--) rcvr_spi();	/* Purge trailing data */
 80033fa:	f7ff fd31 	bl	8002e60 <rcvr_spi>
 80033fe:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 8003402:	d1f9      	bne.n	80033f8 <disk_ioctl+0x124>
						*(DWORD*)buff = 16UL << (csd[10] >> 4);
 8003404:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8003408:	2210      	movs	r2, #16
 800340a:	091b      	lsrs	r3, r3, #4
 800340c:	fa02 f303 	lsl.w	r3, r2, r3
 8003410:	602b      	str	r3, [r5, #0]
 8003412:	e063      	b.n	80034dc <disk_ioctl+0x208>
						res = RES_OK;
					}
				}
			} else {					/* SDC ver 1.XX or MMC */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
 8003414:	2049      	movs	r0, #73	; 0x49
 8003416:	f7ff fd73 	bl	8002f00 <send_cmd>
 800341a:	4607      	mov	r7, r0
 800341c:	2800      	cmp	r0, #0
 800341e:	d19d      	bne.n	800335c <disk_ioctl+0x88>
 8003420:	4668      	mov	r0, sp
 8003422:	2110      	movs	r1, #16
 8003424:	f7ff fdb2 	bl	8002f8c <rcvr_datablock>
 8003428:	2800      	cmp	r0, #0
 800342a:	d097      	beq.n	800335c <disk_ioctl+0x88>
					if (CardType & CT_SD1) {	/* SDC ver 1.XX */
 800342c:	7a34      	ldrb	r4, [r6, #8]
 800342e:	f89d 200a 	ldrb.w	r2, [sp, #10]
 8003432:	f004 0402 	and.w	r4, r4, #2
 8003436:	b2e4      	uxtb	r4, r4
 8003438:	b184      	cbz	r4, 800345c <disk_ioctl+0x188>
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
 800343a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800343e:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8003442:	09db      	lsrs	r3, r3, #7
 8003444:	eb03 0242 	add.w	r2, r3, r2, lsl #1
 8003448:	f89d 300d 	ldrb.w	r3, [sp, #13]
 800344c:	3201      	adds	r2, #1
 800344e:	099b      	lsrs	r3, r3, #6
 8003450:	3b01      	subs	r3, #1
 8003452:	fa02 f203 	lsl.w	r2, r2, r3
					} else {					/* MMC */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
					}
					res = RES_OK;
 8003456:	463c      	mov	r4, r7
					}
				}
			} else {					/* SDC ver 1.XX or MMC */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
					if (CardType & CT_SD1) {	/* SDC ver 1.XX */
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
 8003458:	602a      	str	r2, [r5, #0]
 800345a:	e03f      	b.n	80034dc <disk_ioctl+0x208>
					} else {					/* MMC */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
 800345c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003460:	f3c2 0284 	ubfx	r2, r2, #2, #5
 8003464:	1c51      	adds	r1, r2, #1
 8003466:	f003 0203 	and.w	r2, r3, #3
 800346a:	095b      	lsrs	r3, r3, #5
 800346c:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8003470:	3201      	adds	r2, #1
 8003472:	434a      	muls	r2, r1
 8003474:	602a      	str	r2, [r5, #0]
 8003476:	e031      	b.n	80034dc <disk_ioctl+0x208>
				}
			}
			break;

		case MMC_GET_TYPE :		/* Get card type flags (1 byte) */
			*ptr = CardType;
 8003478:	4b20      	ldr	r3, [pc, #128]	; (80034fc <disk_ioctl+0x228>)
 800347a:	7a1b      	ldrb	r3, [r3, #8]
 800347c:	7013      	strb	r3, [r2, #0]
			res = RES_OK;
 800347e:	2400      	movs	r4, #0
			break;
 8003480:	e02c      	b.n	80034dc <disk_ioctl+0x208>

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
 8003482:	2049      	movs	r0, #73	; 0x49
 8003484:	e000      	b.n	8003488 <disk_ioctl+0x1b4>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
 8003486:	204a      	movs	r0, #74	; 0x4a
 8003488:	2100      	movs	r1, #0
 800348a:	f7ff fd39 	bl	8002f00 <send_cmd>
 800348e:	2800      	cmp	r0, #0
 8003490:	f47f af64 	bne.w	800335c <disk_ioctl+0x88>
				&& rcvr_datablock(ptr, 16))
 8003494:	4628      	mov	r0, r5
 8003496:	2110      	movs	r1, #16
 8003498:	e019      	b.n	80034ce <disk_ioctl+0x1fa>
				res = RES_OK;
			break;

		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
 800349a:	207a      	movs	r0, #122	; 0x7a
 800349c:	2100      	movs	r1, #0
 800349e:	f7ff fd2f 	bl	8002f00 <send_cmd>
 80034a2:	2800      	cmp	r0, #0
 80034a4:	f47f af5a 	bne.w	800335c <disk_ioctl+0x88>
 80034a8:	4604      	mov	r4, r0
				for (n = 4; n; n--) *ptr++ = rcvr_spi();
 80034aa:	f7ff fcd9 	bl	8002e60 <rcvr_spi>
 80034ae:	5528      	strb	r0, [r5, r4]
 80034b0:	3401      	adds	r4, #1
 80034b2:	2c04      	cmp	r4, #4
 80034b4:	d1f9      	bne.n	80034aa <disk_ioctl+0x1d6>
 80034b6:	e7e2      	b.n	800347e <disk_ioctl+0x1aa>
				res = RES_OK;
			}
			break;

		case MMC_GET_SDSTAT :	/* Receive SD status as a data block (64 bytes) */
			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
 80034b8:	20cd      	movs	r0, #205	; 0xcd
 80034ba:	2100      	movs	r1, #0
 80034bc:	f7ff fd20 	bl	8002f00 <send_cmd>
 80034c0:	2800      	cmp	r0, #0
 80034c2:	f47f af4b 	bne.w	800335c <disk_ioctl+0x88>
				rcvr_spi();
 80034c6:	f7ff fccb 	bl	8002e60 <rcvr_spi>
				if (rcvr_datablock(ptr, 64))
 80034ca:	4628      	mov	r0, r5
 80034cc:	2140      	movs	r1, #64	; 0x40
 80034ce:	f7ff fd5d 	bl	8002f8c <rcvr_datablock>
 80034d2:	f080 0001 	eor.w	r0, r0, #1

		switch (ctrl) {
		case CTRL_SYNC :		/* Make sure that no pending write process */
			SELECT();
			if (wait_ready() == 0xFF)
				res = RES_OK;
 80034d6:	b2c4      	uxtb	r4, r0
 80034d8:	e000      	b.n	80034dc <disk_ioctl+0x208>
					res = RES_OK;
			}
			break;

		default:
			res = RES_PARERR;
 80034da:	2404      	movs	r4, #4
		}

		release_spi();
 80034dc:	f7ff fcd4 	bl	8002e88 <release_spi>
 80034e0:	e004      	b.n	80034ec <disk_ioctl+0x218>
{
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	WORD csize;

	if (drv) return RES_PARERR;
 80034e2:	2404      	movs	r4, #4
 80034e4:	e002      	b.n	80034ec <disk_ioctl+0x218>
		case 2:		/* Sub control code == 2 (POWER_GET) */
			*(ptr+1) = (BYTE)chk_power();
			res = RES_OK;
			break;
		default :
			res = RES_PARERR;
 80034e6:	460c      	mov	r4, r1
 80034e8:	e000      	b.n	80034ec <disk_ioctl+0x218>
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
 80034ea:	2403      	movs	r4, #3

		release_spi();
	}

	return res;
}
 80034ec:	4620      	mov	r0, r4
 80034ee:	b005      	add	sp, #20
 80034f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80034f2:	bf00      	nop
 80034f4:	2000006c 	.word	0x2000006c
 80034f8:	40010800 	.word	0x40010800
 80034fc:	20000b2c 	.word	0x20000b2c

08003500 <disk_timerproc>:
	static socket_state_t pv;
	socket_state_t ns;
	BYTE n, s;


	n = Timer1;						/* 100Hz decrement timer */
 8003500:	4b0d      	ldr	r3, [pc, #52]	; (8003538 <disk_timerproc+0x38>)
 8003502:	681a      	ldr	r2, [r3, #0]
	if (n) Timer1 = --n;
 8003504:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
 8003508:	d002      	beq.n	8003510 <disk_timerproc+0x10>
 800350a:	3a01      	subs	r2, #1
 800350c:	b2d2      	uxtb	r2, r2
 800350e:	601a      	str	r2, [r3, #0]
	n = Timer2;
 8003510:	685b      	ldr	r3, [r3, #4]
	if (n) Timer2 = --n;
 8003512:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 8003516:	d003      	beq.n	8003520 <disk_timerproc+0x20>
 8003518:	3b01      	subs	r3, #1
 800351a:	4a07      	ldr	r2, [pc, #28]	; (8003538 <disk_timerproc+0x38>)
 800351c:	b2db      	uxtb	r3, r3
 800351e:	6053      	str	r3, [r2, #4]

	ns = pv;
 8003520:	4b05      	ldr	r3, [pc, #20]	; (8003538 <disk_timerproc+0x38>)
	pv = socket_wp_cp_state();	/* Sample socket switch */
 8003522:	2100      	movs	r1, #0
	n = Timer1;						/* 100Hz decrement timer */
	if (n) Timer1 = --n;
	n = Timer2;
	if (n) Timer2 = --n;

	ns = pv;
 8003524:	68da      	ldr	r2, [r3, #12]
	pv = socket_wp_cp_state();	/* Sample socket switch */
 8003526:	60d9      	str	r1, [r3, #12]

	if (ns == pv) {				/* Have contacts stabled? */
 8003528:	b922      	cbnz	r2, 8003534 <disk_timerproc+0x34>
		s = Stat;
 800352a:	4b04      	ldr	r3, [pc, #16]	; (800353c <disk_timerproc+0x3c>)
 800352c:	781a      	ldrb	r2, [r3, #0]
			s &= ~STA_PROTECT;

		if (socket_is_empty(pv))			/* INS = H (Socket empty) */
			s |= (STA_NODISK | STA_NOINIT);
		else								/* INS = L (Card inserted) */
			s &= ~STA_NODISK;
 800352e:	f002 02f9 	and.w	r2, r2, #249	; 0xf9

		Stat = s;
 8003532:	701a      	strb	r2, [r3, #0]
 8003534:	4770      	bx	lr
 8003536:	bf00      	nop
 8003538:	20000b2c 	.word	0x20000b2c
 800353c:	2000006c 	.word	0x2000006c
 8003540:	08021c80 	.word	0x08021c80
 8003544:	20000000 	.word	0x20000000
 8003548:	20000900 	.word	0x20000900
 800354c:	20000908 	.word	0x20000908
 8003550:	2000361c 	.word	0x2000361c

08003554 <SystemInit>:
  */
void SystemInit (void)
{
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8003554:	4b52      	ldr	r3, [pc, #328]	; (80036a0 <SystemInit+0x14c>)
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8003556:	b082      	sub	sp, #8
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8003558:	681a      	ldr	r2, [r3, #0]
 800355a:	f042 0201 	orr.w	r2, r2, #1
 800355e:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
 8003560:	6859      	ldr	r1, [r3, #4]
 8003562:	4a50      	ldr	r2, [pc, #320]	; (80036a4 <SystemInit+0x150>)
 8003564:	400a      	ands	r2, r1
 8003566:	605a      	str	r2, [r3, #4]
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8003568:	681a      	ldr	r2, [r3, #0]
 800356a:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 800356e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8003572:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8003574:	681a      	ldr	r2, [r3, #0]
 8003576:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800357a:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 800357c:	685a      	ldr	r2, [r3, #4]
 800357e:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8003582:	605a      	str	r2, [r3, #4]

#ifdef STM32F10X_CL
  /* Reset PLL2ON and PLL3ON bits */
  RCC->CR &= (uint32_t)0xEBFFFFFF;
 8003584:	681a      	ldr	r2, [r3, #0]
 8003586:	f022 52a0 	bic.w	r2, r2, #335544320	; 0x14000000
 800358a:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x00FF0000;
 800358c:	f44f 027f 	mov.w	r2, #16711680	; 0xff0000
 8003590:	609a      	str	r2, [r3, #8]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;
 8003592:	2200      	movs	r2, #0
 8003594:	62da      	str	r2, [r3, #44]	; 0x2c
  * @param  None
  * @retval None
  */
static void SetSysClockTo72(void)
{
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8003596:	9200      	str	r2, [sp, #0]
 8003598:	9201      	str	r2, [sp, #4]
  
  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 800359a:	681a      	ldr	r2, [r3, #0]
 800359c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80035a0:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 80035a2:	681a      	ldr	r2, [r3, #0]
 80035a4:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 80035a8:	9201      	str	r2, [sp, #4]
    StartUpCounter++;  
 80035aa:	9a00      	ldr	r2, [sp, #0]
 80035ac:	3201      	adds	r2, #1
 80035ae:	9200      	str	r2, [sp, #0]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 80035b0:	9a01      	ldr	r2, [sp, #4]
 80035b2:	b91a      	cbnz	r2, 80035bc <SystemInit+0x68>
 80035b4:	9a00      	ldr	r2, [sp, #0]
 80035b6:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 80035ba:	d1f2      	bne.n	80035a2 <SystemInit+0x4e>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 80035bc:	4b38      	ldr	r3, [pc, #224]	; (80036a0 <SystemInit+0x14c>)
 80035be:	681b      	ldr	r3, [r3, #0]
 80035c0:	f413 3300 	ands.w	r3, r3, #131072	; 0x20000
  {
    HSEStatus = (uint32_t)0x01;
 80035c4:	bf18      	it	ne
 80035c6:	2301      	movne	r3, #1
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 80035c8:	9301      	str	r3, [sp, #4]
  }  

  if (HSEStatus == (uint32_t)0x01)
 80035ca:	9b01      	ldr	r3, [sp, #4]
 80035cc:	2b01      	cmp	r3, #1
 80035ce:	d01d      	beq.n	800360c <SystemInit+0xb8>
  SetSysClock();

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 80035d0:	4b35      	ldr	r3, [pc, #212]	; (80036a8 <SystemInit+0x154>)
 80035d2:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80035d6:	609a      	str	r2, [r3, #8]
static __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
  
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80035d8:	68d9      	ldr	r1, [r3, #12]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 80035da:	f64f 02ff 	movw	r2, #63743	; 0xf8ff
 80035de:	400a      	ands	r2, r1
  reg_value  =  (reg_value                       |
 80035e0:	f042 62bf 	orr.w	r2, r2, #100139008	; 0x5f80000
 80035e4:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
                (0x5FA << SCB_AIRCR_VECTKEY_Pos) | 
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80035e8:	60da      	str	r2, [r3, #12]
{
	/* Ensure all priority bits are assigned as preemption priority bits.
	http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	NVIC_SetPriorityGrouping( 0 );

	SysTick_Config(SystemCoreClock / 1000);
 80035ea:	4a30      	ldr	r2, [pc, #192]	; (80036ac <SystemInit+0x158>)
 80035ec:	6811      	ldr	r1, [r2, #0]
 80035ee:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80035f2:	fbb1 f1f2 	udiv	r1, r1, r2
 */
static __INLINE uint32_t SysTick_Config(uint32_t ticks)
{ 
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
                                                               
  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 80035f6:	4a2e      	ldr	r2, [pc, #184]	; (80036b0 <SystemInit+0x15c>)
 80035f8:	3901      	subs	r1, #1
 80035fa:	6051      	str	r1, [r2, #4]
 * Note: The priority cannot be set for every core interrupt.
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
 80035fc:	21f0      	movs	r1, #240	; 0xf0
 80035fe:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
{ 
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
                                                               
  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8003602:	2300      	movs	r3, #0
 8003604:	6093      	str	r3, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | 
 8003606:	2307      	movs	r3, #7
 8003608:	6013      	str	r3, [r2, #0]
 800360a:	e047      	b.n	800369c <SystemInit+0x148>
  }  

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
 800360c:	4b29      	ldr	r3, [pc, #164]	; (80036b4 <SystemInit+0x160>)
 800360e:	681a      	ldr	r2, [r3, #0]
 8003610:	f042 0210 	orr.w	r2, r2, #16
 8003614:	601a      	str	r2, [r3, #0]

    /* Flash 2 wait state */
    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
 8003616:	681a      	ldr	r2, [r3, #0]
 8003618:	f022 0203 	bic.w	r2, r2, #3
 800361c:	601a      	str	r2, [r3, #0]
    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
 800361e:	681a      	ldr	r2, [r3, #0]
 8003620:	f042 0202 	orr.w	r2, r2, #2
 8003624:	601a      	str	r2, [r3, #0]

 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 8003626:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
 800362a:	685a      	ldr	r2, [r3, #4]
 800362c:	605a      	str	r2, [r3, #4]
      
    /* PCLK2 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
 800362e:	685a      	ldr	r2, [r3, #4]
 8003630:	605a      	str	r2, [r3, #4]
    
    /* PCLK1 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
 8003632:	685a      	ldr	r2, [r3, #4]
 8003634:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8003638:	605a      	str	r2, [r3, #4]
#ifdef STM32F10X_CL
    /* Configure PLLs ------------------------------------------------------*/
    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
        
    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
 800363a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 800363c:	4a1e      	ldr	r2, [pc, #120]	; (80036b8 <SystemInit+0x164>)
 800363e:	400a      	ands	r2, r1
 8003640:	62da      	str	r2, [r3, #44]	; 0x2c
                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
 8003642:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8003644:	f442 3283 	orr.w	r2, r2, #67072	; 0x10600
 8003648:	f042 0244 	orr.w	r2, r2, #68	; 0x44
 800364c:	62da      	str	r2, [r3, #44]	; 0x2c
                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
  
    /* Enable PLL2 */
    RCC->CR |= RCC_CR_PLL2ON;
 800364e:	681a      	ldr	r2, [r3, #0]
 8003650:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8003654:	601a      	str	r2, [r3, #0]
    /* Wait till PLL2 is ready */
    while((RCC->CR & RCC_CR_PLL2RDY) == 0)
 8003656:	6819      	ldr	r1, [r3, #0]
 8003658:	4a11      	ldr	r2, [pc, #68]	; (80036a0 <SystemInit+0x14c>)
 800365a:	0109      	lsls	r1, r1, #4
 800365c:	d5fb      	bpl.n	8003656 <SystemInit+0x102>
    {
    }
    
   
    /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
 800365e:	6853      	ldr	r3, [r2, #4]
 8003660:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 8003664:	6053      	str	r3, [r2, #4]
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
 8003666:	6853      	ldr	r3, [r2, #4]
 8003668:	f443 13e8 	orr.w	r3, r3, #1900544	; 0x1d0000
 800366c:	6053      	str	r3, [r2, #4]
                                        RCC_CFGR_PLLMULL));
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
#endif /* STM32F10X_CL */

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 800366e:	6813      	ldr	r3, [r2, #0]
 8003670:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8003674:	6013      	str	r3, [r2, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8003676:	6813      	ldr	r3, [r2, #0]
 8003678:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 800367c:	4b08      	ldr	r3, [pc, #32]	; (80036a0 <SystemInit+0x14c>)
 800367e:	d0fa      	beq.n	8003676 <SystemInit+0x122>
    {
    }
    
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8003680:	685a      	ldr	r2, [r3, #4]
 8003682:	f022 0203 	bic.w	r2, r2, #3
 8003686:	605a      	str	r2, [r3, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
 8003688:	685a      	ldr	r2, [r3, #4]
 800368a:	f042 0202 	orr.w	r2, r2, #2
 800368e:	605a      	str	r2, [r3, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
 8003690:	685a      	ldr	r2, [r3, #4]
 8003692:	f002 020c 	and.w	r2, r2, #12
 8003696:	2a08      	cmp	r2, #8
 8003698:	d1fa      	bne.n	8003690 <SystemInit+0x13c>
 800369a:	e799      	b.n	80035d0 <SystemInit+0x7c>
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
#endif 

  prvSetupHardware();
}
 800369c:	b002      	add	sp, #8
 800369e:	4770      	bx	lr
 80036a0:	40021000 	.word	0x40021000
 80036a4:	f0ff0000 	.word	0xf0ff0000
 80036a8:	e000ed00 	.word	0xe000ed00
 80036ac:	20000070 	.word	0x20000070
 80036b0:	e000e010 	.word	0xe000e010
 80036b4:	40022000 	.word	0x40022000
 80036b8:	fffef000 	.word	0xfffef000

080036bc <SystemCoreClockUpdate>:
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80036bc:	4a23      	ldr	r2, [pc, #140]	; (800374c <SystemCoreClockUpdate+0x90>)
  *           value for HSE crystal.
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate (void)
{
 80036be:	b530      	push	{r4, r5, lr}
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80036c0:	6851      	ldr	r1, [r2, #4]
 80036c2:	4b23      	ldr	r3, [pc, #140]	; (8003750 <SystemCoreClockUpdate+0x94>)
 80036c4:	f001 010c 	and.w	r1, r1, #12
  
  switch (tmp)
 80036c8:	2904      	cmp	r1, #4
 80036ca:	d003      	beq.n	80036d4 <SystemCoreClockUpdate+0x18>
 80036cc:	2908      	cmp	r1, #8
 80036ce:	d004      	beq.n	80036da <SystemCoreClockUpdate+0x1e>
 80036d0:	4a20      	ldr	r2, [pc, #128]	; (8003754 <SystemCoreClockUpdate+0x98>)
 80036d2:	e000      	b.n	80036d6 <SystemCoreClockUpdate+0x1a>
  {
    case 0x00:  /* HSI used as system clock */
      SystemCoreClock = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock */
      SystemCoreClock = HSE_VALUE;
 80036d4:	4a20      	ldr	r2, [pc, #128]	; (8003758 <SystemCoreClockUpdate+0x9c>)
 80036d6:	601a      	str	r2, [r3, #0]
      break;
 80036d8:	e02b      	b.n	8003732 <SystemCoreClockUpdate+0x76>
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 80036da:	6853      	ldr	r3, [r2, #4]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 80036dc:	6852      	ldr	r2, [r2, #4]
          SystemCoreClock = HSE_VALUE * pllmull;
        }
 #endif
      }
#else
      pllmull = pllmull >> 18;
 80036de:	f3c3 4383 	ubfx	r3, r3, #18, #4
      
      if (pllmull != 0x0D)
 80036e2:	2b0d      	cmp	r3, #13
      break;
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 80036e4:	f402 3280 	and.w	r2, r2, #65536	; 0x10000
 #endif
      }
#else
      pllmull = pllmull >> 18;
      
      if (pllmull != 0x0D)
 80036e8:	d001      	beq.n	80036ee <SystemCoreClockUpdate+0x32>
      {
         pllmull += 2;
 80036ea:	3302      	adds	r3, #2
 80036ec:	e000      	b.n	80036f0 <SystemCoreClockUpdate+0x34>
      }
      else
      { /* PLL multiplication factor = PLL input clock * 6.5 */
        pllmull = 13 / 2; 
 80036ee:	2306      	movs	r3, #6
      }
            
      if (pllsource == 0x00)
 80036f0:	b922      	cbnz	r2, 80036fc <SystemCoreClockUpdate+0x40>
      {
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
 80036f2:	4a1a      	ldr	r2, [pc, #104]	; (800375c <SystemCoreClockUpdate+0xa0>)
 80036f4:	4353      	muls	r3, r2
 80036f6:	4a16      	ldr	r2, [pc, #88]	; (8003750 <SystemCoreClockUpdate+0x94>)
 80036f8:	6013      	str	r3, [r2, #0]
 80036fa:	e01a      	b.n	8003732 <SystemCoreClockUpdate+0x76>
      }
      else
      {/* PREDIV1 selected as PLL clock entry */
        
        /* Get PREDIV1 clock source and division factor */
        prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
 80036fc:	4a13      	ldr	r2, [pc, #76]	; (800374c <SystemCoreClockUpdate+0x90>)
 80036fe:	4c16      	ldr	r4, [pc, #88]	; (8003758 <SystemCoreClockUpdate+0x9c>)
 8003700:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 8003702:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8003704:	f000 000f 	and.w	r0, r0, #15
 8003708:	3001      	adds	r0, #1
        
        if (prediv1source == 0)
 800370a:	f411 3f80 	tst.w	r1, #65536	; 0x10000
 800370e:	4910      	ldr	r1, [pc, #64]	; (8003750 <SystemCoreClockUpdate+0x94>)
 8003710:	d100      	bne.n	8003714 <SystemCoreClockUpdate+0x58>
 8003712:	e00a      	b.n	800372a <SystemCoreClockUpdate+0x6e>
        }
        else
        {/* PLL2 clock selected as PREDIV1 clock entry */
          
          /* Get PREDIV2 division factor and PLL2 multiplication factor */
          prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
 8003714:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
          pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
 8003716:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
        }
        else
        {/* PLL2 clock selected as PREDIV1 clock entry */
          
          /* Get PREDIV2 division factor and PLL2 multiplication factor */
          prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
 8003718:	f3c5 1503 	ubfx	r5, r5, #4, #4
 800371c:	3501      	adds	r5, #1
          pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
 800371e:	f3c2 2203 	ubfx	r2, r2, #8, #4
          SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
 8003722:	fbb4 f4f5 	udiv	r4, r4, r5
        else
        {/* PLL2 clock selected as PREDIV1 clock entry */
          
          /* Get PREDIV2 division factor and PLL2 multiplication factor */
          prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
          pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
 8003726:	3202      	adds	r2, #2
          SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
 8003728:	4354      	muls	r4, r2
 800372a:	fbb4 f0f0 	udiv	r0, r4, r0
 800372e:	4343      	muls	r3, r0
 8003730:	600b      	str	r3, [r1, #0]
      break;
  }
  
  /* Compute HCLK clock frequency ----------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8003732:	4b06      	ldr	r3, [pc, #24]	; (800374c <SystemCoreClockUpdate+0x90>)
 8003734:	685a      	ldr	r2, [r3, #4]
 8003736:	4b06      	ldr	r3, [pc, #24]	; (8003750 <SystemCoreClockUpdate+0x94>)
 8003738:	f3c2 1203 	ubfx	r2, r2, #4, #4
 800373c:	189a      	adds	r2, r3, r2
 800373e:	7911      	ldrb	r1, [r2, #4]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;  
 8003740:	681a      	ldr	r2, [r3, #0]
 8003742:	fa22 f201 	lsr.w	r2, r2, r1
 8003746:	601a      	str	r2, [r3, #0]
 8003748:	bd30      	pop	{r4, r5, pc}
 800374a:	bf00      	nop
 800374c:	40021000 	.word	0x40021000
 8003750:	20000070 	.word	0x20000070
 8003754:	007a1200 	.word	0x007a1200
 8003758:	017d7840 	.word	0x017d7840
 800375c:	003d0900 	.word	0x003d0900

08003760 <__get_PSP>:
uint32_t __get_PSP(void) __attribute__( ( naked ) );
uint32_t __get_PSP(void)
{
  uint32_t result=0;

  __ASM volatile ("MRS %0, psp\n\t" 
 8003760:	f3ef 8009 	mrs	r0, PSP
 8003764:	4600      	mov	r0, r0
 8003766:	4770      	bx	lr

08003768 <__set_PSP>:
 * (process stack pointer) Cortex processor register
 */
void __set_PSP(uint32_t topOfProcStack) __attribute__( ( naked ) );
void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n\t"
 8003768:	f380 8809 	msr	PSP, r0
 800376c:	4770      	bx	lr

0800376e <__get_MSP>:
uint32_t __get_MSP(void) __attribute__( ( naked ) );
uint32_t __get_MSP(void)
{
  uint32_t result=0;

  __ASM volatile ("MRS %0, msp\n\t" 
 800376e:	f3ef 8008 	mrs	r0, MSP
 8003772:	4600      	mov	r0, r0
 8003774:	4770      	bx	lr

08003776 <__set_MSP>:
 * (main stack pointer) Cortex processor register
 */
void __set_MSP(uint32_t topOfMainStack) __attribute__( ( naked ) );
void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n\t"
 8003776:	f380 8808 	msr	MSP, r0
 800377a:	4770      	bx	lr

0800377c <__get_BASEPRI>:
 */
uint32_t __get_BASEPRI(void)
{
  uint32_t result=0;
  
  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
 800377c:	f3ef 8012 	mrs	r0, BASEPRI_MAX
  return(result);
}
 8003780:	4770      	bx	lr

08003782 <__set_BASEPRI>:
 *
 * Set the base priority register
 */
void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
 8003782:	f380 8811 	msr	BASEPRI, r0
 8003786:	4770      	bx	lr

08003788 <__get_PRIMASK>:
 */
uint32_t __get_PRIMASK(void)
{
  uint32_t result=0;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8003788:	f3ef 8010 	mrs	r0, PRIMASK
  return(result);
}
 800378c:	4770      	bx	lr

0800378e <__set_PRIMASK>:
 *
 * Set the priority mask bit in the priority mask register
 */
void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
 800378e:	f380 8810 	msr	PRIMASK, r0
 8003792:	4770      	bx	lr

08003794 <__get_FAULTMASK>:
 */
uint32_t __get_FAULTMASK(void)
{
  uint32_t result=0;
  
  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 8003794:	f3ef 8013 	mrs	r0, FAULTMASK
  return(result);
}
 8003798:	4770      	bx	lr

0800379a <__set_FAULTMASK>:
 *
 * Set the fault mask register
 */
void __set_FAULTMASK(uint32_t faultMask)
{
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
 800379a:	f380 8813 	msr	FAULTMASK, r0
 800379e:	4770      	bx	lr

080037a0 <__get_CONTROL>:
 */
uint32_t __get_CONTROL(void)
{
  uint32_t result=0;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
 80037a0:	f3ef 8014 	mrs	r0, CONTROL
  return(result);
}
 80037a4:	4770      	bx	lr

080037a6 <__set_CONTROL>:
 *
 * Set the control register
 */
void __set_CONTROL(uint32_t control)
{
  __ASM volatile ("MSR control, %0" : : "r" (control) );
 80037a6:	f380 8814 	msr	CONTROL, r0
 80037aa:	4770      	bx	lr

080037ac <__REV>:
 */
uint32_t __REV(uint32_t value)
{
  uint32_t result=0;
  
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 80037ac:	ba00      	rev	r0, r0
  return(result);
}
 80037ae:	4770      	bx	lr

080037b0 <__REV16>:
 */
uint32_t __REV16(uint16_t value)
{
  uint32_t result=0;
  
  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
 80037b0:	ba40      	rev16	r0, r0
  return(result);
}
 80037b2:	4770      	bx	lr

080037b4 <__REVSH>:
 */
int32_t __REVSH(int16_t value)
{
  uint32_t result=0;
  
  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
 80037b4:	bac0      	revsh	r0, r0
  return(result);
}
 80037b6:	4770      	bx	lr

080037b8 <__RBIT>:
 */
uint32_t __RBIT(uint32_t value)
{
  uint32_t result=0;
  
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80037b8:	fa90 f0a0 	rbit	r0, r0
   return(result);
}
 80037bc:	4770      	bx	lr

080037be <__LDREXB>:
 */
uint8_t __LDREXB(uint8_t *addr)
{
    uint8_t result=0;
  
   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
 80037be:	e8d0 0f4f 	ldrexb	r0, [r0]
   return(result);
}
 80037c2:	b2c0      	uxtb	r0, r0
 80037c4:	4770      	bx	lr

080037c6 <__LDREXH>:
 */
uint16_t __LDREXH(uint16_t *addr)
{
    uint16_t result=0;
  
   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
 80037c6:	e8d0 0f5f 	ldrexh	r0, [r0]
   return(result);
}
 80037ca:	b280      	uxth	r0, r0
 80037cc:	4770      	bx	lr

080037ce <__LDREXW>:
 */
uint32_t __LDREXW(uint32_t *addr)
{
    uint32_t result=0;
  
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
 80037ce:	e850 0f00 	ldrex	r0, [r0]
   return(result);
}
 80037d2:	4770      	bx	lr

080037d4 <__STREXW>:
 */
uint32_t __STREXW(uint32_t value, uint32_t *addr)
{
   uint32_t result=0;
  
   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
 80037d4:	e841 0000 	strex	r0, r0, [r1]
   return(result);
}
 80037d8:	4770      	bx	lr
	...

080037dc <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 80037dc:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 80037e0:	4b02      	ldr	r3, [pc, #8]	; (80037ec <NVIC_PriorityGroupConfig+0x10>)
 80037e2:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
 80037e6:	60d8      	str	r0, [r3, #12]
 80037e8:	4770      	bx	lr
 80037ea:	bf00      	nop
 80037ec:	e000ed00 	.word	0xe000ed00

080037f0 <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 80037f0:	78c3      	ldrb	r3, [r0, #3]
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 80037f2:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 80037f4:	b303      	cbz	r3, 8003838 <NVIC_Init+0x48>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 80037f6:	4b16      	ldr	r3, [pc, #88]	; (8003850 <NVIC_Init+0x60>)
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 80037f8:	7841      	ldrb	r1, [r0, #1]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 80037fa:	68db      	ldr	r3, [r3, #12]
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 80037fc:	7884      	ldrb	r4, [r0, #2]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 80037fe:	43db      	mvns	r3, r3
 8003800:	f3c3 2302 	ubfx	r3, r3, #8, #3
    tmppre = (0x4 - tmppriority);
 8003804:	f1c3 0204 	rsb	r2, r3, #4
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003808:	fa01 f102 	lsl.w	r1, r1, r2
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
 800380c:	220f      	movs	r2, #15
 800380e:	fa22 f203 	lsr.w	r2, r2, r3

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003812:	7803      	ldrb	r3, [r0, #0]
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8003814:	4022      	ands	r2, r4
 8003816:	430a      	orrs	r2, r1
    tmppriority = tmppriority << 0x04;
 8003818:	0112      	lsls	r2, r2, #4
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 800381a:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 800381e:	b2d2      	uxtb	r2, r2
 8003820:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 8003824:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003828:	7803      	ldrb	r3, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800382a:	2201      	movs	r2, #1
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800382c:	0959      	lsrs	r1, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800382e:	f003 031f 	and.w	r3, r3, #31
 8003832:	fa02 f303 	lsl.w	r3, r2, r3
 8003836:	e007      	b.n	8003848 <NVIC_Init+0x58>
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003838:	7803      	ldrb	r3, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800383a:	2201      	movs	r2, #1
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800383c:	0959      	lsrs	r1, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800383e:	f003 031f 	and.w	r3, r3, #31
 8003842:	fa02 f303 	lsl.w	r3, r2, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003846:	3120      	adds	r1, #32
 8003848:	4a02      	ldr	r2, [pc, #8]	; (8003854 <NVIC_Init+0x64>)
 800384a:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 800384e:	bd10      	pop	{r4, pc}
 8003850:	e000ed00 	.word	0xe000ed00
 8003854:	e000e100 	.word	0xe000e100

08003858 <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 8003858:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 800385c:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 8003860:	4b01      	ldr	r3, [pc, #4]	; (8003868 <NVIC_SetVectorTable+0x10>)
 8003862:	4308      	orrs	r0, r1
 8003864:	6098      	str	r0, [r3, #8]
 8003866:	4770      	bx	lr
 8003868:	e000ed00 	.word	0xe000ed00

0800386c <NVIC_SystemLPConfig>:
  *     @arg NVIC_LP_SLEEPONEXIT
  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)
{
 800386c:	4b04      	ldr	r3, [pc, #16]	; (8003880 <NVIC_SystemLPConfig+0x14>)
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 800386e:	691a      	ldr	r2, [r3, #16]
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 8003870:	b109      	cbz	r1, 8003876 <NVIC_SystemLPConfig+0xa>
  {
    SCB->SCR |= LowPowerMode;
 8003872:	4310      	orrs	r0, r2
 8003874:	e001      	b.n	800387a <NVIC_SystemLPConfig+0xe>
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 8003876:	ea22 0000 	bic.w	r0, r2, r0
 800387a:	6118      	str	r0, [r3, #16]
 800387c:	4770      	bx	lr
 800387e:	bf00      	nop
 8003880:	e000ed00 	.word	0xe000ed00

08003884 <SysTick_CLKSourceConfig>:
  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.
  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
 8003884:	4b04      	ldr	r3, [pc, #16]	; (8003898 <SysTick_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 8003886:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8003888:	681a      	ldr	r2, [r3, #0]
 800388a:	bf0c      	ite	eq
 800388c:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8003890:	f022 0204 	bicne.w	r2, r2, #4
 8003894:	601a      	str	r2, [r3, #0]
 8003896:	4770      	bx	lr
 8003898:	e000e010 	.word	0xe000e010

0800389c <CRC_ResetDR>:
  * @retval None
  */
void CRC_ResetDR(void)
{
  /* Reset CRC generator */
  CRC->CR = CRC_CR_RESET;
 800389c:	4b01      	ldr	r3, [pc, #4]	; (80038a4 <CRC_ResetDR+0x8>)
 800389e:	2201      	movs	r2, #1
 80038a0:	609a      	str	r2, [r3, #8]
 80038a2:	4770      	bx	lr
 80038a4:	40023000 	.word	0x40023000

080038a8 <CRC_CalcCRC>:
  * @param  Data: data word(32-bit) to compute its CRC
  * @retval 32-bit CRC
  */
uint32_t CRC_CalcCRC(uint32_t Data)
{
  CRC->DR = Data;
 80038a8:	4b01      	ldr	r3, [pc, #4]	; (80038b0 <CRC_CalcCRC+0x8>)
 80038aa:	6018      	str	r0, [r3, #0]
  
  return (CRC->DR);
 80038ac:	6818      	ldr	r0, [r3, #0]
}
 80038ae:	4770      	bx	lr
 80038b0:	40023000 	.word	0x40023000

080038b4 <CRC_CalcBlockCRC>:
  * @param  pBuffer: pointer to the buffer containing the data to be computed
  * @param  BufferLength: length of the buffer to be computed					
  * @retval 32-bit CRC
  */
uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)
{
 80038b4:	b510      	push	{r4, lr}
  uint32_t index = 0;
  
  for(index = 0; index < BufferLength; index++)
 80038b6:	2300      	movs	r3, #0
 80038b8:	4c05      	ldr	r4, [pc, #20]	; (80038d0 <CRC_CalcBlockCRC+0x1c>)
 80038ba:	e003      	b.n	80038c4 <CRC_CalcBlockCRC+0x10>
  {
    CRC->DR = pBuffer[index];
 80038bc:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
  */
uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)
{
  uint32_t index = 0;
  
  for(index = 0; index < BufferLength; index++)
 80038c0:	3301      	adds	r3, #1
  {
    CRC->DR = pBuffer[index];
 80038c2:	6022      	str	r2, [r4, #0]
  */
uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)
{
  uint32_t index = 0;
  
  for(index = 0; index < BufferLength; index++)
 80038c4:	428b      	cmp	r3, r1
 80038c6:	d1f9      	bne.n	80038bc <CRC_CalcBlockCRC+0x8>
  {
    CRC->DR = pBuffer[index];
  }
  return (CRC->DR);
 80038c8:	4b01      	ldr	r3, [pc, #4]	; (80038d0 <CRC_CalcBlockCRC+0x1c>)
 80038ca:	6818      	ldr	r0, [r3, #0]
}
 80038cc:	bd10      	pop	{r4, pc}
 80038ce:	bf00      	nop
 80038d0:	40023000 	.word	0x40023000

080038d4 <CRC_GetCRC>:
  * @param  None
  * @retval 32-bit CRC
  */
uint32_t CRC_GetCRC(void)
{
  return (CRC->DR);
 80038d4:	4b01      	ldr	r3, [pc, #4]	; (80038dc <CRC_GetCRC+0x8>)
 80038d6:	6818      	ldr	r0, [r3, #0]
}
 80038d8:	4770      	bx	lr
 80038da:	bf00      	nop
 80038dc:	40023000 	.word	0x40023000

080038e0 <CRC_SetIDRegister>:
  * @param  IDValue: 8-bit value to be stored in the ID register 					
  * @retval None
  */
void CRC_SetIDRegister(uint8_t IDValue)
{
  CRC->IDR = IDValue;
 80038e0:	4b01      	ldr	r3, [pc, #4]	; (80038e8 <CRC_SetIDRegister+0x8>)
 80038e2:	7118      	strb	r0, [r3, #4]
 80038e4:	4770      	bx	lr
 80038e6:	bf00      	nop
 80038e8:	40023000 	.word	0x40023000

080038ec <CRC_GetIDRegister>:
  * @param  None
  * @retval 8-bit value of the ID register 
  */
uint8_t CRC_GetIDRegister(void)
{
  return (CRC->IDR);
 80038ec:	4b01      	ldr	r3, [pc, #4]	; (80038f4 <CRC_GetIDRegister+0x8>)
 80038ee:	7918      	ldrb	r0, [r3, #4]
}
 80038f0:	4770      	bx	lr
 80038f2:	bf00      	nop
 80038f4:	40023000 	.word	0x40023000

080038f8 <DBGMCU_GetREVID>:
  * @param  None
  * @retval Device revision identifier
  */
uint32_t DBGMCU_GetREVID(void)
{
   return(DBGMCU->IDCODE >> 16);
 80038f8:	4b01      	ldr	r3, [pc, #4]	; (8003900 <DBGMCU_GetREVID+0x8>)
 80038fa:	6818      	ldr	r0, [r3, #0]
}
 80038fc:	0c00      	lsrs	r0, r0, #16
 80038fe:	4770      	bx	lr
 8003900:	e0042000 	.word	0xe0042000

08003904 <DBGMCU_GetDEVID>:
  * @param  None
  * @retval Device identifier
  */
uint32_t DBGMCU_GetDEVID(void)
{
   return(DBGMCU->IDCODE & IDCODE_DEVID_MASK);
 8003904:	4b02      	ldr	r3, [pc, #8]	; (8003910 <DBGMCU_GetDEVID+0xc>)
 8003906:	6818      	ldr	r0, [r3, #0]
 8003908:	0500      	lsls	r0, r0, #20
}
 800390a:	0d00      	lsrs	r0, r0, #20
 800390c:	4770      	bx	lr
 800390e:	bf00      	nop
 8003910:	e0042000 	.word	0xe0042000

08003914 <DBGMCU_Config>:
  * @param  NewState: new state of the specified peripheral in Debug mode.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState)
{
 8003914:	4b04      	ldr	r3, [pc, #16]	; (8003928 <DBGMCU_Config+0x14>)
  assert_param(IS_DBGMCU_PERIPH(DBGMCU_Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    DBGMCU->CR |= DBGMCU_Periph;
 8003916:	685a      	ldr	r2, [r3, #4]
{
  /* Check the parameters */
  assert_param(IS_DBGMCU_PERIPH(DBGMCU_Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003918:	b109      	cbz	r1, 800391e <DBGMCU_Config+0xa>
  {
    DBGMCU->CR |= DBGMCU_Periph;
 800391a:	4310      	orrs	r0, r2
 800391c:	e001      	b.n	8003922 <DBGMCU_Config+0xe>
  }
  else
  {
    DBGMCU->CR &= ~DBGMCU_Periph;
 800391e:	ea22 0000 	bic.w	r0, r2, r0
 8003922:	6058      	str	r0, [r3, #4]
 8003924:	4770      	bx	lr
 8003926:	bf00      	nop
 8003928:	e0042000 	.word	0xe0042000

0800392c <DMA_DeInit>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  
  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
 800392c:	6802      	ldr	r2, [r0, #0]
 800392e:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8003932:	4013      	ands	r3, r2
 8003934:	6003      	str	r3, [r0, #0]
  
  /* Reset DMAy Channelx control register */
  DMAy_Channelx->CCR  = 0;
 8003936:	2300      	movs	r3, #0
 8003938:	6003      	str	r3, [r0, #0]
  
  /* Reset DMAy Channelx remaining bytes register */
  DMAy_Channelx->CNDTR = 0;
 800393a:	6043      	str	r3, [r0, #4]
  
  /* Reset DMAy Channelx peripheral address register */
  DMAy_Channelx->CPAR  = 0;
 800393c:	6083      	str	r3, [r0, #8]
  
  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
 800393e:	60c3      	str	r3, [r0, #12]
  
  if (DMAy_Channelx == DMA1_Channel1)
 8003940:	4b2c      	ldr	r3, [pc, #176]	; (80039f4 <DMA_DeInit+0xc8>)
 8003942:	4298      	cmp	r0, r3
 8003944:	d100      	bne.n	8003948 <DMA_DeInit+0x1c>
 8003946:	e026      	b.n	8003996 <DMA_DeInit+0x6a>
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_Channel1_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel2)
 8003948:	4b2b      	ldr	r3, [pc, #172]	; (80039f8 <DMA_DeInit+0xcc>)
 800394a:	4298      	cmp	r0, r3
 800394c:	d100      	bne.n	8003950 <DMA_DeInit+0x24>
 800394e:	e02c      	b.n	80039aa <DMA_DeInit+0x7e>
  {
    /* Reset interrupt pending bits for DMA1 Channel2 */
    DMA1->IFCR |= DMA1_Channel2_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel3)
 8003950:	4b2a      	ldr	r3, [pc, #168]	; (80039fc <DMA_DeInit+0xd0>)
 8003952:	4298      	cmp	r0, r3
 8003954:	d100      	bne.n	8003958 <DMA_DeInit+0x2c>
 8003956:	e032      	b.n	80039be <DMA_DeInit+0x92>
  {
    /* Reset interrupt pending bits for DMA1 Channel3 */
    DMA1->IFCR |= DMA1_Channel3_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel4)
 8003958:	4b29      	ldr	r3, [pc, #164]	; (8003a00 <DMA_DeInit+0xd4>)
 800395a:	4298      	cmp	r0, r3
 800395c:	d100      	bne.n	8003960 <DMA_DeInit+0x34>
 800395e:	e038      	b.n	80039d2 <DMA_DeInit+0xa6>
  {
    /* Reset interrupt pending bits for DMA1 Channel4 */
    DMA1->IFCR |= DMA1_Channel4_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel5)
 8003960:	4b28      	ldr	r3, [pc, #160]	; (8003a04 <DMA_DeInit+0xd8>)
 8003962:	4298      	cmp	r0, r3
 8003964:	d100      	bne.n	8003968 <DMA_DeInit+0x3c>
 8003966:	e03e      	b.n	80039e6 <DMA_DeInit+0xba>
  {
    /* Reset interrupt pending bits for DMA1 Channel5 */
    DMA1->IFCR |= DMA1_Channel5_IT_Mask;
  }
  else if (DMAy_Channelx == DMA1_Channel6)
 8003968:	4b27      	ldr	r3, [pc, #156]	; (8003a08 <DMA_DeInit+0xdc>)
 800396a:	4298      	cmp	r0, r3
 800396c:	d106      	bne.n	800397c <DMA_DeInit+0x50>
  {
    /* Reset interrupt pending bits for DMA1 Channel6 */
    DMA1->IFCR |= DMA1_Channel6_IT_Mask;
 800396e:	f853 2c68 	ldr.w	r2, [r3, #-104]
 8003972:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8003976:	f843 2c68 	str.w	r2, [r3, #-104]
 800397a:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA1_Channel7)
 800397c:	4b23      	ldr	r3, [pc, #140]	; (8003a0c <DMA_DeInit+0xe0>)
 800397e:	4298      	cmp	r0, r3
 8003980:	d106      	bne.n	8003990 <DMA_DeInit+0x64>
  {
    /* Reset interrupt pending bits for DMA1 Channel7 */
    DMA1->IFCR |= DMA1_Channel7_IT_Mask;
 8003982:	f853 2c7c 	ldr.w	r2, [r3, #-124]
 8003986:	f042 6270 	orr.w	r2, r2, #251658240	; 0xf000000
 800398a:	f843 2c7c 	str.w	r2, [r3, #-124]
 800398e:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel1)
 8003990:	4b1f      	ldr	r3, [pc, #124]	; (8003a10 <DMA_DeInit+0xe4>)
 8003992:	4298      	cmp	r0, r3
 8003994:	d106      	bne.n	80039a4 <DMA_DeInit+0x78>
  {
    /* Reset interrupt pending bits for DMA2 Channel1 */
    DMA2->IFCR |= DMA2_Channel1_IT_Mask;
 8003996:	f853 2c04 	ldr.w	r2, [r3, #-4]
 800399a:	f042 020f 	orr.w	r2, r2, #15
 800399e:	f843 2c04 	str.w	r2, [r3, #-4]
 80039a2:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel2)
 80039a4:	4b1b      	ldr	r3, [pc, #108]	; (8003a14 <DMA_DeInit+0xe8>)
 80039a6:	4298      	cmp	r0, r3
 80039a8:	d106      	bne.n	80039b8 <DMA_DeInit+0x8c>
  {
    /* Reset interrupt pending bits for DMA2 Channel2 */
    DMA2->IFCR |= DMA2_Channel2_IT_Mask;
 80039aa:	f853 2c18 	ldr.w	r2, [r3, #-24]
 80039ae:	f042 02f0 	orr.w	r2, r2, #240	; 0xf0
 80039b2:	f843 2c18 	str.w	r2, [r3, #-24]
 80039b6:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel3)
 80039b8:	4b17      	ldr	r3, [pc, #92]	; (8003a18 <DMA_DeInit+0xec>)
 80039ba:	4298      	cmp	r0, r3
 80039bc:	d106      	bne.n	80039cc <DMA_DeInit+0xa0>
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_Channel3_IT_Mask;
 80039be:	f853 2c2c 	ldr.w	r2, [r3, #-44]
 80039c2:	f442 6270 	orr.w	r2, r2, #3840	; 0xf00
 80039c6:	f843 2c2c 	str.w	r2, [r3, #-44]
 80039ca:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel4)
 80039cc:	4b13      	ldr	r3, [pc, #76]	; (8003a1c <DMA_DeInit+0xf0>)
 80039ce:	4298      	cmp	r0, r3
 80039d0:	d106      	bne.n	80039e0 <DMA_DeInit+0xb4>
  {
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_Channel4_IT_Mask;
 80039d2:	f853 2c40 	ldr.w	r2, [r3, #-64]
 80039d6:	f442 4270 	orr.w	r2, r2, #61440	; 0xf000
 80039da:	f843 2c40 	str.w	r2, [r3, #-64]
 80039de:	4770      	bx	lr
  }
  else
  { 
    if (DMAy_Channelx == DMA2_Channel5)
 80039e0:	4b0f      	ldr	r3, [pc, #60]	; (8003a20 <DMA_DeInit+0xf4>)
 80039e2:	4298      	cmp	r0, r3
 80039e4:	d105      	bne.n	80039f2 <DMA_DeInit+0xc6>
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
 80039e6:	f853 2c54 	ldr.w	r2, [r3, #-84]
 80039ea:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
 80039ee:	f843 2c54 	str.w	r2, [r3, #-84]
 80039f2:	4770      	bx	lr
 80039f4:	40020008 	.word	0x40020008
 80039f8:	4002001c 	.word	0x4002001c
 80039fc:	40020030 	.word	0x40020030
 8003a00:	40020044 	.word	0x40020044
 8003a04:	40020058 	.word	0x40020058
 8003a08:	4002006c 	.word	0x4002006c
 8003a0c:	40020080 	.word	0x40020080
 8003a10:	40020408 	.word	0x40020408
 8003a14:	4002041c 	.word	0x4002041c
 8003a18:	40020430 	.word	0x40020430
 8003a1c:	40020444 	.word	0x40020444
 8003a20:	40020458 	.word	0x40020458

08003a24 <DMA_Init>:
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
  *         contains the configuration information for the specified DMA Channel.
  * @retval None
  */
void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
{
 8003a24:	b570      	push	{r4, r5, r6, lr}
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8003a26:	688c      	ldr	r4, [r1, #8]
 8003a28:	6a0d      	ldr	r5, [r1, #32]
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
 8003a2a:	6806      	ldr	r6, [r0, #0]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8003a2c:	ea45 0204 	orr.w	r2, r5, r4
 8003a30:	690c      	ldr	r4, [r1, #16]
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 8003a32:	6a8b      	ldr	r3, [r1, #40]	; 0x28
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8003a34:	4322      	orrs	r2, r4
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8003a36:	694c      	ldr	r4, [r1, #20]

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 8003a38:	f426 46ff 	bic.w	r6, r6, #32640	; 0x7f80
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8003a3c:	4322      	orrs	r2, r4
 8003a3e:	698c      	ldr	r4, [r1, #24]

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 8003a40:	f026 0670 	bic.w	r6, r6, #112	; 0x70
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8003a44:	4322      	orrs	r2, r4
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8003a46:	69cc      	ldr	r4, [r1, #28]
 8003a48:	4314      	orrs	r4, r2
 8003a4a:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8003a4c:	4322      	orrs	r2, r4
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 8003a4e:	4313      	orrs	r3, r2
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8003a50:	4333      	orrs	r3, r6
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;

  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;
 8003a52:	6003      	str	r3, [r0, #0]

/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 8003a54:	68cb      	ldr	r3, [r1, #12]
 8003a56:	6043      	str	r3, [r0, #4]

/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 8003a58:	680b      	ldr	r3, [r1, #0]
 8003a5a:	6083      	str	r3, [r0, #8]

/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 8003a5c:	684b      	ldr	r3, [r1, #4]
 8003a5e:	60c3      	str	r3, [r0, #12]
 8003a60:	bd70      	pop	{r4, r5, r6, pc}

08003a62 <DMA_StructInit>:
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
/*-------------- Reset DMA init structure parameters values ------------------*/
  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 8003a62:	2300      	movs	r3, #0
 8003a64:	6003      	str	r3, [r0, #0]
  /* Initialize the DMA_MemoryBaseAddr member */
  DMA_InitStruct->DMA_MemoryBaseAddr = 0;
 8003a66:	6043      	str	r3, [r0, #4]
  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralSRC;
 8003a68:	6083      	str	r3, [r0, #8]
  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 8003a6a:	60c3      	str	r3, [r0, #12]
  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8003a6c:	6103      	str	r3, [r0, #16]
  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 8003a6e:	6143      	str	r3, [r0, #20]
  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8003a70:	6183      	str	r3, [r0, #24]
  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8003a72:	61c3      	str	r3, [r0, #28]
  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 8003a74:	6203      	str	r3, [r0, #32]
  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 8003a76:	6243      	str	r3, [r0, #36]	; 0x24
  /* Initialize the DMA_M2M member */
  DMA_InitStruct->DMA_M2M = DMA_M2M_Disable;
 8003a78:	6283      	str	r3, [r0, #40]	; 0x28
 8003a7a:	4770      	bx	lr

08003a7c <DMA_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003a7c:	b119      	cbz	r1, 8003a86 <DMA_Cmd+0xa>
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= DMA_CCR1_EN;
 8003a7e:	6803      	ldr	r3, [r0, #0]
 8003a80:	f043 0301 	orr.w	r3, r3, #1
 8003a84:	e003      	b.n	8003a8e <DMA_Cmd+0x12>
  }
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
 8003a86:	6802      	ldr	r2, [r0, #0]
 8003a88:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8003a8c:	4013      	ands	r3, r2
 8003a8e:	6003      	str	r3, [r0, #0]
 8003a90:	4770      	bx	lr

08003a92 <DMA_ITConfig>:
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 8003a92:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003a94:	b10a      	cbz	r2, 8003a9a <DMA_ITConfig+0x8>
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 8003a96:	4319      	orrs	r1, r3
 8003a98:	e001      	b.n	8003a9e <DMA_ITConfig+0xc>
  }
  else
  {
    /* Disable the selected DMA interrupts */
    DMAy_Channelx->CCR &= ~DMA_IT;
 8003a9a:	ea23 0101 	bic.w	r1, r3, r1
 8003a9e:	6001      	str	r1, [r0, #0]
 8003aa0:	4770      	bx	lr

08003aa2 <DMA_SetCurrDataCounter>:
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  
/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DataNumber;  
 8003aa2:	6041      	str	r1, [r0, #4]
 8003aa4:	4770      	bx	lr

08003aa6 <DMA_GetCurrDataCounter>:
uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  /* Return the number of remaining data units for DMAy Channelx */
  return ((uint16_t)(DMAy_Channelx->CNDTR));
 8003aa6:	6840      	ldr	r0, [r0, #4]
}
 8003aa8:	b280      	uxth	r0, r0
 8003aaa:	4770      	bx	lr

08003aac <DMA_GetFlagStatus>:
  
  /* Check the parameters */
  assert_param(IS_DMA_GET_FLAG(DMAy_FLAG));

  /* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 8003aac:	00c3      	lsls	r3, r0, #3
  {
    /* Get DMA2 ISR register value */
    tmpreg = DMA2->ISR ;
 8003aae:	bf4c      	ite	mi
 8003ab0:	4b03      	ldrmi	r3, [pc, #12]	; (8003ac0 <DMA_GetFlagStatus+0x14>)
  }
  else
  {
    /* Get DMA1 ISR register value */
    tmpreg = DMA1->ISR ;
 8003ab2:	4b04      	ldrpl	r3, [pc, #16]	; (8003ac4 <DMA_GetFlagStatus+0x18>)
 8003ab4:	681b      	ldr	r3, [r3, #0]
  }

  /* Check the status of the specified DMAy flag */
  if ((tmpreg & DMAy_FLAG) != (uint32_t)RESET)
 8003ab6:	4203      	tst	r3, r0
    bitstatus = RESET;
  }
  
  /* Return the DMAy_FLAG status */
  return  bitstatus;
}
 8003ab8:	bf0c      	ite	eq
 8003aba:	2000      	moveq	r0, #0
 8003abc:	2001      	movne	r0, #1
 8003abe:	4770      	bx	lr
 8003ac0:	40020400 	.word	0x40020400
 8003ac4:	40020000 	.word	0x40020000

08003ac8 <DMA_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_FLAG(DMAy_FLAG));

  /* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 8003ac8:	00c2      	lsls	r2, r0, #3
  {
    /* Clear the selected DMAy flags */
    DMA2->IFCR = DMAy_FLAG;
 8003aca:	bf4c      	ite	mi
 8003acc:	4b01      	ldrmi	r3, [pc, #4]	; (8003ad4 <DMA_ClearFlag+0xc>)
  }
  else
  {
    /* Clear the selected DMAy flags */
    DMA1->IFCR = DMAy_FLAG;
 8003ace:	4b02      	ldrpl	r3, [pc, #8]	; (8003ad8 <DMA_ClearFlag+0x10>)
 8003ad0:	6058      	str	r0, [r3, #4]
 8003ad2:	4770      	bx	lr
 8003ad4:	40020400 	.word	0x40020400
 8003ad8:	40020000 	.word	0x40020000

08003adc <DMA_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_DMA_GET_IT(DMAy_IT));

  /* Calculate the used DMA */
  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)
 8003adc:	00c1      	lsls	r1, r0, #3
  {
    /* Get DMA2 ISR register value */
    tmpreg = DMA2->ISR;
 8003ade:	bf4c      	ite	mi
 8003ae0:	4b03      	ldrmi	r3, [pc, #12]	; (8003af0 <DMA_GetITStatus+0x14>)
  }
  else
  {
    /* Get DMA1 ISR register value */
    tmpreg = DMA1->ISR;
 8003ae2:	4b04      	ldrpl	r3, [pc, #16]	; (8003af4 <DMA_GetITStatus+0x18>)
 8003ae4:	681b      	ldr	r3, [r3, #0]
  }

  /* Check the status of the specified DMAy interrupt */
  if ((tmpreg & DMAy_IT) != (uint32_t)RESET)
 8003ae6:	4203      	tst	r3, r0
    /* DMAy_IT is reset */
    bitstatus = RESET;
  }
  /* Return the DMA_IT status */
  return  bitstatus;
}
 8003ae8:	bf0c      	ite	eq
 8003aea:	2000      	moveq	r0, #0
 8003aec:	2001      	movne	r0, #1
 8003aee:	4770      	bx	lr
 8003af0:	40020400 	.word	0x40020400
 8003af4:	40020000 	.word	0x40020000

08003af8 <DMA_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_IT(DMAy_IT));

  /* Calculate the used DMAy */
  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)
 8003af8:	00c3      	lsls	r3, r0, #3
  {
    /* Clear the selected DMAy interrupt pending bits */
    DMA2->IFCR = DMAy_IT;
 8003afa:	bf4c      	ite	mi
 8003afc:	4b01      	ldrmi	r3, [pc, #4]	; (8003b04 <DMA_ClearITPendingBit+0xc>)
  }
  else
  {
    /* Clear the selected DMAy interrupt pending bits */
    DMA1->IFCR = DMAy_IT;
 8003afe:	4b02      	ldrpl	r3, [pc, #8]	; (8003b08 <DMA_ClearITPendingBit+0x10>)
 8003b00:	6058      	str	r0, [r3, #4]
 8003b02:	4770      	bx	lr
 8003b04:	40020400 	.word	0x40020400
 8003b08:	40020000 	.word	0x40020000

08003b0c <EXTI_DeInit>:
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x00000000;
 8003b0c:	4b04      	ldr	r3, [pc, #16]	; (8003b20 <EXTI_DeInit+0x14>)
 8003b0e:	2200      	movs	r2, #0
 8003b10:	601a      	str	r2, [r3, #0]
  EXTI->EMR = 0x00000000;
 8003b12:	605a      	str	r2, [r3, #4]
  EXTI->RTSR = 0x00000000; 
 8003b14:	609a      	str	r2, [r3, #8]
  EXTI->FTSR = 0x00000000; 
 8003b16:	60da      	str	r2, [r3, #12]
  EXTI->PR = 0x000FFFFF;
 8003b18:	4a02      	ldr	r2, [pc, #8]	; (8003b24 <EXTI_DeInit+0x18>)
 8003b1a:	615a      	str	r2, [r3, #20]
 8003b1c:	4770      	bx	lr
 8003b1e:	bf00      	nop
 8003b20:	40010400 	.word	0x40010400
 8003b24:	000fffff 	.word	0x000fffff

08003b28 <EXTI_Init>:
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8003b28:	7983      	ldrb	r3, [r0, #6]
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 8003b2a:	b510      	push	{r4, lr}
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8003b2c:	2b00      	cmp	r3, #0
 8003b2e:	d029      	beq.n	8003b84 <EXTI_Init+0x5c>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 8003b30:	4b1a      	ldr	r3, [pc, #104]	; (8003b9c <EXTI_Init+0x74>)
 8003b32:	6801      	ldr	r1, [r0, #0]
 8003b34:	681c      	ldr	r4, [r3, #0]
 8003b36:	43ca      	mvns	r2, r1
 8003b38:	4014      	ands	r4, r2
 8003b3a:	601c      	str	r4, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 8003b3c:	685c      	ldr	r4, [r3, #4]
 8003b3e:	4022      	ands	r2, r4
 8003b40:	605a      	str	r2, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 8003b42:	7902      	ldrb	r2, [r0, #4]
 8003b44:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8003b48:	f502 3282 	add.w	r2, r2, #66560	; 0x10400

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8003b4c:	6814      	ldr	r4, [r2, #0]
 8003b4e:	4321      	orrs	r1, r4
 8003b50:	6011      	str	r1, [r2, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 8003b52:	6802      	ldr	r2, [r0, #0]
 8003b54:	689c      	ldr	r4, [r3, #8]
 8003b56:	43d1      	mvns	r1, r2
 8003b58:	400c      	ands	r4, r1
 8003b5a:	609c      	str	r4, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 8003b5c:	68dc      	ldr	r4, [r3, #12]
 8003b5e:	4021      	ands	r1, r4
 8003b60:	60d9      	str	r1, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 8003b62:	7941      	ldrb	r1, [r0, #5]
 8003b64:	2910      	cmp	r1, #16
 8003b66:	d106      	bne.n	8003b76 <EXTI_Init+0x4e>
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 8003b68:	6899      	ldr	r1, [r3, #8]
 8003b6a:	4311      	orrs	r1, r2
 8003b6c:	6099      	str	r1, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 8003b6e:	68d9      	ldr	r1, [r3, #12]
 8003b70:	430a      	orrs	r2, r1
 8003b72:	60da      	str	r2, [r3, #12]
 8003b74:	bd10      	pop	{r4, pc}
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
      tmp += EXTI_InitStruct->EXTI_Trigger;
 8003b76:	f101 4380 	add.w	r3, r1, #1073741824	; 0x40000000
 8003b7a:	f503 3382 	add.w	r3, r3, #66560	; 0x10400

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8003b7e:	6819      	ldr	r1, [r3, #0]
 8003b80:	430a      	orrs	r2, r1
 8003b82:	e008      	b.n	8003b96 <EXTI_Init+0x6e>
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 8003b84:	7903      	ldrb	r3, [r0, #4]

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 8003b86:	6801      	ldr	r1, [r0, #0]
      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 8003b88:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8003b8c:	f503 3382 	add.w	r3, r3, #66560	; 0x10400

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 8003b90:	681a      	ldr	r2, [r3, #0]
 8003b92:	ea22 0201 	bic.w	r2, r2, r1
 8003b96:	601a      	str	r2, [r3, #0]
 8003b98:	bd10      	pop	{r4, pc}
 8003b9a:	bf00      	nop
 8003b9c:	40010400 	.word	0x40010400

08003ba0 <EXTI_StructInit>:
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8003ba0:	2300      	movs	r3, #0
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 8003ba2:	220c      	movs	r2, #12
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8003ba4:	6003      	str	r3, [r0, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 8003ba6:	7103      	strb	r3, [r0, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 8003ba8:	7142      	strb	r2, [r0, #5]
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 8003baa:	7183      	strb	r3, [r0, #6]
 8003bac:	4770      	bx	lr

08003bae <EXTI_GenerateSWInterrupt>:
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->SWIER |= EXTI_Line;
 8003bae:	4b02      	ldr	r3, [pc, #8]	; (8003bb8 <EXTI_GenerateSWInterrupt+0xa>)
 8003bb0:	691a      	ldr	r2, [r3, #16]
 8003bb2:	4310      	orrs	r0, r2
 8003bb4:	6118      	str	r0, [r3, #16]
 8003bb6:	4770      	bx	lr
 8003bb8:	40010400 	.word	0x40010400

08003bbc <EXTI_GetFlagStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 8003bbc:	4b03      	ldr	r3, [pc, #12]	; (8003bcc <EXTI_GetFlagStatus+0x10>)
 8003bbe:	695b      	ldr	r3, [r3, #20]
 8003bc0:	4218      	tst	r0, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8003bc2:	bf0c      	ite	eq
 8003bc4:	2000      	moveq	r0, #0
 8003bc6:	2001      	movne	r0, #1
 8003bc8:	4770      	bx	lr
 8003bca:	bf00      	nop
 8003bcc:	40010400 	.word	0x40010400

08003bd0 <EXTI_ClearFlag>:
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8003bd0:	4b01      	ldr	r3, [pc, #4]	; (8003bd8 <EXTI_ClearFlag+0x8>)
 8003bd2:	6158      	str	r0, [r3, #20]
 8003bd4:	4770      	bx	lr
 8003bd6:	bf00      	nop
 8003bd8:	40010400 	.word	0x40010400

08003bdc <EXTI_GetITStatus>:
  ITStatus bitstatus = RESET;
  uint32_t enablestatus = 0;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 8003bdc:	4b05      	ldr	r3, [pc, #20]	; (8003bf4 <EXTI_GetITStatus+0x18>)
 8003bde:	681a      	ldr	r2, [r3, #0]
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8003be0:	695b      	ldr	r3, [r3, #20]
 8003be2:	4003      	ands	r3, r0
 8003be4:	d004      	beq.n	8003bf0 <EXTI_GetITStatus+0x14>
 8003be6:	4210      	tst	r0, r2
  {
    bitstatus = SET;
 8003be8:	bf0c      	ite	eq
 8003bea:	2000      	moveq	r0, #0
 8003bec:	2001      	movne	r0, #1
 8003bee:	4770      	bx	lr
  }
  else
  {
    bitstatus = RESET;
 8003bf0:	4618      	mov	r0, r3
  }
  return bitstatus;
}
 8003bf2:	4770      	bx	lr
 8003bf4:	40010400 	.word	0x40010400

08003bf8 <EXTI_ClearITPendingBit>:
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8003bf8:	4b01      	ldr	r3, [pc, #4]	; (8003c00 <EXTI_ClearITPendingBit+0x8>)
 8003bfa:	6158      	str	r0, [r3, #20]
 8003bfc:	4770      	bx	lr
 8003bfe:	bf00      	nop
 8003c00:	40010400 	.word	0x40010400

08003c04 <GPIO_DeInit>:
  * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.
  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 8003c04:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  if (GPIOx == GPIOA)
 8003c06:	4b23      	ldr	r3, [pc, #140]	; (8003c94 <GPIO_DeInit+0x90>)
 8003c08:	4298      	cmp	r0, r3
 8003c0a:	d105      	bne.n	8003c18 <GPIO_DeInit+0x14>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
 8003c0c:	2004      	movs	r0, #4
 8003c0e:	2101      	movs	r1, #1
 8003c10:	f000 fd52 	bl	80046b8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
 8003c14:	2004      	movs	r0, #4
 8003c16:	e036      	b.n	8003c86 <GPIO_DeInit+0x82>
  }
  else if (GPIOx == GPIOB)
 8003c18:	4b1f      	ldr	r3, [pc, #124]	; (8003c98 <GPIO_DeInit+0x94>)
 8003c1a:	4298      	cmp	r0, r3
 8003c1c:	d105      	bne.n	8003c2a <GPIO_DeInit+0x26>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
 8003c1e:	2008      	movs	r0, #8
 8003c20:	2101      	movs	r1, #1
 8003c22:	f000 fd49 	bl	80046b8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
 8003c26:	2008      	movs	r0, #8
 8003c28:	e02d      	b.n	8003c86 <GPIO_DeInit+0x82>
  }
  else if (GPIOx == GPIOC)
 8003c2a:	4b1c      	ldr	r3, [pc, #112]	; (8003c9c <GPIO_DeInit+0x98>)
 8003c2c:	4298      	cmp	r0, r3
 8003c2e:	d105      	bne.n	8003c3c <GPIO_DeInit+0x38>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
 8003c30:	2010      	movs	r0, #16
 8003c32:	2101      	movs	r1, #1
 8003c34:	f000 fd40 	bl	80046b8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
 8003c38:	2010      	movs	r0, #16
 8003c3a:	e024      	b.n	8003c86 <GPIO_DeInit+0x82>
  }
  else if (GPIOx == GPIOD)
 8003c3c:	4b18      	ldr	r3, [pc, #96]	; (8003ca0 <GPIO_DeInit+0x9c>)
 8003c3e:	4298      	cmp	r0, r3
 8003c40:	d105      	bne.n	8003c4e <GPIO_DeInit+0x4a>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
 8003c42:	2020      	movs	r0, #32
 8003c44:	2101      	movs	r1, #1
 8003c46:	f000 fd37 	bl	80046b8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
 8003c4a:	2020      	movs	r0, #32
 8003c4c:	e01b      	b.n	8003c86 <GPIO_DeInit+0x82>
  }    
  else if (GPIOx == GPIOE)
 8003c4e:	4b15      	ldr	r3, [pc, #84]	; (8003ca4 <GPIO_DeInit+0xa0>)
 8003c50:	4298      	cmp	r0, r3
 8003c52:	d105      	bne.n	8003c60 <GPIO_DeInit+0x5c>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
 8003c54:	2040      	movs	r0, #64	; 0x40
 8003c56:	2101      	movs	r1, #1
 8003c58:	f000 fd2e 	bl	80046b8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
 8003c5c:	2040      	movs	r0, #64	; 0x40
 8003c5e:	e012      	b.n	8003c86 <GPIO_DeInit+0x82>
  } 
  else if (GPIOx == GPIOF)
 8003c60:	4b11      	ldr	r3, [pc, #68]	; (8003ca8 <GPIO_DeInit+0xa4>)
 8003c62:	4298      	cmp	r0, r3
 8003c64:	d105      	bne.n	8003c72 <GPIO_DeInit+0x6e>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
 8003c66:	2080      	movs	r0, #128	; 0x80
 8003c68:	2101      	movs	r1, #1
 8003c6a:	f000 fd25 	bl	80046b8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
 8003c6e:	2080      	movs	r0, #128	; 0x80
 8003c70:	e009      	b.n	8003c86 <GPIO_DeInit+0x82>
  }
  else
  {
    if (GPIOx == GPIOG)
 8003c72:	4b0e      	ldr	r3, [pc, #56]	; (8003cac <GPIO_DeInit+0xa8>)
 8003c74:	4298      	cmp	r0, r3
 8003c76:	d10b      	bne.n	8003c90 <GPIO_DeInit+0x8c>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
 8003c78:	f44f 7080 	mov.w	r0, #256	; 0x100
 8003c7c:	2101      	movs	r1, #1
 8003c7e:	f000 fd1b 	bl	80046b8 <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
 8003c82:	f44f 7080 	mov.w	r0, #256	; 0x100
 8003c86:	2100      	movs	r1, #0
    }
  }
}
 8003c88:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if (GPIOx == GPIOG)
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
 8003c8c:	f000 bd14 	b.w	80046b8 <RCC_APB2PeriphResetCmd>
 8003c90:	bd08      	pop	{r3, pc}
 8003c92:	bf00      	nop
 8003c94:	40010800 	.word	0x40010800
 8003c98:	40010c00 	.word	0x40010c00
 8003c9c:	40011000 	.word	0x40011000
 8003ca0:	40011400 	.word	0x40011400
 8003ca4:	40011800 	.word	0x40011800
 8003ca8:	40011c00 	.word	0x40011c00
 8003cac:	40012000 	.word	0x40012000

08003cb0 <GPIO_AFIODeInit>:
  * @param  None
  * @retval None
  */
void GPIO_AFIODeInit(void)
{
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
 8003cb0:	2001      	movs	r0, #1
 8003cb2:	4601      	mov	r1, r0
  *   and EXTI configuration) registers to their default reset values.
  * @param  None
  * @retval None
  */
void GPIO_AFIODeInit(void)
{
 8003cb4:	b508      	push	{r3, lr}
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
 8003cb6:	f000 fcff 	bl	80046b8 <RCC_APB2PeriphResetCmd>
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
 8003cba:	2001      	movs	r0, #1
 8003cbc:	2100      	movs	r1, #0
}
 8003cbe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  * @retval None
  */
void GPIO_AFIODeInit(void)
{
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
 8003cc2:	f000 bcf9 	b.w	80046b8 <RCC_APB2PeriphResetCmd>

08003cc6 <GPIO_Init>:
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 8003cc6:	78cb      	ldrb	r3, [r1, #3]
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *         contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8003cc8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 8003ccc:	06da      	lsls	r2, r3, #27
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 8003cce:	bf48      	it	mi
 8003cd0:	788a      	ldrbmi	r2, [r1, #2]
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8003cd2:	8809      	ldrh	r1, [r1, #0]
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 8003cd4:	f003 050f 	and.w	r5, r3, #15
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 8003cd8:	bf48      	it	mi
 8003cda:	4315      	orrmi	r5, r2
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8003cdc:	f011 0fff 	tst.w	r1, #255	; 0xff
 8003ce0:	d01f      	beq.n	8003d22 <GPIO_Init+0x5c>
  {
    tmpreg = GPIOx->CRL;
 8003ce2:	6804      	ldr	r4, [r0, #0]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8003ce4:	2200      	movs	r2, #0
    {
      pos = ((uint32_t)0x01) << pinpos;
 8003ce6:	f04f 0c01 	mov.w	ip, #1
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8003cea:	f04f 080f 	mov.w	r8, #15
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
 8003cee:	fa0c f702 	lsl.w	r7, ip, r2
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8003cf2:	ea07 0601 	and.w	r6, r7, r1
      if (currentpin == pos)
 8003cf6:	42be      	cmp	r6, r7
 8003cf8:	d10f      	bne.n	8003d1a <GPIO_Init+0x54>
      {
        pos = pinpos << 2;
 8003cfa:	0097      	lsls	r7, r2, #2
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8003cfc:	fa08 f907 	lsl.w	r9, r8, r7
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8003d00:	fa05 f707 	lsl.w	r7, r5, r7
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8003d04:	ea24 0409 	bic.w	r4, r4, r9
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8003d08:	2b28      	cmp	r3, #40	; 0x28
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8003d0a:	ea44 0407 	orr.w	r4, r4, r7
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8003d0e:	d101      	bne.n	8003d14 <GPIO_Init+0x4e>
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 8003d10:	6146      	str	r6, [r0, #20]
 8003d12:	e002      	b.n	8003d1a <GPIO_Init+0x54>
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8003d14:	2b48      	cmp	r3, #72	; 0x48
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 8003d16:	bf08      	it	eq
 8003d18:	6106      	streq	r6, [r0, #16]
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8003d1a:	3201      	adds	r2, #1
 8003d1c:	2a08      	cmp	r2, #8
 8003d1e:	d1e6      	bne.n	8003cee <GPIO_Init+0x28>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 8003d20:	6004      	str	r4, [r0, #0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 8003d22:	29ff      	cmp	r1, #255	; 0xff
 8003d24:	d921      	bls.n	8003d6a <GPIO_Init+0xa4>
  {
    tmpreg = GPIOx->CRH;
 8003d26:	6844      	ldr	r4, [r0, #4]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8003d28:	2200      	movs	r2, #0
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 8003d2a:	f04f 0c01 	mov.w	ip, #1
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8003d2e:	f04f 080f 	mov.w	r8, #15
  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *         contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
 8003d32:	f102 0708 	add.w	r7, r2, #8
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 8003d36:	fa0c f707 	lsl.w	r7, ip, r7
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8003d3a:	ea07 0601 	and.w	r6, r7, r1
      if (currentpin == pos)
 8003d3e:	42be      	cmp	r6, r7
 8003d40:	d10f      	bne.n	8003d62 <GPIO_Init+0x9c>
      {
        pos = pinpos << 2;
 8003d42:	0097      	lsls	r7, r2, #2
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8003d44:	fa08 f907 	lsl.w	r9, r8, r7
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8003d48:	fa05 f707 	lsl.w	r7, r5, r7
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8003d4c:	ea24 0409 	bic.w	r4, r4, r9
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8003d50:	2b28      	cmp	r3, #40	; 0x28
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8003d52:	ea44 0407 	orr.w	r4, r4, r7
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8003d56:	d101      	bne.n	8003d5c <GPIO_Init+0x96>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8003d58:	6146      	str	r6, [r0, #20]
 8003d5a:	e002      	b.n	8003d62 <GPIO_Init+0x9c>
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8003d5c:	2b48      	cmp	r3, #72	; 0x48
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8003d5e:	bf08      	it	eq
 8003d60:	6106      	streq	r6, [r0, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8003d62:	3201      	adds	r2, #1
 8003d64:	2a08      	cmp	r2, #8
 8003d66:	d1e4      	bne.n	8003d32 <GPIO_Init+0x6c>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 8003d68:	6044      	str	r4, [r0, #4]
 8003d6a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08003d6e <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8003d6e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8003d72:	8003      	strh	r3, [r0, #0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8003d74:	2302      	movs	r3, #2
 8003d76:	7083      	strb	r3, [r0, #2]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8003d78:	2304      	movs	r3, #4
 8003d7a:	70c3      	strb	r3, [r0, #3]
 8003d7c:	4770      	bx	lr

08003d7e <GPIO_ReadInputDataBit>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8003d7e:	6883      	ldr	r3, [r0, #8]
 8003d80:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8003d82:	bf0c      	ite	eq
 8003d84:	2000      	moveq	r0, #0
 8003d86:	2001      	movne	r0, #1
 8003d88:	4770      	bx	lr

08003d8a <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  return ((uint16_t)GPIOx->IDR);
 8003d8a:	6880      	ldr	r0, [r0, #8]
}
 8003d8c:	b280      	uxth	r0, r0
 8003d8e:	4770      	bx	lr

08003d90 <GPIO_ReadOutputDataBit>:
  uint8_t bitstatus = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8003d90:	68c3      	ldr	r3, [r0, #12]
 8003d92:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8003d94:	bf0c      	ite	eq
 8003d96:	2000      	moveq	r0, #0
 8003d98:	2001      	movne	r0, #1
 8003d9a:	4770      	bx	lr

08003d9c <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    
  return ((uint16_t)GPIOx->ODR);
 8003d9c:	68c0      	ldr	r0, [r0, #12]
}
 8003d9e:	b280      	uxth	r0, r0
 8003da0:	4770      	bx	lr

08003da2 <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
 8003da2:	6101      	str	r1, [r0, #16]
 8003da4:	4770      	bx	lr

08003da6 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
 8003da6:	6141      	str	r1, [r0, #20]
 8003da8:	4770      	bx	lr

08003daa <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
  
  if (BitVal != Bit_RESET)
 8003daa:	b10a      	cbz	r2, 8003db0 <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
 8003dac:	6101      	str	r1, [r0, #16]
 8003dae:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = GPIO_Pin;
 8003db0:	6141      	str	r1, [r0, #20]
 8003db2:	4770      	bx	lr

08003db4 <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  GPIOx->ODR = PortVal;
 8003db4:	60c1      	str	r1, [r0, #12]
 8003db6:	4770      	bx	lr

08003db8 <GPIO_PinLockConfig>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  tmp |= GPIO_Pin;
 8003db8:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8003dbc:	6183      	str	r3, [r0, #24]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 8003dbe:	6181      	str	r1, [r0, #24]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8003dc0:	6183      	str	r3, [r0, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8003dc2:	6983      	ldr	r3, [r0, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8003dc4:	6983      	ldr	r3, [r0, #24]
 8003dc6:	4770      	bx	lr

08003dc8 <GPIO_EventOutputConfig>:
  uint32_t tmpreg = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
 8003dc8:	4a05      	ldr	r2, [pc, #20]	; (8003de0 <GPIO_EventOutputConfig+0x18>)
  * @param  GPIO_PinSource: specifies the pin for the Event output.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 8003dca:	b510      	push	{r4, lr}
  uint32_t tmpreg = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
 8003dcc:	6814      	ldr	r4, [r2, #0]
  /* Clear the PORT[6:4] and PIN[3:0] bits */
  tmpreg &= EVCR_PORTPINCONFIG_MASK;
 8003dce:	f64f 7380 	movw	r3, #65408	; 0xff80
 8003dd2:	4023      	ands	r3, r4
  tmpreg |= (uint32_t)GPIO_PortSource << 0x04;
 8003dd4:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
  tmpreg |= GPIO_PinSource;
 8003dd8:	430b      	orrs	r3, r1
  AFIO->EVCR = tmpreg;
 8003dda:	6013      	str	r3, [r2, #0]
 8003ddc:	bd10      	pop	{r4, pc}
 8003dde:	bf00      	nop
 8003de0:	40010000 	.word	0x40010000

08003de4 <GPIO_EventOutputCmd>:
void GPIO_EventOutputCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) EVCR_EVOE_BB = (uint32_t)NewState;
 8003de4:	4b01      	ldr	r3, [pc, #4]	; (8003dec <GPIO_EventOutputCmd+0x8>)
 8003de6:	6018      	str	r0, [r3, #0]
 8003de8:	4770      	bx	lr
 8003dea:	bf00      	nop
 8003dec:	4220001c 	.word	0x4220001c

08003df0 <GPIO_PinRemapConfig>:

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
 8003df0:	2800      	cmp	r0, #0
 8003df2:	4b17      	ldr	r3, [pc, #92]	; (8003e50 <GPIO_PinRemapConfig+0x60>)
  * @param  NewState: new state of the port pin remapping.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)
{
 8003df4:	b530      	push	{r4, r5, lr}
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8003df6:	f400 1440 	and.w	r4, r0, #3145728	; 0x300000
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
  {
    tmpreg = AFIO->MAPR2;
 8003dfa:	bfb4      	ite	lt
 8003dfc:	69db      	ldrlt	r3, [r3, #28]
  }
  else
  {
    tmpreg = AFIO->MAPR;
 8003dfe:	685b      	ldrge	r3, [r3, #4]
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8003e00:	f5b4 1f40 	cmp.w	r4, #3145728	; 0x300000
  {
    tmpreg = AFIO->MAPR;
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;
 8003e04:	b282      	uxth	r2, r0

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8003e06:	d107      	bne.n	8003e18 <GPIO_PinRemapConfig+0x28>
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 8003e08:	4c11      	ldr	r4, [pc, #68]	; (8003e50 <GPIO_PinRemapConfig+0x60>)
  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
 8003e0a:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 8003e0e:	6865      	ldr	r5, [r4, #4]
 8003e10:	f025 6570 	bic.w	r5, r5, #251658240	; 0xf000000
 8003e14:	6065      	str	r5, [r4, #4]
 8003e16:	e00f      	b.n	8003e38 <GPIO_PinRemapConfig+0x48>
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 8003e18:	02c4      	lsls	r4, r0, #11
 8003e1a:	d505      	bpl.n	8003e28 <GPIO_PinRemapConfig+0x38>
  else
  {
    tmpreg = AFIO->MAPR;
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
 8003e1c:	f3c0 4403 	ubfx	r4, r0, #16, #4
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
  {
    tmp1 = ((uint32_t)0x03) << tmpmask;
 8003e20:	2503      	movs	r5, #3
 8003e22:	fa05 f404 	lsl.w	r4, r5, r4
 8003e26:	e003      	b.n	8003e30 <GPIO_PinRemapConfig+0x40>
    tmpreg &= ~tmp1;
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 8003e28:	0d44      	lsrs	r4, r0, #21
 8003e2a:	0124      	lsls	r4, r4, #4
 8003e2c:	fa02 f404 	lsl.w	r4, r2, r4
 8003e30:	ea23 0304 	bic.w	r3, r3, r4
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 8003e34:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
  }

  if (NewState != DISABLE)
 8003e38:	b121      	cbz	r1, 8003e44 <GPIO_PinRemapConfig+0x54>
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
 8003e3a:	0d41      	lsrs	r1, r0, #21
 8003e3c:	0109      	lsls	r1, r1, #4
 8003e3e:	fa02 f201 	lsl.w	r2, r2, r1
 8003e42:	4313      	orrs	r3, r2
 8003e44:	4a02      	ldr	r2, [pc, #8]	; (8003e50 <GPIO_PinRemapConfig+0x60>)
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
 8003e46:	2800      	cmp	r0, #0
  {
    AFIO->MAPR2 = tmpreg;
 8003e48:	bfb4      	ite	lt
 8003e4a:	61d3      	strlt	r3, [r2, #28]
  }
  else
  {
    AFIO->MAPR = tmpreg;
 8003e4c:	6053      	strge	r3, [r2, #4]
 8003e4e:	bd30      	pop	{r4, r5, pc}
 8003e50:	40010000 	.word	0x40010000

08003e54 <GPIO_EXTILineConfig>:
  uint32_t tmp = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
 8003e54:	f001 0203 	and.w	r2, r1, #3
  * @param  GPIO_PinSource: specifies the EXTI line to be configured.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 8003e58:	b530      	push	{r4, r5, lr}
  uint32_t tmp = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
 8003e5a:	0092      	lsls	r2, r2, #2
 8003e5c:	240f      	movs	r4, #15
 8003e5e:	fa04 f402 	lsl.w	r4, r4, r2
  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));
 8003e62:	fa00 f002 	lsl.w	r0, r0, r2
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
 8003e66:	4b07      	ldr	r3, [pc, #28]	; (8003e84 <GPIO_EXTILineConfig+0x30>)
 8003e68:	0889      	lsrs	r1, r1, #2
 8003e6a:	3102      	adds	r1, #2
 8003e6c:	f853 5021 	ldr.w	r5, [r3, r1, lsl #2]
 8003e70:	ea25 0404 	bic.w	r4, r5, r4
 8003e74:	f843 4021 	str.w	r4, [r3, r1, lsl #2]
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));
 8003e78:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
 8003e7c:	4304      	orrs	r4, r0
 8003e7e:	f843 4021 	str.w	r4, [r3, r1, lsl #2]
 8003e82:	bd30      	pop	{r4, r5, pc}
 8003e84:	40010000 	.word	0x40010000

08003e88 <GPIO_ETH_MediaInterfaceConfig>:
void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface) 
{ 
  assert_param(IS_GPIO_ETH_MEDIA_INTERFACE(GPIO_ETH_MediaInterface)); 

  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) MAPR_MII_RMII_SEL_BB = GPIO_ETH_MediaInterface; 
 8003e88:	4b01      	ldr	r3, [pc, #4]	; (8003e90 <GPIO_ETH_MediaInterfaceConfig+0x8>)
 8003e8a:	6018      	str	r0, [r3, #0]
 8003e8c:	4770      	bx	lr
 8003e8e:	bf00      	nop
 8003e90:	422000dc 	.word	0x422000dc

08003e94 <I2C_DeInit>:
  * @brief  Deinitializes the I2Cx peripheral registers to their default reset values.
  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
  * @retval None
  */
void I2C_DeInit(I2C_TypeDef* I2Cx)
{
 8003e94:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  if (I2Cx == I2C1)
 8003e96:	4b0b      	ldr	r3, [pc, #44]	; (8003ec4 <I2C_DeInit+0x30>)
 8003e98:	4298      	cmp	r0, r3
 8003e9a:	d107      	bne.n	8003eac <I2C_DeInit+0x18>
  {
    /* Enable I2C1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
 8003e9c:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8003ea0:	2101      	movs	r1, #1
 8003ea2:	f000 fc15 	bl	80046d0 <RCC_APB1PeriphResetCmd>
    /* Release I2C1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
 8003ea6:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8003eaa:	e006      	b.n	8003eba <I2C_DeInit+0x26>
  }
  else
  {
    /* Enable I2C2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
 8003eac:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 8003eb0:	2101      	movs	r1, #1
 8003eb2:	f000 fc0d 	bl	80046d0 <RCC_APB1PeriphResetCmd>
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
 8003eb6:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 8003eba:	2100      	movs	r1, #0
  }
}
 8003ebc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    /* Enable I2C2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
 8003ec0:	f000 bc06 	b.w	80046d0 <RCC_APB1PeriphResetCmd>
 8003ec4:	40005400 	.word	0x40005400

08003ec8 <I2C_Init>:
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
  *   contains the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
 8003ec8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003eca:	b087      	sub	sp, #28
 8003ecc:	4604      	mov	r4, r0
  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
 8003ece:	8886      	ldrh	r6, [r0, #4]
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= CR2_FREQ_Reset;
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 8003ed0:	a801      	add	r0, sp, #4
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
  *   contains the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
 8003ed2:	460d      	mov	r5, r1
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= CR2_FREQ_Reset;
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 8003ed4:	f000 fb5e 	bl	8004594 <RCC_GetClocksFreq>
  pclk1 = rcc_clocks.PCLK1_Frequency;
 8003ed8:	9903      	ldr	r1, [sp, #12]
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 8003eda:	482d      	ldr	r0, [pc, #180]	; (8003f90 <I2C_Init+0xc8>)

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= CR2_FREQ_Reset;
 8003edc:	f026 063f 	bic.w	r6, r6, #63	; 0x3f
 8003ee0:	0436      	lsls	r6, r6, #16
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
  pclk1 = rcc_clocks.PCLK1_Frequency;
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 8003ee2:	fbb1 f0f0 	udiv	r0, r1, r0

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= CR2_FREQ_Reset;
 8003ee6:	0c36      	lsrs	r6, r6, #16
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
  pclk1 = rcc_clocks.PCLK1_Frequency;
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 8003ee8:	b287      	uxth	r7, r0
  tmpreg |= freqrange;
 8003eea:	433e      	orrs	r6, r7
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;
 8003eec:	80a6      	strh	r6, [r4, #4]

/*---------------------------- I2Cx CCR Configuration ------------------------*/
  /* Disable the selected I2C peripheral to configure TRISE */
  I2Cx->CR1 &= CR1_PE_Reset;
 8003eee:	8822      	ldrh	r2, [r4, #0]
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 8003ef0:	682b      	ldr	r3, [r5, #0]
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;

/*---------------------------- I2Cx CCR Configuration ------------------------*/
  /* Disable the selected I2C peripheral to configure TRISE */
  I2Cx->CR1 &= CR1_PE_Reset;
 8003ef2:	f022 0201 	bic.w	r2, r2, #1
 8003ef6:	0412      	lsls	r2, r2, #16
 8003ef8:	0c12      	lsrs	r2, r2, #16
 8003efa:	8022      	strh	r2, [r4, #0]
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 8003efc:	4a25      	ldr	r2, [pc, #148]	; (8003f94 <I2C_Init+0xcc>)
 8003efe:	4293      	cmp	r3, r2
 8003f00:	d80a      	bhi.n	8003f18 <I2C_Init+0x50>
  {
    /* Standard mode speed calculate */
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
 8003f02:	005b      	lsls	r3, r3, #1
 8003f04:	fbb1 f3f3 	udiv	r3, r1, r3
      result = 0x04;  
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
 8003f08:	3701      	adds	r7, #1

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
  {
    /* Standard mode speed calculate */
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
 8003f0a:	b29b      	uxth	r3, r3
      result = 0x04;  
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
 8003f0c:	b2bf      	uxth	r7, r7
 8003f0e:	8427      	strh	r7, [r4, #32]
    {
      /* Set minimum allowed value */
      result = 0x04;  
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
 8003f10:	2b03      	cmp	r3, #3
 8003f12:	bf98      	it	ls
 8003f14:	2304      	movls	r3, #4
 8003f16:	e020      	b.n	8003f5a <I2C_Init+0x92>
    I2Cx->TRISE = freqrange + 1; 
  }
  /* Configure speed in fast mode */
  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
  {
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
 8003f18:	88ee      	ldrh	r6, [r5, #6]
 8003f1a:	f64b 72ff 	movw	r2, #49151	; 0xbfff
 8003f1e:	4296      	cmp	r6, r2
 8003f20:	d104      	bne.n	8003f2c <I2C_Init+0x64>
    {
      /* Fast mode speed calculate: Tlow/Thigh = 2 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
 8003f22:	2203      	movs	r2, #3
 8003f24:	4353      	muls	r3, r2
 8003f26:	fbb1 f3f3 	udiv	r3, r1, r3
 8003f2a:	e005      	b.n	8003f38 <I2C_Init+0x70>
    }
    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    {
      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
 8003f2c:	2219      	movs	r2, #25
 8003f2e:	4353      	muls	r3, r2
 8003f30:	fbb1 f3f3 	udiv	r3, r1, r3
      /* Set DUTY bit */
      result |= I2C_DutyCycle_16_9;
 8003f34:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003f38:	b29b      	uxth	r3, r3
    }

    /* Test if CCR value is under 0x1*/
    if ((result & CCR_CCR_Set) == 0)
 8003f3a:	051a      	lsls	r2, r3, #20
      result |= (uint16_t)0x0001;  
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | CCR_FS_Set);
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 8003f3c:	f44f 7296 	mov.w	r2, #300	; 0x12c

    /* Test if CCR value is under 0x1*/
    if ((result & CCR_CCR_Set) == 0)
    {
      /* Set minimum allowed value */
      result |= (uint16_t)0x0001;  
 8003f40:	bf08      	it	eq
 8003f42:	f043 0301 	orreq.w	r3, r3, #1
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | CCR_FS_Set);
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 8003f46:	4350      	muls	r0, r2
 8003f48:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8003f4c:	fb90 f0f2 	sdiv	r0, r0, r2
 8003f50:	3001      	adds	r0, #1
 8003f52:	b280      	uxth	r0, r0
    {
      /* Set minimum allowed value */
      result |= (uint16_t)0x0001;  
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | CCR_FS_Set);
 8003f54:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 8003f58:	8420      	strh	r0, [r4, #32]
  }

  /* Write to I2Cx CCR */
  I2Cx->CCR = tmpreg;
 8003f5a:	83a3      	strh	r3, [r4, #28]
  /* Enable the selected I2C peripheral */
  I2Cx->CR1 |= CR1_PE_Set;
 8003f5c:	8823      	ldrh	r3, [r4, #0]
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_Mask;
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8003f5e:	8969      	ldrh	r1, [r5, #10]
  }

  /* Write to I2Cx CCR */
  I2Cx->CCR = tmpreg;
  /* Enable the selected I2C peripheral */
  I2Cx->CR1 |= CR1_PE_Set;
 8003f60:	b29b      	uxth	r3, r3
 8003f62:	f043 0301 	orr.w	r3, r3, #1
 8003f66:	8023      	strh	r3, [r4, #0]

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
 8003f68:	8823      	ldrh	r3, [r4, #0]
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_Mask;
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8003f6a:	88aa      	ldrh	r2, [r5, #4]

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_Mask;
 8003f6c:	f423 6381 	bic.w	r3, r3, #1032	; 0x408
 8003f70:	f023 0302 	bic.w	r3, r3, #2
 8003f74:	041b      	lsls	r3, r3, #16
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8003f76:	430a      	orrs	r2, r1

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_Mask;
 8003f78:	0c1b      	lsrs	r3, r3, #16
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8003f7a:	4313      	orrs	r3, r2
 8003f7c:	b29b      	uxth	r3, r3
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;
 8003f7e:	8023      	strh	r3, [r4, #0]

/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
  /* Set I2Cx Own Address1 and acknowledged address */
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 8003f80:	892a      	ldrh	r2, [r5, #8]
 8003f82:	89ab      	ldrh	r3, [r5, #12]
 8003f84:	4313      	orrs	r3, r2
 8003f86:	b29b      	uxth	r3, r3
 8003f88:	8123      	strh	r3, [r4, #8]
}
 8003f8a:	b007      	add	sp, #28
 8003f8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003f8e:	bf00      	nop
 8003f90:	000f4240 	.word	0x000f4240
 8003f94:	000186a0 	.word	0x000186a0

08003f98 <I2C_StructInit>:
  */
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
{
/*---------------- Reset I2C init structure parameters values ----------------*/
  /* initialize the I2C_ClockSpeed member */
  I2C_InitStruct->I2C_ClockSpeed = 5000;
 8003f98:	f241 3388 	movw	r3, #5000	; 0x1388
 8003f9c:	6003      	str	r3, [r0, #0]
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
 8003f9e:	2300      	movs	r3, #0
 8003fa0:	8083      	strh	r3, [r0, #4]
  /* Initialize the I2C_DutyCycle member */
  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
 8003fa2:	f64b 72ff 	movw	r2, #49151	; 0xbfff
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
 8003fa6:	8103      	strh	r3, [r0, #8]
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
 8003fa8:	8143      	strh	r3, [r0, #10]
  /* Initialize the I2C_AcknowledgedAddress member */
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8003faa:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  /* initialize the I2C_ClockSpeed member */
  I2C_InitStruct->I2C_ClockSpeed = 5000;
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
  /* Initialize the I2C_DutyCycle member */
  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
 8003fae:	80c2      	strh	r2, [r0, #6]
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
  /* Initialize the I2C_AcknowledgedAddress member */
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8003fb0:	8183      	strh	r3, [r0, #12]
 8003fb2:	4770      	bx	lr

08003fb4 <I2C_Cmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= CR1_PE_Set;
 8003fb4:	8803      	ldrh	r3, [r0, #0]
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003fb6:	b119      	cbz	r1, 8003fc0 <I2C_Cmd+0xc>
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= CR1_PE_Set;
 8003fb8:	b29b      	uxth	r3, r3
 8003fba:	f043 0301 	orr.w	r3, r3, #1
 8003fbe:	e003      	b.n	8003fc8 <I2C_Cmd+0x14>
  }
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= CR1_PE_Reset;
 8003fc0:	f023 0301 	bic.w	r3, r3, #1
 8003fc4:	041b      	lsls	r3, r3, #16
 8003fc6:	0c1b      	lsrs	r3, r3, #16
 8003fc8:	8003      	strh	r3, [r0, #0]
 8003fca:	4770      	bx	lr

08003fcc <I2C_DMACmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR2 |= CR2_DMAEN_Set;
 8003fcc:	8883      	ldrh	r3, [r0, #4]
void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003fce:	b119      	cbz	r1, 8003fd8 <I2C_DMACmd+0xc>
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR2 |= CR2_DMAEN_Set;
 8003fd0:	b29b      	uxth	r3, r3
 8003fd2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8003fd6:	e003      	b.n	8003fe0 <I2C_DMACmd+0x14>
  }
  else
  {
    /* Disable the selected I2C DMA requests */
    I2Cx->CR2 &= CR2_DMAEN_Reset;
 8003fd8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8003fdc:	041b      	lsls	r3, r3, #16
 8003fde:	0c1b      	lsrs	r3, r3, #16
 8003fe0:	8083      	strh	r3, [r0, #4]
 8003fe2:	4770      	bx	lr

08003fe4 <I2C_DMALastTransferCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Next DMA transfer is the last transfer */
    I2Cx->CR2 |= CR2_LAST_Set;
 8003fe4:	8883      	ldrh	r3, [r0, #4]
void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003fe6:	b119      	cbz	r1, 8003ff0 <I2C_DMALastTransferCmd+0xc>
  {
    /* Next DMA transfer is the last transfer */
    I2Cx->CR2 |= CR2_LAST_Set;
 8003fe8:	b29b      	uxth	r3, r3
 8003fea:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8003fee:	e003      	b.n	8003ff8 <I2C_DMALastTransferCmd+0x14>
  }
  else
  {
    /* Next DMA transfer is not the last transfer */
    I2Cx->CR2 &= CR2_LAST_Reset;
 8003ff0:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8003ff4:	041b      	lsls	r3, r3, #16
 8003ff6:	0c1b      	lsrs	r3, r3, #16
 8003ff8:	8083      	strh	r3, [r0, #4]
 8003ffa:	4770      	bx	lr

08003ffc <I2C_GenerateSTART>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Generate a START condition */
    I2Cx->CR1 |= CR1_START_Set;
 8003ffc:	8803      	ldrh	r3, [r0, #0]
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003ffe:	b119      	cbz	r1, 8004008 <I2C_GenerateSTART+0xc>
  {
    /* Generate a START condition */
    I2Cx->CR1 |= CR1_START_Set;
 8004000:	b29b      	uxth	r3, r3
 8004002:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004006:	e003      	b.n	8004010 <I2C_GenerateSTART+0x14>
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= CR1_START_Reset;
 8004008:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800400c:	041b      	lsls	r3, r3, #16
 800400e:	0c1b      	lsrs	r3, r3, #16
 8004010:	8003      	strh	r3, [r0, #0]
 8004012:	4770      	bx	lr

08004014 <I2C_GenerateSTOP>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= CR1_STOP_Set;
 8004014:	8803      	ldrh	r3, [r0, #0]
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004016:	b119      	cbz	r1, 8004020 <I2C_GenerateSTOP+0xc>
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= CR1_STOP_Set;
 8004018:	b29b      	uxth	r3, r3
 800401a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800401e:	e003      	b.n	8004028 <I2C_GenerateSTOP+0x14>
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= CR1_STOP_Reset;
 8004020:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8004024:	041b      	lsls	r3, r3, #16
 8004026:	0c1b      	lsrs	r3, r3, #16
 8004028:	8003      	strh	r3, [r0, #0]
 800402a:	4770      	bx	lr

0800402c <I2C_AcknowledgeConfig>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= CR1_ACK_Set;
 800402c:	8803      	ldrh	r3, [r0, #0]
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800402e:	b119      	cbz	r1, 8004038 <I2C_AcknowledgeConfig+0xc>
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= CR1_ACK_Set;
 8004030:	b29b      	uxth	r3, r3
 8004032:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8004036:	e003      	b.n	8004040 <I2C_AcknowledgeConfig+0x14>
  }
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= CR1_ACK_Reset;
 8004038:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800403c:	041b      	lsls	r3, r3, #16
 800403e:	0c1b      	lsrs	r3, r3, #16
 8004040:	8003      	strh	r3, [r0, #0]
 8004042:	4770      	bx	lr

08004044 <I2C_OwnAddress2Config>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Get the old register value */
  tmpreg = I2Cx->OAR2;
 8004044:	8983      	ldrh	r3, [r0, #12]

  /* Reset I2Cx Own address2 bit [7:1] */
  tmpreg &= OAR2_ADD2_Reset;

  /* Set I2Cx Own address2 */
  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
 8004046:	f001 01fe 	and.w	r1, r1, #254	; 0xfe

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Get the old register value */
  tmpreg = I2Cx->OAR2;
 800404a:	b29b      	uxth	r3, r3

  /* Reset I2Cx Own address2 bit [7:1] */
  tmpreg &= OAR2_ADD2_Reset;
 800404c:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe

  /* Set I2Cx Own address2 */
  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
 8004050:	430b      	orrs	r3, r1

  /* Store the new register value */
  I2Cx->OAR2 = tmpreg;
 8004052:	8183      	strh	r3, [r0, #12]
 8004054:	4770      	bx	lr

08004056 <I2C_DualAddressCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable dual addressing mode */
    I2Cx->OAR2 |= OAR2_ENDUAL_Set;
 8004056:	8983      	ldrh	r3, [r0, #12]
void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004058:	b119      	cbz	r1, 8004062 <I2C_DualAddressCmd+0xc>
  {
    /* Enable dual addressing mode */
    I2Cx->OAR2 |= OAR2_ENDUAL_Set;
 800405a:	b29b      	uxth	r3, r3
 800405c:	f043 0301 	orr.w	r3, r3, #1
 8004060:	e003      	b.n	800406a <I2C_DualAddressCmd+0x14>
  }
  else
  {
    /* Disable dual addressing mode */
    I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
 8004062:	f023 0301 	bic.w	r3, r3, #1
 8004066:	041b      	lsls	r3, r3, #16
 8004068:	0c1b      	lsrs	r3, r3, #16
 800406a:	8183      	strh	r3, [r0, #12]
 800406c:	4770      	bx	lr

0800406e <I2C_GeneralCallCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable generall call */
    I2Cx->CR1 |= CR1_ENGC_Set;
 800406e:	8803      	ldrh	r3, [r0, #0]
void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004070:	b119      	cbz	r1, 800407a <I2C_GeneralCallCmd+0xc>
  {
    /* Enable generall call */
    I2Cx->CR1 |= CR1_ENGC_Set;
 8004072:	b29b      	uxth	r3, r3
 8004074:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8004078:	e003      	b.n	8004082 <I2C_GeneralCallCmd+0x14>
  }
  else
  {
    /* Disable generall call */
    I2Cx->CR1 &= CR1_ENGC_Reset;
 800407a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800407e:	041b      	lsls	r3, r3, #16
 8004080:	0c1b      	lsrs	r3, r3, #16
 8004082:	8003      	strh	r3, [r0, #0]
 8004084:	4770      	bx	lr

08004086 <I2C_ITConfig>:
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
 8004086:	8883      	ldrh	r3, [r0, #4]
 8004088:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
 800408a:	b10a      	cbz	r2, 8004090 <I2C_ITConfig+0xa>
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
 800408c:	4319      	orrs	r1, r3
 800408e:	e001      	b.n	8004094 <I2C_ITConfig+0xe>
  }
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
 8004090:	ea23 0101 	bic.w	r1, r3, r1
 8004094:	8081      	strh	r1, [r0, #4]
 8004096:	4770      	bx	lr

08004098 <I2C_SendData>:
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
 8004098:	8201      	strh	r1, [r0, #16]
 800409a:	4770      	bx	lr

0800409c <I2C_ReceiveData>:
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
 800409c:	8a00      	ldrh	r0, [r0, #16]
}
 800409e:	b2c0      	uxtb	r0, r0
 80040a0:	4770      	bx	lr

080040a2 <I2C_Send7bitAddress>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
 80040a2:	b112      	cbz	r2, 80040aa <I2C_Send7bitAddress+0x8>
  {
    /* Set the address bit0 for read */
    Address |= OAR1_ADD0_Set;
 80040a4:	f041 0101 	orr.w	r1, r1, #1
 80040a8:	e001      	b.n	80040ae <I2C_Send7bitAddress+0xc>
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= OAR1_ADD0_Reset;
 80040aa:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
  }
  /* Send the address */
  I2Cx->DR = Address;
 80040ae:	8201      	strh	r1, [r0, #16]
 80040b0:	4770      	bx	lr

080040b2 <I2C_ReadRegister>:
  *     @arg I2C_Register_CCR:   CCR register.
  *     @arg I2C_Register_TRISE: TRISE register.
  * @retval The value of the read register.
  */
uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
{
 80040b2:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 80040b4:	2300      	movs	r3, #0
 80040b6:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_REGISTER(I2C_Register));

  tmp = (uint32_t) I2Cx;
 80040b8:	9001      	str	r0, [sp, #4]
  tmp += I2C_Register;
 80040ba:	9b01      	ldr	r3, [sp, #4]
 80040bc:	18c9      	adds	r1, r1, r3
 80040be:	9101      	str	r1, [sp, #4]

  /* Return the selected register value */
  return (*(__IO uint16_t *) tmp);
 80040c0:	9b01      	ldr	r3, [sp, #4]
 80040c2:	8818      	ldrh	r0, [r3, #0]
}
 80040c4:	b280      	uxth	r0, r0
 80040c6:	b002      	add	sp, #8
 80040c8:	4770      	bx	lr

080040ca <I2C_SoftwareResetCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Peripheral under reset */
    I2Cx->CR1 |= CR1_SWRST_Set;
 80040ca:	8803      	ldrh	r3, [r0, #0]
void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80040cc:	b129      	cbz	r1, 80040da <I2C_SoftwareResetCmd+0x10>
  {
    /* Peripheral under reset */
    I2Cx->CR1 |= CR1_SWRST_Set;
 80040ce:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80040d2:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80040d6:	b29b      	uxth	r3, r3
 80040d8:	e001      	b.n	80040de <I2C_SoftwareResetCmd+0x14>
  }
  else
  {
    /* Peripheral not under reset */
    I2Cx->CR1 &= CR1_SWRST_Reset;
 80040da:	045b      	lsls	r3, r3, #17
 80040dc:	0c5b      	lsrs	r3, r3, #17
 80040de:	8003      	strh	r3, [r0, #0]
 80040e0:	4770      	bx	lr

080040e2 <I2C_NACKPositionConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
  
  /* Check the input parameter */
  if (I2C_NACKPosition == I2C_NACKPosition_Next)
 80040e2:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
  {
    /* Next byte in shift register is the last received byte */
    I2Cx->CR1 |= I2C_NACKPosition_Next;
 80040e6:	8803      	ldrh	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
  
  /* Check the input parameter */
  if (I2C_NACKPosition == I2C_NACKPosition_Next)
 80040e8:	d103      	bne.n	80040f2 <I2C_NACKPositionConfig+0x10>
  {
    /* Next byte in shift register is the last received byte */
    I2Cx->CR1 |= I2C_NACKPosition_Next;
 80040ea:	b29b      	uxth	r3, r3
 80040ec:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80040f0:	e003      	b.n	80040fa <I2C_NACKPositionConfig+0x18>
  }
  else
  {
    /* Current byte in shift register is the last received byte */
    I2Cx->CR1 &= I2C_NACKPosition_Current;
 80040f2:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80040f6:	041b      	lsls	r3, r3, #16
 80040f8:	0c1b      	lsrs	r3, r3, #16
 80040fa:	8003      	strh	r3, [r0, #0]
 80040fc:	4770      	bx	lr

080040fe <I2C_SMBusAlertConfig>:
void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
 80040fe:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
  {
    /* Drive the SMBusAlert pin Low */
    I2Cx->CR1 |= I2C_SMBusAlert_Low;
 8004102:	8803      	ldrh	r3, [r0, #0]
void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
 8004104:	d103      	bne.n	800410e <I2C_SMBusAlertConfig+0x10>
  {
    /* Drive the SMBusAlert pin Low */
    I2Cx->CR1 |= I2C_SMBusAlert_Low;
 8004106:	b29b      	uxth	r3, r3
 8004108:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800410c:	e003      	b.n	8004116 <I2C_SMBusAlertConfig+0x18>
  }
  else
  {
    /* Drive the SMBusAlert pin High  */
    I2Cx->CR1 &= I2C_SMBusAlert_High;
 800410e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8004112:	041b      	lsls	r3, r3, #16
 8004114:	0c1b      	lsrs	r3, r3, #16
 8004116:	8003      	strh	r3, [r0, #0]
 8004118:	4770      	bx	lr

0800411a <I2C_TransmitPEC>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C PEC transmission */
    I2Cx->CR1 |= CR1_PEC_Set;
 800411a:	8803      	ldrh	r3, [r0, #0]
void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800411c:	b119      	cbz	r1, 8004126 <I2C_TransmitPEC+0xc>
  {
    /* Enable the selected I2C PEC transmission */
    I2Cx->CR1 |= CR1_PEC_Set;
 800411e:	b29b      	uxth	r3, r3
 8004120:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8004124:	e003      	b.n	800412e <I2C_TransmitPEC+0x14>
  }
  else
  {
    /* Disable the selected I2C PEC transmission */
    I2Cx->CR1 &= CR1_PEC_Reset;
 8004126:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800412a:	041b      	lsls	r3, r3, #16
 800412c:	0c1b      	lsrs	r3, r3, #16
 800412e:	8003      	strh	r3, [r0, #0]
 8004130:	4770      	bx	lr

08004132 <I2C_PECPositionConfig>:
void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
  if (I2C_PECPosition == I2C_PECPosition_Next)
 8004132:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
  {
    /* Next byte in shift register is PEC */
    I2Cx->CR1 |= I2C_PECPosition_Next;
 8004136:	8803      	ldrh	r3, [r0, #0]
void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
  if (I2C_PECPosition == I2C_PECPosition_Next)
 8004138:	d103      	bne.n	8004142 <I2C_PECPositionConfig+0x10>
  {
    /* Next byte in shift register is PEC */
    I2Cx->CR1 |= I2C_PECPosition_Next;
 800413a:	b29b      	uxth	r3, r3
 800413c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8004140:	e003      	b.n	800414a <I2C_PECPositionConfig+0x18>
  }
  else
  {
    /* Current byte in shift register is PEC */
    I2Cx->CR1 &= I2C_PECPosition_Current;
 8004142:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8004146:	041b      	lsls	r3, r3, #16
 8004148:	0c1b      	lsrs	r3, r3, #16
 800414a:	8003      	strh	r3, [r0, #0]
 800414c:	4770      	bx	lr

0800414e <I2C_CalculatePEC>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C PEC calculation */
    I2Cx->CR1 |= CR1_ENPEC_Set;
 800414e:	8803      	ldrh	r3, [r0, #0]
void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004150:	b119      	cbz	r1, 800415a <I2C_CalculatePEC+0xc>
  {
    /* Enable the selected I2C PEC calculation */
    I2Cx->CR1 |= CR1_ENPEC_Set;
 8004152:	b29b      	uxth	r3, r3
 8004154:	f043 0320 	orr.w	r3, r3, #32
 8004158:	e003      	b.n	8004162 <I2C_CalculatePEC+0x14>
  }
  else
  {
    /* Disable the selected I2C PEC calculation */
    I2Cx->CR1 &= CR1_ENPEC_Reset;
 800415a:	f023 0320 	bic.w	r3, r3, #32
 800415e:	041b      	lsls	r3, r3, #16
 8004160:	0c1b      	lsrs	r3, r3, #16
 8004162:	8003      	strh	r3, [r0, #0]
 8004164:	4770      	bx	lr

08004166 <I2C_GetPEC>:
uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the selected I2C PEC value */
  return ((I2Cx->SR2) >> 8);
 8004166:	8b00      	ldrh	r0, [r0, #24]
}
 8004168:	f3c0 2007 	ubfx	r0, r0, #8, #8
 800416c:	4770      	bx	lr

0800416e <I2C_ARPCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C ARP */
    I2Cx->CR1 |= CR1_ENARP_Set;
 800416e:	8803      	ldrh	r3, [r0, #0]
void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004170:	b119      	cbz	r1, 800417a <I2C_ARPCmd+0xc>
  {
    /* Enable the selected I2C ARP */
    I2Cx->CR1 |= CR1_ENARP_Set;
 8004172:	b29b      	uxth	r3, r3
 8004174:	f043 0310 	orr.w	r3, r3, #16
 8004178:	e003      	b.n	8004182 <I2C_ARPCmd+0x14>
  }
  else
  {
    /* Disable the selected I2C ARP */
    I2Cx->CR1 &= CR1_ENARP_Reset;
 800417a:	f023 0310 	bic.w	r3, r3, #16
 800417e:	041b      	lsls	r3, r3, #16
 8004180:	0c1b      	lsrs	r3, r3, #16
 8004182:	8003      	strh	r3, [r0, #0]
 8004184:	4770      	bx	lr

08004186 <I2C_StretchClockCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState == DISABLE)
  {
    /* Enable the selected I2C Clock stretching */
    I2Cx->CR1 |= CR1_NOSTRETCH_Set;
 8004186:	8803      	ldrh	r3, [r0, #0]
void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState == DISABLE)
 8004188:	b919      	cbnz	r1, 8004192 <I2C_StretchClockCmd+0xc>
  {
    /* Enable the selected I2C Clock stretching */
    I2Cx->CR1 |= CR1_NOSTRETCH_Set;
 800418a:	b29b      	uxth	r3, r3
 800418c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004190:	e003      	b.n	800419a <I2C_StretchClockCmd+0x14>
  }
  else
  {
    /* Disable the selected I2C Clock stretching */
    I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
 8004192:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004196:	041b      	lsls	r3, r3, #16
 8004198:	0c1b      	lsrs	r3, r3, #16
 800419a:	8003      	strh	r3, [r0, #0]
 800419c:	4770      	bx	lr

0800419e <I2C_FastModeDutyCycleConfig>:
void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
 800419e:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
  {
    /* I2C fast mode Tlow/Thigh=2 */
    I2Cx->CCR &= I2C_DutyCycle_2;
 80041a2:	8b83      	ldrh	r3, [r0, #28]
void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
 80041a4:	d004      	beq.n	80041b0 <I2C_FastModeDutyCycleConfig+0x12>
  {
    /* I2C fast mode Tlow/Thigh=2 */
    I2Cx->CCR &= I2C_DutyCycle_2;
 80041a6:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80041aa:	041b      	lsls	r3, r3, #16
 80041ac:	0c1b      	lsrs	r3, r3, #16
 80041ae:	e002      	b.n	80041b6 <I2C_FastModeDutyCycleConfig+0x18>
  }
  else
  {
    /* I2C fast mode Tlow/Thigh=16/9 */
    I2Cx->CCR |= I2C_DutyCycle_16_9;
 80041b0:	b29b      	uxth	r3, r3
 80041b2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80041b6:	8383      	strh	r3, [r0, #28]
 80041b8:	4770      	bx	lr

080041ba <I2C_CheckEvent>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_EVENT(I2C_EVENT));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 80041ba:	8a83      	ldrh	r3, [r0, #20]
  flag2 = I2Cx->SR2;
 80041bc:	8b00      	ldrh	r0, [r0, #24]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_EVENT(I2C_EVENT));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 80041be:	b29b      	uxth	r3, r3
  flag2 = I2Cx->SR2;
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_Mask;
 80041c0:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80041c4:	4008      	ands	r0, r1

  /* Check whether the last event contains the I2C_EVENT */
  if ((lastevent & I2C_EVENT) == I2C_EVENT)
 80041c6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    /* ERROR: last event is different from I2C_EVENT */
    status = ERROR;
  }
  /* Return status */
  return status;
}
 80041ca:	1a43      	subs	r3, r0, r1
 80041cc:	4258      	negs	r0, r3
 80041ce:	4158      	adcs	r0, r3
 80041d0:	4770      	bx	lr

080041d2 <I2C_GetLastEvent>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 80041d2:	8a83      	ldrh	r3, [r0, #20]
  flag2 = I2Cx->SR2;
 80041d4:	8b00      	ldrh	r0, [r0, #24]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 80041d6:	b29b      	uxth	r3, r3
  flag2 = I2Cx->SR2;
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_Mask;
 80041d8:	ea43 4000 	orr.w	r0, r3, r0, lsl #16

  /* Return status */
  return lastevent;
}
 80041dc:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80041e0:	4770      	bx	lr

080041e2 <I2C_GetFlagStatus>:
  *   Address matched flag (Slave mode)"ENDA"
  *     @arg I2C_FLAG_SB: Start bit flag (Master mode)
  * @retval The new state of I2C_FLAG (SET or RESET).
  */
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
 80041e2:	b082      	sub	sp, #8
  FlagStatus bitstatus = RESET;
  __IO uint32_t i2creg = 0, i2cxbase = 0;
 80041e4:	2300      	movs	r3, #0
 80041e6:	9300      	str	r3, [sp, #0]
 80041e8:	9301      	str	r3, [sp, #4]

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
 80041ea:	0f0b      	lsrs	r3, r1, #28
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
 80041ec:	9001      	str	r0, [sp, #4]
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
 80041ee:	9300      	str	r3, [sp, #0]
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_Mask;
  
  if(i2creg != 0)
 80041f0:	9b00      	ldr	r3, [sp, #0]
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_Mask;
 80041f2:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
  
  if(i2creg != 0)
 80041f6:	b113      	cbz	r3, 80041fe <I2C_GetFlagStatus+0x1c>
  {
    /* Get the I2Cx SR1 register address */
    i2cxbase += 0x14;
 80041f8:	9b01      	ldr	r3, [sp, #4]
 80041fa:	3314      	adds	r3, #20
 80041fc:	e002      	b.n	8004204 <I2C_GetFlagStatus+0x22>
  else
  {
    /* Flag in I2Cx SR2 Register */
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
 80041fe:	9b01      	ldr	r3, [sp, #4]
    i2cxbase += 0x14;
  }
  else
  {
    /* Flag in I2Cx SR2 Register */
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
 8004200:	0c09      	lsrs	r1, r1, #16
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
 8004202:	3318      	adds	r3, #24
 8004204:	9301      	str	r3, [sp, #4]
  }
  
  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
 8004206:	9b01      	ldr	r3, [sp, #4]
 8004208:	681b      	ldr	r3, [r3, #0]
 800420a:	4219      	tst	r1, r3
    bitstatus = RESET;
  }
  
  /* Return the I2C_FLAG status */
  return  bitstatus;
}
 800420c:	bf0c      	ite	eq
 800420e:	2000      	moveq	r0, #0
 8004210:	2001      	movne	r0, #1
 8004212:	b002      	add	sp, #8
 8004214:	4770      	bx	lr

08004216 <I2C_ClearFlag>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
  /* Get the I2C flag position */
  flagpos = I2C_FLAG & FLAG_Mask;
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 8004216:	43c9      	mvns	r1, r1
 8004218:	b289      	uxth	r1, r1
 800421a:	8281      	strh	r1, [r0, #20]
 800421c:	4770      	bx	lr

0800421e <I2C_GetITStatus>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  enablestatus = (uint32_t)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2)) ;
 800421e:	8883      	ldrh	r3, [r0, #4]
  
  /* Get bit[23:0] of the flag */
  I2C_IT &= FLAG_Mask;

  /* Check the status of the specified I2C flag */
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
 8004220:	8a80      	ldrh	r0, [r0, #20]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  enablestatus = (uint32_t)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2)) ;
 8004222:	b29b      	uxth	r3, r3
  
  /* Get bit[23:0] of the flag */
  I2C_IT &= FLAG_Mask;

  /* Check the status of the specified I2C flag */
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
 8004224:	b280      	uxth	r0, r0
 8004226:	4008      	ands	r0, r1
 8004228:	d006      	beq.n	8004238 <I2C_GetITStatus+0x1a>
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  enablestatus = (uint32_t)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2)) ;
 800422a:	f001 61e0 	and.w	r1, r1, #117440512	; 0x7000000
  
  /* Get bit[23:0] of the flag */
  I2C_IT &= FLAG_Mask;

  /* Check the status of the specified I2C flag */
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
 800422e:	ea13 4111 	ands.w	r1, r3, r1, lsr #16
  {
    /* I2C_IT is set */
    bitstatus = SET;
 8004232:	bf0c      	ite	eq
 8004234:	2000      	moveq	r0, #0
 8004236:	2001      	movne	r0, #1
    /* I2C_IT is reset */
    bitstatus = RESET;
  }
  /* Return the I2C_IT status */
  return  bitstatus;
}
 8004238:	4770      	bx	lr

0800423a <I2C_ClearITPendingBit>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
  /* Get the I2C flag position */
  flagpos = I2C_IT & FLAG_Mask;
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 800423a:	43c9      	mvns	r1, r1
 800423c:	b289      	uxth	r1, r1
 800423e:	8281      	strh	r1, [r0, #20]
 8004240:	4770      	bx	lr
 8004242:	bf00      	nop

08004244 <IWDG_WriteAccessCmd>:
  */
void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess)
{
  /* Check the parameters */
  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));
  IWDG->KR = IWDG_WriteAccess;
 8004244:	4b01      	ldr	r3, [pc, #4]	; (800424c <IWDG_WriteAccessCmd+0x8>)
 8004246:	6018      	str	r0, [r3, #0]
 8004248:	4770      	bx	lr
 800424a:	bf00      	nop
 800424c:	40003000 	.word	0x40003000

08004250 <IWDG_SetPrescaler>:
  */
void IWDG_SetPrescaler(uint8_t IWDG_Prescaler)
{
  /* Check the parameters */
  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));
  IWDG->PR = IWDG_Prescaler;
 8004250:	4b01      	ldr	r3, [pc, #4]	; (8004258 <IWDG_SetPrescaler+0x8>)
 8004252:	6058      	str	r0, [r3, #4]
 8004254:	4770      	bx	lr
 8004256:	bf00      	nop
 8004258:	40003000 	.word	0x40003000

0800425c <IWDG_SetReload>:
  */
void IWDG_SetReload(uint16_t Reload)
{
  /* Check the parameters */
  assert_param(IS_IWDG_RELOAD(Reload));
  IWDG->RLR = Reload;
 800425c:	4b01      	ldr	r3, [pc, #4]	; (8004264 <IWDG_SetReload+0x8>)
 800425e:	6098      	str	r0, [r3, #8]
 8004260:	4770      	bx	lr
 8004262:	bf00      	nop
 8004264:	40003000 	.word	0x40003000

08004268 <IWDG_ReloadCounter>:
  * @param  None
  * @retval None
  */
void IWDG_ReloadCounter(void)
{
  IWDG->KR = KR_KEY_Reload;
 8004268:	4b02      	ldr	r3, [pc, #8]	; (8004274 <IWDG_ReloadCounter+0xc>)
 800426a:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 800426e:	601a      	str	r2, [r3, #0]
 8004270:	4770      	bx	lr
 8004272:	bf00      	nop
 8004274:	40003000 	.word	0x40003000

08004278 <IWDG_Enable>:
  * @param  None
  * @retval None
  */
void IWDG_Enable(void)
{
  IWDG->KR = KR_KEY_Enable;
 8004278:	4b02      	ldr	r3, [pc, #8]	; (8004284 <IWDG_Enable+0xc>)
 800427a:	f64c 42cc 	movw	r2, #52428	; 0xcccc
 800427e:	601a      	str	r2, [r3, #0]
 8004280:	4770      	bx	lr
 8004282:	bf00      	nop
 8004284:	40003000 	.word	0x40003000

08004288 <IWDG_GetFlagStatus>:
FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG)
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_IWDG_FLAG(IWDG_FLAG));
  if ((IWDG->SR & IWDG_FLAG) != (uint32_t)RESET)
 8004288:	4b03      	ldr	r3, [pc, #12]	; (8004298 <IWDG_GetFlagStatus+0x10>)
 800428a:	68db      	ldr	r3, [r3, #12]
 800428c:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 800428e:	bf0c      	ite	eq
 8004290:	2000      	moveq	r0, #0
 8004292:	2001      	movne	r0, #1
 8004294:	4770      	bx	lr
 8004296:	bf00      	nop
 8004298:	40003000 	.word	0x40003000

0800429c <PWR_DeInit>:
  * @param  None
  * @retval None
  */
void PWR_DeInit(void)
{
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
 800429c:	2101      	movs	r1, #1
  * @brief  Deinitializes the PWR peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void PWR_DeInit(void)
{
 800429e:	b508      	push	{r3, lr}
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
 80042a0:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 80042a4:	f000 fa14 	bl	80046d0 <RCC_APB1PeriphResetCmd>
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
 80042a8:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 80042ac:	2100      	movs	r1, #0
}
 80042ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  * @retval None
  */
void PWR_DeInit(void)
{
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
 80042b2:	f000 ba0d 	b.w	80046d0 <RCC_APB1PeriphResetCmd>

080042b6 <PWR_BackupAccessCmd>:
  */
void PWR_BackupAccessCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 80042b6:	4b01      	ldr	r3, [pc, #4]	; (80042bc <PWR_BackupAccessCmd+0x6>)
 80042b8:	6018      	str	r0, [r3, #0]
 80042ba:	4770      	bx	lr
 80042bc:	420e0020 	.word	0x420e0020

080042c0 <PWR_PVDCmd>:
  */
void PWR_PVDCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
 80042c0:	4b01      	ldr	r3, [pc, #4]	; (80042c8 <PWR_PVDCmd+0x8>)
 80042c2:	6018      	str	r0, [r3, #0]
 80042c4:	4770      	bx	lr
 80042c6:	bf00      	nop
 80042c8:	420e0010 	.word	0x420e0010

080042cc <PWR_PVDLevelConfig>:
void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
  tmpreg = PWR->CR;
 80042cc:	4b03      	ldr	r3, [pc, #12]	; (80042dc <PWR_PVDLevelConfig+0x10>)
 80042ce:	681a      	ldr	r2, [r3, #0]
  /* Clear PLS[7:5] bits */
  tmpreg &= CR_PLS_MASK;
 80042d0:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
  tmpreg |= PWR_PVDLevel;
 80042d4:	4310      	orrs	r0, r2
  /* Store the new value */
  PWR->CR = tmpreg;
 80042d6:	6018      	str	r0, [r3, #0]
 80042d8:	4770      	bx	lr
 80042da:	bf00      	nop
 80042dc:	40007000 	.word	0x40007000

080042e0 <PWR_WakeUpPinCmd>:
  */
void PWR_WakeUpPinCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
 80042e0:	4b01      	ldr	r3, [pc, #4]	; (80042e8 <PWR_WakeUpPinCmd+0x8>)
 80042e2:	6018      	str	r0, [r3, #0]
 80042e4:	4770      	bx	lr
 80042e6:	bf00      	nop
 80042e8:	420e00a0 	.word	0x420e00a0

080042ec <PWR_EnterSTOPMode>:
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
  
  /* Select the regulator state in STOP mode ---------------------------------*/
  tmpreg = PWR->CR;
 80042ec:	4b0a      	ldr	r3, [pc, #40]	; (8004318 <PWR_EnterSTOPMode+0x2c>)
  PWR->CR = tmpreg;
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP;
  
  /* Select STOP mode entry --------------------------------------------------*/
  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 80042ee:	2901      	cmp	r1, #1
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
  
  /* Select the regulator state in STOP mode ---------------------------------*/
  tmpreg = PWR->CR;
 80042f0:	681a      	ldr	r2, [r3, #0]
  /* Clear PDDS and LPDS bits */
  tmpreg &= CR_DS_MASK;
 80042f2:	f022 0203 	bic.w	r2, r2, #3
  /* Set LPDS bit according to PWR_Regulator value */
  tmpreg |= PWR_Regulator;
 80042f6:	ea40 0002 	orr.w	r0, r0, r2
  /* Store the new value */
  PWR->CR = tmpreg;
 80042fa:	6018      	str	r0, [r3, #0]
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP;
 80042fc:	4b07      	ldr	r3, [pc, #28]	; (800431c <PWR_EnterSTOPMode+0x30>)
 80042fe:	691a      	ldr	r2, [r3, #16]
 8004300:	f042 0204 	orr.w	r2, r2, #4
 8004304:	611a      	str	r2, [r3, #16]
  
  /* Select STOP mode entry --------------------------------------------------*/
  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 8004306:	d101      	bne.n	800430c <PWR_EnterSTOPMode+0x20>
  {   
    /* Request Wait For Interrupt */
    __WFI();
 8004308:	bf30      	wfi
 800430a:	e000      	b.n	800430e <PWR_EnterSTOPMode+0x22>
  }
  else
  {
    /* Request Wait For Event */
    __WFE();
 800430c:	bf20      	wfe
  }
  
  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);  
 800430e:	691a      	ldr	r2, [r3, #16]
 8004310:	f022 0204 	bic.w	r2, r2, #4
 8004314:	611a      	str	r2, [r3, #16]
 8004316:	4770      	bx	lr
 8004318:	40007000 	.word	0x40007000
 800431c:	e000ed00 	.word	0xe000ed00

08004320 <PWR_EnterSTANDBYMode>:
  * @retval None
  */
void PWR_EnterSTANDBYMode(void)
{
  /* Clear Wake-up flag */
  PWR->CR |= PWR_CR_CWUF;
 8004320:	4b07      	ldr	r3, [pc, #28]	; (8004340 <PWR_EnterSTANDBYMode+0x20>)
 8004322:	681a      	ldr	r2, [r3, #0]
 8004324:	f042 0204 	orr.w	r2, r2, #4
 8004328:	601a      	str	r2, [r3, #0]
  /* Select STANDBY mode */
  PWR->CR |= PWR_CR_PDDS;
 800432a:	681a      	ldr	r2, [r3, #0]
 800432c:	f042 0202 	orr.w	r2, r2, #2
 8004330:	601a      	str	r2, [r3, #0]
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP;
 8004332:	4b04      	ldr	r3, [pc, #16]	; (8004344 <PWR_EnterSTANDBYMode+0x24>)
 8004334:	691a      	ldr	r2, [r3, #16]
 8004336:	f042 0204 	orr.w	r2, r2, #4
 800433a:	611a      	str	r2, [r3, #16]
/* This option is used to ensure that store operations are completed */
#if defined ( __CC_ARM   )
  __force_stores();
#endif
  /* Request Wait For Interrupt */
  __WFI();
 800433c:	bf30      	wfi
 800433e:	4770      	bx	lr
 8004340:	40007000 	.word	0x40007000
 8004344:	e000ed00 	.word	0xe000ed00

08004348 <PWR_GetFlagStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
  
  if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
 8004348:	4b03      	ldr	r3, [pc, #12]	; (8004358 <PWR_GetFlagStatus+0x10>)
 800434a:	685b      	ldr	r3, [r3, #4]
 800434c:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 800434e:	bf0c      	ite	eq
 8004350:	2000      	moveq	r0, #0
 8004352:	2001      	movne	r0, #1
 8004354:	4770      	bx	lr
 8004356:	bf00      	nop
 8004358:	40007000 	.word	0x40007000

0800435c <PWR_ClearFlag>:
void PWR_ClearFlag(uint32_t PWR_FLAG)
{
  /* Check the parameters */
  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
         
  PWR->CR |=  PWR_FLAG << 2;
 800435c:	4b02      	ldr	r3, [pc, #8]	; (8004368 <PWR_ClearFlag+0xc>)
 800435e:	681a      	ldr	r2, [r3, #0]
 8004360:	ea42 0080 	orr.w	r0, r2, r0, lsl #2
 8004364:	6018      	str	r0, [r3, #0]
 8004366:	4770      	bx	lr
 8004368:	40007000 	.word	0x40007000

0800436c <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800436c:	4b10      	ldr	r3, [pc, #64]	; (80043b0 <RCC_DeInit+0x44>)
 800436e:	681a      	ldr	r2, [r3, #0]
 8004370:	f042 0201 	orr.w	r2, r2, #1
 8004374:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
 8004376:	6859      	ldr	r1, [r3, #4]
 8004378:	4a0e      	ldr	r2, [pc, #56]	; (80043b4 <RCC_DeInit+0x48>)
 800437a:	400a      	ands	r2, r1
 800437c:	605a      	str	r2, [r3, #4]
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800437e:	681a      	ldr	r2, [r3, #0]
 8004380:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8004384:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8004388:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800438a:	681a      	ldr	r2, [r3, #0]
 800438c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8004390:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 8004392:	685a      	ldr	r2, [r3, #4]
 8004394:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8004398:	605a      	str	r2, [r3, #4]

#ifdef STM32F10X_CL
  /* Reset PLL2ON and PLL3ON bits */
  RCC->CR &= (uint32_t)0xEBFFFFFF;
 800439a:	681a      	ldr	r2, [r3, #0]
 800439c:	f022 52a0 	bic.w	r2, r2, #335544320	; 0x14000000
 80043a0:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x00FF0000;
 80043a2:	f44f 027f 	mov.w	r2, #16711680	; 0xff0000
 80043a6:	609a      	str	r2, [r3, #8]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;
 80043a8:	2200      	movs	r2, #0
 80043aa:	62da      	str	r2, [r3, #44]	; 0x2c
 80043ac:	4770      	bx	lr
 80043ae:	bf00      	nop
 80043b0:	40021000 	.word	0x40021000
 80043b4:	f0ff0000 	.word	0xf0ff0000

080043b8 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 80043b8:	4b0c      	ldr	r3, [pc, #48]	; (80043ec <RCC_HSEConfig+0x34>)
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 80043ba:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 80043be:	681a      	ldr	r2, [r3, #0]
 80043c0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80043c4:	601a      	str	r2, [r3, #0]
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
 80043c6:	681a      	ldr	r2, [r3, #0]
 80043c8:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80043cc:	601a      	str	r2, [r3, #0]
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 80043ce:	d003      	beq.n	80043d8 <RCC_HSEConfig+0x20>
 80043d0:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 80043d4:	d108      	bne.n	80043e8 <RCC_HSEConfig+0x30>
 80043d6:	e003      	b.n	80043e0 <RCC_HSEConfig+0x28>
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
 80043d8:	681a      	ldr	r2, [r3, #0]
 80043da:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80043de:	e002      	b.n	80043e6 <RCC_HSEConfig+0x2e>
      break;
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
 80043e0:	681a      	ldr	r2, [r3, #0]
 80043e2:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 80043e6:	601a      	str	r2, [r3, #0]
 80043e8:	4770      	bx	lr
 80043ea:	bf00      	nop
 80043ec:	40021000 	.word	0x40021000

080043f0 <RCC_AdjustHSICalibrationValue>:
void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
  tmpreg = RCC->CR;
 80043f0:	4b03      	ldr	r3, [pc, #12]	; (8004400 <RCC_AdjustHSICalibrationValue+0x10>)
 80043f2:	681a      	ldr	r2, [r3, #0]
  /* Clear HSITRIM[4:0] bits */
  tmpreg &= CR_HSITRIM_Mask;
 80043f4:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 80043f8:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
  /* Store the new value */
  RCC->CR = tmpreg;
 80043fc:	6018      	str	r0, [r3, #0]
 80043fe:	4770      	bx	lr
 8004400:	40021000 	.word	0x40021000

08004404 <RCC_HSICmd>:
  */
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 8004404:	4b01      	ldr	r3, [pc, #4]	; (800440c <RCC_HSICmd+0x8>)
 8004406:	6018      	str	r0, [r3, #0]
 8004408:	4770      	bx	lr
 800440a:	bf00      	nop
 800440c:	42420000 	.word	0x42420000

08004410 <RCC_PLLConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 8004410:	4b03      	ldr	r3, [pc, #12]	; (8004420 <RCC_PLLConfig+0x10>)
 8004412:	685a      	ldr	r2, [r3, #4]
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
 8004414:	f422 1274 	bic.w	r2, r2, #3997696	; 0x3d0000
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 8004418:	4310      	orrs	r0, r2
 800441a:	4301      	orrs	r1, r0
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800441c:	6059      	str	r1, [r3, #4]
 800441e:	4770      	bx	lr
 8004420:	40021000 	.word	0x40021000

08004424 <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8004424:	4b01      	ldr	r3, [pc, #4]	; (800442c <RCC_PLLCmd+0x8>)
 8004426:	6018      	str	r0, [r3, #0]
 8004428:	4770      	bx	lr
 800442a:	bf00      	nop
 800442c:	42420060 	.word	0x42420060

08004430 <RCC_PREDIV1Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_PREDIV1_SOURCE(RCC_PREDIV1_Source));
  assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));

  tmpreg = RCC->CFGR2;
 8004430:	4b04      	ldr	r3, [pc, #16]	; (8004444 <RCC_PREDIV1Config+0x14>)
 8004432:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  /* Clear PREDIV1[3:0] and PREDIV1SRC bits */
  tmpreg &= ~(CFGR2_PREDIV1 | CFGR2_PREDIV1SRC);
 8004434:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8004438:	f022 020f 	bic.w	r2, r2, #15
  /* Set the PREDIV1 clock source and division factor */
  tmpreg |= RCC_PREDIV1_Source | RCC_PREDIV1_Div ;
 800443c:	4310      	orrs	r0, r2
 800443e:	4301      	orrs	r1, r0
  /* Store the new value */
  RCC->CFGR2 = tmpreg;
 8004440:	62d9      	str	r1, [r3, #44]	; 0x2c
 8004442:	4770      	bx	lr
 8004444:	40021000 	.word	0x40021000

08004448 <RCC_PREDIV2Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PREDIV2(RCC_PREDIV2_Div));

  tmpreg = RCC->CFGR2;
 8004448:	4b03      	ldr	r3, [pc, #12]	; (8004458 <RCC_PREDIV2Config+0x10>)
 800444a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  /* Clear PREDIV2[3:0] bits */
  tmpreg &= ~CFGR2_PREDIV2;
 800444c:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  /* Set the PREDIV2 division factor */
  tmpreg |= RCC_PREDIV2_Div;
 8004450:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR2 = tmpreg;
 8004452:	62d8      	str	r0, [r3, #44]	; 0x2c
 8004454:	4770      	bx	lr
 8004456:	bf00      	nop
 8004458:	40021000 	.word	0x40021000

0800445c <RCC_PLL2Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PLL2_MUL(RCC_PLL2Mul));

  tmpreg = RCC->CFGR2;
 800445c:	4b03      	ldr	r3, [pc, #12]	; (800446c <RCC_PLL2Config+0x10>)
 800445e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  /* Clear PLL2Mul[3:0] bits */
  tmpreg &= ~CFGR2_PLL2MUL;
 8004460:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
  /* Set the PLL2 configuration bits */
  tmpreg |= RCC_PLL2Mul;
 8004464:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR2 = tmpreg;
 8004466:	62d8      	str	r0, [r3, #44]	; 0x2c
 8004468:	4770      	bx	lr
 800446a:	bf00      	nop
 800446c:	40021000 	.word	0x40021000

08004470 <RCC_PLL2Cmd>:
void RCC_PLL2Cmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLL2ON_BB = (uint32_t)NewState;
 8004470:	4b01      	ldr	r3, [pc, #4]	; (8004478 <RCC_PLL2Cmd+0x8>)
 8004472:	6018      	str	r0, [r3, #0]
 8004474:	4770      	bx	lr
 8004476:	bf00      	nop
 8004478:	42420068 	.word	0x42420068

0800447c <RCC_PLL3Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PLL3_MUL(RCC_PLL3Mul));

  tmpreg = RCC->CFGR2;
 800447c:	4b03      	ldr	r3, [pc, #12]	; (800448c <RCC_PLL3Config+0x10>)
 800447e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  /* Clear PLL3Mul[3:0] bits */
  tmpreg &= ~CFGR2_PLL3MUL;
 8004480:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
  /* Set the PLL3 configuration bits */
  tmpreg |= RCC_PLL3Mul;
 8004484:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR2 = tmpreg;
 8004486:	62d8      	str	r0, [r3, #44]	; 0x2c
 8004488:	4770      	bx	lr
 800448a:	bf00      	nop
 800448c:	40021000 	.word	0x40021000

08004490 <RCC_PLL3Cmd>:
void RCC_PLL3Cmd(FunctionalState NewState)
{
  /* Check the parameters */

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLL3ON_BB = (uint32_t)NewState;
 8004490:	4b01      	ldr	r3, [pc, #4]	; (8004498 <RCC_PLL3Cmd+0x8>)
 8004492:	6018      	str	r0, [r3, #0]
 8004494:	4770      	bx	lr
 8004496:	bf00      	nop
 8004498:	42420070 	.word	0x42420070

0800449c <RCC_SYSCLKConfig>:
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
 800449c:	4b03      	ldr	r3, [pc, #12]	; (80044ac <RCC_SYSCLKConfig+0x10>)
 800449e:	685a      	ldr	r2, [r3, #4]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 80044a0:	f022 0203 	bic.w	r2, r2, #3
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 80044a4:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80044a6:	6058      	str	r0, [r3, #4]
 80044a8:	4770      	bx	lr
 80044aa:	bf00      	nop
 80044ac:	40021000 	.word	0x40021000

080044b0 <RCC_GetSYSCLKSource>:
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
 80044b0:	4b02      	ldr	r3, [pc, #8]	; (80044bc <RCC_GetSYSCLKSource+0xc>)
 80044b2:	6858      	ldr	r0, [r3, #4]
}
 80044b4:	f000 000c 	and.w	r0, r0, #12
 80044b8:	4770      	bx	lr
 80044ba:	bf00      	nop
 80044bc:	40021000 	.word	0x40021000

080044c0 <RCC_HCLKConfig>:
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
 80044c0:	4b03      	ldr	r3, [pc, #12]	; (80044d0 <RCC_HCLKConfig+0x10>)
 80044c2:	685a      	ldr	r2, [r3, #4]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 80044c4:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 80044c8:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80044ca:	6058      	str	r0, [r3, #4]
 80044cc:	4770      	bx	lr
 80044ce:	bf00      	nop
 80044d0:	40021000 	.word	0x40021000

080044d4 <RCC_PCLK1Config>:
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 80044d4:	4b03      	ldr	r3, [pc, #12]	; (80044e4 <RCC_PCLK1Config+0x10>)
 80044d6:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 80044d8:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 80044dc:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80044de:	6058      	str	r0, [r3, #4]
 80044e0:	4770      	bx	lr
 80044e2:	bf00      	nop
 80044e4:	40021000 	.word	0x40021000

080044e8 <RCC_PCLK2Config>:
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 80044e8:	4b03      	ldr	r3, [pc, #12]	; (80044f8 <RCC_PCLK2Config+0x10>)
 80044ea:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 80044ec:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 80044f0:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80044f4:	6058      	str	r0, [r3, #4]
 80044f6:	4770      	bx	lr
 80044f8:	40021000 	.word	0x40021000

080044fc <RCC_ITConfig>:
  * @param  NewState: new state of the specified RCC interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
 80044fc:	4b04      	ldr	r3, [pc, #16]	; (8004510 <RCC_ITConfig+0x14>)
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 80044fe:	781a      	ldrb	r2, [r3, #0]
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004500:	b109      	cbz	r1, 8004506 <RCC_ITConfig+0xa>
  {
    /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 8004502:	4310      	orrs	r0, r2
 8004504:	e001      	b.n	800450a <RCC_ITConfig+0xe>
  }
  else
  {
    /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 8004506:	ea22 0000 	bic.w	r0, r2, r0
 800450a:	7018      	strb	r0, [r3, #0]
 800450c:	4770      	bx	lr
 800450e:	bf00      	nop
 8004510:	40021009 	.word	0x40021009

08004514 <RCC_OTGFSCLKConfig>:
void RCC_OTGFSCLKConfig(uint32_t RCC_OTGFSCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_OTGFSCLK_SOURCE(RCC_OTGFSCLKSource));

  *(__IO uint32_t *) CFGR_OTGFSPRE_BB = RCC_OTGFSCLKSource;
 8004514:	4b01      	ldr	r3, [pc, #4]	; (800451c <RCC_OTGFSCLKConfig+0x8>)
 8004516:	6018      	str	r0, [r3, #0]
 8004518:	4770      	bx	lr
 800451a:	bf00      	nop
 800451c:	424200d8 	.word	0x424200d8

08004520 <RCC_ADCCLKConfig>:
void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
  tmpreg = RCC->CFGR;
 8004520:	4b03      	ldr	r3, [pc, #12]	; (8004530 <RCC_ADCCLKConfig+0x10>)
 8004522:	685a      	ldr	r2, [r3, #4]
  /* Clear ADCPRE[1:0] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
 8004524:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2;
 8004528:	4310      	orrs	r0, r2
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800452a:	6058      	str	r0, [r3, #4]
 800452c:	4770      	bx	lr
 800452e:	bf00      	nop
 8004530:	40021000 	.word	0x40021000

08004534 <RCC_I2S2CLKConfig>:
void RCC_I2S2CLKConfig(uint32_t RCC_I2S2CLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_I2S2CLK_SOURCE(RCC_I2S2CLKSource));

  *(__IO uint32_t *) CFGR2_I2S2SRC_BB = RCC_I2S2CLKSource;
 8004534:	4b01      	ldr	r3, [pc, #4]	; (800453c <RCC_I2S2CLKConfig+0x8>)
 8004536:	6018      	str	r0, [r3, #0]
 8004538:	4770      	bx	lr
 800453a:	bf00      	nop
 800453c:	424205c4 	.word	0x424205c4

08004540 <RCC_I2S3CLKConfig>:
void RCC_I2S3CLKConfig(uint32_t RCC_I2S3CLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_I2S3CLK_SOURCE(RCC_I2S3CLKSource));

  *(__IO uint32_t *) CFGR2_I2S3SRC_BB = RCC_I2S3CLKSource;
 8004540:	4b01      	ldr	r3, [pc, #4]	; (8004548 <RCC_I2S3CLKConfig+0x8>)
 8004542:	6018      	str	r0, [r3, #0]
 8004544:	4770      	bx	lr
 8004546:	bf00      	nop
 8004548:	424205c8 	.word	0x424205c8

0800454c <RCC_LSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));
  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 800454c:	4b06      	ldr	r3, [pc, #24]	; (8004568 <RCC_LSEConfig+0x1c>)
 800454e:	2200      	movs	r2, #0
  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 8004550:	2801      	cmp	r0, #1
{
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));
  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8004552:	701a      	strb	r2, [r3, #0]
  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8004554:	701a      	strb	r2, [r3, #0]
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 8004556:	d002      	beq.n	800455e <RCC_LSEConfig+0x12>
 8004558:	2804      	cmp	r0, #4
 800455a:	d104      	bne.n	8004566 <RCC_LSEConfig+0x1a>
 800455c:	e001      	b.n	8004562 <RCC_LSEConfig+0x16>
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 800455e:	7018      	strb	r0, [r3, #0]
      break;
 8004560:	4770      	bx	lr
      
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 8004562:	2205      	movs	r2, #5
 8004564:	701a      	strb	r2, [r3, #0]
 8004566:	4770      	bx	lr
 8004568:	40021020 	.word	0x40021020

0800456c <RCC_LSICmd>:
  */
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 800456c:	4b01      	ldr	r3, [pc, #4]	; (8004574 <RCC_LSICmd+0x8>)
 800456e:	6018      	str	r0, [r3, #0]
 8004570:	4770      	bx	lr
 8004572:	bf00      	nop
 8004574:	42420480 	.word	0x42420480

08004578 <RCC_RTCCLKConfig>:
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 8004578:	4b02      	ldr	r3, [pc, #8]	; (8004584 <RCC_RTCCLKConfig+0xc>)
 800457a:	6a1a      	ldr	r2, [r3, #32]
 800457c:	4310      	orrs	r0, r2
 800457e:	6218      	str	r0, [r3, #32]
 8004580:	4770      	bx	lr
 8004582:	bf00      	nop
 8004584:	40021000 	.word	0x40021000

08004588 <RCC_RTCCLKCmd>:
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 8004588:	4b01      	ldr	r3, [pc, #4]	; (8004590 <RCC_RTCCLKCmd+0x8>)
 800458a:	6018      	str	r0, [r3, #0]
 800458c:	4770      	bx	lr
 800458e:	bf00      	nop
 8004590:	4242043c 	.word	0x4242043c

08004594 <RCC_GetClocksFreq>:
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8004594:	4a2b      	ldr	r2, [pc, #172]	; (8004644 <RCC_GetClocksFreq+0xb0>)
  * @note   The result of this function could be not correct when using 
  *         fractional value for HSE crystal.  
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8004596:	b530      	push	{r4, r5, lr}
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8004598:	6853      	ldr	r3, [r2, #4]
 800459a:	f003 030c 	and.w	r3, r3, #12
  
  switch (tmp)
 800459e:	2b04      	cmp	r3, #4
 80045a0:	d003      	beq.n	80045aa <RCC_GetClocksFreq+0x16>
 80045a2:	2b08      	cmp	r3, #8
 80045a4:	d003      	beq.n	80045ae <RCC_GetClocksFreq+0x1a>
 80045a6:	4b28      	ldr	r3, [pc, #160]	; (8004648 <RCC_GetClocksFreq+0xb4>)
 80045a8:	e029      	b.n	80045fe <RCC_GetClocksFreq+0x6a>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 80045aa:	4b28      	ldr	r3, [pc, #160]	; (800464c <RCC_GetClocksFreq+0xb8>)
 80045ac:	e027      	b.n	80045fe <RCC_GetClocksFreq+0x6a>
      break;
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 80045ae:	6853      	ldr	r3, [r2, #4]
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 80045b0:	6852      	ldr	r2, [r2, #4]
          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
        }
 #endif
      }
#else
      pllmull = pllmull >> 18;
 80045b2:	f3c3 4383 	ubfx	r3, r3, #18, #4
      
      if (pllmull != 0x0D)
 80045b6:	2b0d      	cmp	r3, #13
      break;
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 80045b8:	f402 3280 	and.w	r2, r2, #65536	; 0x10000
 #endif
      }
#else
      pllmull = pllmull >> 18;
      
      if (pllmull != 0x0D)
 80045bc:	d001      	beq.n	80045c2 <RCC_GetClocksFreq+0x2e>
      {
         pllmull += 2;
 80045be:	3302      	adds	r3, #2
 80045c0:	e000      	b.n	80045c4 <RCC_GetClocksFreq+0x30>
      }
      else
      { /* PLL multiplication factor = PLL input clock * 6.5 */
        pllmull = 13 / 2; 
 80045c2:	2306      	movs	r3, #6
      }
            
      if (pllsource == 0x00)
 80045c4:	b912      	cbnz	r2, 80045cc <RCC_GetClocksFreq+0x38>
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
 80045c6:	4a22      	ldr	r2, [pc, #136]	; (8004650 <RCC_GetClocksFreq+0xbc>)
 80045c8:	4353      	muls	r3, r2
 80045ca:	e018      	b.n	80045fe <RCC_GetClocksFreq+0x6a>
      }
      else
      {/* PREDIV1 selected as PLL clock entry */
        
        /* Get PREDIV1 clock source and division factor */
        prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
 80045cc:	4a1d      	ldr	r2, [pc, #116]	; (8004644 <RCC_GetClocksFreq+0xb0>)
 80045ce:	6ad4      	ldr	r4, [r2, #44]	; 0x2c
        prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
 80045d0:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 80045d2:	f001 010f 	and.w	r1, r1, #15
 80045d6:	3101      	adds	r1, #1
        
        if (prediv1source == 0)
 80045d8:	f414 3f80 	tst.w	r4, #65536	; 0x10000
 80045dc:	4c1b      	ldr	r4, [pc, #108]	; (800464c <RCC_GetClocksFreq+0xb8>)
 80045de:	d100      	bne.n	80045e2 <RCC_GetClocksFreq+0x4e>
 80045e0:	e00a      	b.n	80045f8 <RCC_GetClocksFreq+0x64>
        }
        else
        {/* PLL2 clock selected as PREDIV1 clock entry */
          
          /* Get PREDIV2 division factor and PLL2 multiplication factor */
          prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
 80045e2:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
 80045e4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
        }
        else
        {/* PLL2 clock selected as PREDIV1 clock entry */
          
          /* Get PREDIV2 division factor and PLL2 multiplication factor */
          prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
 80045e6:	f3c5 1503 	ubfx	r5, r5, #4, #4
 80045ea:	3501      	adds	r5, #1
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
 80045ec:	f3c2 2203 	ubfx	r2, r2, #8, #4
          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
 80045f0:	fbb4 f4f5 	udiv	r4, r4, r5
        else
        {/* PLL2 clock selected as PREDIV1 clock entry */
          
          /* Get PREDIV2 division factor and PLL2 multiplication factor */
          prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
 80045f4:	3202      	adds	r2, #2
          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
 80045f6:	4354      	muls	r4, r2
 80045f8:	fbb4 f1f1 	udiv	r1, r4, r1
 80045fc:	434b      	muls	r3, r1
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 80045fe:	4a11      	ldr	r2, [pc, #68]	; (8004644 <RCC_GetClocksFreq+0xb0>)
        {/* PLL2 clock selected as PREDIV1 clock entry */
          
          /* Get PREDIV2 division factor and PLL2 multiplication factor */
          prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
 8004600:	6003      	str	r3, [r0, #0]
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 8004602:	6851      	ldr	r1, [r2, #4]
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 8004604:	4b13      	ldr	r3, [pc, #76]	; (8004654 <RCC_GetClocksFreq+0xc0>)
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
  tmp = tmp >> 4;
 8004606:	f3c1 1103 	ubfx	r1, r1, #4, #4
  presc = APBAHBPrescTable[tmp];
 800460a:	5c5c      	ldrb	r4, [r3, r1]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 800460c:	6801      	ldr	r1, [r0, #0]
 800460e:	fa21 f104 	lsr.w	r1, r1, r4
 8004612:	6041      	str	r1, [r0, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 8004614:	6854      	ldr	r4, [r2, #4]
  tmp = tmp >> 8;
 8004616:	f3c4 2402 	ubfx	r4, r4, #8, #3
  presc = APBAHBPrescTable[tmp];
 800461a:	5d1c      	ldrb	r4, [r3, r4]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800461c:	fa21 f404 	lsr.w	r4, r1, r4
 8004620:	6084      	str	r4, [r0, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 8004622:	6854      	ldr	r4, [r2, #4]
  tmp = tmp >> 11;
 8004624:	f3c4 24c2 	ubfx	r4, r4, #11, #3
  presc = APBAHBPrescTable[tmp];
 8004628:	5d1c      	ldrb	r4, [r3, r4]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800462a:	fa21 f104 	lsr.w	r1, r1, r4
 800462e:	60c1      	str	r1, [r0, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 8004630:	6852      	ldr	r2, [r2, #4]
  tmp = tmp >> 14;
 8004632:	f3c2 3281 	ubfx	r2, r2, #14, #2
  presc = ADCPrescTable[tmp];
 8004636:	189b      	adds	r3, r3, r2
 8004638:	7c1b      	ldrb	r3, [r3, #16]
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 800463a:	fbb1 f1f3 	udiv	r1, r1, r3
 800463e:	6101      	str	r1, [r0, #16]
 8004640:	bd30      	pop	{r4, r5, pc}
 8004642:	bf00      	nop
 8004644:	40021000 	.word	0x40021000
 8004648:	007a1200 	.word	0x007a1200
 800464c:	017d7840 	.word	0x017d7840
 8004650:	003d0900 	.word	0x003d0900
 8004654:	20000084 	.word	0x20000084

08004658 <RCC_AHBPeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 8004658:	4b04      	ldr	r3, [pc, #16]	; (800466c <RCC_AHBPeriphClockCmd+0x14>)
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 800465a:	695a      	ldr	r2, [r3, #20]
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800465c:	b109      	cbz	r1, 8004662 <RCC_AHBPeriphClockCmd+0xa>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 800465e:	4310      	orrs	r0, r2
 8004660:	e001      	b.n	8004666 <RCC_AHBPeriphClockCmd+0xe>
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 8004662:	ea22 0000 	bic.w	r0, r2, r0
 8004666:	6158      	str	r0, [r3, #20]
 8004668:	4770      	bx	lr
 800466a:	bf00      	nop
 800466c:	40021000 	.word	0x40021000

08004670 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8004670:	4b04      	ldr	r3, [pc, #16]	; (8004684 <RCC_APB2PeriphClockCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8004672:	699a      	ldr	r2, [r3, #24]
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004674:	b109      	cbz	r1, 800467a <RCC_APB2PeriphClockCmd+0xa>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8004676:	4310      	orrs	r0, r2
 8004678:	e001      	b.n	800467e <RCC_APB2PeriphClockCmd+0xe>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 800467a:	ea22 0000 	bic.w	r0, r2, r0
 800467e:	6198      	str	r0, [r3, #24]
 8004680:	4770      	bx	lr
 8004682:	bf00      	nop
 8004684:	40021000 	.word	0x40021000

08004688 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8004688:	4b04      	ldr	r3, [pc, #16]	; (800469c <RCC_APB1PeriphClockCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 800468a:	69da      	ldr	r2, [r3, #28]
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800468c:	b109      	cbz	r1, 8004692 <RCC_APB1PeriphClockCmd+0xa>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 800468e:	4310      	orrs	r0, r2
 8004690:	e001      	b.n	8004696 <RCC_APB1PeriphClockCmd+0xe>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8004692:	ea22 0000 	bic.w	r0, r2, r0
 8004696:	61d8      	str	r0, [r3, #28]
 8004698:	4770      	bx	lr
 800469a:	bf00      	nop
 800469c:	40021000 	.word	0x40021000

080046a0 <RCC_AHBPeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 80046a0:	4b04      	ldr	r3, [pc, #16]	; (80046b4 <RCC_AHBPeriphResetCmd+0x14>)
  assert_param(IS_RCC_AHB_PERIPH_RESET(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHBRSTR |= RCC_AHBPeriph;
 80046a2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH_RESET(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80046a4:	b109      	cbz	r1, 80046aa <RCC_AHBPeriphResetCmd+0xa>
  {
    RCC->AHBRSTR |= RCC_AHBPeriph;
 80046a6:	4310      	orrs	r0, r2
 80046a8:	e001      	b.n	80046ae <RCC_AHBPeriphResetCmd+0xe>
  }
  else
  {
    RCC->AHBRSTR &= ~RCC_AHBPeriph;
 80046aa:	ea22 0000 	bic.w	r0, r2, r0
 80046ae:	6298      	str	r0, [r3, #40]	; 0x28
 80046b0:	4770      	bx	lr
 80046b2:	bf00      	nop
 80046b4:	40021000 	.word	0x40021000

080046b8 <RCC_APB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 80046b8:	4b04      	ldr	r3, [pc, #16]	; (80046cc <RCC_APB2PeriphResetCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 80046ba:	68da      	ldr	r2, [r3, #12]
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80046bc:	b109      	cbz	r1, 80046c2 <RCC_APB2PeriphResetCmd+0xa>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 80046be:	4310      	orrs	r0, r2
 80046c0:	e001      	b.n	80046c6 <RCC_APB2PeriphResetCmd+0xe>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 80046c2:	ea22 0000 	bic.w	r0, r2, r0
 80046c6:	60d8      	str	r0, [r3, #12]
 80046c8:	4770      	bx	lr
 80046ca:	bf00      	nop
 80046cc:	40021000 	.word	0x40021000

080046d0 <RCC_APB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 80046d0:	4b04      	ldr	r3, [pc, #16]	; (80046e4 <RCC_APB1PeriphResetCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 80046d2:	691a      	ldr	r2, [r3, #16]
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80046d4:	b109      	cbz	r1, 80046da <RCC_APB1PeriphResetCmd+0xa>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 80046d6:	4310      	orrs	r0, r2
 80046d8:	e001      	b.n	80046de <RCC_APB1PeriphResetCmd+0xe>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 80046da:	ea22 0000 	bic.w	r0, r2, r0
 80046de:	6118      	str	r0, [r3, #16]
 80046e0:	4770      	bx	lr
 80046e2:	bf00      	nop
 80046e4:	40021000 	.word	0x40021000

080046e8 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 80046e8:	4b01      	ldr	r3, [pc, #4]	; (80046f0 <RCC_BackupResetCmd+0x8>)
 80046ea:	6018      	str	r0, [r3, #0]
 80046ec:	4770      	bx	lr
 80046ee:	bf00      	nop
 80046f0:	42420440 	.word	0x42420440

080046f4 <RCC_ClockSecuritySystemCmd>:
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 80046f4:	4b01      	ldr	r3, [pc, #4]	; (80046fc <RCC_ClockSecuritySystemCmd+0x8>)
 80046f6:	6018      	str	r0, [r3, #0]
 80046f8:	4770      	bx	lr
 80046fa:	bf00      	nop
 80046fc:	4242004c 	.word	0x4242004c

08004700 <RCC_MCOConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCO));

  /* Perform Byte access to MCO bits to select the MCO source */
  *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
 8004700:	4b01      	ldr	r3, [pc, #4]	; (8004708 <RCC_MCOConfig+0x8>)
 8004702:	7018      	strb	r0, [r3, #0]
 8004704:	4770      	bx	lr
 8004706:	bf00      	nop
 8004708:	40021007 	.word	0x40021007

0800470c <RCC_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 800470c:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 800470e:	2b01      	cmp	r3, #1
 8004710:	4a07      	ldr	r2, [pc, #28]	; (8004730 <RCC_GetFlagStatus+0x24>)
 8004712:	d101      	bne.n	8004718 <RCC_GetFlagStatus+0xc>
  {
    statusreg = RCC->CR;
 8004714:	6813      	ldr	r3, [r2, #0]
 8004716:	e003      	b.n	8004720 <RCC_GetFlagStatus+0x14>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 8004718:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 800471a:	bf0c      	ite	eq
 800471c:	6a13      	ldreq	r3, [r2, #32]
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 800471e:	6a53      	ldrne	r3, [r2, #36]	; 0x24
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8004720:	f000 001f 	and.w	r0, r0, #31
 8004724:	fa23 f000 	lsr.w	r0, r3, r0
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
}
 8004728:	f000 0001 	and.w	r0, r0, #1
 800472c:	4770      	bx	lr
 800472e:	bf00      	nop
 8004730:	40021000 	.word	0x40021000

08004734 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 8004734:	b507      	push	{r0, r1, r2, lr}
  __IO uint32_t StartUpCounter = 0;
 8004736:	2300      	movs	r3, #0
 8004738:	9301      	str	r3, [sp, #4]
  FlagStatus HSEStatus = RESET;
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 800473a:	2031      	movs	r0, #49	; 0x31
 800473c:	f7ff ffe6 	bl	800470c <RCC_GetFlagStatus>
    StartUpCounter++;  
 8004740:	9b01      	ldr	r3, [sp, #4]
 8004742:	3301      	adds	r3, #1
 8004744:	9301      	str	r3, [sp, #4]
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 8004746:	9b01      	ldr	r3, [sp, #4]
 8004748:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800474c:	d001      	beq.n	8004752 <RCC_WaitForHSEStartUp+0x1e>
 800474e:	2800      	cmp	r0, #0
 8004750:	d0f3      	beq.n	800473a <RCC_WaitForHSEStartUp+0x6>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8004752:	2031      	movs	r0, #49	; 0x31
 8004754:	f7ff ffda 	bl	800470c <RCC_GetFlagStatus>
  else
  {
    status = ERROR;
  }  
  return (status);
}
 8004758:	3000      	adds	r0, #0
 800475a:	bf18      	it	ne
 800475c:	2001      	movne	r0, #1
 800475e:	bd0e      	pop	{r1, r2, r3, pc}

08004760 <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= CSR_RMVF_Set;
 8004760:	4b02      	ldr	r3, [pc, #8]	; (800476c <RCC_ClearFlag+0xc>)
 8004762:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004764:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8004768:	625a      	str	r2, [r3, #36]	; 0x24
 800476a:	4770      	bx	lr
 800476c:	40021000 	.word	0x40021000

08004770 <RCC_GetITStatus>:
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 8004770:	4b03      	ldr	r3, [pc, #12]	; (8004780 <RCC_GetITStatus+0x10>)
 8004772:	689b      	ldr	r3, [r3, #8]
 8004774:	4218      	tst	r0, r3
    bitstatus = RESET;
  }

  /* Return the RCC_IT status */
  return  bitstatus;
}
 8004776:	bf0c      	ite	eq
 8004778:	2000      	moveq	r0, #0
 800477a:	2001      	movne	r0, #1
 800477c:	4770      	bx	lr
 800477e:	bf00      	nop
 8004780:	40021000 	.word	0x40021000

08004784 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 8004784:	4b01      	ldr	r3, [pc, #4]	; (800478c <RCC_ClearITPendingBit+0x8>)
 8004786:	7018      	strb	r0, [r3, #0]
 8004788:	4770      	bx	lr
 800478a:	bf00      	nop
 800478c:	4002100a 	.word	0x4002100a

08004790 <RTC_ITConfig>:
  * @param  NewState: new state of the specified RTC interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState)
{
 8004790:	4b04      	ldr	r3, [pc, #16]	; (80047a4 <RTC_ITConfig+0x14>)
  assert_param(IS_RTC_IT(RTC_IT));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RTC->CRH |= RTC_IT;
 8004792:	881a      	ldrh	r2, [r3, #0]
 8004794:	b292      	uxth	r2, r2
{
  /* Check the parameters */
  assert_param(IS_RTC_IT(RTC_IT));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8004796:	b109      	cbz	r1, 800479c <RTC_ITConfig+0xc>
  {
    RTC->CRH |= RTC_IT;
 8004798:	4310      	orrs	r0, r2
 800479a:	e001      	b.n	80047a0 <RTC_ITConfig+0x10>
  }
  else
  {
    RTC->CRH &= (uint16_t)~RTC_IT;
 800479c:	ea22 0000 	bic.w	r0, r2, r0
 80047a0:	8018      	strh	r0, [r3, #0]
 80047a2:	4770      	bx	lr
 80047a4:	40002800 	.word	0x40002800

080047a8 <RTC_EnterConfigMode>:
  * @retval None
  */
void RTC_EnterConfigMode(void)
{
  /* Set the CNF flag to enter in the Configuration Mode */
  RTC->CRL |= RTC_CRL_CNF;
 80047a8:	4b03      	ldr	r3, [pc, #12]	; (80047b8 <RTC_EnterConfigMode+0x10>)
 80047aa:	889a      	ldrh	r2, [r3, #4]
 80047ac:	b292      	uxth	r2, r2
 80047ae:	f042 0210 	orr.w	r2, r2, #16
 80047b2:	809a      	strh	r2, [r3, #4]
 80047b4:	4770      	bx	lr
 80047b6:	bf00      	nop
 80047b8:	40002800 	.word	0x40002800

080047bc <RTC_ExitConfigMode>:
  * @retval None
  */
void RTC_ExitConfigMode(void)
{
  /* Reset the CNF flag to exit from the Configuration Mode */
  RTC->CRL &= (uint16_t)~((uint16_t)RTC_CRL_CNF); 
 80047bc:	4a03      	ldr	r2, [pc, #12]	; (80047cc <RTC_ExitConfigMode+0x10>)
 80047be:	8893      	ldrh	r3, [r2, #4]
 80047c0:	f023 0310 	bic.w	r3, r3, #16
 80047c4:	041b      	lsls	r3, r3, #16
 80047c6:	0c1b      	lsrs	r3, r3, #16
 80047c8:	8093      	strh	r3, [r2, #4]
 80047ca:	4770      	bx	lr
 80047cc:	40002800 	.word	0x40002800

080047d0 <RTC_GetCounter>:
  */
uint32_t RTC_GetCounter(void)
{
  uint16_t high1 = 0, high2 = 0, low = 0;

  high1 = RTC->CNTH;
 80047d0:	4b08      	ldr	r3, [pc, #32]	; (80047f4 <RTC_GetCounter+0x24>)
 80047d2:	8b1a      	ldrh	r2, [r3, #24]
  low   = RTC->CNTL;
 80047d4:	8b98      	ldrh	r0, [r3, #28]
  high2 = RTC->CNTH;
 80047d6:	8b19      	ldrh	r1, [r3, #24]
  */
uint32_t RTC_GetCounter(void)
{
  uint16_t high1 = 0, high2 = 0, low = 0;

  high1 = RTC->CNTH;
 80047d8:	b292      	uxth	r2, r2
  low   = RTC->CNTL;
  high2 = RTC->CNTH;
 80047da:	b289      	uxth	r1, r1

  if (high1 != high2)
 80047dc:	428a      	cmp	r2, r1
uint32_t RTC_GetCounter(void)
{
  uint16_t high1 = 0, high2 = 0, low = 0;

  high1 = RTC->CNTH;
  low   = RTC->CNTL;
 80047de:	b280      	uxth	r0, r0
  high2 = RTC->CNTH;

  if (high1 != high2)
 80047e0:	d004      	beq.n	80047ec <RTC_GetCounter+0x1c>
  { /* In this case the counter roll over during reading of CNTL and CNTH registers, 
       read again CNTL register then return the counter value */
    return (((uint32_t) high2 << 16 ) | RTC->CNTL);
 80047e2:	8b98      	ldrh	r0, [r3, #28]
 80047e4:	b280      	uxth	r0, r0
 80047e6:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 80047ea:	4770      	bx	lr
  }
  else
  { /* No counter roll over during reading of CNTL and CNTH registers, counter 
       value is equal to first value of CNTL and CNTH */
    return (((uint32_t) high1 << 16 ) | low);
 80047ec:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
  }
}
 80047f0:	4770      	bx	lr
 80047f2:	bf00      	nop
 80047f4:	40002800 	.word	0x40002800

080047f8 <RTC_SetCounter>:
  * @brief  Sets the RTC counter value.
  * @param  CounterValue: RTC counter new value.
  * @retval None
  */
void RTC_SetCounter(uint32_t CounterValue)
{ 
 80047f8:	b510      	push	{r4, lr}
 80047fa:	4604      	mov	r4, r0
  RTC_EnterConfigMode();
 80047fc:	f7ff ffd4 	bl	80047a8 <RTC_EnterConfigMode>
  /* Set RTC COUNTER MSB word */
  RTC->CNTH = CounterValue >> 16;
 8004800:	4b04      	ldr	r3, [pc, #16]	; (8004814 <RTC_SetCounter+0x1c>)
 8004802:	0c22      	lsrs	r2, r4, #16
  /* Set RTC COUNTER LSB word */
  RTC->CNTL = (CounterValue & RTC_LSB_MASK);
 8004804:	b2a4      	uxth	r4, r4
  */
void RTC_SetCounter(uint32_t CounterValue)
{ 
  RTC_EnterConfigMode();
  /* Set RTC COUNTER MSB word */
  RTC->CNTH = CounterValue >> 16;
 8004806:	831a      	strh	r2, [r3, #24]
  /* Set RTC COUNTER LSB word */
  RTC->CNTL = (CounterValue & RTC_LSB_MASK);
 8004808:	839c      	strh	r4, [r3, #28]
  RTC_ExitConfigMode();
}
 800480a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  RTC_EnterConfigMode();
  /* Set RTC COUNTER MSB word */
  RTC->CNTH = CounterValue >> 16;
  /* Set RTC COUNTER LSB word */
  RTC->CNTL = (CounterValue & RTC_LSB_MASK);
  RTC_ExitConfigMode();
 800480e:	f7ff bfd5 	b.w	80047bc <RTC_ExitConfigMode>
 8004812:	bf00      	nop
 8004814:	40002800 	.word	0x40002800

08004818 <RTC_SetPrescaler>:
  * @brief  Sets the RTC prescaler value.
  * @param  PrescalerValue: RTC prescaler new value.
  * @retval None
  */
void RTC_SetPrescaler(uint32_t PrescalerValue)
{
 8004818:	b510      	push	{r4, lr}
 800481a:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_RTC_PRESCALER(PrescalerValue));
  
  RTC_EnterConfigMode();
 800481c:	f7ff ffc4 	bl	80047a8 <RTC_EnterConfigMode>
  /* Set RTC PRESCALER MSB word */
  RTC->PRLH = (PrescalerValue & PRLH_MSB_MASK) >> 16;
 8004820:	4b04      	ldr	r3, [pc, #16]	; (8004834 <RTC_SetPrescaler+0x1c>)
 8004822:	f3c4 4203 	ubfx	r2, r4, #16, #4
  /* Set RTC PRESCALER LSB word */
  RTC->PRLL = (PrescalerValue & RTC_LSB_MASK);
 8004826:	b2a4      	uxth	r4, r4
  /* Check the parameters */
  assert_param(IS_RTC_PRESCALER(PrescalerValue));
  
  RTC_EnterConfigMode();
  /* Set RTC PRESCALER MSB word */
  RTC->PRLH = (PrescalerValue & PRLH_MSB_MASK) >> 16;
 8004828:	811a      	strh	r2, [r3, #8]
  /* Set RTC PRESCALER LSB word */
  RTC->PRLL = (PrescalerValue & RTC_LSB_MASK);
 800482a:	819c      	strh	r4, [r3, #12]
  RTC_ExitConfigMode();
}
 800482c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  RTC_EnterConfigMode();
  /* Set RTC PRESCALER MSB word */
  RTC->PRLH = (PrescalerValue & PRLH_MSB_MASK) >> 16;
  /* Set RTC PRESCALER LSB word */
  RTC->PRLL = (PrescalerValue & RTC_LSB_MASK);
  RTC_ExitConfigMode();
 8004830:	f7ff bfc4 	b.w	80047bc <RTC_ExitConfigMode>
 8004834:	40002800 	.word	0x40002800

08004838 <RTC_SetAlarm>:
  * @brief  Sets the RTC alarm value.
  * @param  AlarmValue: RTC alarm new value.
  * @retval None
  */
void RTC_SetAlarm(uint32_t AlarmValue)
{  
 8004838:	b510      	push	{r4, lr}
 800483a:	4604      	mov	r4, r0
  RTC_EnterConfigMode();
 800483c:	f7ff ffb4 	bl	80047a8 <RTC_EnterConfigMode>
  /* Set the ALARM MSB word */
  RTC->ALRH = AlarmValue >> 16;
 8004840:	4b04      	ldr	r3, [pc, #16]	; (8004854 <RTC_SetAlarm+0x1c>)
 8004842:	0c22      	lsrs	r2, r4, #16
  /* Set the ALARM LSB word */
  RTC->ALRL = (AlarmValue & RTC_LSB_MASK);
 8004844:	b2a4      	uxth	r4, r4
  */
void RTC_SetAlarm(uint32_t AlarmValue)
{  
  RTC_EnterConfigMode();
  /* Set the ALARM MSB word */
  RTC->ALRH = AlarmValue >> 16;
 8004846:	841a      	strh	r2, [r3, #32]
  /* Set the ALARM LSB word */
  RTC->ALRL = (AlarmValue & RTC_LSB_MASK);
 8004848:	849c      	strh	r4, [r3, #36]	; 0x24
  RTC_ExitConfigMode();
}
 800484a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  RTC_EnterConfigMode();
  /* Set the ALARM MSB word */
  RTC->ALRH = AlarmValue >> 16;
  /* Set the ALARM LSB word */
  RTC->ALRL = (AlarmValue & RTC_LSB_MASK);
  RTC_ExitConfigMode();
 800484e:	f7ff bfb5 	b.w	80047bc <RTC_ExitConfigMode>
 8004852:	bf00      	nop
 8004854:	40002800 	.word	0x40002800

08004858 <RTC_GetDivider>:
  * @retval RTC Divider value.
  */
uint32_t RTC_GetDivider(void)
{
  uint32_t tmp = 0x00;
  tmp = ((uint32_t)RTC->DIVH & (uint32_t)0x000F) << 16;
 8004858:	4b04      	ldr	r3, [pc, #16]	; (800486c <RTC_GetDivider+0x14>)
 800485a:	8a18      	ldrh	r0, [r3, #16]
  tmp |= RTC->DIVL;
 800485c:	8a9b      	ldrh	r3, [r3, #20]
  * @retval RTC Divider value.
  */
uint32_t RTC_GetDivider(void)
{
  uint32_t tmp = 0x00;
  tmp = ((uint32_t)RTC->DIVH & (uint32_t)0x000F) << 16;
 800485e:	f000 000f 	and.w	r0, r0, #15
  tmp |= RTC->DIVL;
 8004862:	b29b      	uxth	r3, r3
  return tmp;
}
 8004864:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8004868:	4770      	bx	lr
 800486a:	bf00      	nop
 800486c:	40002800 	.word	0x40002800

08004870 <RTC_WaitForLastTask>:
  * @retval None
  */
void RTC_WaitForLastTask(void)
{
  /* Loop until RTOFF flag is set */
  while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)
 8004870:	4a03      	ldr	r2, [pc, #12]	; (8004880 <RTC_WaitForLastTask+0x10>)
 8004872:	8893      	ldrh	r3, [r2, #4]
 8004874:	f003 0320 	and.w	r3, r3, #32
 8004878:	b29b      	uxth	r3, r3
 800487a:	2b00      	cmp	r3, #0
 800487c:	d0f9      	beq.n	8004872 <RTC_WaitForLastTask+0x2>
  {
  }
}
 800487e:	4770      	bx	lr
 8004880:	40002800 	.word	0x40002800

08004884 <RTC_WaitForSynchro>:
  * @retval None
  */
void RTC_WaitForSynchro(void)
{
  /* Clear RSF flag */
  RTC->CRL &= (uint16_t)~RTC_FLAG_RSF;
 8004884:	4a06      	ldr	r2, [pc, #24]	; (80048a0 <RTC_WaitForSynchro+0x1c>)
 8004886:	8893      	ldrh	r3, [r2, #4]
 8004888:	f023 0308 	bic.w	r3, r3, #8
 800488c:	041b      	lsls	r3, r3, #16
 800488e:	0c1b      	lsrs	r3, r3, #16
 8004890:	8093      	strh	r3, [r2, #4]
  /* Loop until RSF flag is set */
  while ((RTC->CRL & RTC_FLAG_RSF) == (uint16_t)RESET)
 8004892:	8893      	ldrh	r3, [r2, #4]
 8004894:	f003 0308 	and.w	r3, r3, #8
 8004898:	b29b      	uxth	r3, r3
 800489a:	2b00      	cmp	r3, #0
 800489c:	d0f9      	beq.n	8004892 <RTC_WaitForSynchro+0xe>
  {
  }
}
 800489e:	4770      	bx	lr
 80048a0:	40002800 	.word	0x40002800

080048a4 <RTC_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  
  /* Check the parameters */
  assert_param(IS_RTC_GET_FLAG(RTC_FLAG)); 
  
  if ((RTC->CRL & RTC_FLAG) != (uint16_t)RESET)
 80048a4:	4b03      	ldr	r3, [pc, #12]	; (80048b4 <RTC_GetFlagStatus+0x10>)
 80048a6:	889b      	ldrh	r3, [r3, #4]
 80048a8:	4218      	tst	r0, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80048aa:	bf0c      	ite	eq
 80048ac:	2000      	moveq	r0, #0
 80048ae:	2001      	movne	r0, #1
 80048b0:	4770      	bx	lr
 80048b2:	bf00      	nop
 80048b4:	40002800 	.word	0x40002800

080048b8 <RTC_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG)); 
    
  /* Clear the corresponding RTC flag */
  RTC->CRL &= (uint16_t)~RTC_FLAG;
 80048b8:	4b03      	ldr	r3, [pc, #12]	; (80048c8 <RTC_ClearFlag+0x10>)
 80048ba:	889a      	ldrh	r2, [r3, #4]
 80048bc:	b292      	uxth	r2, r2
 80048be:	ea22 0000 	bic.w	r0, r2, r0
 80048c2:	8098      	strh	r0, [r3, #4]
 80048c4:	4770      	bx	lr
 80048c6:	bf00      	nop
 80048c8:	40002800 	.word	0x40002800

080048cc <RTC_GetITStatus>:
{
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT)); 
  
  bitstatus = (ITStatus)(RTC->CRL & RTC_IT);
 80048cc:	4b07      	ldr	r3, [pc, #28]	; (80048ec <RTC_GetITStatus+0x20>)
 80048ce:	889a      	ldrh	r2, [r3, #4]
  if (((RTC->CRH & RTC_IT) != (uint16_t)RESET) && (bitstatus != (uint16_t)RESET))
 80048d0:	881b      	ldrh	r3, [r3, #0]
{
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT)); 
  
  bitstatus = (ITStatus)(RTC->CRL & RTC_IT);
 80048d2:	b292      	uxth	r2, r2
  if (((RTC->CRH & RTC_IT) != (uint16_t)RESET) && (bitstatus != (uint16_t)RESET))
 80048d4:	4003      	ands	r3, r0
 80048d6:	d006      	beq.n	80048e6 <RTC_GetITStatus+0x1a>
{
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT)); 
  
  bitstatus = (ITStatus)(RTC->CRL & RTC_IT);
 80048d8:	4010      	ands	r0, r2
  if (((RTC->CRH & RTC_IT) != (uint16_t)RESET) && (bitstatus != (uint16_t)RESET))
 80048da:	f010 0fff 	tst.w	r0, #255	; 0xff
 80048de:	bf0c      	ite	eq
 80048e0:	2000      	moveq	r0, #0
 80048e2:	2001      	movne	r0, #1
 80048e4:	4770      	bx	lr
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 80048e6:	4618      	mov	r0, r3
  }
  return bitstatus;
}
 80048e8:	4770      	bx	lr
 80048ea:	bf00      	nop
 80048ec:	40002800 	.word	0x40002800

080048f0 <RTC_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_RTC_IT(RTC_IT));  
  
  /* Clear the corresponding RTC pending bit */
  RTC->CRL &= (uint16_t)~RTC_IT;
 80048f0:	4b03      	ldr	r3, [pc, #12]	; (8004900 <RTC_ClearITPendingBit+0x10>)
 80048f2:	889a      	ldrh	r2, [r3, #4]
 80048f4:	b292      	uxth	r2, r2
 80048f6:	ea22 0000 	bic.w	r0, r2, r0
 80048fa:	8098      	strh	r0, [r3, #4]
 80048fc:	4770      	bx	lr
 80048fe:	bf00      	nop
 8004900:	40002800 	.word	0x40002800

08004904 <SPI_I2S_DeInit>:
  *         reset values (Affects also the I2Ss).
  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
  * @retval None
  */
void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
{
 8004904:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  if (SPIx == SPI1)
 8004906:	4b15      	ldr	r3, [pc, #84]	; (800495c <SPI_I2S_DeInit+0x58>)
 8004908:	4298      	cmp	r0, r3
 800490a:	d10b      	bne.n	8004924 <SPI_I2S_DeInit+0x20>
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
 800490c:	2101      	movs	r1, #1
 800490e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8004912:	f7ff fed1 	bl	80046b8 <RCC_APB2PeriphResetCmd>
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 8004916:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800491a:	2100      	movs	r1, #0
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
    }
  }
}
 800491c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  if (SPIx == SPI1)
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 8004920:	f7ff beca 	b.w	80046b8 <RCC_APB2PeriphResetCmd>
  }
  else if (SPIx == SPI2)
 8004924:	4b0e      	ldr	r3, [pc, #56]	; (8004960 <SPI_I2S_DeInit+0x5c>)
 8004926:	4298      	cmp	r0, r3
 8004928:	d107      	bne.n	800493a <SPI_I2S_DeInit+0x36>
  {
    /* Enable SPI2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
 800492a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800492e:	2101      	movs	r1, #1
 8004930:	f7ff fece 	bl	80046d0 <RCC_APB1PeriphResetCmd>
    /* Release SPI2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
 8004934:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8004938:	e009      	b.n	800494e <SPI_I2S_DeInit+0x4a>
  }
  else
  {
    if (SPIx == SPI3)
 800493a:	4b0a      	ldr	r3, [pc, #40]	; (8004964 <SPI_I2S_DeInit+0x60>)
 800493c:	4298      	cmp	r0, r3
 800493e:	d10b      	bne.n	8004958 <SPI_I2S_DeInit+0x54>
    {
      /* Enable SPI3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
 8004940:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8004944:	2101      	movs	r1, #1
 8004946:	f7ff fec3 	bl	80046d0 <RCC_APB1PeriphResetCmd>
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 800494a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800494e:	2100      	movs	r1, #0
    }
  }
}
 8004950:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    if (SPIx == SPI3)
    {
      /* Enable SPI3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 8004954:	f7ff bebc 	b.w	80046d0 <RCC_APB1PeriphResetCmd>
 8004958:	bd08      	pop	{r3, pc}
 800495a:	bf00      	nop
 800495c:	40013000 	.word	0x40013000
 8004960:	40003800 	.word	0x40003800
 8004964:	40003c00 	.word	0x40003c00

08004968 <SPI_Init>:
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8004968:	880b      	ldrh	r3, [r1, #0]
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral.
  * @retval None
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
 800496a:	b510      	push	{r4, lr}
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 800496c:	884c      	ldrh	r4, [r1, #2]
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
 800496e:	8802      	ldrh	r2, [r0, #0]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8004970:	4323      	orrs	r3, r4
 8004972:	888c      	ldrh	r4, [r1, #4]

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_Mask;
 8004974:	f402 5241 	and.w	r2, r2, #12352	; 0x3040
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8004978:	4323      	orrs	r3, r4
 800497a:	88cc      	ldrh	r4, [r1, #6]
 800497c:	4323      	orrs	r3, r4
 800497e:	890c      	ldrh	r4, [r1, #8]
 8004980:	4323      	orrs	r3, r4
 8004982:	894c      	ldrh	r4, [r1, #10]
 8004984:	4323      	orrs	r3, r4
 8004986:	898c      	ldrh	r4, [r1, #12]
 8004988:	4323      	orrs	r3, r4
 800498a:	89cc      	ldrh	r4, [r1, #14]
 800498c:	4323      	orrs	r3, r4
 800498e:	4313      	orrs	r3, r2
 8004990:	b29b      	uxth	r3, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;
 8004992:	8003      	strh	r3, [r0, #0]
  
  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= SPI_Mode_Select;		
 8004994:	8b83      	ldrh	r3, [r0, #28]
 8004996:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800499a:	041b      	lsls	r3, r3, #16
 800499c:	0c1b      	lsrs	r3, r3, #16
 800499e:	8383      	strh	r3, [r0, #28]

/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 80049a0:	8a0b      	ldrh	r3, [r1, #16]
 80049a2:	8203      	strh	r3, [r0, #16]
 80049a4:	bd10      	pop	{r4, pc}

080049a6 <I2S_Init>:
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
 80049a6:	8b83      	ldrh	r3, [r0, #28]
  *  and the product configuration). But in case the prescaler value is greater 
  *  than 511, the default value (0x02) will be configured instead.  *   
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
 80049a8:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
 80049aa:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 80049ae:	f023 030f 	bic.w	r3, r3, #15
 80049b2:	041b      	lsls	r3, r3, #16
 80049b4:	0c1b      	lsrs	r3, r3, #16
 80049b6:	8383      	strh	r3, [r0, #28]
  SPIx->I2SPR = 0x0002;
 80049b8:	2302      	movs	r3, #2
 80049ba:	8403      	strh	r3, [r0, #32]
  
  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
  
  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 80049bc:	688b      	ldr	r3, [r1, #8]
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
  SPIx->I2SPR = 0x0002;
  
  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
 80049be:	8b86      	ldrh	r6, [r0, #28]
  
  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 80049c0:	2b02      	cmp	r3, #2
  *  and the product configuration). But in case the prescaler value is greater 
  *  than 511, the default value (0x02) will be configured instead.  *   
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
 80049c2:	b087      	sub	sp, #28
 80049c4:	4605      	mov	r5, r0
 80049c6:	460c      	mov	r4, r1
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
  SPIx->I2SPR = 0x0002;
  
  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
 80049c8:	b2b6      	uxth	r6, r6
  
  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 80049ca:	d043      	beq.n	8004a54 <I2S_Init+0xae>
  }
  /* If the requested audio frequency is not the default, compute the prescaler */
  else
  {
    /* Check the frame length (For the Prescaler computing) */
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
 80049cc:	888f      	ldrh	r7, [r1, #4]
    }

    /* Check the I2S clock source configuration depending on the Device:
       Only Connectivity line devices have the PLL3 VCO clock */
#ifdef STM32F10X_CL
    if((RCC->CFGR2 & tmp) != 0)
 80049ce:	492f      	ldr	r1, [pc, #188]	; (8004a8c <I2S_Init+0xe6>)

    /* Get the I2S clock source mask depending on the peripheral number */
    if(((uint32_t)SPIx) == SPI2_BASE)
    {
      /* The mask is relative to I2S2 */
      tmp = I2S2_CLOCK_SRC;
 80049d0:	4a2f      	ldr	r2, [pc, #188]	; (8004a90 <I2S_Init+0xea>)
    }

    /* Check the I2S clock source configuration depending on the Device:
       Only Connectivity line devices have the PLL3 VCO clock */
#ifdef STM32F10X_CL
    if((RCC->CFGR2 & tmp) != 0)
 80049d2:	6acb      	ldr	r3, [r1, #44]	; 0x2c

    /* Get the I2S clock source mask depending on the peripheral number */
    if(((uint32_t)SPIx) == SPI2_BASE)
    {
      /* The mask is relative to I2S2 */
      tmp = I2S2_CLOCK_SRC;
 80049d4:	4290      	cmp	r0, r2
 80049d6:	bf14      	ite	ne
 80049d8:	f44f 2280 	movne.w	r2, #262144	; 0x40000
 80049dc:	f44f 3200 	moveq.w	r2, #131072	; 0x20000
  {
    /* Check the frame length (For the Prescaler computing) */
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
    {
      /* Packet length is 16 bits */
      packetlength = 1;
 80049e0:	2f00      	cmp	r7, #0
 80049e2:	bf14      	ite	ne
 80049e4:	2702      	movne	r7, #2
 80049e6:	2701      	moveq	r7, #1
    }

    /* Check the I2S clock source configuration depending on the Device:
       Only Connectivity line devices have the PLL3 VCO clock */
#ifdef STM32F10X_CL
    if((RCC->CFGR2 & tmp) != 0)
 80049e8:	421a      	tst	r2, r3
 80049ea:	d014      	beq.n	8004a16 <I2S_Init+0x70>
    {
      /* Get the configuration bits of RCC PLL3 multiplier */
      tmp = (uint32_t)((RCC->CFGR2 & I2S_MUL_MASK) >> 12);
 80049ec:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 80049ee:	f3c3 3303 	ubfx	r3, r3, #12, #4

      /* Get the value of the PLL3 multiplier */      
      if((tmp > 5) && (tmp < 15))
 80049f2:	1f9a      	subs	r2, r3, #6
 80049f4:	2a08      	cmp	r2, #8
 80049f6:	d801      	bhi.n	80049fc <I2S_Init+0x56>
      {
        /* Multiplier is between 8 and 14 (value 15 is forbidden) */
        tmp += 2;
 80049f8:	3302      	adds	r3, #2
 80049fa:	e002      	b.n	8004a02 <I2S_Init+0x5c>
      else
      {
        if (tmp == 15)
        {
          /* Multiplier is 20 */
          tmp = 20;
 80049fc:	2b0f      	cmp	r3, #15
 80049fe:	bf08      	it	eq
 8004a00:	2314      	moveq	r3, #20
        }
      }      
      /* Get the PREDIV2 value */
      sourceclock = (uint32_t)(((RCC->CFGR2 & I2S_DIV_MASK) >> 4) + 1);
 8004a02:	6aca      	ldr	r2, [r1, #44]	; 0x2c
      
      /* Calculate the Source Clock frequency based on PLL3 and PREDIV2 values */
      sourceclock = (uint32_t) ((HSE_Value / sourceclock) * tmp * 2); 
 8004a04:	4923      	ldr	r1, [pc, #140]	; (8004a94 <I2S_Init+0xee>)
          /* Multiplier is 20 */
          tmp = 20;
        }
      }      
      /* Get the PREDIV2 value */
      sourceclock = (uint32_t)(((RCC->CFGR2 & I2S_DIV_MASK) >> 4) + 1);
 8004a06:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8004a0a:	3201      	adds	r2, #1
      
      /* Calculate the Source Clock frequency based on PLL3 and PREDIV2 values */
      sourceclock = (uint32_t) ((HSE_Value / sourceclock) * tmp * 2); 
 8004a0c:	fbb1 f2f2 	udiv	r2, r1, r2
 8004a10:	0052      	lsls	r2, r2, #1
 8004a12:	4353      	muls	r3, r2
 8004a14:	e003      	b.n	8004a1e <I2S_Init+0x78>
    }
    else
    {
      /* I2S Clock source is System clock: Get System Clock frequency */
      RCC_GetClocksFreq(&RCC_Clocks);      
 8004a16:	a801      	add	r0, sp, #4
 8004a18:	f7ff fdbc 	bl	8004594 <RCC_GetClocksFreq>
      
      /* Get the source clock value: based on System Clock value */
      sourceclock = RCC_Clocks.SYSCLK_Frequency;
 8004a1c:	9b01      	ldr	r3, [sp, #4]
    /* Get the source clock value: based on System Clock value */
    sourceclock = RCC_Clocks.SYSCLK_Frequency;    
#endif /* STM32F10X_CL */    

    /* Compute the Real divider depending on the MCLK output state with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 8004a1e:	88e2      	ldrh	r2, [r4, #6]
 8004a20:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8004a24:	f04f 020a 	mov.w	r2, #10
 8004a28:	d101      	bne.n	8004a2e <I2S_Init+0x88>
    {
      /* MCLK output is enabled */
      tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8004a2a:	0a1b      	lsrs	r3, r3, #8
 8004a2c:	e002      	b.n	8004a34 <I2S_Init+0x8e>
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8004a2e:	017f      	lsls	r7, r7, #5
 8004a30:	fbb3 f3f7 	udiv	r3, r3, r7
 8004a34:	4353      	muls	r3, r2
 8004a36:	68a1      	ldr	r1, [r4, #8]
    }
    
    /* Remove the floating point */
    tmp = tmp / 10;  
 8004a38:	220a      	movs	r2, #10
      tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8004a3a:	fbb3 f3f1 	udiv	r3, r3, r1
 8004a3e:	3305      	adds	r3, #5
 8004a40:	b29b      	uxth	r3, r3
    }
    
    /* Remove the floating point */
    tmp = tmp / 10;  
 8004a42:	fbb3 f3f2 	udiv	r3, r3, r2
      
    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
   
    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 8004a46:	f003 0201 	and.w	r2, r3, #1
   
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
 8004a4a:	0212      	lsls	r2, r2, #8
      
    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
   
    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 8004a4c:	f3c3 034f 	ubfx	r3, r3, #1, #16
   
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
 8004a50:	b292      	uxth	r2, r2
 8004a52:	e000      	b.n	8004a56 <I2S_Init+0xb0>
  tmpreg = SPIx->I2SCFGR;
  
  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
  {
    i2sodd = (uint16_t)0;
 8004a54:	2200      	movs	r2, #0
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
  }
  
  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
 8004a56:	1e99      	subs	r1, r3, #2
 8004a58:	b289      	uxth	r1, r1
  {
    /* Set the default values */
    i2sdiv = 2;
    i2sodd = 0;
 8004a5a:	29fe      	cmp	r1, #254	; 0xfe
 8004a5c:	bf28      	it	cs
 8004a5e:	2200      	movcs	r2, #0
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));  
 8004a60:	88e1      	ldrh	r1, [r4, #6]
  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
  {
    /* Set the default values */
    i2sdiv = 2;
    i2sodd = 0;
 8004a62:	bf28      	it	cs
 8004a64:	2302      	movcs	r3, #2
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));  
 8004a66:	4313      	orrs	r3, r2
 8004a68:	430b      	orrs	r3, r1
 8004a6a:	b29b      	uxth	r3, r3
 8004a6c:	842b      	strh	r3, [r5, #32]
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)(I2S_Mode_Select | (uint16_t)(I2S_InitStruct->I2S_Mode | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8004a6e:	8823      	ldrh	r3, [r4, #0]

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));  
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)(I2S_Mode_Select | (uint16_t)(I2S_InitStruct->I2S_Mode | \
 8004a70:	8862      	ldrh	r2, [r4, #2]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8004a72:	4333      	orrs	r3, r6
 8004a74:	f443 6300 	orr.w	r3, r3, #2048	; 0x800

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));  
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)(I2S_Mode_Select | (uint16_t)(I2S_InitStruct->I2S_Mode | \
 8004a78:	4313      	orrs	r3, r2
 8004a7a:	88a2      	ldrh	r2, [r4, #4]
 8004a7c:	4313      	orrs	r3, r2
 8004a7e:	89a2      	ldrh	r2, [r4, #12]
 8004a80:	4313      	orrs	r3, r2
 8004a82:	b29b      	uxth	r3, r3
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 
  /* Write to SPIx I2SCFGR */  
  SPIx->I2SCFGR = tmpreg;   
 8004a84:	83ab      	strh	r3, [r5, #28]
}
 8004a86:	b007      	add	sp, #28
 8004a88:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004a8a:	bf00      	nop
 8004a8c:	40021000 	.word	0x40021000
 8004a90:	40003800 	.word	0x40003800
 8004a94:	017d7840 	.word	0x017d7840

08004a98 <SPI_StructInit>:
  */
void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
{
/*--------------- Reset SPI init structure parameters values -----------------*/
  /* Initialize the SPI_Direction member */
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 8004a98:	2300      	movs	r3, #0
 8004a9a:	8003      	strh	r3, [r0, #0]
  /* initialize the SPI_Mode member */
  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
 8004a9c:	8043      	strh	r3, [r0, #2]
  /* initialize the SPI_DataSize member */
  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
 8004a9e:	8083      	strh	r3, [r0, #4]
  /* Initialize the SPI_CPOL member */
  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
 8004aa0:	80c3      	strh	r3, [r0, #6]
  /* Initialize the SPI_CPHA member */
  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
 8004aa2:	8103      	strh	r3, [r0, #8]
  /* Initialize the SPI_NSS member */
  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
 8004aa4:	8143      	strh	r3, [r0, #10]
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
 8004aa6:	8183      	strh	r3, [r0, #12]
  /* Initialize the SPI_FirstBit member */
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
 8004aa8:	81c3      	strh	r3, [r0, #14]
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStruct->SPI_CRCPolynomial = 7;
 8004aaa:	2307      	movs	r3, #7
 8004aac:	8203      	strh	r3, [r0, #16]
 8004aae:	4770      	bx	lr

08004ab0 <I2S_StructInit>:
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 8004ab0:	2300      	movs	r3, #0
  
  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
  
  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 8004ab2:	2202      	movs	r2, #2
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 8004ab4:	8003      	strh	r3, [r0, #0]
  
  /* Initialize the I2S_Standard member */
  I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
 8004ab6:	8043      	strh	r3, [r0, #2]
  
  /* Initialize the I2S_DataFormat member */
  I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
 8004ab8:	8083      	strh	r3, [r0, #4]
  
  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
 8004aba:	80c3      	strh	r3, [r0, #6]
  
  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 8004abc:	6082      	str	r2, [r0, #8]
  
  /* Initialize the I2S_CPOL member */
  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
 8004abe:	8183      	strh	r3, [r0, #12]
 8004ac0:	4770      	bx	lr

08004ac2 <SPI_Cmd>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= CR1_SPE_Set;
 8004ac2:	8803      	ldrh	r3, [r0, #0]
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004ac4:	b119      	cbz	r1, 8004ace <SPI_Cmd+0xc>
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= CR1_SPE_Set;
 8004ac6:	b29b      	uxth	r3, r3
 8004ac8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8004acc:	e003      	b.n	8004ad6 <SPI_Cmd+0x14>
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= CR1_SPE_Reset;
 8004ace:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8004ad2:	041b      	lsls	r3, r3, #16
 8004ad4:	0c1b      	lsrs	r3, r3, #16
 8004ad6:	8003      	strh	r3, [r0, #0]
 8004ad8:	4770      	bx	lr

08004ada <I2S_Cmd>:
  assert_param(IS_SPI_23_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral (in I2S mode) */
    SPIx->I2SCFGR |= I2SCFGR_I2SE_Set;
 8004ada:	8b83      	ldrh	r3, [r0, #28]
void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_23_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004adc:	b119      	cbz	r1, 8004ae6 <I2S_Cmd+0xc>
  {
    /* Enable the selected SPI peripheral (in I2S mode) */
    SPIx->I2SCFGR |= I2SCFGR_I2SE_Set;
 8004ade:	b29b      	uxth	r3, r3
 8004ae0:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8004ae4:	e003      	b.n	8004aee <I2S_Cmd+0x14>
  }
  else
  {
    /* Disable the selected SPI peripheral (in I2S mode) */
    SPIx->I2SCFGR &= I2SCFGR_I2SE_Reset;
 8004ae6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8004aea:	041b      	lsls	r3, r3, #16
 8004aec:	0c1b      	lsrs	r3, r3, #16
 8004aee:	8383      	strh	r3, [r0, #28]
 8004af0:	4770      	bx	lr

08004af2 <SPI_I2S_ITConfig>:

  /* Get the SPI/I2S IT index */
  itpos = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = (uint16_t)1 << (uint16_t)itpos;
 8004af2:	0909      	lsrs	r1, r1, #4
 8004af4:	2301      	movs	r3, #1
 8004af6:	fa03 f301 	lsl.w	r3, r3, r1
 8004afa:	b29b      	uxth	r3, r3

  if (NewState != DISABLE)
 8004afc:	b11a      	cbz	r2, 8004b06 <SPI_I2S_ITConfig+0x14>
  {
    /* Enable the selected SPI/I2S interrupt */
    SPIx->CR2 |= itmask;
 8004afe:	8882      	ldrh	r2, [r0, #4]
 8004b00:	b292      	uxth	r2, r2
 8004b02:	4313      	orrs	r3, r2
 8004b04:	e003      	b.n	8004b0e <SPI_I2S_ITConfig+0x1c>
  }
  else
  {
    /* Disable the selected SPI/I2S interrupt */
    SPIx->CR2 &= (uint16_t)~itmask;
 8004b06:	8882      	ldrh	r2, [r0, #4]
 8004b08:	b292      	uxth	r2, r2
 8004b0a:	ea22 0303 	bic.w	r3, r2, r3
 8004b0e:	8083      	strh	r3, [r0, #4]
 8004b10:	4770      	bx	lr

08004b12 <SPI_I2S_DMACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI/I2S DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 8004b12:	8883      	ldrh	r3, [r0, #4]
 8004b14:	b29b      	uxth	r3, r3
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
  if (NewState != DISABLE)
 8004b16:	b10a      	cbz	r2, 8004b1c <SPI_I2S_DMACmd+0xa>
  {
    /* Enable the selected SPI/I2S DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 8004b18:	4319      	orrs	r1, r3
 8004b1a:	e001      	b.n	8004b20 <SPI_I2S_DMACmd+0xe>
  }
  else
  {
    /* Disable the selected SPI/I2S DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 8004b1c:	ea23 0101 	bic.w	r1, r3, r1
 8004b20:	8081      	strh	r1, [r0, #4]
 8004b22:	4770      	bx	lr

08004b24 <SPI_I2S_SendData>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Write in the DR register the data to be sent */
  SPIx->DR = Data;
 8004b24:	8181      	strh	r1, [r0, #12]
 8004b26:	4770      	bx	lr

08004b28 <SPI_I2S_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Return the data in the DR register */
  return SPIx->DR;
 8004b28:	8980      	ldrh	r0, [r0, #12]
}
 8004b2a:	b280      	uxth	r0, r0
 8004b2c:	4770      	bx	lr

08004b2e <SPI_NSSInternalSoftwareConfig>:
void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 8004b2e:	f64f 63ff 	movw	r3, #65279	; 0xfeff
 8004b32:	4299      	cmp	r1, r3
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 8004b34:	8803      	ldrh	r3, [r0, #0]
void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 8004b36:	d003      	beq.n	8004b40 <SPI_NSSInternalSoftwareConfig+0x12>
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 8004b38:	b29b      	uxth	r3, r3
 8004b3a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004b3e:	e003      	b.n	8004b48 <SPI_NSSInternalSoftwareConfig+0x1a>
  }
  else
  {
    /* Reset NSS pin internally by software */
    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
 8004b40:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8004b44:	041b      	lsls	r3, r3, #16
 8004b46:	0c1b      	lsrs	r3, r3, #16
 8004b48:	8003      	strh	r3, [r0, #0]
 8004b4a:	4770      	bx	lr

08004b4c <SPI_SSOutputCmd>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= CR2_SSOE_Set;
 8004b4c:	8883      	ldrh	r3, [r0, #4]
void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004b4e:	b119      	cbz	r1, 8004b58 <SPI_SSOutputCmd+0xc>
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= CR2_SSOE_Set;
 8004b50:	b29b      	uxth	r3, r3
 8004b52:	f043 0304 	orr.w	r3, r3, #4
 8004b56:	e003      	b.n	8004b60 <SPI_SSOutputCmd+0x14>
  }
  else
  {
    /* Disable the selected SPI SS output */
    SPIx->CR2 &= CR2_SSOE_Reset;
 8004b58:	f023 0304 	bic.w	r3, r3, #4
 8004b5c:	041b      	lsls	r3, r3, #16
 8004b5e:	0c1b      	lsrs	r3, r3, #16
 8004b60:	8083      	strh	r3, [r0, #4]
 8004b62:	4770      	bx	lr

08004b64 <SPI_DataSizeConfig>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DATASIZE(SPI_DataSize));
  /* Clear DFF bit */
  SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
 8004b64:	8803      	ldrh	r3, [r0, #0]
 8004b66:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8004b6a:	041b      	lsls	r3, r3, #16
 8004b6c:	0c1b      	lsrs	r3, r3, #16
 8004b6e:	8003      	strh	r3, [r0, #0]
  /* Set new DFF bit value */
  SPIx->CR1 |= SPI_DataSize;
 8004b70:	8803      	ldrh	r3, [r0, #0]
 8004b72:	b29b      	uxth	r3, r3
 8004b74:	4319      	orrs	r1, r3
 8004b76:	8001      	strh	r1, [r0, #0]
 8004b78:	4770      	bx	lr

08004b7a <SPI_TransmitCRC>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Enable the selected SPI CRC transmission */
  SPIx->CR1 |= CR1_CRCNext_Set;
 8004b7a:	8803      	ldrh	r3, [r0, #0]
 8004b7c:	b29b      	uxth	r3, r3
 8004b7e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8004b82:	8003      	strh	r3, [r0, #0]
 8004b84:	4770      	bx	lr

08004b86 <SPI_CalculateCRC>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= CR1_CRCEN_Set;
 8004b86:	8803      	ldrh	r3, [r0, #0]
void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004b88:	b119      	cbz	r1, 8004b92 <SPI_CalculateCRC+0xc>
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= CR1_CRCEN_Set;
 8004b8a:	b29b      	uxth	r3, r3
 8004b8c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8004b90:	e003      	b.n	8004b9a <SPI_CalculateCRC+0x14>
  }
  else
  {
    /* Disable the selected SPI CRC calculation */
    SPIx->CR1 &= CR1_CRCEN_Reset;
 8004b92:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8004b96:	041b      	lsls	r3, r3, #16
 8004b98:	0c1b      	lsrs	r3, r3, #16
 8004b9a:	8003      	strh	r3, [r0, #0]
 8004b9c:	4770      	bx	lr

08004b9e <SPI_GetCRC>:
{
  uint16_t crcreg = 0;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_CRC(SPI_CRC));
  if (SPI_CRC != SPI_CRC_Rx)
 8004b9e:	2901      	cmp	r1, #1
  {
    /* Get the Tx CRC register */
    crcreg = SPIx->TXCRCR;
 8004ba0:	bf14      	ite	ne
 8004ba2:	8b00      	ldrhne	r0, [r0, #24]
  }
  else
  {
    /* Get the Rx CRC register */
    crcreg = SPIx->RXCRCR;
 8004ba4:	8a80      	ldrheq	r0, [r0, #20]
 8004ba6:	b280      	uxth	r0, r0
  }
  /* Return the selected CRC register */
  return crcreg;
}
 8004ba8:	4770      	bx	lr

08004baa <SPI_GetCRCPolynomial>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Return the CRC polynomial register */
  return SPIx->CRCPR;
 8004baa:	8a00      	ldrh	r0, [r0, #16]
}
 8004bac:	b280      	uxth	r0, r0
 8004bae:	4770      	bx	lr

08004bb0 <SPI_BiDirectionalLineConfig>:
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 8004bb0:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
 8004bb4:	8803      	ldrh	r3, [r0, #0]
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 8004bb6:	d103      	bne.n	8004bc0 <SPI_BiDirectionalLineConfig+0x10>
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
 8004bb8:	b29b      	uxth	r3, r3
 8004bba:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8004bbe:	e003      	b.n	8004bc8 <SPI_BiDirectionalLineConfig+0x18>
  }
  else
  {
    /* Set the Rx only mode */
    SPIx->CR1 &= SPI_Direction_Rx;
 8004bc0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8004bc4:	041b      	lsls	r3, r3, #16
 8004bc6:	0c1b      	lsrs	r3, r3, #16
 8004bc8:	8003      	strh	r3, [r0, #0]
 8004bca:	4770      	bx	lr

08004bcc <SPI_I2S_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
  /* Check the status of the specified SPI/I2S flag */
  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
 8004bcc:	8903      	ldrh	r3, [r0, #8]
 8004bce:	4219      	tst	r1, r3
    /* SPI_I2S_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_FLAG status */
  return  bitstatus;
}
 8004bd0:	bf0c      	ite	eq
 8004bd2:	2000      	moveq	r0, #0
 8004bd4:	2001      	movne	r0, #1
 8004bd6:	4770      	bx	lr

08004bd8 <SPI_I2S_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
    
    /* Clear the selected SPI CRC Error (CRCERR) flag */
    SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
 8004bd8:	43c9      	mvns	r1, r1
 8004bda:	b289      	uxth	r1, r1
 8004bdc:	8101      	strh	r1, [r0, #8]
 8004bde:	4770      	bx	lr

08004be0 <SPI_I2S_GetITStatus>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));

  /* Get the SPI/I2S IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 8004be0:	2301      	movs	r3, #1
 8004be2:	f001 020f 	and.w	r2, r1, #15
 8004be6:	fa03 f202 	lsl.w	r2, r3, r2
  *     @arg SPI_IT_CRCERR: CRC Error interrupt.
  *     @arg I2S_IT_UDR: Underrun Error interrupt.
  * @retval The new state of SPI_I2S_IT (SET or RESET).
  */
ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
{
 8004bea:	b510      	push	{r4, lr}

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 8004bec:	8884      	ldrh	r4, [r0, #4]

  /* Check the status of the specified SPI/I2S interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8004bee:	8900      	ldrh	r0, [r0, #8]

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 8004bf0:	b2a4      	uxth	r4, r4

  /* Check the status of the specified SPI/I2S interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8004bf2:	b280      	uxth	r0, r0
 8004bf4:	4010      	ands	r0, r2
 8004bf6:	d006      	beq.n	8004c06 <SPI_I2S_GetITStatus+0x26>

  /* Get the SPI/I2S IT mask */
  itmask = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = 0x01 << itmask;
 8004bf8:	0909      	lsrs	r1, r1, #4
 8004bfa:	fa03 f301 	lsl.w	r3, r3, r1

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;

  /* Check the status of the specified SPI/I2S interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8004bfe:	421c      	tst	r4, r3
  {
    /* SPI_I2S_IT is set */
    bitstatus = SET;
 8004c00:	bf0c      	ite	eq
 8004c02:	2000      	moveq	r0, #0
 8004c04:	2001      	movne	r0, #1
    /* SPI_I2S_IT is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_IT status */
  return bitstatus;
}
 8004c06:	bd10      	pop	{r4, pc}

08004c08 <SPI_I2S_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));

  /* Get the SPI IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 8004c08:	f001 010f 	and.w	r1, r1, #15
 8004c0c:	2301      	movs	r3, #1
 8004c0e:	fa03 f301 	lsl.w	r3, r3, r1

  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
  SPIx->SR = (uint16_t)~itpos;
 8004c12:	43db      	mvns	r3, r3
 8004c14:	b29b      	uxth	r3, r3
 8004c16:	8103      	strh	r3, [r0, #8]
 8004c18:	4770      	bx	lr
 8004c1a:	bf00      	nop

08004c1c <TI1_Config>:
  *   This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8004c1c:	b530      	push	{r4, r5, lr}
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
 8004c1e:	8c04      	ldrh	r4, [r0, #32]
 8004c20:	f024 0401 	bic.w	r4, r4, #1
 8004c24:	0424      	lsls	r4, r4, #16
 8004c26:	0c24      	lsrs	r4, r4, #16
 8004c28:	8404      	strh	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004c2a:	8b05      	ldrh	r5, [r0, #24]
  tmpccer = TIMx->CCER;
 8004c2c:	8c04      	ldrh	r4, [r0, #32]
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
  tmpccmr1 = TIMx->CCMR1;
 8004c2e:	b2ad      	uxth	r5, r5
  tmpccer = TIMx->CCER;
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
 8004c30:	f025 05f3 	bic.w	r5, r5, #243	; 0xf3
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8004c34:	432a      	orrs	r2, r5
 8004c36:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
 8004c3a:	b29d      	uxth	r5, r3
  
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
 8004c3c:	4b11      	ldr	r3, [pc, #68]	; (8004c84 <TI1_Config+0x68>)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8004c3e:	b2a4      	uxth	r4, r4
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
  
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
 8004c40:	4298      	cmp	r0, r3
 8004c42:	d015      	beq.n	8004c70 <TI1_Config+0x54>
 8004c44:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004c48:	4298      	cmp	r0, r3
 8004c4a:	d011      	beq.n	8004c70 <TI1_Config+0x54>
 8004c4c:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8004c50:	d00e      	beq.n	8004c70 <TI1_Config+0x54>
 8004c52:	f5a3 3398 	sub.w	r3, r3, #77824	; 0x13000
 8004c56:	4298      	cmp	r0, r3
 8004c58:	d00a      	beq.n	8004c70 <TI1_Config+0x54>
 8004c5a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004c5e:	4298      	cmp	r0, r3
 8004c60:	d006      	beq.n	8004c70 <TI1_Config+0x54>
     (TIMx == TIM4) ||(TIMx == TIM5))
 8004c62:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004c66:	4298      	cmp	r0, r3
    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
  }
  else
  {
    /* Select the Polarity and set the CC1E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
 8004c68:	bf18      	it	ne
 8004c6a:	f024 040a 	bicne.w	r4, r4, #10
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
  
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
     (TIMx == TIM4) ||(TIMx == TIM5))
 8004c6e:	d102      	bne.n	8004c76 <TI1_Config+0x5a>
  {
    /* Select the Polarity and set the CC1E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P));
 8004c70:	f024 0402 	bic.w	r4, r4, #2
 8004c74:	e7ff      	b.n	8004c76 <TI1_Config+0x5a>
  }
  else
  {
    /* Select the Polarity and set the CC1E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8004c76:	f044 0401 	orr.w	r4, r4, #1
 8004c7a:	4321      	orrs	r1, r4
  }

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8004c7c:	8305      	strh	r5, [r0, #24]
  TIMx->CCER = tmpccer;
 8004c7e:	8401      	strh	r1, [r0, #32]
 8004c80:	bd30      	pop	{r4, r5, pc}
 8004c82:	bf00      	nop
 8004c84:	40012c00 	.word	0x40012c00

08004c88 <TI2_Config>:
  *   This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8004c88:	b530      	push	{r4, r5, lr}
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
 8004c8a:	8c04      	ldrh	r4, [r0, #32]
 8004c8c:	f024 0410 	bic.w	r4, r4, #16
 8004c90:	0424      	lsls	r4, r4, #16
 8004c92:	0c24      	lsrs	r4, r4, #16
 8004c94:	8404      	strh	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004c96:	8b04      	ldrh	r4, [r0, #24]
  tmpccer = TIMx->CCER;
 8004c98:	8c05      	ldrh	r5, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
 8004c9a:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 8004c9e:	0524      	lsls	r4, r4, #20
 8004ca0:	0d24      	lsrs	r4, r4, #20
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8004ca2:	ea44 2202 	orr.w	r2, r4, r2, lsl #8
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
 8004ca6:	ea42 3303 	orr.w	r3, r2, r3, lsl #12
  
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
 8004caa:	4a14      	ldr	r2, [pc, #80]	; (8004cfc <TI2_Config+0x74>)
{
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8004cac:	b2ad      	uxth	r5, r5
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
  
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
 8004cae:	4290      	cmp	r0, r2
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
 8004cb0:	b29b      	uxth	r3, r3
  
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
 8004cb2:	d012      	beq.n	8004cda <TI2_Config+0x52>
 8004cb4:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8004cb8:	4290      	cmp	r0, r2
 8004cba:	d00e      	beq.n	8004cda <TI2_Config+0x52>
 8004cbc:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8004cc0:	d00b      	beq.n	8004cda <TI2_Config+0x52>
 8004cc2:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8004cc6:	4290      	cmp	r0, r2
 8004cc8:	d007      	beq.n	8004cda <TI2_Config+0x52>
 8004cca:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004cce:	4290      	cmp	r0, r2
 8004cd0:	d003      	beq.n	8004cda <TI2_Config+0x52>
     (TIMx == TIM4) ||(TIMx == TIM5))
 8004cd2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004cd6:	4290      	cmp	r0, r2
 8004cd8:	d107      	bne.n	8004cea <TI2_Config+0x62>
  {
    /* Select the Polarity and set the CC2E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P));
 8004cda:	f025 0520 	bic.w	r5, r5, #32
    tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8004cde:	f045 0510 	orr.w	r5, r5, #16
 8004ce2:	ea45 1101 	orr.w	r1, r5, r1, lsl #4
 8004ce6:	b289      	uxth	r1, r1
 8004ce8:	e004      	b.n	8004cf4 <TI2_Config+0x6c>
  }
  else
  {
    /* Select the Polarity and set the CC2E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
 8004cea:	f025 05a0 	bic.w	r5, r5, #160	; 0xa0
    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC2E);
 8004cee:	f045 0510 	orr.w	r5, r5, #16
 8004cf2:	4329      	orrs	r1, r5
  }
  
  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8004cf4:	8303      	strh	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8004cf6:	8401      	strh	r1, [r0, #32]
 8004cf8:	bd30      	pop	{r4, r5, pc}
 8004cfa:	bf00      	nop
 8004cfc:	40012c00 	.word	0x40012c00

08004d00 <TIM_DeInit>:
  * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
  * @retval None
  */
void TIM_DeInit(TIM_TypeDef* TIMx)
{
 8004d00:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
 
  if (TIMx == TIM1)
 8004d02:	4b5a      	ldr	r3, [pc, #360]	; (8004e6c <TIM_DeInit+0x16c>)
 8004d04:	4298      	cmp	r0, r3
 8004d06:	d107      	bne.n	8004d18 <TIM_DeInit+0x18>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
 8004d08:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8004d0c:	2101      	movs	r1, #1
 8004d0e:	f7ff fcd3 	bl	80046b8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
 8004d12:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8004d16:	e0a2      	b.n	8004e5e <TIM_DeInit+0x15e>
  }     
  else if (TIMx == TIM2)
 8004d18:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8004d1c:	d105      	bne.n	8004d2a <TIM_DeInit+0x2a>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
 8004d1e:	2001      	movs	r0, #1
 8004d20:	4601      	mov	r1, r0
 8004d22:	f7ff fcd5 	bl	80046d0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
 8004d26:	2001      	movs	r0, #1
 8004d28:	e007      	b.n	8004d3a <TIM_DeInit+0x3a>
  }
  else if (TIMx == TIM3)
 8004d2a:	4b51      	ldr	r3, [pc, #324]	; (8004e70 <TIM_DeInit+0x170>)
 8004d2c:	4298      	cmp	r0, r3
 8004d2e:	d109      	bne.n	8004d44 <TIM_DeInit+0x44>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
 8004d30:	2002      	movs	r0, #2
 8004d32:	2101      	movs	r1, #1
 8004d34:	f7ff fccc 	bl	80046d0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 8004d38:	2002      	movs	r0, #2
 8004d3a:	2100      	movs	r1, #0
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
    }  
  }
}
 8004d3c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
  }
  else if (TIMx == TIM3)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 8004d40:	f7ff bcc6 	b.w	80046d0 <RCC_APB1PeriphResetCmd>
  }
  else if (TIMx == TIM4)
 8004d44:	4b4b      	ldr	r3, [pc, #300]	; (8004e74 <TIM_DeInit+0x174>)
 8004d46:	4298      	cmp	r0, r3
 8004d48:	d105      	bne.n	8004d56 <TIM_DeInit+0x56>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
 8004d4a:	2004      	movs	r0, #4
 8004d4c:	2101      	movs	r1, #1
 8004d4e:	f7ff fcbf 	bl	80046d0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
 8004d52:	2004      	movs	r0, #4
 8004d54:	e7f1      	b.n	8004d3a <TIM_DeInit+0x3a>
  } 
  else if (TIMx == TIM5)
 8004d56:	4b48      	ldr	r3, [pc, #288]	; (8004e78 <TIM_DeInit+0x178>)
 8004d58:	4298      	cmp	r0, r3
 8004d5a:	d105      	bne.n	8004d68 <TIM_DeInit+0x68>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
 8004d5c:	2008      	movs	r0, #8
 8004d5e:	2101      	movs	r1, #1
 8004d60:	f7ff fcb6 	bl	80046d0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
 8004d64:	2008      	movs	r0, #8
 8004d66:	e7e8      	b.n	8004d3a <TIM_DeInit+0x3a>
  } 
  else if (TIMx == TIM6)
 8004d68:	4b44      	ldr	r3, [pc, #272]	; (8004e7c <TIM_DeInit+0x17c>)
 8004d6a:	4298      	cmp	r0, r3
 8004d6c:	d105      	bne.n	8004d7a <TIM_DeInit+0x7a>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
 8004d6e:	2010      	movs	r0, #16
 8004d70:	2101      	movs	r1, #1
 8004d72:	f7ff fcad 	bl	80046d0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
 8004d76:	2010      	movs	r0, #16
 8004d78:	e7df      	b.n	8004d3a <TIM_DeInit+0x3a>
  } 
  else if (TIMx == TIM7)
 8004d7a:	4b41      	ldr	r3, [pc, #260]	; (8004e80 <TIM_DeInit+0x180>)
 8004d7c:	4298      	cmp	r0, r3
 8004d7e:	d105      	bne.n	8004d8c <TIM_DeInit+0x8c>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
 8004d80:	2020      	movs	r0, #32
 8004d82:	2101      	movs	r1, #1
 8004d84:	f7ff fca4 	bl	80046d0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
 8004d88:	2020      	movs	r0, #32
 8004d8a:	e7d6      	b.n	8004d3a <TIM_DeInit+0x3a>
  } 
  else if (TIMx == TIM8)
 8004d8c:	4b3d      	ldr	r3, [pc, #244]	; (8004e84 <TIM_DeInit+0x184>)
 8004d8e:	4298      	cmp	r0, r3
 8004d90:	d107      	bne.n	8004da2 <TIM_DeInit+0xa2>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
 8004d92:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8004d96:	2101      	movs	r1, #1
 8004d98:	f7ff fc8e 	bl	80046b8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);
 8004d9c:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8004da0:	e05d      	b.n	8004e5e <TIM_DeInit+0x15e>
  }
  else if (TIMx == TIM9)
 8004da2:	4b39      	ldr	r3, [pc, #228]	; (8004e88 <TIM_DeInit+0x188>)
 8004da4:	4298      	cmp	r0, r3
 8004da6:	d107      	bne.n	8004db8 <TIM_DeInit+0xb8>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
 8004da8:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8004dac:	2101      	movs	r1, #1
 8004dae:	f7ff fc83 	bl	80046b8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
 8004db2:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8004db6:	e052      	b.n	8004e5e <TIM_DeInit+0x15e>
   }  
  else if (TIMx == TIM10)
 8004db8:	4b34      	ldr	r3, [pc, #208]	; (8004e8c <TIM_DeInit+0x18c>)
 8004dba:	4298      	cmp	r0, r3
 8004dbc:	d107      	bne.n	8004dce <TIM_DeInit+0xce>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
 8004dbe:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8004dc2:	2101      	movs	r1, #1
 8004dc4:	f7ff fc78 	bl	80046b8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
 8004dc8:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8004dcc:	e047      	b.n	8004e5e <TIM_DeInit+0x15e>
  }  
  else if (TIMx == TIM11) 
 8004dce:	4b30      	ldr	r3, [pc, #192]	; (8004e90 <TIM_DeInit+0x190>)
 8004dd0:	4298      	cmp	r0, r3
 8004dd2:	d107      	bne.n	8004de4 <TIM_DeInit+0xe4>
  {     
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
 8004dd4:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8004dd8:	2101      	movs	r1, #1
 8004dda:	f7ff fc6d 	bl	80046b8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
 8004dde:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8004de2:	e03c      	b.n	8004e5e <TIM_DeInit+0x15e>
  }  
  else if (TIMx == TIM12)
 8004de4:	4b2b      	ldr	r3, [pc, #172]	; (8004e94 <TIM_DeInit+0x194>)
 8004de6:	4298      	cmp	r0, r3
 8004de8:	d105      	bne.n	8004df6 <TIM_DeInit+0xf6>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
 8004dea:	2040      	movs	r0, #64	; 0x40
 8004dec:	2101      	movs	r1, #1
 8004dee:	f7ff fc6f 	bl	80046d0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
 8004df2:	2040      	movs	r0, #64	; 0x40
 8004df4:	e7a1      	b.n	8004d3a <TIM_DeInit+0x3a>
  }  
  else if (TIMx == TIM13) 
 8004df6:	4b28      	ldr	r3, [pc, #160]	; (8004e98 <TIM_DeInit+0x198>)
 8004df8:	4298      	cmp	r0, r3
 8004dfa:	d105      	bne.n	8004e08 <TIM_DeInit+0x108>
  {       
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
 8004dfc:	2080      	movs	r0, #128	; 0x80
 8004dfe:	2101      	movs	r1, #1
 8004e00:	f7ff fc66 	bl	80046d0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
 8004e04:	2080      	movs	r0, #128	; 0x80
 8004e06:	e798      	b.n	8004d3a <TIM_DeInit+0x3a>
  }
  else if (TIMx == TIM14) 
 8004e08:	4b24      	ldr	r3, [pc, #144]	; (8004e9c <TIM_DeInit+0x19c>)
 8004e0a:	4298      	cmp	r0, r3
 8004e0c:	d107      	bne.n	8004e1e <TIM_DeInit+0x11e>
  {       
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
 8004e0e:	f44f 7080 	mov.w	r0, #256	; 0x100
 8004e12:	2101      	movs	r1, #1
 8004e14:	f7ff fc5c 	bl	80046d0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);  
 8004e18:	f44f 7080 	mov.w	r0, #256	; 0x100
 8004e1c:	e78d      	b.n	8004d3a <TIM_DeInit+0x3a>
  }        
  else if (TIMx == TIM15)
 8004e1e:	4b20      	ldr	r3, [pc, #128]	; (8004ea0 <TIM_DeInit+0x1a0>)
 8004e20:	4298      	cmp	r0, r3
 8004e22:	d107      	bne.n	8004e34 <TIM_DeInit+0x134>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
 8004e24:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8004e28:	2101      	movs	r1, #1
 8004e2a:	f7ff fc45 	bl	80046b8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
 8004e2e:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8004e32:	e014      	b.n	8004e5e <TIM_DeInit+0x15e>
  } 
  else if (TIMx == TIM16)
 8004e34:	4b1b      	ldr	r3, [pc, #108]	; (8004ea4 <TIM_DeInit+0x1a4>)
 8004e36:	4298      	cmp	r0, r3
 8004e38:	d107      	bne.n	8004e4a <TIM_DeInit+0x14a>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
 8004e3a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8004e3e:	2101      	movs	r1, #1
 8004e40:	f7ff fc3a 	bl	80046b8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
 8004e44:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8004e48:	e009      	b.n	8004e5e <TIM_DeInit+0x15e>
  } 
  else
  {
    if (TIMx == TIM17)
 8004e4a:	4b17      	ldr	r3, [pc, #92]	; (8004ea8 <TIM_DeInit+0x1a8>)
 8004e4c:	4298      	cmp	r0, r3
 8004e4e:	d10b      	bne.n	8004e68 <TIM_DeInit+0x168>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
 8004e50:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8004e54:	2101      	movs	r1, #1
 8004e56:	f7ff fc2f 	bl	80046b8 <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
 8004e5a:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8004e5e:	2100      	movs	r1, #0
    }  
  }
}
 8004e60:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if (TIMx == TIM17)
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
 8004e64:	f7ff bc28 	b.w	80046b8 <RCC_APB2PeriphResetCmd>
 8004e68:	bd08      	pop	{r3, pc}
 8004e6a:	bf00      	nop
 8004e6c:	40012c00 	.word	0x40012c00
 8004e70:	40000400 	.word	0x40000400
 8004e74:	40000800 	.word	0x40000800
 8004e78:	40000c00 	.word	0x40000c00
 8004e7c:	40001000 	.word	0x40001000
 8004e80:	40001400 	.word	0x40001400
 8004e84:	40013400 	.word	0x40013400
 8004e88:	40014c00 	.word	0x40014c00
 8004e8c:	40015000 	.word	0x40015000
 8004e90:	40015400 	.word	0x40015400
 8004e94:	40001800 	.word	0x40001800
 8004e98:	40001c00 	.word	0x40001c00
 8004e9c:	40002000 	.word	0x40002000
 8004ea0:	40014000 	.word	0x40014000
 8004ea4:	40014400 	.word	0x40014400
 8004ea8:	40014800 	.word	0x40014800

08004eac <TIM_TimeBaseInit>:
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 8004eac:	4a22      	ldr	r2, [pc, #136]	; (8004f38 <TIM_TimeBaseInit+0x8c>)
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8004eae:	8803      	ldrh	r3, [r0, #0]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 8004eb0:	4290      	cmp	r0, r2
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8004eb2:	b29b      	uxth	r3, r3

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
 8004eb4:	d012      	beq.n	8004edc <TIM_TimeBaseInit+0x30>
 8004eb6:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8004eba:	4290      	cmp	r0, r2
 8004ebc:	d00e      	beq.n	8004edc <TIM_TimeBaseInit+0x30>
 8004ebe:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8004ec2:	d00b      	beq.n	8004edc <TIM_TimeBaseInit+0x30>
 8004ec4:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8004ec8:	4290      	cmp	r0, r2
 8004eca:	d007      	beq.n	8004edc <TIM_TimeBaseInit+0x30>
 8004ecc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004ed0:	4290      	cmp	r0, r2
 8004ed2:	d003      	beq.n	8004edc <TIM_TimeBaseInit+0x30>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 8004ed4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004ed8:	4290      	cmp	r0, r2
 8004eda:	d103      	bne.n	8004ee4 <TIM_TimeBaseInit+0x38>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8004edc:	884a      	ldrh	r2, [r1, #2]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
     (TIMx == TIM4) || (TIMx == TIM5)) 
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
 8004ede:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8004ee2:	4313      	orrs	r3, r2
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 8004ee4:	4a15      	ldr	r2, [pc, #84]	; (8004f3c <TIM_TimeBaseInit+0x90>)
 8004ee6:	4290      	cmp	r0, r2
 8004ee8:	d008      	beq.n	8004efc <TIM_TimeBaseInit+0x50>
 8004eea:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004eee:	4290      	cmp	r0, r2
 8004ef0:	d004      	beq.n	8004efc <TIM_TimeBaseInit+0x50>
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 8004ef2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8004ef6:	88ca      	ldrh	r2, [r1, #6]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 8004ef8:	b29b      	uxth	r3, r3
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8004efa:	4313      	orrs	r3, r2
  }

  TIMx->CR1 = tmpcr1;
 8004efc:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 8004efe:	888b      	ldrh	r3, [r1, #4]
 8004f00:	8583      	strh	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8004f02:	880b      	ldrh	r3, [r1, #0]
 8004f04:	8503      	strh	r3, [r0, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
 8004f06:	4b0c      	ldr	r3, [pc, #48]	; (8004f38 <TIM_TimeBaseInit+0x8c>)
 8004f08:	4298      	cmp	r0, r3
 8004f0a:	d00f      	beq.n	8004f2c <TIM_TimeBaseInit+0x80>
 8004f0c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004f10:	4298      	cmp	r0, r3
 8004f12:	d00b      	beq.n	8004f2c <TIM_TimeBaseInit+0x80>
 8004f14:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
 8004f18:	4298      	cmp	r0, r3
 8004f1a:	d007      	beq.n	8004f2c <TIM_TimeBaseInit+0x80>
 8004f1c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004f20:	4298      	cmp	r0, r3
 8004f22:	d003      	beq.n	8004f2c <TIM_TimeBaseInit+0x80>
 8004f24:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004f28:	4298      	cmp	r0, r3
 8004f2a:	d101      	bne.n	8004f30 <TIM_TimeBaseInit+0x84>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 8004f2c:	7a0b      	ldrb	r3, [r1, #8]
 8004f2e:	8603      	strh	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler and the Repetition counter
     values immediately */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;           
 8004f30:	2301      	movs	r3, #1
 8004f32:	8283      	strh	r3, [r0, #20]
 8004f34:	4770      	bx	lr
 8004f36:	bf00      	nop
 8004f38:	40012c00 	.word	0x40012c00
 8004f3c:	40001000 	.word	0x40001000

08004f40 <TIM_OC1Init>:
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
 /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
 8004f40:	8c03      	ldrh	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004f42:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
 /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
 8004f44:	f023 0301 	bic.w	r3, r3, #1
 8004f48:	041b      	lsls	r3, r3, #16
 8004f4a:	0c1b      	lsrs	r3, r3, #16
 8004f4c:	8403      	strh	r3, [r0, #32]
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004f4e:	8c03      	ldrh	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004f50:	8884      	ldrh	r4, [r0, #4]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8004f52:	8b02      	ldrh	r2, [r0, #24]
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));

  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004f54:	880d      	ldrh	r5, [r1, #0]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
 8004f56:	f022 0273 	bic.w	r2, r2, #115	; 0x73
 8004f5a:	0412      	lsls	r2, r2, #16
 8004f5c:	0c12      	lsrs	r2, r2, #16

  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004f5e:	432a      	orrs	r2, r5
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8004f60:	884e      	ldrh	r6, [r1, #2]
 8004f62:	890d      	ldrh	r5, [r1, #8]

  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
 8004f64:	f023 0302 	bic.w	r3, r3, #2
 8004f68:	041b      	lsls	r3, r3, #16
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8004f6a:	4335      	orrs	r5, r6

  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
 8004f6c:	0c1b      	lsrs	r3, r3, #16
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8004f6e:	b2ad      	uxth	r5, r5
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
 8004f70:	432b      	orrs	r3, r5
    
  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)||
 8004f72:	4d14      	ldr	r5, [pc, #80]	; (8004fc4 <TIM_OC1Init+0x84>)
 /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004f74:	b2a4      	uxth	r4, r4
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
    
  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)||
 8004f76:	42a8      	cmp	r0, r5
 8004f78:	d00f      	beq.n	8004f9a <TIM_OC1Init+0x5a>
 8004f7a:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004f7e:	42a8      	cmp	r0, r5
 8004f80:	d00b      	beq.n	8004f9a <TIM_OC1Init+0x5a>
 8004f82:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 8004f86:	42a8      	cmp	r0, r5
 8004f88:	d007      	beq.n	8004f9a <TIM_OC1Init+0x5a>
 8004f8a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004f8e:	42a8      	cmp	r0, r5
 8004f90:	d003      	beq.n	8004f9a <TIM_OC1Init+0x5a>
     (TIMx == TIM16)|| (TIMx == TIM17))
 8004f92:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004f96:	42a8      	cmp	r0, r5
 8004f98:	d10e      	bne.n	8004fb8 <TIM_OC1Init+0x78>
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8004f9a:	894d      	ldrh	r5, [r1, #10]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
 8004f9c:	f023 0308 	bic.w	r3, r3, #8
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8004fa0:	432b      	orrs	r3, r5
    
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8004fa2:	888d      	ldrh	r5, [r1, #4]
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
 8004fa4:	f023 0304 	bic.w	r3, r3, #4
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8004fa8:	432b      	orrs	r3, r5
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
    
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 8004faa:	89ce      	ldrh	r6, [r1, #14]
 8004fac:	898d      	ldrh	r5, [r1, #12]
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
 8004fae:	f424 7440 	bic.w	r4, r4, #768	; 0x300
    
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 8004fb2:	4335      	orrs	r5, r6
 8004fb4:	b2ad      	uxth	r5, r5
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
 8004fb6:	432c      	orrs	r4, r5
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004fb8:	8084      	strh	r4, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8004fba:	8302      	strh	r2, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
 8004fbc:	88ca      	ldrh	r2, [r1, #6]
 8004fbe:	8682      	strh	r2, [r0, #52]	; 0x34
 
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004fc0:	8403      	strh	r3, [r0, #32]
 8004fc2:	bd70      	pop	{r4, r5, r6, pc}
 8004fc4:	40012c00 	.word	0x40012c00

08004fc8 <TIM_OC2Init>:
  assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
   /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
 8004fc8:	8c03      	ldrh	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004fca:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
   /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
 8004fcc:	f023 0310 	bic.w	r3, r3, #16
 8004fd0:	041b      	lsls	r3, r3, #16
 8004fd2:	0c1b      	lsrs	r3, r3, #16
 8004fd4:	8403      	strh	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
 8004fd6:	8c03      	ldrh	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004fd8:	8882      	ldrh	r2, [r0, #4]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8004fda:	8b04      	ldrh	r4, [r0, #24]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004fdc:	880d      	ldrh	r5, [r1, #0]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
 8004fde:	f424 44e6 	bic.w	r4, r4, #29440	; 0x7300
 8004fe2:	0424      	lsls	r4, r4, #16
 8004fe4:	0c24      	lsrs	r4, r4, #16
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
 8004fe6:	f023 0320 	bic.w	r3, r3, #32
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004fea:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
 8004fee:	041b      	lsls	r3, r3, #16
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
 8004ff0:	890d      	ldrh	r5, [r1, #8]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
 8004ff2:	0c1b      	lsrs	r3, r3, #16
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
 8004ff4:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 8004ff8:	884d      	ldrh	r5, [r1, #2]
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004ffa:	b292      	uxth	r2, r2
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 8004ffc:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8005000:	4d12      	ldr	r5, [pc, #72]	; (800504c <TIM_OC2Init+0x84>)
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8005002:	b2a4      	uxth	r4, r4
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8005004:	42a8      	cmp	r0, r5
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 8005006:	b29b      	uxth	r3, r3
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8005008:	d003      	beq.n	8005012 <TIM_OC2Init+0x4a>
 800500a:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800500e:	42a8      	cmp	r0, r5
 8005010:	d115      	bne.n	800503e <TIM_OC2Init+0x76>
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
 8005012:	894d      	ldrh	r5, [r1, #10]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
 8005014:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8005018:	b29b      	uxth	r3, r3
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
 800501a:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
 800501e:	f64f 75bf 	movw	r5, #65471	; 0xffbf
 8005022:	401d      	ands	r5, r3
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 8005024:	888b      	ldrh	r3, [r1, #4]
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
 8005026:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
    
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 800502a:	ea45 1303 	orr.w	r3, r5, r3, lsl #4
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
    
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
 800502e:	898d      	ldrh	r5, [r1, #12]
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
    
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 8005030:	b29b      	uxth	r3, r3
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
    
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
 8005032:	ea42 0285 	orr.w	r2, r2, r5, lsl #2
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
 8005036:	89cd      	ldrh	r5, [r1, #14]
 8005038:	ea42 0285 	orr.w	r2, r2, r5, lsl #2
 800503c:	b292      	uxth	r2, r2
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800503e:	8082      	strh	r2, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 8005040:	88ca      	ldrh	r2, [r1, #6]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8005042:	8304      	strh	r4, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 8005044:	8702      	strh	r2, [r0, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8005046:	8403      	strh	r3, [r0, #32]
 8005048:	bd30      	pop	{r4, r5, pc}
 800504a:	bf00      	nop
 800504c:	40012c00 	.word	0x40012c00

08005050 <TIM_OC3Init>:
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
 8005050:	8c03      	ldrh	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8005052:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
 8005054:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8005058:	041b      	lsls	r3, r3, #16
 800505a:	0c1b      	lsrs	r3, r3, #16
 800505c:	8403      	strh	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800505e:	8c03      	ldrh	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8005060:	8882      	ldrh	r2, [r0, #4]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8005062:	8b84      	ldrh	r4, [r0, #28]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8005064:	880d      	ldrh	r5, [r1, #0]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
 8005066:	f024 0473 	bic.w	r4, r4, #115	; 0x73
 800506a:	0424      	lsls	r4, r4, #16
 800506c:	0c24      	lsrs	r4, r4, #16
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
 800506e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8005072:	041b      	lsls	r3, r3, #16
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8005074:	432c      	orrs	r4, r5
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
 8005076:	890d      	ldrh	r5, [r1, #8]
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
 8005078:	0c1b      	lsrs	r3, r3, #16
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
 800507a:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 800507e:	884d      	ldrh	r5, [r1, #2]
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8005080:	b292      	uxth	r2, r2
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 8005082:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8005086:	4d12      	ldr	r5, [pc, #72]	; (80050d0 <TIM_OC3Init+0x80>)
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 8005088:	b29b      	uxth	r3, r3
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 800508a:	42a8      	cmp	r0, r5
 800508c:	d003      	beq.n	8005096 <TIM_OC3Init+0x46>
 800508e:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8005092:	42a8      	cmp	r0, r5
 8005094:	d115      	bne.n	80050c2 <TIM_OC3Init+0x72>
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
 8005096:	894d      	ldrh	r5, [r1, #10]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
 8005098:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800509c:	b29b      	uxth	r3, r3
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
 800509e:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
 80050a2:	f64f 35ff 	movw	r5, #64511	; 0xfbff
 80050a6:	401d      	ands	r5, r3
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
 80050a8:	888b      	ldrh	r3, [r1, #4]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
 80050aa:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
 80050ae:	ea45 2303 	orr.w	r3, r5, r3, lsl #8
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
 80050b2:	898d      	ldrh	r5, [r1, #12]
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
 80050b4:	b29b      	uxth	r3, r3
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
 80050b6:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
 80050ba:	89cd      	ldrh	r5, [r1, #14]
 80050bc:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
 80050c0:	b292      	uxth	r2, r2
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80050c2:	8082      	strh	r2, [r0, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 80050c4:	88ca      	ldrh	r2, [r1, #6]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 80050c6:	8384      	strh	r4, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 80050c8:	8782      	strh	r2, [r0, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80050ca:	8403      	strh	r3, [r0, #32]
 80050cc:	bd30      	pop	{r4, r5, pc}
 80050ce:	bf00      	nop
 80050d0:	40012c00 	.word	0x40012c00

080050d4 <TIM_OC4Init>:
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
  /* Disable the Channel 2: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
 80050d4:	8c03      	ldrh	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 80050d6:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
  /* Disable the Channel 2: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
 80050d8:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80050dc:	041b      	lsls	r3, r3, #16
 80050de:	0c1b      	lsrs	r3, r3, #16
 80050e0:	8403      	strh	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80050e2:	8c03      	ldrh	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80050e4:	8884      	ldrh	r4, [r0, #4]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 80050e6:	8b82      	ldrh	r2, [r0, #28]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 80050e8:	880d      	ldrh	r5, [r1, #0]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
 80050ea:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
 80050ee:	0412      	lsls	r2, r2, #16
 80050f0:	0c12      	lsrs	r2, r2, #16
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
 80050f2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 80050f6:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
 80050fa:	041b      	lsls	r3, r3, #16
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
 80050fc:	890d      	ldrh	r5, [r1, #8]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
 80050fe:	0c1b      	lsrs	r3, r3, #16
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
 8005100:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
 8005104:	884d      	ldrh	r5, [r1, #2]
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8005106:	b2a4      	uxth	r4, r4
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
 8005108:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 800510c:	4d0a      	ldr	r5, [pc, #40]	; (8005138 <TIM_OC4Init+0x64>)
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 800510e:	b292      	uxth	r2, r2
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8005110:	42a8      	cmp	r0, r5
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
 8005112:	b29b      	uxth	r3, r3
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8005114:	d003      	beq.n	800511e <TIM_OC4Init+0x4a>
 8005116:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800511a:	42a8      	cmp	r0, r5
 800511c:	d105      	bne.n	800512a <TIM_OC4Init+0x56>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
 800511e:	898d      	ldrh	r5, [r1, #12]
    
  if((TIMx == TIM1) || (TIMx == TIM8))
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
 8005120:	f424 4480 	bic.w	r4, r4, #16384	; 0x4000
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
 8005124:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
 8005128:	b2a4      	uxth	r4, r4
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800512a:	8084      	strh	r4, [r0, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
 800512c:	8382      	strh	r2, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 800512e:	88ca      	ldrh	r2, [r1, #6]
 8005130:	f8a0 2040 	strh.w	r2, [r0, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8005134:	8403      	strh	r3, [r0, #32]
 8005136:	bd30      	pop	{r4, r5, pc}
 8005138:	40012c00 	.word	0x40012c00

0800513c <TIM_BDTRConfig>:
  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 800513c:	884a      	ldrh	r2, [r1, #2]
 800513e:	880b      	ldrh	r3, [r1, #0]
 8005140:	4313      	orrs	r3, r2
 8005142:	888a      	ldrh	r2, [r1, #4]
 8005144:	4313      	orrs	r3, r2
 8005146:	88ca      	ldrh	r2, [r1, #6]
 8005148:	4313      	orrs	r3, r2
 800514a:	890a      	ldrh	r2, [r1, #8]
 800514c:	4313      	orrs	r3, r2
 800514e:	894a      	ldrh	r2, [r1, #10]
 8005150:	4313      	orrs	r3, r2
 8005152:	898a      	ldrh	r2, [r1, #12]
 8005154:	4313      	orrs	r3, r2
 8005156:	b29b      	uxth	r3, r3
 8005158:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
 800515c:	4770      	bx	lr

0800515e <TIM_TimeBaseStructInit>:
  * @retval None
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
 800515e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8005162:	8083      	strh	r3, [r0, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 8005164:	2300      	movs	r3, #0
 8005166:	8003      	strh	r3, [r0, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
 8005168:	80c3      	strh	r3, [r0, #6]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
 800516a:	8043      	strh	r3, [r0, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
 800516c:	7203      	strb	r3, [r0, #8]
 800516e:	4770      	bx	lr

08005170 <TIM_OCStructInit>:
  * @retval None
  */
void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
{
  /* Set the default configuration */
  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
 8005170:	2300      	movs	r3, #0
 8005172:	8003      	strh	r3, [r0, #0]
  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
 8005174:	8043      	strh	r3, [r0, #2]
  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
 8005176:	8083      	strh	r3, [r0, #4]
  TIM_OCInitStruct->TIM_Pulse = 0x0000;
 8005178:	80c3      	strh	r3, [r0, #6]
  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
 800517a:	8103      	strh	r3, [r0, #8]
  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
 800517c:	8143      	strh	r3, [r0, #10]
  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
 800517e:	8183      	strh	r3, [r0, #12]
  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
 8005180:	81c3      	strh	r3, [r0, #14]
 8005182:	4770      	bx	lr

08005184 <TIM_ICStructInit>:
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 8005184:	2300      	movs	r3, #0
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 8005186:	2201      	movs	r2, #1
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 8005188:	8003      	strh	r3, [r0, #0]
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
 800518a:	8043      	strh	r3, [r0, #2]
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 800518c:	8082      	strh	r2, [r0, #4]
  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
 800518e:	80c3      	strh	r3, [r0, #6]
  TIM_ICInitStruct->TIM_ICFilter = 0x00;
 8005190:	8103      	strh	r3, [r0, #8]
 8005192:	4770      	bx	lr

08005194 <TIM_BDTRStructInit>:
  * @retval None
  */
void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
{
  /* Set the default configuration */
  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
 8005194:	2300      	movs	r3, #0
 8005196:	8003      	strh	r3, [r0, #0]
  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
 8005198:	8043      	strh	r3, [r0, #2]
  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
 800519a:	8083      	strh	r3, [r0, #4]
  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
 800519c:	80c3      	strh	r3, [r0, #6]
  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
 800519e:	8103      	strh	r3, [r0, #8]
  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
 80051a0:	8143      	strh	r3, [r0, #10]
  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
 80051a2:	8183      	strh	r3, [r0, #12]
 80051a4:	4770      	bx	lr

080051a6 <TIM_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 80051a6:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80051a8:	b119      	cbz	r1, 80051b2 <TIM_Cmd+0xc>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 80051aa:	b29b      	uxth	r3, r3
 80051ac:	f043 0301 	orr.w	r3, r3, #1
 80051b0:	e003      	b.n	80051ba <TIM_Cmd+0x14>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
 80051b2:	f023 0301 	bic.w	r3, r3, #1
 80051b6:	041b      	lsls	r3, r3, #16
 80051b8:	0c1b      	lsrs	r3, r3, #16
 80051ba:	8003      	strh	r3, [r0, #0]
 80051bc:	4770      	bx	lr

080051be <TIM_CtrlPWMOutputs>:
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 80051be:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80051c2:	b129      	cbz	r1, 80051d0 <TIM_CtrlPWMOutputs+0x12>
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 80051c4:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80051c8:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80051cc:	b29b      	uxth	r3, r3
 80051ce:	e001      	b.n	80051d4 <TIM_CtrlPWMOutputs+0x16>
  }
  else
  {
    /* Disable the TIM Main Output */
    TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
 80051d0:	045b      	lsls	r3, r3, #17
 80051d2:	0c5b      	lsrs	r3, r3, #17
 80051d4:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
 80051d8:	4770      	bx	lr

080051da <TIM_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 80051da:	8983      	ldrh	r3, [r0, #12]
 80051dc:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80051de:	b10a      	cbz	r2, 80051e4 <TIM_ITConfig+0xa>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 80051e0:	4319      	orrs	r1, r3
 80051e2:	e001      	b.n	80051e8 <TIM_ITConfig+0xe>
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
 80051e4:	ea23 0101 	bic.w	r1, r3, r1
 80051e8:	8181      	strh	r1, [r0, #12]
 80051ea:	4770      	bx	lr

080051ec <TIM_GenerateEvent>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
  
  /* Set the event sources */
  TIMx->EGR = TIM_EventSource;
 80051ec:	8281      	strh	r1, [r0, #20]
 80051ee:	4770      	bx	lr

080051f0 <TIM_DMAConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
  /* Set the DMA Base and the DMA Burst Length */
  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
 80051f0:	430a      	orrs	r2, r1
 80051f2:	f8a0 2048 	strh.w	r2, [r0, #72]	; 0x48
 80051f6:	4770      	bx	lr

080051f8 <TIM_DMACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 80051f8:	8983      	ldrh	r3, [r0, #12]
 80051fa:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_TIM_LIST9_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80051fc:	b10a      	cbz	r2, 8005202 <TIM_DMACmd+0xa>
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 80051fe:	4319      	orrs	r1, r3
 8005200:	e001      	b.n	8005206 <TIM_DMACmd+0xe>
  }
  else
  {
    /* Disable the DMA sources */
    TIMx->DIER &= (uint16_t)~TIM_DMASource;
 8005202:	ea23 0101 	bic.w	r1, r3, r1
 8005206:	8181      	strh	r1, [r0, #12]
 8005208:	4770      	bx	lr

0800520a <TIM_InternalClockConfig>:
void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  /* Disable slave mode to clock the prescaler directly with the internal clock */
  TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
 800520a:	8903      	ldrh	r3, [r0, #8]
 800520c:	f023 0307 	bic.w	r3, r3, #7
 8005210:	041b      	lsls	r3, r3, #16
 8005212:	0c1b      	lsrs	r3, r3, #16
 8005214:	8103      	strh	r3, [r0, #8]
 8005216:	4770      	bx	lr

08005218 <TIM_ITRxExternalClockConfig>:
  uint16_t tmpsmcr = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8005218:	8903      	ldrh	r3, [r0, #8]
  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
 800521a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800521e:	041b      	lsls	r3, r3, #16
 8005220:	0c1b      	lsrs	r3, r3, #16
  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
 8005222:	4319      	orrs	r1, r3
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005224:	8101      	strh	r1, [r0, #8]
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
  /* Select the Internal Trigger */
  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 8005226:	8903      	ldrh	r3, [r0, #8]
 8005228:	b29b      	uxth	r3, r3
 800522a:	f043 0307 	orr.w	r3, r3, #7
 800522e:	8103      	strh	r3, [r0, #8]
 8005230:	4770      	bx	lr

08005232 <TIM_TIxExternalClockConfig>:
  *   This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
 8005232:	b538      	push	{r3, r4, r5, lr}
 8005234:	460d      	mov	r5, r1
 8005236:	4611      	mov	r1, r2
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));
  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
  {
    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 8005238:	2201      	movs	r2, #1
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));
  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 800523a:	2d60      	cmp	r5, #96	; 0x60
  *   This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
 800523c:	4604      	mov	r4, r0
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));
  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 800523e:	d102      	bne.n	8005246 <TIM_TIxExternalClockConfig+0x14>
  {
    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 8005240:	f7ff fd22 	bl	8004c88 <TI2_Config>
 8005244:	e001      	b.n	800524a <TIM_TIxExternalClockConfig+0x18>
  }
  else
  {
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 8005246:	f7ff fce9 	bl	8004c1c <TI1_Config>
  uint16_t tmpsmcr = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800524a:	8923      	ldrh	r3, [r4, #8]
  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
 800524c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8005250:	041b      	lsls	r3, r3, #16
 8005252:	0c1b      	lsrs	r3, r3, #16
  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
 8005254:	432b      	orrs	r3, r5
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005256:	8123      	strh	r3, [r4, #8]
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
  }
  /* Select the Trigger source */
  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 8005258:	8923      	ldrh	r3, [r4, #8]
 800525a:	b29b      	uxth	r3, r3
 800525c:	f043 0307 	orr.w	r3, r3, #7
 8005260:	8123      	strh	r3, [r4, #8]
 8005262:	bd38      	pop	{r3, r4, r5, pc}

08005264 <TIM_ETRConfig>:
  *   This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
                   uint16_t ExtTRGFilter)
{
 8005264:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  tmpsmcr = TIMx->SMCR;
 8005266:	8904      	ldrh	r4, [r0, #8]
  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_Mask;
 8005268:	b2e4      	uxtb	r4, r4
  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 800526a:	4321      	orrs	r1, r4
 800526c:	430a      	orrs	r2, r1
 800526e:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 8005272:	b29c      	uxth	r4, r3
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005274:	8104      	strh	r4, [r0, #8]
 8005276:	bd10      	pop	{r4, pc}

08005278 <TIM_ETRClockMode2Config>:
  *   This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 8005278:	b510      	push	{r4, lr}
 800527a:	4604      	mov	r4, r0
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 800527c:	f7ff fff2 	bl	8005264 <TIM_ETRConfig>
  /* Enable the External clock mode2 */
  TIMx->SMCR |= TIM_SMCR_ECE;
 8005280:	8923      	ldrh	r3, [r4, #8]
 8005282:	b29b      	uxth	r3, r3
 8005284:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005288:	8123      	strh	r3, [r4, #8]
 800528a:	bd10      	pop	{r4, pc}

0800528c <TIM_ETRClockMode1Config>:
  *   This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
                             uint16_t ExtTRGFilter)
{
 800528c:	b510      	push	{r4, lr}
 800528e:	4604      	mov	r4, r0
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 8005290:	f7ff ffe8 	bl	8005264 <TIM_ETRConfig>
  
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8005294:	8923      	ldrh	r3, [r4, #8]
  /* Reset the SMS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
  /* Select the External clock mode1 */
  tmpsmcr |= TIM_SlaveMode_External1;
  /* Select the Trigger selection : ETRF */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
 8005296:	f023 0377 	bic.w	r3, r3, #119	; 0x77
 800529a:	041b      	lsls	r3, r3, #16
 800529c:	0c1b      	lsrs	r3, r3, #16
  tmpsmcr |= TIM_TS_ETRF;
 800529e:	f043 0377 	orr.w	r3, r3, #119	; 0x77
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80052a2:	8123      	strh	r3, [r4, #8]
 80052a4:	bd10      	pop	{r4, pc}

080052a6 <TIM_PrescalerConfig>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
  /* Set the Prescaler value */
  TIMx->PSC = Prescaler;
 80052a6:	8501      	strh	r1, [r0, #40]	; 0x28
  /* Set or reset the UG Bit */
  TIMx->EGR = TIM_PSCReloadMode;
 80052a8:	8282      	strh	r2, [r0, #20]
 80052aa:	4770      	bx	lr

080052ac <TIM_CounterModeConfig>:
{
  uint16_t tmpcr1 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
  tmpcr1 = TIMx->CR1;
 80052ac:	8803      	ldrh	r3, [r0, #0]
  /* Reset the CMS and DIR Bits */
  tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
 80052ae:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80052b2:	041b      	lsls	r3, r3, #16
 80052b4:	0c1b      	lsrs	r3, r3, #16
  /* Set the Counter Mode */
  tmpcr1 |= TIM_CounterMode;
 80052b6:	4319      	orrs	r1, r3
  /* Write to TIMx CR1 register */
  TIMx->CR1 = tmpcr1;
 80052b8:	8001      	strh	r1, [r0, #0]
 80052ba:	4770      	bx	lr

080052bc <TIM_SelectInputTrigger>:
  uint16_t tmpsmcr = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 80052bc:	8903      	ldrh	r3, [r0, #8]
  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
 80052be:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80052c2:	041b      	lsls	r3, r3, #16
 80052c4:	0c1b      	lsrs	r3, r3, #16
  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
 80052c6:	4319      	orrs	r1, r3
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80052c8:	8101      	strh	r1, [r0, #8]
 80052ca:	4770      	bx	lr

080052cc <TIM_EncoderInterfaceConfig>:
  *     @arg TIM_ICPolarity_Rising: IC Rising edge.
  * @retval None
  */
void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
{
 80052cc:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 80052ce:	8905      	ldrh	r5, [r0, #8]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 80052d0:	8b04      	ldrh	r4, [r0, #24]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80052d2:	8c06      	ldrh	r6, [r0, #32]
  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
  tmpsmcr |= TIM_EncoderMode;
  
  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
 80052d4:	f424 7440 	bic.w	r4, r4, #768	; 0x300
  
  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80052d8:	b2b6      	uxth	r6, r6
  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
  tmpsmcr |= TIM_EncoderMode;
  
  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
 80052da:	f024 0403 	bic.w	r4, r4, #3
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
  
  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
 80052de:	f026 0622 	bic.w	r6, r6, #34	; 0x22
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  
  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
 80052e2:	f025 0507 	bic.w	r5, r5, #7
  tmpsmcr |= TIM_EncoderMode;
  
  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
 80052e6:	0424      	lsls	r4, r4, #16
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
  
  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 80052e8:	4332      	orrs	r2, r6
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  
  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
 80052ea:	042d      	lsls	r5, r5, #16
  tmpsmcr |= TIM_EncoderMode;
  
  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
 80052ec:	0c24      	lsrs	r4, r4, #16
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  
  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
 80052ee:	0c2d      	lsrs	r5, r5, #16
  tmpsmcr |= TIM_EncoderMode;
  
  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
 80052f0:	f444 7480 	orr.w	r4, r4, #256	; 0x100
  
  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 80052f4:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  
  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
  tmpsmcr |= TIM_EncoderMode;
 80052f8:	4329      	orrs	r1, r5
  
  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
 80052fa:	f044 0401 	orr.w	r4, r4, #1
  
  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 80052fe:	b29e      	uxth	r6, r3
  
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005300:	8101      	strh	r1, [r0, #8]
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8005302:	8304      	strh	r4, [r0, #24]
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8005304:	8406      	strh	r6, [r0, #32]
 8005306:	bd70      	pop	{r4, r5, r6, pc}

08005308 <TIM_ForcedOC1Config>:
{
  uint16_t tmpccmr1 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 8005308:	8b03      	ldrh	r3, [r0, #24]
  /* Reset the OC1M Bits */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
 800530a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800530e:	041b      	lsls	r3, r3, #16
 8005310:	0c1b      	lsrs	r3, r3, #16
  /* Configure The Forced output Mode */
  tmpccmr1 |= TIM_ForcedAction;
 8005312:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8005314:	8301      	strh	r1, [r0, #24]
 8005316:	4770      	bx	lr

08005318 <TIM_ForcedOC2Config>:
{
  uint16_t tmpccmr1 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 8005318:	8b03      	ldrh	r3, [r0, #24]
  /* Reset the OC2M Bits */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
 800531a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800531e:	041b      	lsls	r3, r3, #16
 8005320:	0c1b      	lsrs	r3, r3, #16
  /* Configure The Forced output Mode */
  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
 8005322:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8005326:	b28b      	uxth	r3, r1
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8005328:	8303      	strh	r3, [r0, #24]
 800532a:	4770      	bx	lr

0800532c <TIM_ForcedOC3Config>:
{
  uint16_t tmpccmr2 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr2 = TIMx->CCMR2;
 800532c:	8b83      	ldrh	r3, [r0, #28]
  /* Reset the OC1M Bits */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
 800532e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8005332:	041b      	lsls	r3, r3, #16
 8005334:	0c1b      	lsrs	r3, r3, #16
  /* Configure The Forced output Mode */
  tmpccmr2 |= TIM_ForcedAction;
 8005336:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8005338:	8381      	strh	r1, [r0, #28]
 800533a:	4770      	bx	lr

0800533c <TIM_ForcedOC4Config>:
{
  uint16_t tmpccmr2 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr2 = TIMx->CCMR2;
 800533c:	8b83      	ldrh	r3, [r0, #28]
  /* Reset the OC2M Bits */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
 800533e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8005342:	041b      	lsls	r3, r3, #16
 8005344:	0c1b      	lsrs	r3, r3, #16
  /* Configure The Forced output Mode */
  tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
 8005346:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 800534a:	b28b      	uxth	r3, r1
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800534c:	8383      	strh	r3, [r0, #28]
 800534e:	4770      	bx	lr

08005350 <TIM_ARRPreloadConfig>:
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 8005350:	8803      	ldrh	r3, [r0, #0]
void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005352:	b119      	cbz	r1, 800535c <TIM_ARRPreloadConfig+0xc>
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 8005354:	b29b      	uxth	r3, r3
 8005356:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800535a:	e003      	b.n	8005364 <TIM_ARRPreloadConfig+0x14>
  }
  else
  {
    /* Reset the ARR Preload Bit */
    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
 800535c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8005360:	041b      	lsls	r3, r3, #16
 8005362:	0c1b      	lsrs	r3, r3, #16
 8005364:	8003      	strh	r3, [r0, #0]
 8005366:	4770      	bx	lr

08005368 <TIM_SelectCOM>:
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the COM Bit */
    TIMx->CR2 |= TIM_CR2_CCUS;
 8005368:	8883      	ldrh	r3, [r0, #4]
void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800536a:	b119      	cbz	r1, 8005374 <TIM_SelectCOM+0xc>
  {
    /* Set the COM Bit */
    TIMx->CR2 |= TIM_CR2_CCUS;
 800536c:	b29b      	uxth	r3, r3
 800536e:	f043 0304 	orr.w	r3, r3, #4
 8005372:	e003      	b.n	800537c <TIM_SelectCOM+0x14>
  }
  else
  {
    /* Reset the COM Bit */
    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
 8005374:	f023 0304 	bic.w	r3, r3, #4
 8005378:	041b      	lsls	r3, r3, #16
 800537a:	0c1b      	lsrs	r3, r3, #16
 800537c:	8083      	strh	r3, [r0, #4]
 800537e:	4770      	bx	lr

08005380 <TIM_SelectCCDMA>:
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the CCDS Bit */
    TIMx->CR2 |= TIM_CR2_CCDS;
 8005380:	8883      	ldrh	r3, [r0, #4]
void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005382:	b119      	cbz	r1, 800538c <TIM_SelectCCDMA+0xc>
  {
    /* Set the CCDS Bit */
    TIMx->CR2 |= TIM_CR2_CCDS;
 8005384:	b29b      	uxth	r3, r3
 8005386:	f043 0308 	orr.w	r3, r3, #8
 800538a:	e003      	b.n	8005394 <TIM_SelectCCDMA+0x14>
  }
  else
  {
    /* Reset the CCDS Bit */
    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
 800538c:	f023 0308 	bic.w	r3, r3, #8
 8005390:	041b      	lsls	r3, r3, #16
 8005392:	0c1b      	lsrs	r3, r3, #16
 8005394:	8083      	strh	r3, [r0, #4]
 8005396:	4770      	bx	lr

08005398 <TIM_CCPreloadControl>:
  assert_param(IS_TIM_LIST5_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the CCPC Bit */
    TIMx->CR2 |= TIM_CR2_CCPC;
 8005398:	8883      	ldrh	r3, [r0, #4]
void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_TIM_LIST5_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800539a:	b119      	cbz	r1, 80053a4 <TIM_CCPreloadControl+0xc>
  {
    /* Set the CCPC Bit */
    TIMx->CR2 |= TIM_CR2_CCPC;
 800539c:	b29b      	uxth	r3, r3
 800539e:	f043 0301 	orr.w	r3, r3, #1
 80053a2:	e003      	b.n	80053ac <TIM_CCPreloadControl+0x14>
  }
  else
  {
    /* Reset the CCPC Bit */
    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
 80053a4:	f023 0301 	bic.w	r3, r3, #1
 80053a8:	041b      	lsls	r3, r3, #16
 80053aa:	0c1b      	lsrs	r3, r3, #16
 80053ac:	8083      	strh	r3, [r0, #4]
 80053ae:	4770      	bx	lr

080053b0 <TIM_OC1PreloadConfig>:
{
  uint16_t tmpccmr1 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  tmpccmr1 = TIMx->CCMR1;
 80053b0:	8b03      	ldrh	r3, [r0, #24]
  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
 80053b2:	f023 0308 	bic.w	r3, r3, #8
 80053b6:	041b      	lsls	r3, r3, #16
 80053b8:	0c1b      	lsrs	r3, r3, #16
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= TIM_OCPreload;
 80053ba:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 80053bc:	8301      	strh	r1, [r0, #24]
 80053be:	4770      	bx	lr

080053c0 <TIM_OC2PreloadConfig>:
{
  uint16_t tmpccmr1 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  tmpccmr1 = TIMx->CCMR1;
 80053c0:	8b03      	ldrh	r3, [r0, #24]
  /* Reset the OC2PE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
 80053c2:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80053c6:	041b      	lsls	r3, r3, #16
 80053c8:	0c1b      	lsrs	r3, r3, #16
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
 80053ca:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 80053ce:	b28b      	uxth	r3, r1
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 80053d0:	8303      	strh	r3, [r0, #24]
 80053d2:	4770      	bx	lr

080053d4 <TIM_OC3PreloadConfig>:
{
  uint16_t tmpccmr2 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  tmpccmr2 = TIMx->CCMR2;
 80053d4:	8b83      	ldrh	r3, [r0, #28]
  /* Reset the OC3PE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
 80053d6:	f023 0308 	bic.w	r3, r3, #8
 80053da:	041b      	lsls	r3, r3, #16
 80053dc:	0c1b      	lsrs	r3, r3, #16
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= TIM_OCPreload;
 80053de:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 80053e0:	8381      	strh	r1, [r0, #28]
 80053e2:	4770      	bx	lr

080053e4 <TIM_OC4PreloadConfig>:
{
  uint16_t tmpccmr2 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  tmpccmr2 = TIMx->CCMR2;
 80053e4:	8b83      	ldrh	r3, [r0, #28]
  /* Reset the OC4PE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
 80053e6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80053ea:	041b      	lsls	r3, r3, #16
 80053ec:	0c1b      	lsrs	r3, r3, #16
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
 80053ee:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 80053f2:	b28b      	uxth	r3, r1
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 80053f4:	8383      	strh	r3, [r0, #28]
 80053f6:	4770      	bx	lr

080053f8 <TIM_OC1FastConfig>:
  uint16_t tmpccmr1 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 80053f8:	8b03      	ldrh	r3, [r0, #24]
  /* Reset the OC1FE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
 80053fa:	f023 0304 	bic.w	r3, r3, #4
 80053fe:	041b      	lsls	r3, r3, #16
 8005400:	0c1b      	lsrs	r3, r3, #16
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= TIM_OCFast;
 8005402:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8005404:	8301      	strh	r1, [r0, #24]
 8005406:	4770      	bx	lr

08005408 <TIM_OC2FastConfig>:
  uint16_t tmpccmr1 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8005408:	8b03      	ldrh	r3, [r0, #24]
  /* Reset the OC2FE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
 800540a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800540e:	041b      	lsls	r3, r3, #16
 8005410:	0c1b      	lsrs	r3, r3, #16
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
 8005412:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8005416:	b28b      	uxth	r3, r1
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8005418:	8303      	strh	r3, [r0, #24]
 800541a:	4770      	bx	lr

0800541c <TIM_OC3FastConfig>:
  uint16_t tmpccmr2 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 800541c:	8b83      	ldrh	r3, [r0, #28]
  /* Reset the OC3FE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
 800541e:	f023 0304 	bic.w	r3, r3, #4
 8005422:	041b      	lsls	r3, r3, #16
 8005424:	0c1b      	lsrs	r3, r3, #16
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= TIM_OCFast;
 8005426:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 8005428:	8381      	strh	r1, [r0, #28]
 800542a:	4770      	bx	lr

0800542c <TIM_OC4FastConfig>:
  uint16_t tmpccmr2 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 800542c:	8b83      	ldrh	r3, [r0, #28]
  /* Reset the OC4FE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
 800542e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8005432:	041b      	lsls	r3, r3, #16
 8005434:	0c1b      	lsrs	r3, r3, #16
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
 8005436:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 800543a:	b28b      	uxth	r3, r1
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 800543c:	8383      	strh	r3, [r0, #28]
 800543e:	4770      	bx	lr

08005440 <TIM_ClearOC1Ref>:
  uint16_t tmpccmr1 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 8005440:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC1CE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
 8005442:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8005446:	041b      	lsls	r3, r3, #16
 8005448:	0c1b      	lsrs	r3, r3, #16
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= TIM_OCClear;
 800544a:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800544c:	8301      	strh	r1, [r0, #24]
 800544e:	4770      	bx	lr

08005450 <TIM_ClearOC2Ref>:
{
  uint16_t tmpccmr1 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  tmpccmr1 = TIMx->CCMR1;
 8005450:	8b03      	ldrh	r3, [r0, #24]
  /* Reset the OC2CE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
 8005452:	0209      	lsls	r1, r1, #8
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  tmpccmr1 = TIMx->CCMR1;
  /* Reset the OC2CE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
 8005454:	045b      	lsls	r3, r3, #17
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
 8005456:	ea41 4353 	orr.w	r3, r1, r3, lsr #17
 800545a:	b29b      	uxth	r3, r3
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800545c:	8303      	strh	r3, [r0, #24]
 800545e:	4770      	bx	lr

08005460 <TIM_ClearOC3Ref>:
{
  uint16_t tmpccmr2 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  tmpccmr2 = TIMx->CCMR2;
 8005460:	8b83      	ldrh	r3, [r0, #28]
  /* Reset the OC3CE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
 8005462:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8005466:	041b      	lsls	r3, r3, #16
 8005468:	0c1b      	lsrs	r3, r3, #16
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= TIM_OCClear;
 800546a:	4319      	orrs	r1, r3
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800546c:	8381      	strh	r1, [r0, #28]
 800546e:	4770      	bx	lr

08005470 <TIM_ClearOC4Ref>:
{
  uint16_t tmpccmr2 = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  tmpccmr2 = TIMx->CCMR2;
 8005470:	8b83      	ldrh	r3, [r0, #28]
  /* Reset the OC4CE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
 8005472:	0209      	lsls	r1, r1, #8
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  tmpccmr2 = TIMx->CCMR2;
  /* Reset the OC4CE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
 8005474:	045b      	lsls	r3, r3, #17
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
 8005476:	ea41 4353 	orr.w	r3, r1, r3, lsr #17
 800547a:	b29b      	uxth	r3, r3
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800547c:	8383      	strh	r3, [r0, #28]
 800547e:	4770      	bx	lr

08005480 <TIM_OC1PolarityConfig>:
{
  uint16_t tmpccer = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  tmpccer = TIMx->CCER;
 8005480:	8c03      	ldrh	r3, [r0, #32]
  /* Set or Reset the CC1P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
 8005482:	f023 0302 	bic.w	r3, r3, #2
 8005486:	041b      	lsls	r3, r3, #16
 8005488:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= TIM_OCPolarity;
 800548a:	4319      	orrs	r1, r3
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800548c:	8401      	strh	r1, [r0, #32]
 800548e:	4770      	bx	lr

08005490 <TIM_OC1NPolarityConfig>:
  uint16_t tmpccer = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   
  tmpccer = TIMx->CCER;
 8005490:	8c03      	ldrh	r3, [r0, #32]
  /* Set or Reset the CC1NP Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
 8005492:	f023 0308 	bic.w	r3, r3, #8
 8005496:	041b      	lsls	r3, r3, #16
 8005498:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= TIM_OCNPolarity;
 800549a:	4319      	orrs	r1, r3
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800549c:	8401      	strh	r1, [r0, #32]
 800549e:	4770      	bx	lr

080054a0 <TIM_OC2PolarityConfig>:
{
  uint16_t tmpccer = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  tmpccer = TIMx->CCER;
 80054a0:	8c03      	ldrh	r3, [r0, #32]
  /* Set or Reset the CC2P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
 80054a2:	f023 0320 	bic.w	r3, r3, #32
 80054a6:	041b      	lsls	r3, r3, #16
 80054a8:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
 80054aa:	ea43 1101 	orr.w	r1, r3, r1, lsl #4
 80054ae:	b28b      	uxth	r3, r1
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 80054b0:	8403      	strh	r3, [r0, #32]
 80054b2:	4770      	bx	lr

080054b4 <TIM_OC2NPolarityConfig>:
  uint16_t tmpccer = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
  
  tmpccer = TIMx->CCER;
 80054b4:	8c03      	ldrh	r3, [r0, #32]
  /* Set or Reset the CC2NP Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
 80054b6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80054ba:	041b      	lsls	r3, r3, #16
 80054bc:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
 80054be:	ea43 1101 	orr.w	r1, r3, r1, lsl #4
 80054c2:	b28b      	uxth	r3, r1
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 80054c4:	8403      	strh	r3, [r0, #32]
 80054c6:	4770      	bx	lr

080054c8 <TIM_OC3PolarityConfig>:
{
  uint16_t tmpccer = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  tmpccer = TIMx->CCER;
 80054c8:	8c03      	ldrh	r3, [r0, #32]
  /* Set or Reset the CC3P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
 80054ca:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80054ce:	041b      	lsls	r3, r3, #16
 80054d0:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
 80054d2:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 80054d6:	b28b      	uxth	r3, r1
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 80054d8:	8403      	strh	r3, [r0, #32]
 80054da:	4770      	bx	lr

080054dc <TIM_OC3NPolarityConfig>:
 
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
    
  tmpccer = TIMx->CCER;
 80054dc:	8c03      	ldrh	r3, [r0, #32]
  /* Set or Reset the CC3NP Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
 80054de:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80054e2:	041b      	lsls	r3, r3, #16
 80054e4:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
 80054e6:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 80054ea:	b28b      	uxth	r3, r1
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 80054ec:	8403      	strh	r3, [r0, #32]
 80054ee:	4770      	bx	lr

080054f0 <TIM_OC4PolarityConfig>:
{
  uint16_t tmpccer = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  tmpccer = TIMx->CCER;
 80054f0:	8c03      	ldrh	r3, [r0, #32]
  /* Set or Reset the CC4P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
 80054f2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80054f6:	041b      	lsls	r3, r3, #16
 80054f8:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
 80054fa:	ea43 3101 	orr.w	r1, r3, r1, lsl #12
 80054fe:	b28b      	uxth	r3, r1
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8005500:	8403      	strh	r3, [r0, #32]
 8005502:	4770      	bx	lr

08005504 <TIM_CCxCmd>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = CCER_CCE_Set << TIM_Channel;
 8005504:	2301      	movs	r3, #1
 8005506:	fa03 f301 	lsl.w	r3, r3, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t)~ tmp;

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
 800550a:	fa02 f201 	lsl.w	r2, r2, r1
  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
  *   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
  * @retval None
  */
void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
{
 800550e:	b510      	push	{r4, lr}
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = CCER_CCE_Set << TIM_Channel;

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t)~ tmp;
 8005510:	8c04      	ldrh	r4, [r0, #32]
 8005512:	b2a4      	uxth	r4, r4
 8005514:	ea24 0303 	bic.w	r3, r4, r3
 8005518:	8403      	strh	r3, [r0, #32]

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
 800551a:	8c03      	ldrh	r3, [r0, #32]
 800551c:	4313      	orrs	r3, r2
 800551e:	b29b      	uxth	r3, r3
 8005520:	8403      	strh	r3, [r0, #32]
 8005522:	bd10      	pop	{r4, pc}

08005524 <TIM_CCxNCmd>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = CCER_CCNE_Set << TIM_Channel;
 8005524:	2304      	movs	r3, #4
 8005526:	fa03 f301 	lsl.w	r3, r3, r1

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint16_t) ~tmp;

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
 800552a:	fa02 f201 	lsl.w	r2, r2, r1
  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
  *   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
  * @retval None
  */
void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
{
 800552e:	b510      	push	{r4, lr}
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = CCER_CCNE_Set << TIM_Channel;

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint16_t) ~tmp;
 8005530:	8c04      	ldrh	r4, [r0, #32]
 8005532:	b2a4      	uxth	r4, r4
 8005534:	ea24 0303 	bic.w	r3, r4, r3
 8005538:	8403      	strh	r3, [r0, #32]

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
 800553a:	8c03      	ldrh	r3, [r0, #32]
 800553c:	4313      	orrs	r3, r2
 800553e:	b29b      	uxth	r3, r3
 8005540:	8403      	strh	r3, [r0, #32]
 8005542:	bd10      	pop	{r4, pc}

08005544 <TIM_SelectOCxM>:
  *     @arg TIM_ForcedAction_Active
  *     @arg TIM_ForcedAction_InActive
  * @retval None
  */
void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
{
 8005544:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
  tmp += CCMR_Offset;

  tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;
 8005546:	2401      	movs	r4, #1
 8005548:	fa04 f401 	lsl.w	r4, r4, r1

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 800554c:	8c05      	ldrh	r5, [r0, #32]
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
  tmp += CCMR_Offset;
 800554e:	f100 0318 	add.w	r3, r0, #24

  tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 8005552:	b2ad      	uxth	r5, r5
 8005554:	ea25 0404 	bic.w	r4, r5, r4
 8005558:	8404      	strh	r4, [r0, #32]

  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
 800555a:	b109      	cbz	r1, 8005560 <TIM_SelectOCxM+0x1c>
 800555c:	2908      	cmp	r1, #8
 800555e:	d106      	bne.n	800556e <TIM_SelectOCxM+0x2a>
  {
    tmp += (TIM_Channel>>1);
 8005560:	0849      	lsrs	r1, r1, #1

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
 8005562:	58c8      	ldr	r0, [r1, r3]
 8005564:	f020 0070 	bic.w	r0, r0, #112	; 0x70
 8005568:	50c8      	str	r0, [r1, r3]
   
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= TIM_OCMode;
 800556a:	58c8      	ldr	r0, [r1, r3]
 800556c:	e009      	b.n	8005582 <TIM_SelectOCxM+0x3e>
  }
  else
  {
    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
 800556e:	3904      	subs	r1, #4
 8005570:	f3c1 014e 	ubfx	r1, r1, #1, #15

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
 8005574:	58c8      	ldr	r0, [r1, r3]
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 8005576:	0212      	lsls	r2, r2, #8
  else
  {
    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
 8005578:	f420 40e0 	bic.w	r0, r0, #28672	; 0x7000
 800557c:	50c8      	str	r0, [r1, r3]
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 800557e:	58c8      	ldr	r0, [r1, r3]
 8005580:	b292      	uxth	r2, r2
 8005582:	4302      	orrs	r2, r0
 8005584:	50ca      	str	r2, [r1, r3]
 8005586:	bd30      	pop	{r4, r5, pc}

08005588 <TIM_UpdateDisableConfig>:
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 8005588:	8803      	ldrh	r3, [r0, #0]
void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800558a:	b119      	cbz	r1, 8005594 <TIM_UpdateDisableConfig+0xc>
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 800558c:	b29b      	uxth	r3, r3
 800558e:	f043 0302 	orr.w	r3, r3, #2
 8005592:	e003      	b.n	800559c <TIM_UpdateDisableConfig+0x14>
  }
  else
  {
    /* Reset the Update Disable Bit */
    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
 8005594:	f023 0302 	bic.w	r3, r3, #2
 8005598:	041b      	lsls	r3, r3, #16
 800559a:	0c1b      	lsrs	r3, r3, #16
 800559c:	8003      	strh	r3, [r0, #0]
 800559e:	4770      	bx	lr

080055a0 <TIM_UpdateRequestConfig>:
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
  if (TIM_UpdateSource != TIM_UpdateSource_Global)
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 80055a0:	8803      	ldrh	r3, [r0, #0]
void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
  if (TIM_UpdateSource != TIM_UpdateSource_Global)
 80055a2:	b119      	cbz	r1, 80055ac <TIM_UpdateRequestConfig+0xc>
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 80055a4:	b29b      	uxth	r3, r3
 80055a6:	f043 0304 	orr.w	r3, r3, #4
 80055aa:	e003      	b.n	80055b4 <TIM_UpdateRequestConfig+0x14>
  }
  else
  {
    /* Reset the URS Bit */
    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
 80055ac:	f023 0304 	bic.w	r3, r3, #4
 80055b0:	041b      	lsls	r3, r3, #16
 80055b2:	0c1b      	lsrs	r3, r3, #16
 80055b4:	8003      	strh	r3, [r0, #0]
 80055b6:	4770      	bx	lr

080055b8 <TIM_SelectHallSensor>:
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the TI1S Bit */
    TIMx->CR2 |= TIM_CR2_TI1S;
 80055b8:	8883      	ldrh	r3, [r0, #4]
void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80055ba:	b119      	cbz	r1, 80055c4 <TIM_SelectHallSensor+0xc>
  {
    /* Set the TI1S Bit */
    TIMx->CR2 |= TIM_CR2_TI1S;
 80055bc:	b29b      	uxth	r3, r3
 80055be:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80055c2:	e003      	b.n	80055cc <TIM_SelectHallSensor+0x14>
  }
  else
  {
    /* Reset the TI1S Bit */
    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
 80055c4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80055c8:	041b      	lsls	r3, r3, #16
 80055ca:	0c1b      	lsrs	r3, r3, #16
 80055cc:	8083      	strh	r3, [r0, #4]
 80055ce:	4770      	bx	lr

080055d0 <TIM_SelectOnePulseMode>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
  /* Reset the OPM Bit */
  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
 80055d0:	8803      	ldrh	r3, [r0, #0]
 80055d2:	f023 0308 	bic.w	r3, r3, #8
 80055d6:	041b      	lsls	r3, r3, #16
 80055d8:	0c1b      	lsrs	r3, r3, #16
 80055da:	8003      	strh	r3, [r0, #0]
  /* Configure the OPM Mode */
  TIMx->CR1 |= TIM_OPMode;
 80055dc:	8803      	ldrh	r3, [r0, #0]
 80055de:	b29b      	uxth	r3, r3
 80055e0:	4319      	orrs	r1, r3
 80055e2:	8001      	strh	r1, [r0, #0]
 80055e4:	4770      	bx	lr

080055e6 <TIM_SelectOutputTrigger>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST7_PERIPH(TIMx));
  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
  /* Reset the MMS Bits */
  TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
 80055e6:	8883      	ldrh	r3, [r0, #4]
 80055e8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80055ec:	041b      	lsls	r3, r3, #16
 80055ee:	0c1b      	lsrs	r3, r3, #16
 80055f0:	8083      	strh	r3, [r0, #4]
  /* Select the TRGO source */
  TIMx->CR2 |=  TIM_TRGOSource;
 80055f2:	8883      	ldrh	r3, [r0, #4]
 80055f4:	b29b      	uxth	r3, r3
 80055f6:	4319      	orrs	r1, r3
 80055f8:	8081      	strh	r1, [r0, #4]
 80055fa:	4770      	bx	lr

080055fc <TIM_SelectSlaveMode>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
 /* Reset the SMS Bits */
  TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
 80055fc:	8903      	ldrh	r3, [r0, #8]
 80055fe:	f023 0307 	bic.w	r3, r3, #7
 8005602:	041b      	lsls	r3, r3, #16
 8005604:	0c1b      	lsrs	r3, r3, #16
 8005606:	8103      	strh	r3, [r0, #8]
  /* Select the Slave Mode */
  TIMx->SMCR |= TIM_SlaveMode;
 8005608:	8903      	ldrh	r3, [r0, #8]
 800560a:	b29b      	uxth	r3, r3
 800560c:	4319      	orrs	r1, r3
 800560e:	8101      	strh	r1, [r0, #8]
 8005610:	4770      	bx	lr

08005612 <TIM_SelectMasterSlaveMode>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
  /* Reset the MSM Bit */
  TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
 8005612:	8903      	ldrh	r3, [r0, #8]
 8005614:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8005618:	041b      	lsls	r3, r3, #16
 800561a:	0c1b      	lsrs	r3, r3, #16
 800561c:	8103      	strh	r3, [r0, #8]
  
  /* Set or Reset the MSM Bit */
  TIMx->SMCR |= TIM_MasterSlaveMode;
 800561e:	8903      	ldrh	r3, [r0, #8]
 8005620:	b29b      	uxth	r3, r3
 8005622:	4319      	orrs	r1, r3
 8005624:	8101      	strh	r1, [r0, #8]
 8005626:	4770      	bx	lr

08005628 <TIM_SetCounter>:
void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  /* Set the Counter Register value */
  TIMx->CNT = Counter;
 8005628:	8481      	strh	r1, [r0, #36]	; 0x24
 800562a:	4770      	bx	lr

0800562c <TIM_SetAutoreload>:
void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  /* Set the Autoreload Register value */
  TIMx->ARR = Autoreload;
 800562c:	8581      	strh	r1, [r0, #44]	; 0x2c
 800562e:	4770      	bx	lr

08005630 <TIM_SetCompare1>:
void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  /* Set the Capture Compare1 Register value */
  TIMx->CCR1 = Compare1;
 8005630:	8681      	strh	r1, [r0, #52]	; 0x34
 8005632:	4770      	bx	lr

08005634 <TIM_SetCompare2>:
void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  /* Set the Capture Compare2 Register value */
  TIMx->CCR2 = Compare2;
 8005634:	8701      	strh	r1, [r0, #56]	; 0x38
 8005636:	4770      	bx	lr

08005638 <TIM_SetCompare3>:
void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  /* Set the Capture Compare3 Register value */
  TIMx->CCR3 = Compare3;
 8005638:	8781      	strh	r1, [r0, #60]	; 0x3c
 800563a:	4770      	bx	lr

0800563c <TIM_SetCompare4>:
void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  /* Set the Capture Compare4 Register value */
  TIMx->CCR4 = Compare4;
 800563c:	f8a0 1040 	strh.w	r1, [r0, #64]	; 0x40
 8005640:	4770      	bx	lr

08005642 <TIM_SetIC1Prescaler>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
 8005642:	8b03      	ldrh	r3, [r0, #24]
 8005644:	f023 030c 	bic.w	r3, r3, #12
 8005648:	041b      	lsls	r3, r3, #16
 800564a:	0c1b      	lsrs	r3, r3, #16
 800564c:	8303      	strh	r3, [r0, #24]
  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 800564e:	8b03      	ldrh	r3, [r0, #24]
 8005650:	b29b      	uxth	r3, r3
 8005652:	4319      	orrs	r1, r3
 8005654:	8301      	strh	r1, [r0, #24]
 8005656:	4770      	bx	lr

08005658 <TIM_SetIC2Prescaler>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
 8005658:	8b03      	ldrh	r3, [r0, #24]
 800565a:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 800565e:	041b      	lsls	r3, r3, #16
 8005660:	0c1b      	lsrs	r3, r3, #16
 8005662:	8303      	strh	r3, [r0, #24]
  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8005664:	8b03      	ldrh	r3, [r0, #24]
 8005666:	b29b      	uxth	r3, r3
 8005668:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 800566c:	b28b      	uxth	r3, r1
 800566e:	8303      	strh	r3, [r0, #24]
 8005670:	4770      	bx	lr

08005672 <TIM_PWMIConfig>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8005672:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005674:	460c      	mov	r4, r1
  else
  {
    icoppositepolarity = TIM_ICPolarity_Rising;
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
 8005676:	88a2      	ldrh	r2, [r4, #4]
  uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
  uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
 8005678:	8849      	ldrh	r1, [r1, #2]
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 800567a:	f8b4 e000 	ldrh.w	lr, [r4]
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 800567e:	4605      	mov	r5, r0
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
  {
    icoppositepolarity = TIM_ICPolarity_Falling;
 8005680:	2900      	cmp	r1, #0
 8005682:	bf0c      	ite	eq
 8005684:	2702      	moveq	r7, #2
 8005686:	2700      	movne	r7, #0
    icoppositepolarity = TIM_ICPolarity_Rising;
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
  {
    icoppositeselection = TIM_ICSelection_IndirectTI;
 8005688:	2a01      	cmp	r2, #1
 800568a:	bf14      	ite	ne
 800568c:	2601      	movne	r6, #1
 800568e:	2602      	moveq	r6, #2
 8005690:	8923      	ldrh	r3, [r4, #8]
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8005692:	f1be 0f00 	cmp.w	lr, #0
 8005696:	d111      	bne.n	80056bc <TIM_PWMIConfig+0x4a>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 8005698:	f7ff fac0 	bl	8004c1c <TI1_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800569c:	4628      	mov	r0, r5
 800569e:	88e1      	ldrh	r1, [r4, #6]
 80056a0:	f7ff ffcf 	bl	8005642 <TIM_SetIC1Prescaler>
    /* TI2 Configuration */
    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 80056a4:	4628      	mov	r0, r5
 80056a6:	4639      	mov	r1, r7
 80056a8:	4632      	mov	r2, r6
 80056aa:	8923      	ldrh	r3, [r4, #8]
 80056ac:	f7ff faec 	bl	8004c88 <TI2_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80056b0:	88e1      	ldrh	r1, [r4, #6]
 80056b2:	4628      	mov	r0, r5
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 80056b4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    /* TI2 Configuration */
    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80056b8:	f7ff bfce 	b.w	8005658 <TIM_SetIC2Prescaler>
  }
  else
  { 
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 80056bc:	f7ff fae4 	bl	8004c88 <TI2_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80056c0:	4628      	mov	r0, r5
 80056c2:	88e1      	ldrh	r1, [r4, #6]
 80056c4:	f7ff ffc8 	bl	8005658 <TIM_SetIC2Prescaler>
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 80056c8:	4628      	mov	r0, r5
 80056ca:	4639      	mov	r1, r7
 80056cc:	4632      	mov	r2, r6
 80056ce:	8923      	ldrh	r3, [r4, #8]
 80056d0:	f7ff faa4 	bl	8004c1c <TI1_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80056d4:	88e1      	ldrh	r1, [r4, #6]
 80056d6:	4628      	mov	r0, r5
  }
}
 80056d8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80056dc:	f7ff bfb1 	b.w	8005642 <TIM_SetIC1Prescaler>

080056e0 <TIM_SetIC3Prescaler>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  /* Reset the IC3PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
 80056e0:	8b83      	ldrh	r3, [r0, #28]
 80056e2:	f023 030c 	bic.w	r3, r3, #12
 80056e6:	041b      	lsls	r3, r3, #16
 80056e8:	0c1b      	lsrs	r3, r3, #16
 80056ea:	8383      	strh	r3, [r0, #28]
  /* Set the IC3PSC value */
  TIMx->CCMR2 |= TIM_ICPSC;
 80056ec:	8b83      	ldrh	r3, [r0, #28]
 80056ee:	b29b      	uxth	r3, r3
 80056f0:	4319      	orrs	r1, r3
 80056f2:	8381      	strh	r1, [r0, #28]
 80056f4:	4770      	bx	lr

080056f6 <TIM_SetIC4Prescaler>:
{  
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
 80056f6:	8b83      	ldrh	r3, [r0, #28]
 80056f8:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 80056fc:	041b      	lsls	r3, r3, #16
 80056fe:	0c1b      	lsrs	r3, r3, #16
 8005700:	8383      	strh	r3, [r0, #28]
  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 8005702:	8b83      	ldrh	r3, [r0, #28]
 8005704:	b29b      	uxth	r3, r3
 8005706:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 800570a:	b28b      	uxth	r3, r1
 800570c:	8383      	strh	r3, [r0, #28]
 800570e:	4770      	bx	lr

08005710 <TIM_ICInit>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8005710:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  }
  else
  {
    assert_param(IS_TIM_IC_POLARITY_LITE(TIM_ICInitStruct->TIM_ICPolarity));
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8005712:	880b      	ldrh	r3, [r1, #0]
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8005714:	460d      	mov	r5, r1
 8005716:	4604      	mov	r4, r0
 8005718:	8849      	ldrh	r1, [r1, #2]
 800571a:	88aa      	ldrh	r2, [r5, #4]
  }
  else
  {
    assert_param(IS_TIM_IC_POLARITY_LITE(TIM_ICInitStruct->TIM_ICPolarity));
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 800571c:	b943      	cbnz	r3, 8005730 <TIM_ICInit+0x20>
  {
    assert_param(IS_TIM_LIST8_PERIPH(TIMx));
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800571e:	892b      	ldrh	r3, [r5, #8]
 8005720:	f7ff fa7c 	bl	8004c1c <TI1_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005724:	88e9      	ldrh	r1, [r5, #6]
 8005726:	4620      	mov	r0, r4
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8005728:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800572c:	f7ff bf89 	b.w	8005642 <TIM_SetIC1Prescaler>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
 8005730:	2b04      	cmp	r3, #4
 8005732:	d108      	bne.n	8005746 <TIM_ICInit+0x36>
  {
    assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8005734:	892b      	ldrh	r3, [r5, #8]
 8005736:	f7ff faa7 	bl	8004c88 <TI2_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800573a:	88e9      	ldrh	r1, [r5, #6]
 800573c:	4620      	mov	r0, r4
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 800573e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005742:	f7ff bf89 	b.w	8005658 <TIM_SetIC2Prescaler>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 8005746:	2b08      	cmp	r3, #8
 8005748:	460e      	mov	r6, r1
 800574a:	892f      	ldrh	r7, [r5, #8]
static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
 800574c:	8c00      	ldrh	r0, [r0, #32]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 800574e:	d13a      	bne.n	80057c6 <TIM_ICInit+0xb6>
static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
 8005750:	f420 7080 	bic.w	r0, r0, #256	; 0x100
 8005754:	0400      	lsls	r0, r0, #16
 8005756:	0c00      	lsrs	r0, r0, #16
 8005758:	8420      	strh	r0, [r4, #32]
  tmpccmr2 = TIMx->CCMR2;
 800575a:	8ba3      	ldrh	r3, [r4, #28]
  tmpccer = TIMx->CCER;
 800575c:	8c20      	ldrh	r0, [r4, #32]
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
  tmpccmr2 = TIMx->CCMR2;
 800575e:	b29b      	uxth	r3, r3
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
 8005760:	f023 03f3 	bic.w	r3, r3, #243	; 0xf3
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8005764:	ea43 1707 	orr.w	r7, r3, r7, lsl #4
    
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
 8005768:	4b35      	ldr	r3, [pc, #212]	; (8005840 <TIM_ICInit+0x130>)
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 800576a:	b2bf      	uxth	r7, r7
    
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
 800576c:	429c      	cmp	r4, r3
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
 800576e:	b280      	uxth	r0, r0
  tmp = (uint16_t)(TIM_ICPolarity << 8);
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8005770:	ea47 0202 	orr.w	r2, r7, r2
    
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
 8005774:	d012      	beq.n	800579c <TIM_ICInit+0x8c>
 8005776:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 800577a:	429c      	cmp	r4, r3
 800577c:	d00e      	beq.n	800579c <TIM_ICInit+0x8c>
 800577e:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 8005782:	d00b      	beq.n	800579c <TIM_ICInit+0x8c>
 8005784:	f5a3 3398 	sub.w	r3, r3, #77824	; 0x13000
 8005788:	429c      	cmp	r4, r3
 800578a:	d007      	beq.n	800579c <TIM_ICInit+0x8c>
 800578c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005790:	429c      	cmp	r4, r3
 8005792:	d003      	beq.n	800579c <TIM_ICInit+0x8c>
     (TIMx == TIM4) ||(TIMx == TIM5))
 8005794:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005798:	429c      	cmp	r4, r3
 800579a:	d107      	bne.n	80057ac <TIM_ICInit+0x9c>
  {
    /* Select the Polarity and set the CC3E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P));
 800579c:	f420 7100 	bic.w	r1, r0, #512	; 0x200
    tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 80057a0:	ea41 2106 	orr.w	r1, r1, r6, lsl #8
 80057a4:	b289      	uxth	r1, r1
 80057a6:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 80057aa:	e004      	b.n	80057b6 <TIM_ICInit+0xa6>
  }
  else
  {
    /* Select the Polarity and set the CC3E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
 80057ac:	f420 6020 	bic.w	r0, r0, #2560	; 0xa00
    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC3E);
 80057b0:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 80057b4:	4301      	orrs	r1, r0
  }
  
  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 80057b6:	83a2      	strh	r2, [r4, #28]
  TIMx->CCER = tmpccer;
 80057b8:	8421      	strh	r1, [r4, #32]
    /* TI3 Configuration */
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80057ba:	88e9      	ldrh	r1, [r5, #6]
 80057bc:	4620      	mov	r0, r4
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 80057be:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI3 Configuration */
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80057c2:	f7ff bf8d 	b.w	80056e0 <TIM_SetIC3Prescaler>
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

   /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
 80057c6:	f420 5080 	bic.w	r0, r0, #4096	; 0x1000
 80057ca:	0400      	lsls	r0, r0, #16
 80057cc:	0c00      	lsrs	r0, r0, #16
 80057ce:	8420      	strh	r0, [r4, #32]
  tmpccmr2 = TIMx->CCMR2;
 80057d0:	8ba3      	ldrh	r3, [r4, #28]
  tmpccer = TIMx->CCER;
 80057d2:	8c20      	ldrh	r0, [r4, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 12);
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
 80057d4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80057d8:	051b      	lsls	r3, r3, #20
 80057da:	0d1b      	lsrs	r3, r3, #20
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 80057dc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
  
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
 80057e0:	4a17      	ldr	r2, [pc, #92]	; (8005840 <TIM_ICInit+0x130>)
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
 80057e2:	ea43 3307 	orr.w	r3, r3, r7, lsl #12
  
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
 80057e6:	4294      	cmp	r4, r2
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

   /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
 80057e8:	b280      	uxth	r0, r0
  tmp = (uint16_t)(TIM_ICPolarity << 12);
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
 80057ea:	b29b      	uxth	r3, r3
  
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
 80057ec:	d012      	beq.n	8005814 <TIM_ICInit+0x104>
 80057ee:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 80057f2:	4294      	cmp	r4, r2
 80057f4:	d00e      	beq.n	8005814 <TIM_ICInit+0x104>
 80057f6:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 80057fa:	d00b      	beq.n	8005814 <TIM_ICInit+0x104>
 80057fc:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8005800:	4294      	cmp	r4, r2
 8005802:	d007      	beq.n	8005814 <TIM_ICInit+0x104>
 8005804:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8005808:	4294      	cmp	r4, r2
 800580a:	d003      	beq.n	8005814 <TIM_ICInit+0x104>
     (TIMx == TIM4) ||(TIMx == TIM5))
 800580c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8005810:	4294      	cmp	r4, r2
 8005812:	d107      	bne.n	8005824 <TIM_ICInit+0x114>
  {
    /* Select the Polarity and set the CC4E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P));
 8005814:	f420 5200 	bic.w	r2, r0, #8192	; 0x2000
    tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 8005818:	ea42 3206 	orr.w	r2, r2, r6, lsl #12
 800581c:	b292      	uxth	r2, r2
 800581e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8005822:	e005      	b.n	8005830 <TIM_ICInit+0x120>
  }
  else
  {
    /* Select the Polarity and set the CC4E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC4NP));
 8005824:	f647 52ff 	movw	r2, #32255	; 0x7dff
 8005828:	4002      	ands	r2, r0
    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC4E);
 800582a:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 800582e:	430a      	orrs	r2, r1
    /* TI4 Configuration */
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005830:	88e9      	ldrh	r1, [r5, #6]
 8005832:	4620      	mov	r0, r4
    /* Select the Polarity and set the CC4E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC4NP));
    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC4E);
  }
  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8005834:	83a3      	strh	r3, [r4, #28]
  TIMx->CCER = tmpccer;
 8005836:	8422      	strh	r2, [r4, #32]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8005838:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI4 Configuration */
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800583c:	f7ff bf5b 	b.w	80056f6 <TIM_SetIC4Prescaler>
 8005840:	40012c00 	.word	0x40012c00

08005844 <TIM_SetClockDivision>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_CKD_DIV(TIM_CKD));
  /* Reset the CKD Bits */
  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
 8005844:	8803      	ldrh	r3, [r0, #0]
 8005846:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800584a:	041b      	lsls	r3, r3, #16
 800584c:	0c1b      	lsrs	r3, r3, #16
 800584e:	8003      	strh	r3, [r0, #0]
  /* Set the CKD value */
  TIMx->CR1 |= TIM_CKD;
 8005850:	8803      	ldrh	r3, [r0, #0]
 8005852:	b29b      	uxth	r3, r3
 8005854:	4319      	orrs	r1, r3
 8005856:	8001      	strh	r1, [r0, #0]
 8005858:	4770      	bx	lr

0800585a <TIM_GetCapture1>:
uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  /* Get the Capture 1 Register value */
  return TIMx->CCR1;
 800585a:	8e80      	ldrh	r0, [r0, #52]	; 0x34
}
 800585c:	b280      	uxth	r0, r0
 800585e:	4770      	bx	lr

08005860 <TIM_GetCapture2>:
uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  /* Get the Capture 2 Register value */
  return TIMx->CCR2;
 8005860:	8f00      	ldrh	r0, [r0, #56]	; 0x38
}
 8005862:	b280      	uxth	r0, r0
 8005864:	4770      	bx	lr

08005866 <TIM_GetCapture3>:
uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
  /* Get the Capture 3 Register value */
  return TIMx->CCR3;
 8005866:	8f80      	ldrh	r0, [r0, #60]	; 0x3c
}
 8005868:	b280      	uxth	r0, r0
 800586a:	4770      	bx	lr

0800586c <TIM_GetCapture4>:
uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  /* Get the Capture 4 Register value */
  return TIMx->CCR4;
 800586c:	f8b0 0040 	ldrh.w	r0, [r0, #64]	; 0x40
}
 8005870:	b280      	uxth	r0, r0
 8005872:	4770      	bx	lr

08005874 <TIM_GetCounter>:
uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  /* Get the Counter Register value */
  return TIMx->CNT;
 8005874:	8c80      	ldrh	r0, [r0, #36]	; 0x24
}
 8005876:	b280      	uxth	r0, r0
 8005878:	4770      	bx	lr

0800587a <TIM_GetPrescaler>:
uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  /* Get the Prescaler Register value */
  return TIMx->PSC;
 800587a:	8d00      	ldrh	r0, [r0, #40]	; 0x28
}
 800587c:	b280      	uxth	r0, r0
 800587e:	4770      	bx	lr

08005880 <TIM_GetFlagStatus>:
  ITStatus bitstatus = RESET;  
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
  
  if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
 8005880:	8a03      	ldrh	r3, [r0, #16]
 8005882:	4219      	tst	r1, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8005884:	bf0c      	ite	eq
 8005886:	2000      	moveq	r0, #0
 8005888:	2001      	movne	r0, #1
 800588a:	4770      	bx	lr

0800588c <TIM_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
   
  /* Clear the flags */
  TIMx->SR = (uint16_t)~TIM_FLAG;
 800588c:	43c9      	mvns	r1, r1
 800588e:	b289      	uxth	r1, r1
 8005890:	8201      	strh	r1, [r0, #16]
 8005892:	4770      	bx	lr

08005894 <TIM_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 8005894:	8a03      	ldrh	r3, [r0, #16]
  
  itenable = TIMx->DIER & TIM_IT;
 8005896:	8982      	ldrh	r2, [r0, #12]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 8005898:	ea11 0003 	ands.w	r0, r1, r3
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
  
  itenable = TIMx->DIER & TIM_IT;
 800589c:	b292      	uxth	r2, r2
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 800589e:	d003      	beq.n	80058a8 <TIM_GetITStatus+0x14>
 80058a0:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 80058a2:	bf0c      	ite	eq
 80058a4:	2000      	moveq	r0, #0
 80058a6:	2001      	movne	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80058a8:	4770      	bx	lr

080058aa <TIM_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 80058aa:	43c9      	mvns	r1, r1
 80058ac:	b289      	uxth	r1, r1
 80058ae:	8201      	strh	r1, [r0, #16]
 80058b0:	4770      	bx	lr
 80058b2:	bf00      	nop

080058b4 <USART_DeInit>:
  *   This parameter can be one of the following values: 
  *      USART1, USART2, USART3, UART4 or UART5.
  * @retval None
  */
void USART_DeInit(USART_TypeDef* USARTx)
{
 80058b4:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
 80058b6:	4b20      	ldr	r3, [pc, #128]	; (8005938 <USART_DeInit+0x84>)
 80058b8:	4298      	cmp	r0, r3
 80058ba:	d10b      	bne.n	80058d4 <USART_DeInit+0x20>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
 80058bc:	2101      	movs	r1, #1
 80058be:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80058c2:	f7fe fef9 	bl	80046b8 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 80058c6:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80058ca:	2100      	movs	r1, #0
    { 
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
    }
  }
}
 80058cc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 80058d0:	f7fe bef2 	b.w	80046b8 <RCC_APB2PeriphResetCmd>
  }
  else if (USARTx == USART2)
 80058d4:	4b19      	ldr	r3, [pc, #100]	; (800593c <USART_DeInit+0x88>)
 80058d6:	4298      	cmp	r0, r3
 80058d8:	d107      	bne.n	80058ea <USART_DeInit+0x36>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
 80058da:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80058de:	2101      	movs	r1, #1
 80058e0:	f7fe fef6 	bl	80046d0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 80058e4:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80058e8:	e01f      	b.n	800592a <USART_DeInit+0x76>
  }
  else if (USARTx == USART3)
 80058ea:	4b15      	ldr	r3, [pc, #84]	; (8005940 <USART_DeInit+0x8c>)
 80058ec:	4298      	cmp	r0, r3
 80058ee:	d107      	bne.n	8005900 <USART_DeInit+0x4c>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 80058f0:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80058f4:	2101      	movs	r1, #1
 80058f6:	f7fe feeb 	bl	80046d0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 80058fa:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80058fe:	e014      	b.n	800592a <USART_DeInit+0x76>
  }    
  else if (USARTx == UART4)
 8005900:	4b10      	ldr	r3, [pc, #64]	; (8005944 <USART_DeInit+0x90>)
 8005902:	4298      	cmp	r0, r3
 8005904:	d107      	bne.n	8005916 <USART_DeInit+0x62>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 8005906:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800590a:	2101      	movs	r1, #1
 800590c:	f7fe fee0 	bl	80046d0 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 8005910:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8005914:	e009      	b.n	800592a <USART_DeInit+0x76>
  }    
  else
  {
    if (USARTx == UART5)
 8005916:	4b0c      	ldr	r3, [pc, #48]	; (8005948 <USART_DeInit+0x94>)
 8005918:	4298      	cmp	r0, r3
 800591a:	d10b      	bne.n	8005934 <USART_DeInit+0x80>
    { 
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 800591c:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8005920:	2101      	movs	r1, #1
 8005922:	f7fe fed5 	bl	80046d0 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 8005926:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800592a:	2100      	movs	r1, #0
    }
  }
}
 800592c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if (USARTx == UART5)
    { 
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 8005930:	f7fe bece 	b.w	80046d0 <RCC_APB1PeriphResetCmd>
 8005934:	bd08      	pop	{r3, pc}
 8005936:	bf00      	nop
 8005938:	40013800 	.word	0x40013800
 800593c:	40004400 	.word	0x40004400
 8005940:	40004800 	.word	0x40004800
 8005944:	40004c00 	.word	0x40004c00
 8005948:	40005000 	.word	0x40005000

0800594c <USART_Init>:
  }

  usartxbase = (uint32_t)USARTx;

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 800594c:	8a03      	ldrh	r3, [r0, #16]
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 800594e:	88ca      	ldrh	r2, [r1, #6]
  }

  usartxbase = (uint32_t)USARTx;

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8005950:	b29b      	uxth	r3, r3
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
 8005952:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8005956:	4313      	orrs	r3, r2
  *         that contains the configuration information for the specified USART 
  *         peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8005958:	b530      	push	{r4, r5, lr}
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 800595a:	8203      	strh	r3, [r0, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 800595c:	8983      	ldrh	r3, [r0, #12]
  *         that contains the configuration information for the specified USART 
  *         peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 800595e:	460d      	mov	r5, r1
  tmpreg &= CR1_CLEAR_Mask;
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8005960:	88aa      	ldrh	r2, [r5, #4]
 8005962:	8909      	ldrh	r1, [r1, #8]
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 8005964:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8005968:	430a      	orrs	r2, r1
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 800596a:	f023 030c 	bic.w	r3, r3, #12
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 800596e:	8969      	ldrh	r1, [r5, #10]
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 8005970:	041b      	lsls	r3, r3, #16
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8005972:	430a      	orrs	r2, r1
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 8005974:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8005976:	4313      	orrs	r3, r2
 8005978:	b29b      	uxth	r3, r3
            USART_InitStruct->USART_Mode;
  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 800597a:	8183      	strh	r3, [r0, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 800597c:	8a83      	ldrh	r3, [r0, #20]
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 800597e:	89aa      	ldrh	r2, [r5, #12]
            USART_InitStruct->USART_Mode;
  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8005980:	b29b      	uxth	r3, r3
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
 8005982:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  *         that contains the configuration information for the specified USART 
  *         peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8005986:	b087      	sub	sp, #28
  tmpreg = USARTx->CR3;
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 8005988:	4313      	orrs	r3, r2
  *         that contains the configuration information for the specified USART 
  *         peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 800598a:	4604      	mov	r4, r0
  tmpreg &= CR3_CLEAR_Mask;
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 800598c:	8283      	strh	r3, [r0, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 800598e:	a801      	add	r0, sp, #4
 8005990:	f7fe fe00 	bl	8004594 <RCC_GetClocksFreq>
  if (usartxbase == USART1_BASE)
 8005994:	4b17      	ldr	r3, [pc, #92]	; (80059f4 <USART_Init+0xa8>)
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 8005996:	89a2      	ldrh	r2, [r4, #12]
  USARTx->CR3 = (uint16_t)tmpreg;

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
  if (usartxbase == USART1_BASE)
 8005998:	429c      	cmp	r4, r3
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 800599a:	bf0c      	ite	eq
 800599c:	9b04      	ldreq	r3, [sp, #16]
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 800599e:	9b03      	ldrne	r3, [sp, #12]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 80059a0:	b212      	sxth	r2, r2
 80059a2:	2a00      	cmp	r2, #0
 80059a4:	f04f 0119 	mov.w	r1, #25
 80059a8:	682a      	ldr	r2, [r5, #0]
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 80059aa:	fb01 f103 	mul.w	r1, r1, r3
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 80059ae:	da01      	bge.n	80059b4 <USART_Init+0x68>
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 80059b0:	0052      	lsls	r2, r2, #1
 80059b2:	e000      	b.n	80059b6 <USART_Init+0x6a>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 80059b4:	0092      	lsls	r2, r2, #2
  }
  tmpreg = (integerdivider / 100) << 4;
 80059b6:	2364      	movs	r3, #100	; 0x64
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 80059b8:	fbb1 f1f2 	udiv	r1, r1, r2
  }
  tmpreg = (integerdivider / 100) << 4;
 80059bc:	fbb1 f2f3 	udiv	r2, r1, r3
 80059c0:	0112      	lsls	r2, r2, #4

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 80059c2:	0910      	lsrs	r0, r2, #4
 80059c4:	fb03 1110 	mls	r1, r3, r0, r1

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 80059c8:	89a0      	ldrh	r0, [r4, #12]
 80059ca:	b200      	sxth	r0, r0
 80059cc:	2800      	cmp	r0, #0
 80059ce:	da06      	bge.n	80059de <USART_Init+0x92>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 80059d0:	00c9      	lsls	r1, r1, #3
 80059d2:	3132      	adds	r1, #50	; 0x32
 80059d4:	fbb1 f3f3 	udiv	r3, r1, r3
 80059d8:	f003 0307 	and.w	r3, r3, #7
 80059dc:	e005      	b.n	80059ea <USART_Init+0x9e>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 80059de:	0109      	lsls	r1, r1, #4
 80059e0:	3132      	adds	r1, #50	; 0x32
 80059e2:	fbb1 f3f3 	udiv	r3, r1, r3
 80059e6:	f003 030f 	and.w	r3, r3, #15
 80059ea:	431a      	orrs	r2, r3
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)tmpreg;
 80059ec:	b292      	uxth	r2, r2
 80059ee:	8122      	strh	r2, [r4, #8]
}
 80059f0:	b007      	add	sp, #28
 80059f2:	bd30      	pop	{r4, r5, pc}
 80059f4:	40013800 	.word	0x40013800

080059f8 <USART_StructInit>:
  * @retval None
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
 80059f8:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 80059fc:	6003      	str	r3, [r0, #0]
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
  USART_InitStruct->USART_Parity = USART_Parity_No ;
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 80059fe:	220c      	movs	r2, #12
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 8005a00:	2300      	movs	r3, #0
 8005a02:	8083      	strh	r3, [r0, #4]
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
 8005a04:	80c3      	strh	r3, [r0, #6]
  USART_InitStruct->USART_Parity = USART_Parity_No ;
 8005a06:	8103      	strh	r3, [r0, #8]
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8005a08:	8142      	strh	r2, [r0, #10]
  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 8005a0a:	8183      	strh	r3, [r0, #12]
 8005a0c:	4770      	bx	lr

08005a0e <USART_ClockInit>:
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 8005a0e:	880b      	ldrh	r3, [r1, #0]
  *         USART peripheral.  
  * @note The Smart Card and Synchronous modes are not available for UART4 and UART5.
  * @retval None
  */
void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
{
 8005a10:	b510      	push	{r4, lr}
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 8005a12:	884c      	ldrh	r4, [r1, #2]
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8005a14:	8a02      	ldrh	r2, [r0, #16]
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 8005a16:	4323      	orrs	r3, r4
 8005a18:	888c      	ldrh	r4, [r1, #4]
 8005a1a:	88c9      	ldrh	r1, [r1, #6]
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8005a1c:	b292      	uxth	r2, r2
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 8005a1e:	4323      	orrs	r3, r4
 8005a20:	430b      	orrs	r3, r1
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
  tmpreg &= CR2_CLOCK_CLEAR_Mask;
 8005a22:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
  /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 8005a26:	4313      	orrs	r3, r2
 8005a28:	b29b      	uxth	r3, r3
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8005a2a:	8203      	strh	r3, [r0, #16]
 8005a2c:	bd10      	pop	{r4, pc}

08005a2e <USART_ClockStructInit>:
  * @retval None
  */
void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
{
  /* USART_ClockInitStruct members default value */
  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 8005a2e:	2300      	movs	r3, #0
 8005a30:	8003      	strh	r3, [r0, #0]
  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 8005a32:	8043      	strh	r3, [r0, #2]
  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 8005a34:	8083      	strh	r3, [r0, #4]
  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 8005a36:	80c3      	strh	r3, [r0, #6]
 8005a38:	4770      	bx	lr

08005a3a <USART_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= CR1_UE_Set;
 8005a3a:	8983      	ldrh	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005a3c:	b119      	cbz	r1, 8005a46 <USART_Cmd+0xc>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= CR1_UE_Set;
 8005a3e:	b29b      	uxth	r3, r3
 8005a40:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8005a44:	e003      	b.n	8005a4e <USART_Cmd+0x14>
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= CR1_UE_Reset;
 8005a46:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8005a4a:	041b      	lsls	r3, r3, #16
 8005a4c:	0c1b      	lsrs	r3, r3, #16
 8005a4e:	8183      	strh	r3, [r0, #12]
 8005a50:	4770      	bx	lr

08005a52 <USART_ITConfig>:
  }   
  
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8005a52:	f3c1 1342 	ubfx	r3, r1, #5, #3
  * @param  NewState: new state of the specified USARTx interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 8005a56:	b510      	push	{r4, lr}
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
  itmask = (((uint32_t)0x01) << itpos);
 8005a58:	2401      	movs	r4, #1
 8005a5a:	f001 011f 	and.w	r1, r1, #31
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8005a5e:	42a3      	cmp	r3, r4
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
  itmask = (((uint32_t)0x01) << itpos);
 8005a60:	fa04 f101 	lsl.w	r1, r4, r1
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8005a64:	d101      	bne.n	8005a6a <USART_ITConfig+0x18>
  {
    usartxbase += 0x0C;
 8005a66:	300c      	adds	r0, #12
 8005a68:	e004      	b.n	8005a74 <USART_ITConfig+0x22>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 8005a6a:	2b02      	cmp	r3, #2
 8005a6c:	d101      	bne.n	8005a72 <USART_ITConfig+0x20>
  {
    usartxbase += 0x10;
 8005a6e:	3010      	adds	r0, #16
 8005a70:	e000      	b.n	8005a74 <USART_ITConfig+0x22>
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 8005a72:	3014      	adds	r0, #20
  }
  if (NewState != DISABLE)
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8005a74:	6803      	ldr	r3, [r0, #0]
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
  }
  if (NewState != DISABLE)
 8005a76:	b10a      	cbz	r2, 8005a7c <USART_ITConfig+0x2a>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8005a78:	4319      	orrs	r1, r3
 8005a7a:	e001      	b.n	8005a80 <USART_ITConfig+0x2e>
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8005a7c:	ea23 0101 	bic.w	r1, r3, r1
 8005a80:	6001      	str	r1, [r0, #0]
 8005a82:	bd10      	pop	{r4, pc}

08005a84 <USART_DMACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  if (NewState != DISABLE)
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 8005a84:	8a83      	ldrh	r3, [r0, #20]
 8005a86:	b29b      	uxth	r3, r3
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  if (NewState != DISABLE)
 8005a88:	b10a      	cbz	r2, 8005a8e <USART_DMACmd+0xa>
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 8005a8a:	4319      	orrs	r1, r3
 8005a8c:	e001      	b.n	8005a92 <USART_DMACmd+0xe>
  }
  else
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (uint16_t)~USART_DMAReq;
 8005a8e:	ea23 0101 	bic.w	r1, r3, r1
 8005a92:	8281      	strh	r1, [r0, #20]
 8005a94:	4770      	bx	lr

08005a96 <USART_SetAddress>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_ADDRESS(USART_Address)); 
    
  /* Clear the USART address */
  USARTx->CR2 &= CR2_Address_Mask;
 8005a96:	8a03      	ldrh	r3, [r0, #16]
 8005a98:	f023 030f 	bic.w	r3, r3, #15
 8005a9c:	041b      	lsls	r3, r3, #16
 8005a9e:	0c1b      	lsrs	r3, r3, #16
 8005aa0:	8203      	strh	r3, [r0, #16]
  /* Set the USART address node */
  USARTx->CR2 |= USART_Address;
 8005aa2:	8a03      	ldrh	r3, [r0, #16]
 8005aa4:	b29b      	uxth	r3, r3
 8005aa6:	4319      	orrs	r1, r3
 8005aa8:	8201      	strh	r1, [r0, #16]
 8005aaa:	4770      	bx	lr

08005aac <USART_WakeUpConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_WAKEUP(USART_WakeUp));
  
  USARTx->CR1 &= CR1_WAKE_Mask;
 8005aac:	8983      	ldrh	r3, [r0, #12]
 8005aae:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8005ab2:	041b      	lsls	r3, r3, #16
 8005ab4:	0c1b      	lsrs	r3, r3, #16
 8005ab6:	8183      	strh	r3, [r0, #12]
  USARTx->CR1 |= USART_WakeUp;
 8005ab8:	8983      	ldrh	r3, [r0, #12]
 8005aba:	b29b      	uxth	r3, r3
 8005abc:	4319      	orrs	r1, r3
 8005abe:	8181      	strh	r1, [r0, #12]
 8005ac0:	4770      	bx	lr

08005ac2 <USART_ReceiverWakeUpCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
  {
    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    USARTx->CR1 |= CR1_RWU_Set;
 8005ac2:	8983      	ldrh	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
 8005ac4:	b119      	cbz	r1, 8005ace <USART_ReceiverWakeUpCmd+0xc>
  {
    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    USARTx->CR1 |= CR1_RWU_Set;
 8005ac6:	b29b      	uxth	r3, r3
 8005ac8:	f043 0302 	orr.w	r3, r3, #2
 8005acc:	e003      	b.n	8005ad6 <USART_ReceiverWakeUpCmd+0x14>
  }
  else
  {
    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    USARTx->CR1 &= CR1_RWU_Reset;
 8005ace:	f023 0302 	bic.w	r3, r3, #2
 8005ad2:	041b      	lsls	r3, r3, #16
 8005ad4:	0c1b      	lsrs	r3, r3, #16
 8005ad6:	8183      	strh	r3, [r0, #12]
 8005ad8:	4770      	bx	lr

08005ada <USART_LINBreakDetectLengthConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
  
  USARTx->CR2 &= CR2_LBDL_Mask;
 8005ada:	8a03      	ldrh	r3, [r0, #16]
 8005adc:	f023 0320 	bic.w	r3, r3, #32
 8005ae0:	041b      	lsls	r3, r3, #16
 8005ae2:	0c1b      	lsrs	r3, r3, #16
 8005ae4:	8203      	strh	r3, [r0, #16]
  USARTx->CR2 |= USART_LINBreakDetectLength;  
 8005ae6:	8a03      	ldrh	r3, [r0, #16]
 8005ae8:	b29b      	uxth	r3, r3
 8005aea:	4319      	orrs	r1, r3
 8005aec:	8201      	strh	r1, [r0, #16]
 8005aee:	4770      	bx	lr

08005af0 <USART_LINCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= CR2_LINEN_Set;
 8005af0:	8a03      	ldrh	r3, [r0, #16]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005af2:	b119      	cbz	r1, 8005afc <USART_LINCmd+0xc>
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= CR2_LINEN_Set;
 8005af4:	b29b      	uxth	r3, r3
 8005af6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005afa:	e003      	b.n	8005b04 <USART_LINCmd+0x14>
  }
  else
  {
    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    USARTx->CR2 &= CR2_LINEN_Reset;
 8005afc:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8005b00:	041b      	lsls	r3, r3, #16
 8005b02:	0c1b      	lsrs	r3, r3, #16
 8005b04:	8203      	strh	r3, [r0, #16]
 8005b06:	4770      	bx	lr

08005b08 <USART_SendData>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
 8005b08:	05c9      	lsls	r1, r1, #23
 8005b0a:	0dc9      	lsrs	r1, r1, #23
 8005b0c:	8081      	strh	r1, [r0, #4]
 8005b0e:	4770      	bx	lr

08005b10 <USART_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Receive Data */
  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 8005b10:	8880      	ldrh	r0, [r0, #4]
 8005b12:	05c0      	lsls	r0, r0, #23
}
 8005b14:	0dc0      	lsrs	r0, r0, #23
 8005b16:	4770      	bx	lr

08005b18 <USART_SendBreak>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Send break characters */
  USARTx->CR1 |= CR1_SBK_Set;
 8005b18:	8983      	ldrh	r3, [r0, #12]
 8005b1a:	b29b      	uxth	r3, r3
 8005b1c:	f043 0301 	orr.w	r3, r3, #1
 8005b20:	8183      	strh	r3, [r0, #12]
 8005b22:	4770      	bx	lr

08005b24 <USART_SetGuardTime>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  
  /* Clear the USART Guard time */
  USARTx->GTPR &= GTPR_LSB_Mask;
 8005b24:	8b03      	ldrh	r3, [r0, #24]
 8005b26:	b2db      	uxtb	r3, r3
 8005b28:	8303      	strh	r3, [r0, #24]
  /* Set the USART guard time */
  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 8005b2a:	8b03      	ldrh	r3, [r0, #24]
 8005b2c:	b29b      	uxth	r3, r3
 8005b2e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8005b32:	8301      	strh	r1, [r0, #24]
 8005b34:	4770      	bx	lr

08005b36 <USART_SetPrescaler>:
{ 
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Clear the USART prescaler */
  USARTx->GTPR &= GTPR_MSB_Mask;
 8005b36:	8b03      	ldrh	r3, [r0, #24]
 8005b38:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8005b3c:	8303      	strh	r3, [r0, #24]
  /* Set the USART prescaler */
  USARTx->GTPR |= USART_Prescaler;
 8005b3e:	8b03      	ldrh	r3, [r0, #24]
 8005b40:	b29b      	uxth	r3, r3
 8005b42:	4319      	orrs	r1, r3
 8005b44:	8301      	strh	r1, [r0, #24]
 8005b46:	4770      	bx	lr

08005b48 <USART_SmartCardCmd>:
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= CR3_SCEN_Set;
 8005b48:	8a83      	ldrh	r3, [r0, #20]
void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005b4a:	b119      	cbz	r1, 8005b54 <USART_SmartCardCmd+0xc>
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= CR3_SCEN_Set;
 8005b4c:	b29b      	uxth	r3, r3
 8005b4e:	f043 0320 	orr.w	r3, r3, #32
 8005b52:	e003      	b.n	8005b5c <USART_SmartCardCmd+0x14>
  }
  else
  {
    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    USARTx->CR3 &= CR3_SCEN_Reset;
 8005b54:	f023 0320 	bic.w	r3, r3, #32
 8005b58:	041b      	lsls	r3, r3, #16
 8005b5a:	0c1b      	lsrs	r3, r3, #16
 8005b5c:	8283      	strh	r3, [r0, #20]
 8005b5e:	4770      	bx	lr

08005b60 <USART_SmartCardNACKCmd>:
  assert_param(IS_USART_123_PERIPH(USARTx));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= CR3_NACK_Set;
 8005b60:	8a83      	ldrh	r3, [r0, #20]
void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005b62:	b119      	cbz	r1, 8005b6c <USART_SmartCardNACKCmd+0xc>
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= CR3_NACK_Set;
 8005b64:	b29b      	uxth	r3, r3
 8005b66:	f043 0310 	orr.w	r3, r3, #16
 8005b6a:	e003      	b.n	8005b74 <USART_SmartCardNACKCmd+0x14>
  }
  else
  {
    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    USARTx->CR3 &= CR3_NACK_Reset;
 8005b6c:	f023 0310 	bic.w	r3, r3, #16
 8005b70:	041b      	lsls	r3, r3, #16
 8005b72:	0c1b      	lsrs	r3, r3, #16
 8005b74:	8283      	strh	r3, [r0, #20]
 8005b76:	4770      	bx	lr

08005b78 <USART_HalfDuplexCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= CR3_HDSEL_Set;
 8005b78:	8a83      	ldrh	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005b7a:	b119      	cbz	r1, 8005b84 <USART_HalfDuplexCmd+0xc>
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= CR3_HDSEL_Set;
 8005b7c:	b29b      	uxth	r3, r3
 8005b7e:	f043 0308 	orr.w	r3, r3, #8
 8005b82:	e003      	b.n	8005b8c <USART_HalfDuplexCmd+0x14>
  }
  else
  {
    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    USARTx->CR3 &= CR3_HDSEL_Reset;
 8005b84:	f023 0308 	bic.w	r3, r3, #8
 8005b88:	041b      	lsls	r3, r3, #16
 8005b8a:	0c1b      	lsrs	r3, r3, #16
 8005b8c:	8283      	strh	r3, [r0, #20]
 8005b8e:	4770      	bx	lr

08005b90 <USART_OverSampling8Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= CR1_OVER8_Set;
 8005b90:	8983      	ldrh	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005b92:	b129      	cbz	r1, 8005ba0 <USART_OverSampling8Cmd+0x10>
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= CR1_OVER8_Set;
 8005b94:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8005b98:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8005b9c:	b29b      	uxth	r3, r3
 8005b9e:	e001      	b.n	8005ba4 <USART_OverSampling8Cmd+0x14>
  }
  else
  {
    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    USARTx->CR1 &= CR1_OVER8_Reset;
 8005ba0:	045b      	lsls	r3, r3, #17
 8005ba2:	0c5b      	lsrs	r3, r3, #17
 8005ba4:	8183      	strh	r3, [r0, #12]
 8005ba6:	4770      	bx	lr

08005ba8 <USART_OneBitMethodCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= CR3_ONEBITE_Set;
 8005ba8:	8a83      	ldrh	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005baa:	b119      	cbz	r1, 8005bb4 <USART_OneBitMethodCmd+0xc>
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= CR3_ONEBITE_Set;
 8005bac:	b29b      	uxth	r3, r3
 8005bae:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8005bb2:	e003      	b.n	8005bbc <USART_OneBitMethodCmd+0x14>
  }
  else
  {
    /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
    USARTx->CR3 &= CR3_ONEBITE_Reset;
 8005bb4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8005bb8:	041b      	lsls	r3, r3, #16
 8005bba:	0c1b      	lsrs	r3, r3, #16
 8005bbc:	8283      	strh	r3, [r0, #20]
 8005bbe:	4770      	bx	lr

08005bc0 <USART_IrDAConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
    
  USARTx->CR3 &= CR3_IRLP_Mask;
 8005bc0:	8a83      	ldrh	r3, [r0, #20]
 8005bc2:	f023 0304 	bic.w	r3, r3, #4
 8005bc6:	041b      	lsls	r3, r3, #16
 8005bc8:	0c1b      	lsrs	r3, r3, #16
 8005bca:	8283      	strh	r3, [r0, #20]
  USARTx->CR3 |= USART_IrDAMode;
 8005bcc:	8a83      	ldrh	r3, [r0, #20]
 8005bce:	b29b      	uxth	r3, r3
 8005bd0:	4319      	orrs	r1, r3
 8005bd2:	8281      	strh	r1, [r0, #20]
 8005bd4:	4770      	bx	lr

08005bd6 <USART_IrDACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= CR3_IREN_Set;
 8005bd6:	8a83      	ldrh	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 8005bd8:	b119      	cbz	r1, 8005be2 <USART_IrDACmd+0xc>
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= CR3_IREN_Set;
 8005bda:	b29b      	uxth	r3, r3
 8005bdc:	f043 0302 	orr.w	r3, r3, #2
 8005be0:	e003      	b.n	8005bea <USART_IrDACmd+0x14>
  }
  else
  {
    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    USARTx->CR3 &= CR3_IREN_Reset;
 8005be2:	f023 0302 	bic.w	r3, r3, #2
 8005be6:	041b      	lsls	r3, r3, #16
 8005be8:	0c1b      	lsrs	r3, r3, #16
 8005bea:	8283      	strh	r3, [r0, #20]
 8005bec:	4770      	bx	lr

08005bee <USART_GetFlagStatus>:
  if (USART_FLAG == USART_FLAG_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }  
  
  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 8005bee:	8803      	ldrh	r3, [r0, #0]
 8005bf0:	4219      	tst	r1, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8005bf2:	bf0c      	ite	eq
 8005bf4:	2000      	moveq	r0, #0
 8005bf6:	2001      	movne	r0, #1
 8005bf8:	4770      	bx	lr

08005bfa <USART_ClearFlag>:
  if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  } 
   
  USARTx->SR = (uint16_t)~USART_FLAG;
 8005bfa:	43c9      	mvns	r1, r1
 8005bfc:	b289      	uxth	r1, r1
 8005bfe:	8001      	strh	r1, [r0, #0]
 8005c00:	4770      	bx	lr

08005c02 <USART_GetITStatus>:
  *     @arg USART_IT_FE:   Framing Error interrupt
  *     @arg USART_IT_PE:   Parity Error interrupt
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 8005c02:	b510      	push	{r4, lr}
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }   
  
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8005c04:	f3c1 1442 	ubfx	r4, r1, #5, #3
  /* Get the interrupt position */
  itmask = USART_IT & IT_Mask;
  itmask = (uint32_t)0x01 << itmask;
 8005c08:	2201      	movs	r2, #1
 8005c0a:	f001 031f 	and.w	r3, r1, #31
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8005c0e:	2c01      	cmp	r4, #1
  
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
  /* Get the interrupt position */
  itmask = USART_IT & IT_Mask;
  itmask = (uint32_t)0x01 << itmask;
 8005c10:	fa02 f203 	lsl.w	r2, r2, r3
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8005c14:	d101      	bne.n	8005c1a <USART_GetITStatus+0x18>
  {
    itmask &= USARTx->CR1;
 8005c16:	8983      	ldrh	r3, [r0, #12]
 8005c18:	e003      	b.n	8005c22 <USART_GetITStatus+0x20>
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 8005c1a:	2c02      	cmp	r4, #2
  {
    itmask &= USARTx->CR2;
 8005c1c:	bf0c      	ite	eq
 8005c1e:	8a03      	ldrheq	r3, [r0, #16]
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 8005c20:	8a83      	ldrhne	r3, [r0, #20]
 8005c22:	b29b      	uxth	r3, r3
 8005c24:	4013      	ands	r3, r2
  }
  
  bitpos = USART_IT >> 0x08;
  bitpos = (uint32_t)0x01 << bitpos;
  bitpos &= USARTx->SR;
 8005c26:	8802      	ldrh	r2, [r0, #0]
 8005c28:	b292      	uxth	r2, r2
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8005c2a:	b143      	cbz	r3, 8005c3e <USART_GetITStatus+0x3c>
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x08;
  bitpos = (uint32_t)0x01 << bitpos;
 8005c2c:	2301      	movs	r3, #1
 8005c2e:	0a09      	lsrs	r1, r1, #8
 8005c30:	fa03 f101 	lsl.w	r1, r3, r1
  bitpos &= USARTx->SR;
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8005c34:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 8005c36:	bf0c      	ite	eq
 8005c38:	2000      	moveq	r0, #0
 8005c3a:	2001      	movne	r0, #1
 8005c3c:	bd10      	pop	{r4, pc}
  }
  else
  {
    bitstatus = RESET;
 8005c3e:	4618      	mov	r0, r3
  }
  
  return bitstatus;  
}
 8005c40:	bd10      	pop	{r4, pc}

08005c42 <USART_ClearITPendingBit>:
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }   
  
  bitpos = USART_IT >> 0x08;
  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
 8005c42:	0a09      	lsrs	r1, r1, #8
 8005c44:	2301      	movs	r3, #1
 8005c46:	fa03 f301 	lsl.w	r3, r3, r1
  USARTx->SR = (uint16_t)~itmask;
 8005c4a:	43db      	mvns	r3, r3
 8005c4c:	b29b      	uxth	r3, r3
 8005c4e:	8003      	strh	r3, [r0, #0]
 8005c50:	4770      	bx	lr
 8005c52:	bf00      	nop

08005c54 <WWDG_DeInit>:
  * @param  None
  * @retval None
  */
void WWDG_DeInit(void)
{
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);
 8005c54:	2101      	movs	r1, #1
  * @brief  Deinitializes the WWDG peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void WWDG_DeInit(void)
{
 8005c56:	b508      	push	{r3, lr}
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);
 8005c58:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8005c5c:	f7fe fd38 	bl	80046d0 <RCC_APB1PeriphResetCmd>
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, DISABLE);
 8005c60:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8005c64:	2100      	movs	r1, #0
}
 8005c66:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  * @retval None
  */
void WWDG_DeInit(void)
{
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, DISABLE);
 8005c6a:	f7fe bd31 	b.w	80046d0 <RCC_APB1PeriphResetCmd>

08005c6e <WWDG_SetPrescaler>:
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_WWDG_PRESCALER(WWDG_Prescaler));
  /* Clear WDGTB[1:0] bits */
  tmpreg = WWDG->CFR & CFR_WDGTB_Mask;
 8005c6e:	4b03      	ldr	r3, [pc, #12]	; (8005c7c <WWDG_SetPrescaler+0xe>)
 8005c70:	685a      	ldr	r2, [r3, #4]
 8005c72:	f422 72c0 	bic.w	r2, r2, #384	; 0x180
  /* Set WDGTB[1:0] bits according to WWDG_Prescaler value */
  tmpreg |= WWDG_Prescaler;
 8005c76:	4310      	orrs	r0, r2
  /* Store the new value */
  WWDG->CFR = tmpreg;
 8005c78:	6058      	str	r0, [r3, #4]
 8005c7a:	4770      	bx	lr
 8005c7c:	40002c00 	.word	0x40002c00

08005c80 <WWDG_SetWindowValue>:
  * @param  WindowValue: specifies the window value to be compared to the downcounter.
  *   This parameter value must be lower than 0x80.
  * @retval None
  */
void WWDG_SetWindowValue(uint8_t WindowValue)
{
 8005c80:	b082      	sub	sp, #8
  __IO uint32_t tmpreg = 0;
 8005c82:	2300      	movs	r3, #0
 8005c84:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_WWDG_WINDOW_VALUE(WindowValue));
  /* Clear W[6:0] bits */

  tmpreg = WWDG->CFR & CFR_W_Mask;
 8005c86:	4b07      	ldr	r3, [pc, #28]	; (8005ca4 <WWDG_SetWindowValue+0x24>)

  /* Set W[6:0] bits according to WindowValue value */
  tmpreg |= WindowValue & (uint32_t) BIT_Mask;
 8005c88:	f000 007f 	and.w	r0, r0, #127	; 0x7f

  /* Check the parameters */
  assert_param(IS_WWDG_WINDOW_VALUE(WindowValue));
  /* Clear W[6:0] bits */

  tmpreg = WWDG->CFR & CFR_W_Mask;
 8005c8c:	685a      	ldr	r2, [r3, #4]
 8005c8e:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
 8005c92:	9201      	str	r2, [sp, #4]

  /* Set W[6:0] bits according to WindowValue value */
  tmpreg |= WindowValue & (uint32_t) BIT_Mask;
 8005c94:	9a01      	ldr	r2, [sp, #4]
 8005c96:	4302      	orrs	r2, r0
 8005c98:	9201      	str	r2, [sp, #4]

  /* Store the new value */
  WWDG->CFR = tmpreg;
 8005c9a:	9a01      	ldr	r2, [sp, #4]
 8005c9c:	605a      	str	r2, [r3, #4]
}
 8005c9e:	b002      	add	sp, #8
 8005ca0:	4770      	bx	lr
 8005ca2:	bf00      	nop
 8005ca4:	40002c00 	.word	0x40002c00

08005ca8 <WWDG_EnableIT>:
  * @param  None
  * @retval None
  */
void WWDG_EnableIT(void)
{
  *(__IO uint32_t *) CFR_EWI_BB = (uint32_t)ENABLE;
 8005ca8:	4b01      	ldr	r3, [pc, #4]	; (8005cb0 <WWDG_EnableIT+0x8>)
 8005caa:	2201      	movs	r2, #1
 8005cac:	601a      	str	r2, [r3, #0]
 8005cae:	4770      	bx	lr
 8005cb0:	420580a4 	.word	0x420580a4

08005cb4 <WWDG_SetCounter>:
{
  /* Check the parameters */
  assert_param(IS_WWDG_COUNTER(Counter));
  /* Write to T[6:0] bits to configure the counter value, no need to do
     a read-modify-write; writing a 0 to WDGA bit does nothing */
  WWDG->CR = Counter & BIT_Mask;
 8005cb4:	4b02      	ldr	r3, [pc, #8]	; (8005cc0 <WWDG_SetCounter+0xc>)
 8005cb6:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 8005cba:	6018      	str	r0, [r3, #0]
 8005cbc:	4770      	bx	lr
 8005cbe:	bf00      	nop
 8005cc0:	40002c00 	.word	0x40002c00

08005cc4 <WWDG_Enable>:
  */
void WWDG_Enable(uint8_t Counter)
{
  /* Check the parameters */
  assert_param(IS_WWDG_COUNTER(Counter));
  WWDG->CR = CR_WDGA_Set | Counter;
 8005cc4:	4b02      	ldr	r3, [pc, #8]	; (8005cd0 <WWDG_Enable+0xc>)
 8005cc6:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 8005cca:	6018      	str	r0, [r3, #0]
 8005ccc:	4770      	bx	lr
 8005cce:	bf00      	nop
 8005cd0:	40002c00 	.word	0x40002c00

08005cd4 <WWDG_GetFlagStatus>:
  * @param  None
  * @retval The new state of the Early Wakeup interrupt flag (SET or RESET)
  */
FlagStatus WWDG_GetFlagStatus(void)
{
  return (FlagStatus)(WWDG->SR);
 8005cd4:	4b01      	ldr	r3, [pc, #4]	; (8005cdc <WWDG_GetFlagStatus+0x8>)
 8005cd6:	6898      	ldr	r0, [r3, #8]
}
 8005cd8:	b2c0      	uxtb	r0, r0
 8005cda:	4770      	bx	lr
 8005cdc:	40002c00 	.word	0x40002c00

08005ce0 <WWDG_ClearFlag>:
  * @param  None
  * @retval None
  */
void WWDG_ClearFlag(void)
{
  WWDG->SR = (uint32_t)RESET;
 8005ce0:	4b01      	ldr	r3, [pc, #4]	; (8005ce8 <WWDG_ClearFlag+0x8>)
 8005ce2:	2200      	movs	r2, #0
 8005ce4:	609a      	str	r2, [r3, #8]
 8005ce6:	4770      	bx	lr
 8005ce8:	40002c00 	.word	0x40002c00

08005cec <BSP_SetTime>:
  *         Configures TIM2 for delay routine based on TIM2
  * @param  unit : msec /usec
  * @retval None
  */
static void BSP_SetTime(uint8_t unit)
{
 8005cec:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
  
  TIM_Cmd(TIM2,DISABLE);
 8005cee:	2100      	movs	r1, #0
  *         Configures TIM2 for delay routine based on TIM2
  * @param  unit : msec /usec
  * @retval None
  */
static void BSP_SetTime(uint8_t unit)
{
 8005cf0:	4604      	mov	r4, r0
  TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
  
  TIM_Cmd(TIM2,DISABLE);
 8005cf2:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005cf6:	f7ff fa56 	bl	80051a6 <TIM_Cmd>
  TIM_ITConfig(TIM2, TIM_IT_Update, DISABLE); 
 8005cfa:	2101      	movs	r1, #1
 8005cfc:	2200      	movs	r2, #0
 8005cfe:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005d02:	f7ff fa6a 	bl	80051da <TIM_ITConfig>
  
  
  if(unit == TIM_USEC_DELAY)
 8005d06:	2c02      	cmp	r4, #2
 8005d08:	d101      	bne.n	8005d0e <BSP_SetTime+0x22>
  {  
    TIM_TimeBaseStructure.TIM_Period = 11;
 8005d0a:	230b      	movs	r3, #11
 8005d0c:	e003      	b.n	8005d16 <BSP_SetTime+0x2a>
  }
  else if(unit == TIM_MSEC_DELAY)
 8005d0e:	2c01      	cmp	r4, #1
 8005d10:	d103      	bne.n	8005d1a <BSP_SetTime+0x2e>
  {
    TIM_TimeBaseStructure.TIM_Period = 11999;
 8005d12:	f642 63df 	movw	r3, #11999	; 0x2edf
 8005d16:	f8ad 3008 	strh.w	r3, [sp, #8]
  }
  TIM_TimeBaseStructure.TIM_Prescaler = 5;
 8005d1a:	2305      	movs	r3, #5
 8005d1c:	f8ad 3004 	strh.w	r3, [sp, #4]
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  
  TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
 8005d20:	a901      	add	r1, sp, #4
  else if(unit == TIM_MSEC_DELAY)
  {
    TIM_TimeBaseStructure.TIM_Period = 11999;
  }
  TIM_TimeBaseStructure.TIM_Prescaler = 5;
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 8005d22:	2300      	movs	r3, #0
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  
  TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
 8005d24:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  else if(unit == TIM_MSEC_DELAY)
  {
    TIM_TimeBaseStructure.TIM_Period = 11999;
  }
  TIM_TimeBaseStructure.TIM_Prescaler = 5;
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 8005d28:	f8ad 300a 	strh.w	r3, [sp, #10]
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8005d2c:	f8ad 3006 	strh.w	r3, [sp, #6]
  
  TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
 8005d30:	f7ff f8bc 	bl	8004eac <TIM_TimeBaseInit>
  TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
 8005d34:	2101      	movs	r1, #1
 8005d36:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005d3a:	f7ff fdb6 	bl	80058aa <TIM_ClearITPendingBit>
  
  TIM_ARRPreloadConfig(TIM2, ENABLE);
 8005d3e:	2101      	movs	r1, #1
 8005d40:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005d44:	f7ff fb04 	bl	8005350 <TIM_ARRPreloadConfig>
  
  /* TIM IT enable */
  TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);
 8005d48:	2101      	movs	r1, #1
 8005d4a:	460a      	mov	r2, r1
 8005d4c:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005d50:	f7ff fa43 	bl	80051da <TIM_ITConfig>
  
  /* TIM2 enable counter */ 
  TIM_Cmd(TIM2, ENABLE);  
 8005d54:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005d58:	2101      	movs	r1, #1
 8005d5a:	f7ff fa24 	bl	80051a6 <TIM_Cmd>
} 
 8005d5e:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

08005d60 <USB_OTG_BSP_Init>:
  * @param  None
  * @retval None
  */

void USB_OTG_BSP_Init(USB_OTG_CORE_HANDLE *pdev)
{
 8005d60:	b513      	push	{r0, r1, r4, lr}

// EXTI_InitTypeDef EXTI_InitStructure;

  RCC_OTGFSCLKConfig(RCC_OTGFSCLKSource_PLLVCO_Div3);
 8005d62:	2000      	movs	r0, #0
 8005d64:	f7fe fbd6 	bl	8004514 <RCC_OTGFSCLKConfig>
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_OTG_FS, ENABLE) ;
 8005d68:	2101      	movs	r1, #1
 8005d6a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8005d6e:	f7fe fc73 	bl	8004658 <RCC_AHBPeriphClockCmd>
{
#ifdef USE_ACCURATE_TIME   
  NVIC_InitTypeDef NVIC_InitStructure;
  
  /* Set the Vector Table base address at 0x08000000 */
  NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x00);
 8005d72:	2100      	movs	r1, #0
 8005d74:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
 8005d78:	f7fd fd6e 	bl	8003858 <NVIC_SetVectorTable>
  
  /* Configure the Priority Group to 2 bits */
  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
 8005d7c:	f44f 60a0 	mov.w	r0, #1280	; 0x500
 8005d80:	f7fd fd2c 	bl	80037dc <NVIC_PriorityGroupConfig>
  
  /* Enable the TIM2 gloabal Interrupt */
  NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
 8005d84:	2401      	movs	r4, #1
  
  /* Configure the Priority Group to 2 bits */
  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
  
  /* Enable the TIM2 gloabal Interrupt */
  NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
 8005d86:	231c      	movs	r3, #28
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  
  NVIC_Init(&NVIC_InitStructure);
 8005d88:	a801      	add	r0, sp, #4
  
  /* Configure the Priority Group to 2 bits */
  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
  
  /* Enable the TIM2 gloabal Interrupt */
  NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
 8005d8a:	f88d 3004 	strb.w	r3, [sp, #4]
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
 8005d8e:	f88d 4005 	strb.w	r4, [sp, #5]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
 8005d92:	f88d 4006 	strb.w	r4, [sp, #6]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8005d96:	f88d 4007 	strb.w	r4, [sp, #7]
  
  NVIC_Init(&NVIC_InitStructure);
 8005d9a:	f7fd fd29 	bl	80037f0 <NVIC_Init>
  
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);  
 8005d9e:	4620      	mov	r0, r4
 8005da0:	4621      	mov	r1, r4
 8005da2:	f7fe fc71 	bl	8004688 <RCC_APB1PeriphClockCmd>
//  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;  
//  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; 
//  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
//  EXTI_Init(&EXTI_InitStructure);
   USB_OTG_BSP_TimeInit();
}
 8005da6:	bd1c      	pop	{r2, r3, r4, pc}

08005da8 <USB_OTG_BSP_EnableInterrupt>:
  *         Configures USB Global interrupt
  * @param  None
  * @retval None
  */
void USB_OTG_BSP_EnableInterrupt(USB_OTG_CORE_HANDLE *pdev)
{
 8005da8:	b507      	push	{r0, r1, r2, lr}
  NVIC_InitTypeDef NVIC_InitStructure; 
  
  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
 8005daa:	f44f 60c0 	mov.w	r0, #1536	; 0x600
 8005dae:	f7fd fd15 	bl	80037dc <NVIC_PriorityGroupConfig>
#ifdef USE_USB_OTG_HS   
  NVIC_InitStructure.NVIC_IRQChannel = OTG_HS_IRQn;
#else
  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;  
 8005db2:	2343      	movs	r3, #67	; 0x43
 8005db4:	f88d 3004 	strb.w	r3, [sp, #4]
#endif
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
 8005db8:	2203      	movs	r2, #3
#ifdef USE_USB_OTG_HS   
  NVIC_InitStructure.NVIC_IRQChannel = OTG_HS_IRQn;
#else
  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;  
#endif
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
 8005dba:	2301      	movs	r3, #1
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);  
 8005dbc:	a801      	add	r0, sp, #4
#ifdef USE_USB_OTG_HS   
  NVIC_InitStructure.NVIC_IRQChannel = OTG_HS_IRQn;
#else
  NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;  
#endif
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
 8005dbe:	f88d 3005 	strb.w	r3, [sp, #5]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
 8005dc2:	f88d 2006 	strb.w	r2, [sp, #6]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8005dc6:	f88d 3007 	strb.w	r3, [sp, #7]
  NVIC_Init(&NVIC_InitStructure);  
 8005dca:	f7fd fd11 	bl	80037f0 <NVIC_Init>
//  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
//  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
//  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
//  
//  NVIC_Init(&NVIC_InitStructure);  
}
 8005dce:	bd0e      	pop	{r1, r2, r3, pc}

08005dd0 <USB_OTG_BSP_DriveVBUS>:
  */
#ifndef USE_USB_OTG_HS   
  if (0 == state)
  { 
    /* DISABLE is needed on output of the Power Switch */
    GPIO_SetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
 8005dd0:	4804      	ldr	r0, [pc, #16]	; (8005de4 <USB_OTG_BSP_DriveVBUS+0x14>)
  Bit 12 PPWR: Port power
  The application uses this field to control power to this port, and the core 
  clears this bit on an overcurrent condition.
  */
#ifndef USE_USB_OTG_HS   
  if (0 == state)
 8005dd2:	b919      	cbnz	r1, 8005ddc <USB_OTG_BSP_DriveVBUS+0xc>
  { 
    /* DISABLE is needed on output of the Power Switch */
    GPIO_SetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
 8005dd4:	f44f 7100 	mov.w	r1, #512	; 0x200
 8005dd8:	f7fd bfe3 	b.w	8003da2 <GPIO_SetBits>
  }
  else
  {
    /*ENABLE the Power Switch by driving the Enable LOW */
    GPIO_ResetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
 8005ddc:	f44f 7100 	mov.w	r1, #512	; 0x200
 8005de0:	f7fd bfe1 	b.w	8003da6 <GPIO_ResetBits>
 8005de4:	40011000 	.word	0x40011000

08005de8 <USB_OTG_BSP_uDelay>:
  *         This function provides delay time in micro sec
  * @param  usec : Value of delay required in micro sec
  * @retval None
  */
void USB_OTG_BSP_uDelay (const uint32_t usec)
{
 8005de8:	b510      	push	{r4, lr}
  * @retval None
  */
static void BSP_Delay(uint32_t nTime, uint8_t unit)
{
  
  BSP_delay = nTime;
 8005dea:	4c07      	ldr	r4, [pc, #28]	; (8005e08 <USB_OTG_BSP_uDelay+0x20>)
 8005dec:	6020      	str	r0, [r4, #0]
  BSP_SetTime(unit);  
 8005dee:	2002      	movs	r0, #2
 8005df0:	f7ff ff7c 	bl	8005cec <BSP_SetTime>
  while(BSP_delay != 0);
 8005df4:	6821      	ldr	r1, [r4, #0]
 8005df6:	2900      	cmp	r1, #0
 8005df8:	d1fc      	bne.n	8005df4 <USB_OTG_BSP_uDelay+0xc>
  TIM_Cmd(TIM2,DISABLE);
 8005dfa:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    }
  }
  while (1);
#endif   
  
}
 8005dfe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
  
  BSP_delay = nTime;
  BSP_SetTime(unit);  
  while(BSP_delay != 0);
  TIM_Cmd(TIM2,DISABLE);
 8005e02:	f7ff b9d0 	b.w	80051a6 <TIM_Cmd>
 8005e06:	bf00      	nop
 8005e08:	20000b3c 	.word	0x20000b3c

08005e0c <USB_OTG_BSP_mDelay>:
  *          This function provides delay time in milli sec
  * @param  msec : Value of delay required in milli sec
  * @retval None
  */
void USB_OTG_BSP_mDelay (const uint32_t msec)
{ 
 8005e0c:	b510      	push	{r4, lr}
  * @retval None
  */
static void BSP_Delay(uint32_t nTime, uint8_t unit)
{
  
  BSP_delay = nTime;
 8005e0e:	4c07      	ldr	r4, [pc, #28]	; (8005e2c <USB_OTG_BSP_mDelay+0x20>)
 8005e10:	6020      	str	r0, [r4, #0]
  BSP_SetTime(unit);  
 8005e12:	2001      	movs	r0, #1
 8005e14:	f7ff ff6a 	bl	8005cec <BSP_SetTime>
  while(BSP_delay != 0);
 8005e18:	6821      	ldr	r1, [r4, #0]
 8005e1a:	2900      	cmp	r1, #0
 8005e1c:	d1fc      	bne.n	8005e18 <USB_OTG_BSP_mDelay+0xc>
  TIM_Cmd(TIM2,DISABLE);
 8005e1e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    BSP_Delay(msec,TIM_MSEC_DELAY);   
#else
    USB_OTG_BSP_uDelay(msec * 1000);   
#endif    

}
 8005e22:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
  
  BSP_delay = nTime;
  BSP_SetTime(unit);  
  while(BSP_delay != 0);
  TIM_Cmd(TIM2,DISABLE);
 8005e26:	f7ff b9be 	b.w	80051a6 <TIM_Cmd>
 8005e2a:	bf00      	nop
 8005e2c:	20000b3c 	.word	0x20000b3c

08005e30 <USB_OTG_BSP_ConfigVBUS>:
  * @param  None
  * @retval None
  */

void  USB_OTG_BSP_ConfigVBUS(USB_OTG_CORE_HANDLE *pdev)
{
 8005e30:	b537      	push	{r0, r1, r2, r4, r5, lr}
#ifdef USE_USB_OTG_FS   
  GPIO_InitTypeDef GPIO_InitStructure; 
  
  RCC_APB2PeriphClockCmd(HOST_POWERSW_PORT_RCC, ENABLE);
 8005e32:	2010      	movs	r0, #16
 8005e34:	2101      	movs	r1, #1
  
  /* Configure Power Switch Vbus Pin */
  GPIO_InitStructure.GPIO_Pin = HOST_POWERSW_VBUS;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_Init(HOST_POWERSW_PORT, &GPIO_InitStructure);
 8005e36:	4d0c      	ldr	r5, [pc, #48]	; (8005e68 <USB_OTG_BSP_ConfigVBUS+0x38>)
void  USB_OTG_BSP_ConfigVBUS(USB_OTG_CORE_HANDLE *pdev)
{
#ifdef USE_USB_OTG_FS   
  GPIO_InitTypeDef GPIO_InitStructure; 
  
  RCC_APB2PeriphClockCmd(HOST_POWERSW_PORT_RCC, ENABLE);
 8005e38:	f7fe fc1a 	bl	8004670 <RCC_APB2PeriphClockCmd>
  
  
  /* Configure Power Switch Vbus Pin */
  GPIO_InitStructure.GPIO_Pin = HOST_POWERSW_VBUS;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8005e3c:	2303      	movs	r3, #3
  
  RCC_APB2PeriphClockCmd(HOST_POWERSW_PORT_RCC, ENABLE);
  
  
  /* Configure Power Switch Vbus Pin */
  GPIO_InitStructure.GPIO_Pin = HOST_POWERSW_VBUS;
 8005e3e:	f44f 7400 	mov.w	r4, #512	; 0x200
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8005e42:	f88d 3006 	strb.w	r3, [sp, #6]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_Init(HOST_POWERSW_PORT, &GPIO_InitStructure);
 8005e46:	4628      	mov	r0, r5
  
  
  /* Configure Power Switch Vbus Pin */
  GPIO_InitStructure.GPIO_Pin = HOST_POWERSW_VBUS;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8005e48:	2310      	movs	r3, #16
  GPIO_Init(HOST_POWERSW_PORT, &GPIO_InitStructure);
 8005e4a:	a901      	add	r1, sp, #4
  
  
  /* Configure Power Switch Vbus Pin */
  GPIO_InitStructure.GPIO_Pin = HOST_POWERSW_VBUS;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8005e4c:	f88d 3007 	strb.w	r3, [sp, #7]
  
  RCC_APB2PeriphClockCmd(HOST_POWERSW_PORT_RCC, ENABLE);
  
  
  /* Configure Power Switch Vbus Pin */
  GPIO_InitStructure.GPIO_Pin = HOST_POWERSW_VBUS;
 8005e50:	f8ad 4004 	strh.w	r4, [sp, #4]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_Init(HOST_POWERSW_PORT, &GPIO_InitStructure);
 8005e54:	f7fd ff37 	bl	8003cc6 <GPIO_Init>

  /* By Default, DISABLE is needed on output of the Power Switch */
  GPIO_SetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
 8005e58:	4628      	mov	r0, r5
 8005e5a:	4621      	mov	r1, r4
 8005e5c:	f7fd ffa1 	bl	8003da2 <GPIO_SetBits>
  
  USB_OTG_BSP_mDelay(200);   /* Delay is need for stabilising the Vbus Low 
 8005e60:	20c8      	movs	r0, #200	; 0xc8
 8005e62:	f7ff ffd3 	bl	8005e0c <USB_OTG_BSP_mDelay>
  in Reset Condition, when Vbus=1 and Reset-button is pressed by user */
#endif  
}
 8005e66:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8005e68:	40011000 	.word	0x40011000

08005e6c <USB_OTG_BSP_TimerIRQ>:
  * @param  None
  * @retval None
  */

void USB_OTG_BSP_TimerIRQ (void)
{
 8005e6c:	b508      	push	{r3, lr}
#ifdef USE_ACCURATE_TIME 
  if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
 8005e6e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005e72:	2101      	movs	r1, #1
 8005e74:	f7ff fd0e 	bl	8005894 <TIM_GetITStatus>
 8005e78:	b188      	cbz	r0, 8005e9e <USB_OTG_BSP_TimerIRQ+0x32>
  {
    TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
 8005e7a:	2101      	movs	r1, #1
 8005e7c:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005e80:	f7ff fd13 	bl	80058aa <TIM_ClearITPendingBit>
    if (BSP_delay > 0x00)
 8005e84:	4b06      	ldr	r3, [pc, #24]	; (8005ea0 <USB_OTG_BSP_TimerIRQ+0x34>)
 8005e86:	6819      	ldr	r1, [r3, #0]
 8005e88:	b119      	cbz	r1, 8005e92 <USB_OTG_BSP_TimerIRQ+0x26>
    { 
      BSP_delay--;
 8005e8a:	681a      	ldr	r2, [r3, #0]
 8005e8c:	3a01      	subs	r2, #1
 8005e8e:	601a      	str	r2, [r3, #0]
 8005e90:	bd08      	pop	{r3, pc}
    }
    else
    {
      TIM_Cmd(TIM2,DISABLE);
 8005e92:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    }
  }
#endif  
} 
 8005e96:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    { 
      BSP_delay--;
    }
    else
    {
      TIM_Cmd(TIM2,DISABLE);
 8005e9a:	f7ff b984 	b.w	80051a6 <TIM_Cmd>
 8005e9e:	bd08      	pop	{r3, pc}
 8005ea0:	20000b3c 	.word	0x20000b3c

08005ea4 <USB_OTG_CoreReset>:
* @brief  USB_OTG_CoreReset : Soft reset of the core
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
{
 8005ea4:	b537      	push	{r0, r1, r2, r4, r5, lr}
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 8005ea6:	2300      	movs	r3, #0
 8005ea8:	4c10      	ldr	r4, [pc, #64]	; (8005eec <USB_OTG_CoreReset+0x48>)
* @brief  USB_OTG_CoreReset : Soft reset of the core
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
{
 8005eaa:	4605      	mov	r5, r0
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 8005eac:	9301      	str	r3, [sp, #4]
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 8005eae:	2003      	movs	r0, #3
 8005eb0:	f7ff ff9a 	bl	8005de8 <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8005eb4:	68eb      	ldr	r3, [r5, #12]
    if (++count > 200000)
 8005eb6:	3c01      	subs	r4, #1
  greset.d32 = 0;
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8005eb8:	691a      	ldr	r2, [r3, #16]
 8005eba:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 8005ebc:	d013      	beq.n	8005ee6 <USB_OTG_CoreReset+0x42>
    {
      return USB_OTG_OK;
    }
  }
  while (greset.b.ahbidle == 0);
 8005ebe:	9a01      	ldr	r2, [sp, #4]
 8005ec0:	2a00      	cmp	r2, #0
 8005ec2:	daf4      	bge.n	8005eae <USB_OTG_CoreReset+0xa>
  /* Core Soft Reset */
  count = 0;
  greset.b.csftrst = 1;
 8005ec4:	9a01      	ldr	r2, [sp, #4]
 8005ec6:	f042 0201 	orr.w	r2, r2, #1
 8005eca:	9201      	str	r2, [sp, #4]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
 8005ecc:	9a01      	ldr	r2, [sp, #4]
 8005ece:	611a      	str	r2, [r3, #16]
 8005ed0:	4a06      	ldr	r2, [pc, #24]	; (8005eec <USB_OTG_CoreReset+0x48>)
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8005ed2:	6919      	ldr	r1, [r3, #16]
    if (++count > 200000)
 8005ed4:	3a01      	subs	r2, #1
  count = 0;
  greset.b.csftrst = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 8005ed6:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
 8005ed8:	d002      	beq.n	8005ee0 <USB_OTG_CoreReset+0x3c>
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 8005eda:	9901      	ldr	r1, [sp, #4]
 8005edc:	07c9      	lsls	r1, r1, #31
 8005ede:	d4f8      	bmi.n	8005ed2 <USB_OTG_CoreReset+0x2e>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8005ee0:	2003      	movs	r0, #3
 8005ee2:	f7ff ff81 	bl	8005de8 <USB_OTG_BSP_uDelay>
  return status;
}
 8005ee6:	2000      	movs	r0, #0
 8005ee8:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8005eea:	bf00      	nop
 8005eec:	00030d41 	.word	0x00030d41

08005ef0 <USB_OTG_WritePacket>:
*/
USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
 8005ef0:	b530      	push	{r4, r5, lr}
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 8005ef2:	78c4      	ldrb	r4, [r0, #3]
 8005ef4:	b96c      	cbnz	r4, 8005f12 <USB_OTG_WritePacket+0x22>
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8005ef6:	eb00 0082 	add.w	r0, r0, r2, lsl #2
  if (pdev->cfg.dma_enable == 0)
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
 8005efa:	3303      	adds	r3, #3
 8005efc:	109b      	asrs	r3, r3, #2
    fifo = pdev->regs.DFIFO[ch_ep_num];
 8005efe:	f8d0 50d0 	ldr.w	r5, [r0, #208]	; 0xd0
    for (i = 0; i < count32b; i++, src+=4)
 8005f02:	4622      	mov	r2, r4
 8005f04:	e003      	b.n	8005f0e <USB_OTG_WritePacket+0x1e>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8005f06:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8005f0a:	3201      	adds	r2, #1
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 8005f0c:	6028      	str	r0, [r5, #0]
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
    for (i = 0; i < count32b; i++, src+=4)
 8005f0e:	429a      	cmp	r2, r3
 8005f10:	d1f9      	bne.n	8005f06 <USB_OTG_WritePacket+0x16>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
    }
  }
  return status;
}
 8005f12:	2000      	movs	r0, #0
 8005f14:	bd30      	pop	{r4, r5, pc}

08005f16 <USB_OTG_ReadPacket>:
void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dest, 
                         uint16_t len)
{
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
 8005f16:	3203      	adds	r2, #3
* @retval None
*/
void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dest, 
                         uint16_t len)
{
 8005f18:	b510      	push	{r4, lr}
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
 8005f1a:	1092      	asrs	r2, r2, #2
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
 8005f1c:	f8d0 40d0 	ldr.w	r4, [r0, #208]	; 0xd0
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8005f20:	2300      	movs	r3, #0
 8005f22:	e003      	b.n	8005f2c <USB_OTG_ReadPacket+0x16>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 8005f24:	6820      	ldr	r0, [r4, #0]
 8005f26:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 8005f2a:	3301      	adds	r3, #1
 8005f2c:	4293      	cmp	r3, r2
 8005f2e:	ea4f 0083 	mov.w	r0, r3, lsl #2
 8005f32:	d1f7      	bne.n	8005f24 <USB_OTG_ReadPacket+0xe>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
    
  }
  return ((void *)dest);
}
 8005f34:	1808      	adds	r0, r1, r0
 8005f36:	bd10      	pop	{r4, pc}

08005f38 <USB_OTG_SelectCore>:
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8005f38:	2201      	movs	r2, #1
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
                               USB_OTG_CORE_ID_TypeDef coreID)
{
 8005f3a:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t i , baseAddress = 0;
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
 8005f3c:	2300      	movs	r3, #0
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 8005f3e:	7082      	strb	r2, [r0, #2]
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 8005f40:	2240      	movs	r2, #64	; 0x40
  
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
 8005f42:	2901      	cmp	r1, #1
                               USB_OTG_CORE_ID_TypeDef coreID)
{
  uint32_t i , baseAddress = 0;
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
 8005f44:	70c3      	strb	r3, [r0, #3]
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 8005f46:	8082      	strh	r2, [r0, #4]
  
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
 8005f48:	d10c      	bne.n	8005f64 <USB_OTG_SelectCore+0x2c>
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
    pdev->cfg.host_channels    = 8 ;
 8005f4a:	2308      	movs	r3, #8
 8005f4c:	7003      	strb	r3, [r0, #0]
    pdev->cfg.dev_endpoints    = 4 ;
 8005f4e:	2304      	movs	r3, #4
 8005f50:	7043      	strb	r3, [r0, #1]
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
 8005f52:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8005f56:	80c3      	strh	r3, [r0, #6]
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 8005f58:	2302      	movs	r3, #2
 8005f5a:	7203      	strb	r3, [r0, #8]
  
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
 8005f5c:	72c1      	strb	r1, [r0, #11]
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
  
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
 8005f5e:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8005f62:	e009      	b.n	8005f78 <USB_OTG_SelectCore+0x40>
    
#ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
    pdev->cfg.low_power        = 1;    
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
 8005f64:	b941      	cbnz	r1, 8005f78 <USB_OTG_SelectCore+0x40>
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
    pdev->cfg.host_channels    = 12 ;
 8005f66:	230c      	movs	r3, #12
 8005f68:	7003      	strb	r3, [r0, #0]
    pdev->cfg.dev_endpoints    = 6 ;
 8005f6a:	2306      	movs	r3, #6
 8005f6c:	7043      	strb	r3, [r0, #1]
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 8005f6e:	f44f 63a0 	mov.w	r3, #1280	; 0x500
 8005f72:	80c3      	strh	r3, [r0, #6]
    pdev->cfg.low_power        = 1;    
#endif     
  }
  else if (coreID == USB_OTG_HS_CORE_ID)
  {
    baseAddress                = USB_OTG_HS_BASE_ADDR;
 8005f74:	4b1f      	ldr	r3, [pc, #124]	; (8005ff4 <USB_OTG_SelectCore+0xbc>)
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
 8005f76:	72c1      	strb	r1, [r0, #11]
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 8005f78:	f503 6200 	add.w	r2, r3, #2048	; 0x800
 8005f7c:	6102      	str	r2, [r0, #16]
    pdev->cfg.low_power        = 1;    
#endif 
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
 8005f7e:	60c3      	str	r3, [r0, #12]
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8005f80:	7845      	ldrb	r5, [r0, #1]
 8005f82:	4602      	mov	r2, r0
 8005f84:	4619      	mov	r1, r3
 8005f86:	2400      	movs	r4, #0
 8005f88:	e007      	b.n	8005f9a <USB_OTG_SelectCore+0x62>
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8005f8a:	f501 6710 	add.w	r7, r1, #2304	; 0x900
 8005f8e:	f501 6130 	add.w	r1, r1, #2816	; 0xb00
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
      (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 8005f92:	6511      	str	r1, [r2, #80]	; 0x50
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
  {
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 8005f94:	6157      	str	r7, [r2, #20]
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 8005f96:	3401      	adds	r4, #1
 8005f98:	4631      	mov	r1, r6
 8005f9a:	3204      	adds	r2, #4
 8005f9c:	42ac      	cmp	r4, r5
 8005f9e:	f101 0620 	add.w	r6, r1, #32
 8005fa2:	d3f2      	bcc.n	8005f8a <USB_OTG_SelectCore+0x52>
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
 8005fa4:	f503 6280 	add.w	r2, r3, #1024	; 0x400
 8005fa8:	6142      	str	r2, [r0, #20]
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
 8005faa:	f503 6288 	add.w	r2, r3, #1088	; 0x440
 8005fae:	f8c0 20cc 	str.w	r2, [r0, #204]	; 0xcc
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8005fb2:	7804      	ldrb	r4, [r0, #0]
 8005fb4:	f503 61a0 	add.w	r1, r3, #1280	; 0x500
 8005fb8:	2200      	movs	r2, #0
 8005fba:	e005      	b.n	8005fc8 <USB_OTG_SelectCore+0x90>
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8005fbc:	eb00 0582 	add.w	r5, r0, r2, lsl #2
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 8005fc0:	f8c5 1090 	str.w	r1, [r5, #144]	; 0x90
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8005fc4:	3201      	adds	r2, #1
 8005fc6:	3120      	adds	r1, #32
 8005fc8:	42a2      	cmp	r2, r4
 8005fca:	d3f7      	bcc.n	8005fbc <USB_OTG_SelectCore+0x84>
 8005fcc:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
 8005fd0:	2200      	movs	r2, #0
 8005fd2:	e006      	b.n	8005fe2 <USB_OTG_SelectCore+0xaa>
*         Initialize core registers address.
* @param  pdev : Selected device
* @param  coreID : USB OTG Core ID
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
 8005fd4:	eb00 0582 	add.w	r5, r0, r2, lsl #2
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 8005fd8:	f8c5 10d0 	str.w	r1, [r5, #208]	; 0xd0
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8005fdc:	3201      	adds	r2, #1
 8005fde:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
 8005fe2:	42a2      	cmp	r2, r4
 8005fe4:	d3f6      	bcc.n	8005fd4 <USB_OTG_SelectCore+0x9c>
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
      (i * USB_OTG_DATA_FIFO_SIZE));
  }
  pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
 8005fe6:	f503 6360 	add.w	r3, r3, #3584	; 0xe00
 8005fea:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
  
  return status;
}
 8005fee:	2000      	movs	r0, #0
 8005ff0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005ff2:	bf00      	nop
 8005ff4:	40040000 	.word	0x40040000

08005ff8 <USB_OTG_CoreInit>:
*         device mode or host mode operation.
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
 8005ff8:	b538      	push	{r3, r4, r5, lr}
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
  
  
  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8005ffa:	7a03      	ldrb	r3, [r0, #8]
  USB_OTG_GCCFG_TypeDef    gccfg;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  usbcfg.d32 = 0;
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
 8005ffc:	2400      	movs	r4, #0
  
  
  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8005ffe:	2b01      	cmp	r3, #1
*         device mode or host mode operation.
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
 8006000:	4605      	mov	r5, r0
 8006002:	68c2      	ldr	r2, [r0, #12]
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
  
  
  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8006004:	d11f      	bne.n	8006046 <USB_OTG_CoreInit+0x4e>
  {
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
 8006006:	6b93      	ldr	r3, [r2, #56]	; 0x38
    gccfg.b.pwdn = 0;
    
    if (pdev->cfg.Sof_output)
 8006008:	7a41      	ldrb	r1, [r0, #9]
  
  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
  {
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
    gccfg.b.pwdn = 0;
 800600a:	f364 4310 	bfi	r3, r4, #16, #1
    
    if (pdev->cfg.Sof_output)
 800600e:	b109      	cbz	r1, 8006014 <USB_OTG_CoreInit+0x1c>
    {
      gccfg.b.sofouten = 1;   
 8006010:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    }
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8006014:	6393      	str	r3, [r2, #56]	; 0x38
    
    /* Init The ULPI Interface */
    usbcfg.d32 = 0;
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8006016:	68d3      	ldr	r3, [r2, #12]
    usbcfg.b.ulpi_fsls = 0;
    usbcfg.b.ulpi_clk_sus_m = 0;
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
    
    /* Reset after a PHY select  */
    USB_OTG_CoreReset(pdev);
 8006018:	4628      	mov	r0, r5
    
    /* Init The ULPI Interface */
    usbcfg.d32 = 0;
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
    
    usbcfg.b.physel            = 0; /* HS Interface */
 800601a:	f36f 1386 	bfc	r3, #6, #1
#else
#ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
    usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
#endif
#endif 
    usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
 800601e:	f36f 5396 	bfc	r3, #22, #1
    
    usbcfg.b.ulpi_fsls = 0;
 8006022:	f36f 4351 	bfc	r3, #17, #1
    usbcfg.b.ulpi_clk_sus_m = 0;
 8006026:	f36f 43d3 	bfc	r3, #19, #1
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 800602a:	60d3      	str	r3, [r2, #12]
    
    /* Reset after a PHY select  */
    USB_OTG_CoreReset(pdev);
 800602c:	f7ff ff3a 	bl	8005ea4 <USB_OTG_CoreReset>
    
    if(pdev->cfg.dma_enable == 1)
 8006030:	78eb      	ldrb	r3, [r5, #3]
 8006032:	2b01      	cmp	r3, #1
 8006034:	d119      	bne.n	800606a <USB_OTG_CoreInit+0x72>
    {
      
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 8006036:	2305      	movs	r3, #5
 8006038:	f363 0444 	bfi	r4, r3, #1, #4
      ahbcfg.b.dmaenable = 1;
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 800603c:	68eb      	ldr	r3, [r5, #12]
    
    if(pdev->cfg.dma_enable == 1)
    {
      
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
      ahbcfg.b.dmaenable = 1;
 800603e:	f044 0420 	orr.w	r4, r4, #32
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 8006042:	609c      	str	r4, [r3, #8]
 8006044:	e011      	b.n	800606a <USB_OTG_CoreInit+0x72>
    }    
  }
  else /* FS interface (embedded Phy) */
  {
    
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
 8006046:	68d3      	ldr	r3, [r2, #12]
    usbcfg.b.physel  = 1; /* FS Interface */
 8006048:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 800604c:	60d3      	str	r3, [r2, #12]
    /* Reset after a PHY select and set Host mode */
    USB_OTG_CoreReset(pdev);
 800604e:	f7ff ff29 	bl	8005ea4 <USB_OTG_CoreReset>
    gccfg.b.vbussensingB = 1 ;     
#ifndef VBUS_SENSING_ENABLED
    gccfg.b.disablevbussensing = 1; 
#endif    
    
    if(pdev->cfg.Sof_output)
 8006052:	7a6b      	ldrb	r3, [r5, #9]
    {
      gccfg.b.sofouten = 1;  
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8006054:	68ea      	ldr	r2, [r5, #12]
    gccfg.b.disablevbussensing = 1; 
#endif    
    
    if(pdev->cfg.Sof_output)
    {
      gccfg.b.sofouten = 1;  
 8006056:	2b00      	cmp	r3, #0
 8006058:	bf0c      	ite	eq
 800605a:	f44f 1334 	moveq.w	r3, #2949120	; 0x2d0000
 800605e:	f44f 1374 	movne.w	r3, #3997696	; 0x3d0000
    }
    
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 8006062:	6393      	str	r3, [r2, #56]	; 0x38
    USB_OTG_BSP_mDelay(20);
 8006064:	2014      	movs	r0, #20
 8006066:	f7ff fed1 	bl	8005e0c <USB_OTG_BSP_mDelay>
  }
  /* case the HS core is working in FS mode */
  if(pdev->cfg.dma_enable == 1)
 800606a:	78eb      	ldrb	r3, [r5, #3]
 800606c:	2b01      	cmp	r3, #1
 800606e:	d107      	bne.n	8006080 <USB_OTG_CoreInit+0x88>
  {
    
    ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
 8006070:	68eb      	ldr	r3, [r5, #12]
    ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 8006072:	2205      	movs	r2, #5
  }
  /* case the HS core is working in FS mode */
  if(pdev->cfg.dma_enable == 1)
  {
    
    ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
 8006074:	689c      	ldr	r4, [r3, #8]
    ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 8006076:	f362 0444 	bfi	r4, r2, #1, #4
    ahbcfg.b.dmaenable = 1;
 800607a:	f044 0420 	orr.w	r4, r4, #32
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 800607e:	609c      	str	r4, [r3, #8]
  usbcfg.b.srpcap = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_EnableCommonInt(pdev);
#endif
  return status;
}
 8006080:	2000      	movs	r0, #0
 8006082:	bd38      	pop	{r3, r4, r5, pc}

08006084 <USB_OTG_EnableGlobalInt>:
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
 8006084:	68c3      	ldr	r3, [r0, #12]
  return status;
}
 8006086:	2000      	movs	r0, #0
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
 8006088:	689a      	ldr	r2, [r3, #8]
 800608a:	f042 0201 	orr.w	r2, r2, #1
 800608e:	609a      	str	r2, [r3, #8]
  return status;
}
 8006090:	4770      	bx	lr

08006092 <USB_OTG_DisableGlobalInt>:
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
 8006092:	68c3      	ldr	r3, [r0, #12]
  return status;
}
 8006094:	2000      	movs	r0, #0
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
 8006096:	689a      	ldr	r2, [r3, #8]
 8006098:	f022 0201 	bic.w	r2, r2, #1
 800609c:	609a      	str	r2, [r3, #8]
  return status;
}
 800609e:	4770      	bx	lr

080060a0 <USB_OTG_FlushTxFifo>:
* @param  pdev : Selected device
* @param  num : FO num
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
{
 80060a0:	b507      	push	{r0, r1, r2, lr}
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  
  uint32_t count = 0;
  greset.d32 = 0;
 80060a2:	2300      	movs	r3, #0
 80060a4:	9301      	str	r3, [sp, #4]
  greset.b.txfflsh = 1;
 80060a6:	9b01      	ldr	r3, [sp, #4]
 80060a8:	f043 0320 	orr.w	r3, r3, #32
 80060ac:	9301      	str	r3, [sp, #4]
  greset.b.txfnum  = num;
 80060ae:	9b01      	ldr	r3, [sp, #4]
 80060b0:	f361 138a 	bfi	r3, r1, #6, #5
 80060b4:	9301      	str	r3, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 80060b6:	9b01      	ldr	r3, [sp, #4]
 80060b8:	68c2      	ldr	r2, [r0, #12]
 80060ba:	6113      	str	r3, [r2, #16]
 80060bc:	4b06      	ldr	r3, [pc, #24]	; (80060d8 <USB_OTG_FlushTxFifo+0x38>)
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80060be:	6911      	ldr	r1, [r2, #16]
    if (++count > 200000)
 80060c0:	3b01      	subs	r3, #1
  greset.b.txfflsh = 1;
  greset.b.txfnum  = num;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80060c2:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
 80060c4:	d002      	beq.n	80060cc <USB_OTG_FlushTxFifo+0x2c>
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 80060c6:	9901      	ldr	r1, [sp, #4]
 80060c8:	0688      	lsls	r0, r1, #26
 80060ca:	d4f8      	bmi.n	80060be <USB_OTG_FlushTxFifo+0x1e>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 80060cc:	2003      	movs	r0, #3
 80060ce:	f7ff fe8b 	bl	8005de8 <USB_OTG_BSP_uDelay>
  return status;
}
 80060d2:	2000      	movs	r0, #0
 80060d4:	bd0e      	pop	{r1, r2, r3, pc}
 80060d6:	bf00      	nop
 80060d8:	00030d41 	.word	0x00030d41

080060dc <USB_OTG_FlushRxFifo>:
* @brief  USB_OTG_FlushRxFifo : Flush a Rx FIFO
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
{
 80060dc:	b507      	push	{r0, r1, r2, lr}
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 80060de:	2300      	movs	r3, #0
 80060e0:	9301      	str	r3, [sp, #4]
  greset.b.rxfflsh = 1;
 80060e2:	9b01      	ldr	r3, [sp, #4]
 80060e4:	f043 0310 	orr.w	r3, r3, #16
 80060e8:	9301      	str	r3, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 80060ea:	9b01      	ldr	r3, [sp, #4]
 80060ec:	68c2      	ldr	r2, [r0, #12]
 80060ee:	6113      	str	r3, [r2, #16]
 80060f0:	4b06      	ldr	r3, [pc, #24]	; (800610c <USB_OTG_FlushRxFifo+0x30>)
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80060f2:	6911      	ldr	r1, [r2, #16]
    if (++count > 200000)
 80060f4:	3b01      	subs	r3, #1
  greset.d32 = 0;
  greset.b.rxfflsh = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 80060f6:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
 80060f8:	d002      	beq.n	8006100 <USB_OTG_FlushRxFifo+0x24>
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 80060fa:	9901      	ldr	r1, [sp, #4]
 80060fc:	06c9      	lsls	r1, r1, #27
 80060fe:	d4f8      	bmi.n	80060f2 <USB_OTG_FlushRxFifo+0x16>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 8006100:	2003      	movs	r0, #3
 8006102:	f7ff fe71 	bl	8005de8 <USB_OTG_BSP_uDelay>
  return status;
}
 8006106:	2000      	movs	r0, #0
 8006108:	bd0e      	pop	{r1, r2, r3, pc}
 800610a:	bf00      	nop
 800610c:	00030d41 	.word	0x00030d41

08006110 <USB_OTG_SetCurrentMode>:
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8006110:	68c2      	ldr	r2, [r0, #12]
* @param  pdev : Selected device
* @param  mode :  (Host/device)
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
{
 8006112:	b508      	push	{r3, lr}
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 8006114:	68d3      	ldr	r3, [r2, #12]
  
  usbcfg.b.force_host = 0;
  usbcfg.b.force_dev = 0;
  
  if ( mode == HOST_MODE)
 8006116:	2901      	cmp	r1, #1
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
  
  usbcfg.b.force_host = 0;
 8006118:	f36f 735d 	bfc	r3, #29, #1
  usbcfg.b.force_dev = 0;
 800611c:	f36f 739e 	bfc	r3, #30, #1
  
  if ( mode == HOST_MODE)
 8006120:	d102      	bne.n	8006128 <USB_OTG_SetCurrentMode+0x18>
  {
    usbcfg.b.force_host = 1;
 8006122:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8006126:	e002      	b.n	800612e <USB_OTG_SetCurrentMode+0x1e>
  }
  else if ( mode == DEVICE_MODE)
 8006128:	b909      	cbnz	r1, 800612e <USB_OTG_SetCurrentMode+0x1e>
  {
    usbcfg.b.force_dev = 1;
 800612a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
  USB_OTG_BSP_mDelay(50);
 800612e:	2032      	movs	r0, #50	; 0x32
  else if ( mode == DEVICE_MODE)
  {
    usbcfg.b.force_dev = 1;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 8006130:	60d3      	str	r3, [r2, #12]
  USB_OTG_BSP_mDelay(50);
 8006132:	f7ff fe6b 	bl	8005e0c <USB_OTG_BSP_mDelay>
  return status;
}
 8006136:	2000      	movs	r0, #0
 8006138:	bd08      	pop	{r3, pc}

0800613a <USB_OTG_GetMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 800613a:	68c3      	ldr	r3, [r0, #12]
 800613c:	6958      	ldr	r0, [r3, #20]
}
 800613e:	f000 0001 	and.w	r0, r0, #1
 8006142:	4770      	bx	lr

08006144 <USB_OTG_IsDeviceMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 8006144:	68c3      	ldr	r3, [r0, #12]
 8006146:	6958      	ldr	r0, [r3, #20]
 8006148:	f000 0001 	and.w	r0, r0, #1
* @retval num_in_ep
*/
uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_GetMode(pdev) != HOST_MODE);
}
 800614c:	f080 0001 	eor.w	r0, r0, #1
 8006150:	4770      	bx	lr

08006152 <USB_OTG_IsHostMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 8006152:	68c3      	ldr	r3, [r0, #12]
 8006154:	6958      	ldr	r0, [r3, #20]
* @retval num_in_ep
*/
uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_GetMode(pdev) == HOST_MODE);
}
 8006156:	f000 0001 	and.w	r0, r0, #1
 800615a:	4770      	bx	lr

0800615c <USB_OTG_ReadCoreItr>:
* @retval Status
*/
uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v = 0;
  v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
 800615c:	68c3      	ldr	r3, [r0, #12]
 800615e:	695a      	ldr	r2, [r3, #20]
  v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
 8006160:	6998      	ldr	r0, [r3, #24]
  return v;
}
 8006162:	4010      	ands	r0, r2
 8006164:	4770      	bx	lr

08006166 <USB_OTG_ReadOtgItr>:
* @param  pdev : Selected device
* @retval Status
*/
uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
 8006166:	68c3      	ldr	r3, [r0, #12]
 8006168:	6858      	ldr	r0, [r3, #4]
}
 800616a:	4770      	bx	lr

0800616c <USB_OTG_IsEvenFrame>:
* @param  pdev : Selected device
* @retval Frame number
*/
uint8_t USB_OTG_IsEvenFrame (USB_OTG_CORE_HANDLE *pdev) 
{
  return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
 800616c:	6943      	ldr	r3, [r0, #20]
 800616e:	6898      	ldr	r0, [r3, #8]
 8006170:	f000 0001 	and.w	r0, r0, #1
}
 8006174:	f080 0001 	eor.w	r0, r0, #1
 8006178:	4770      	bx	lr

0800617a <USB_OTG_EnableHostInt>:
{
  USB_OTG_STS       status = USB_OTG_OK;
  USB_OTG_GINTMSK_TypeDef  intmsk;
  intmsk.d32 = 0;
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
 800617a:	68c2      	ldr	r2, [r0, #12]
*/
USB_OTG_STS USB_OTG_EnableHostInt(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_STS       status = USB_OTG_OK;
  USB_OTG_GINTMSK_TypeDef  intmsk;
  intmsk.d32 = 0;
 800617c:	2300      	movs	r3, #0
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
 800617e:	6193      	str	r3, [r2, #24]
  
  /* Clear any pending interrupts. */
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 8006180:	f04f 33ff 	mov.w	r3, #4294967295
 8006184:	6153      	str	r3, [r2, #20]
  USB_OTG_GINTMSK_TypeDef  int_mask;
  
  int_mask.d32 = 0;
  /* Clear any pending USB_OTG Interrupts */
#ifndef USE_OTG_MODE
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
 8006186:	6053      	str	r3, [r2, #4]
#endif
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
 8006188:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 800618c:	6153      	str	r3, [r2, #20]
  /* Enable the interrupts in the INTMSK */
  int_mask.b.wkupintr = 1;
  int_mask.b.usbsuspend = 1; 
 800618e:	4b0a      	ldr	r3, [pc, #40]	; (80061b8 <USB_OTG_EnableHostInt+0x3e>)
#ifdef USE_OTG_MODE
  int_mask.b.otgintr = 1;
  int_mask.b.sessreqintr = 1;
  int_mask.b.conidstschng = 1;
#endif
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
 8006190:	6193      	str	r3, [r2, #24]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
  
  /* Enable the common interrupts */
  USB_OTG_EnableCommonInt(pdev);
  
  if (pdev->cfg.dma_enable == 0)
 8006192:	78c3      	ldrb	r3, [r0, #3]
  intmsk.b.portintr   = 1;
  intmsk.b.hcintr     = 1;
  intmsk.b.disconnect = 1;  
  intmsk.b.sofintr    = 1;  
  intmsk.b.incomplisoout  = 1; 
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 8006194:	6991      	ldr	r1, [r2, #24]
  /* Enable the common interrupts */
  USB_OTG_EnableCommonInt(pdev);
  
  if (pdev->cfg.dma_enable == 0)
  {  
    intmsk.b.rxstsqlvl  = 1;
 8006196:	2b00      	cmp	r3, #0
 8006198:	bf0c      	ite	eq
 800619a:	2310      	moveq	r3, #16
 800619c:	2300      	movne	r3, #0
  }  
  intmsk.b.portintr   = 1;
  intmsk.b.hcintr     = 1;
  intmsk.b.disconnect = 1;  
  intmsk.b.sofintr    = 1;  
  intmsk.b.incomplisoout  = 1; 
 800619e:	f043 530c 	orr.w	r3, r3, #587202560	; 0x23000000
 80061a2:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80061a6:	f043 0308 	orr.w	r3, r3, #8
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 80061aa:	ea21 0103 	bic.w	r1, r1, r3
 80061ae:	430b      	orrs	r3, r1
 80061b0:	6193      	str	r3, [r2, #24]
  return status;
}
 80061b2:	2000      	movs	r0, #0
 80061b4:	4770      	bx	lr
 80061b6:	bf00      	nop
 80061b8:	80000800 	.word	0x80000800

080061bc <USB_OTG_InitFSLSPClkSel>:
*/
void USB_OTG_InitFSLSPClkSel(USB_OTG_CORE_HANDLE *pdev , uint8_t freq)
{
  USB_OTG_HCFG_TypeDef   hcfg;
  
  hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
 80061bc:	6943      	ldr	r3, [r0, #20]
 80061be:	681a      	ldr	r2, [r3, #0]
  hcfg.b.fslspclksel = freq;
 80061c0:	f361 0201 	bfi	r2, r1, #0, #2
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
 80061c4:	601a      	str	r2, [r3, #0]
 80061c6:	4770      	bx	lr

080061c8 <USB_OTG_ReadHPRT0>:
*/
uint32_t USB_OTG_ReadHPRT0(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_HPRT0_TypeDef  hprt0;
  
  hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 80061c8:	f8d0 30cc 	ldr.w	r3, [r0, #204]	; 0xcc
 80061cc:	6818      	ldr	r0, [r3, #0]
  hprt0.b.prtena = 0;
  hprt0.b.prtconndet = 0;
  hprt0.b.prtenchng = 0;
  hprt0.b.prtovrcurrchng = 0;
  return hprt0.d32;
}
 80061ce:	f020 002e 	bic.w	r0, r0, #46	; 0x2e
 80061d2:	4770      	bx	lr

080061d4 <USB_OTG_DriveVbus>:
* @param  pdev : Selected device
* @param  state : VBUS state
* @retval None
*/
void USB_OTG_DriveVbus (USB_OTG_CORE_HANDLE *pdev, uint8_t state)
{
 80061d4:	b538      	push	{r3, r4, r5, lr}
 80061d6:	4604      	mov	r4, r0
 80061d8:	460d      	mov	r5, r1
  USB_OTG_HPRT0_TypeDef     hprt0;
  
  hprt0.d32 = 0;
  
  /* enable disable the external charge pump */
  USB_OTG_BSP_DriveVBUS(pdev, state);
 80061da:	f7ff fdf9 	bl	8005dd0 <USB_OTG_BSP_DriveVBUS>
  
  /* Turn on the Host port power. */
  hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
 80061de:	4620      	mov	r0, r4
 80061e0:	f7ff fff2 	bl	80061c8 <USB_OTG_ReadHPRT0>
  if ((hprt0.b.prtpwr == 0 ) && (state == 1 ))
 80061e4:	f3c0 2207 	ubfx	r2, r0, #8, #8
 80061e8:	f002 0210 	and.w	r2, r2, #16
 80061ec:	b2d2      	uxtb	r2, r2
 80061ee:	b932      	cbnz	r2, 80061fe <USB_OTG_DriveVbus+0x2a>
 80061f0:	2d01      	cmp	r5, #1
 80061f2:	d104      	bne.n	80061fe <USB_OTG_DriveVbus+0x2a>
  {
    hprt0.b.prtpwr = 1;
    USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 80061f4:	f8d4 20cc 	ldr.w	r2, [r4, #204]	; 0xcc
  
  /* Turn on the Host port power. */
  hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
  if ((hprt0.b.prtpwr == 0 ) && (state == 1 ))
  {
    hprt0.b.prtpwr = 1;
 80061f8:	f440 5080 	orr.w	r0, r0, #4096	; 0x1000
    USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 80061fc:	6010      	str	r0, [r2, #0]
  }
  if ((hprt0.b.prtpwr == 1 ) && (state == 0 ))
 80061fe:	f3c0 2207 	ubfx	r2, r0, #8, #8
 8006202:	f002 0210 	and.w	r2, r2, #16
 8006206:	b2d2      	uxtb	r2, r2
 8006208:	b12a      	cbz	r2, 8006216 <USB_OTG_DriveVbus+0x42>
 800620a:	b925      	cbnz	r5, 8006216 <USB_OTG_DriveVbus+0x42>
  {
    hprt0.b.prtpwr = 0;
    USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 800620c:	f8d4 20cc 	ldr.w	r2, [r4, #204]	; 0xcc
    hprt0.b.prtpwr = 1;
    USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
  }
  if ((hprt0.b.prtpwr == 1 ) && (state == 0 ))
  {
    hprt0.b.prtpwr = 0;
 8006210:	f365 300c 	bfi	r0, r5, #12, #1
    USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 8006214:	6010      	str	r0, [r2, #0]
  }
  
  USB_OTG_BSP_mDelay(200);
 8006216:	20c8      	movs	r0, #200	; 0xc8
}
 8006218:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  {
    hprt0.b.prtpwr = 0;
    USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
  }
  
  USB_OTG_BSP_mDelay(200);
 800621c:	f7ff bdf6 	b.w	8005e0c <USB_OTG_BSP_mDelay>

08006220 <USB_OTG_ReadHostAllChannels_intr>:
* @param  pdev : Selected device
* @retval Status
*/
uint32_t USB_OTG_ReadHostAllChannels_intr (USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32 (&pdev->regs.HREGS->HAINT));
 8006220:	6943      	ldr	r3, [r0, #20]
 8006222:	6958      	ldr	r0, [r3, #20]
}
 8006224:	4770      	bx	lr

08006226 <USB_OTG_ResetPort>:
* @retval status
* @note : (1)The application must wait at least 10 ms (+ 10 ms security)
*   before clearing the reset bit.
*/
uint32_t USB_OTG_ResetPort(USB_OTG_CORE_HANDLE *pdev)
{
 8006226:	b538      	push	{r3, r4, r5, lr}
 8006228:	4605      	mov	r5, r0
  USB_OTG_HPRT0_TypeDef  hprt0;
  
  hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
 800622a:	f7ff ffcd 	bl	80061c8 <USB_OTG_ReadHPRT0>
  hprt0.b.prtrst = 1;
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 800622e:	f8d5 30cc 	ldr.w	r3, [r5, #204]	; 0xcc
uint32_t USB_OTG_ResetPort(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_HPRT0_TypeDef  hprt0;
  
  hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
  hprt0.b.prtrst = 1;
 8006232:	f440 7480 	orr.w	r4, r0, #256	; 0x100
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 8006236:	601c      	str	r4, [r3, #0]
  USB_OTG_BSP_mDelay (10);                                /* See Note #1 */
 8006238:	200a      	movs	r0, #10
 800623a:	f7ff fde7 	bl	8005e0c <USB_OTG_BSP_mDelay>
  hprt0.b.prtrst = 0;
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 800623e:	f8d5 30cc 	ldr.w	r3, [r5, #204]	; 0xcc
  
  hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
  hprt0.b.prtrst = 1;
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
  USB_OTG_BSP_mDelay (10);                                /* See Note #1 */
  hprt0.b.prtrst = 0;
 8006242:	f36f 2408 	bfc	r4, #8, #1
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
  USB_OTG_BSP_mDelay (20);   
 8006246:	2014      	movs	r0, #20
  hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
  hprt0.b.prtrst = 1;
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
  USB_OTG_BSP_mDelay (10);                                /* See Note #1 */
  hprt0.b.prtrst = 0;
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 8006248:	601c      	str	r4, [r3, #0]
  USB_OTG_BSP_mDelay (20);   
 800624a:	f7ff fddf 	bl	8005e0c <USB_OTG_BSP_mDelay>
  return 1;
}
 800624e:	2001      	movs	r0, #1
 8006250:	bd38      	pop	{r3, r4, r5, pc}

08006252 <USB_OTG_CoreInitHost>:
* @brief  USB_OTG_CoreInitHost : Initializes USB_OTG controller for host mode
* @param  pdev : Selected device
* @retval status
*/
USB_OTG_STS USB_OTG_CoreInitHost(USB_OTG_CORE_HANDLE *pdev)
{
 8006252:	b570      	push	{r4, r5, r6, lr}
 8006254:	4604      	mov	r4, r0
#endif
  hcfg.d32 = 0;
  
  
  /* configure charge pump IO */
  USB_OTG_BSP_ConfigVBUS(pdev);
 8006256:	f7ff fdeb 	bl	8005e30 <USB_OTG_BSP_ConfigVBUS>
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 800625a:	f8d4 310c 	ldr.w	r3, [r4, #268]	; 0x10c
  USB_OTG_OTGCTL_TypeDef          gotgctl;
#endif
  
  uint32_t                        i = 0;
  
  nptxfifosize.d32 = 0;  
 800625e:	2500      	movs	r5, #0
  
  /* configure charge pump IO */
  USB_OTG_BSP_ConfigVBUS(pdev);
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 8006260:	601d      	str	r5, [r3, #0]
  
  /* Initialize Host Configuration Register */
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8006262:	7a23      	ldrb	r3, [r4, #8]
  {
    USB_OTG_InitFSLSPClkSel(pdev , HCFG_30_60_MHZ); 
 8006264:	4620      	mov	r0, r4
  
  /* Restart the Phy Clock */
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
  
  /* Initialize Host Configuration Register */
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 8006266:	2b01      	cmp	r3, #1
  {
    USB_OTG_InitFSLSPClkSel(pdev , HCFG_30_60_MHZ); 
 8006268:	bf0c      	ite	eq
 800626a:	4629      	moveq	r1, r5
  }
  else
  {
    USB_OTG_InitFSLSPClkSel(pdev , HCFG_48_MHZ); 
 800626c:	2101      	movne	r1, #1
 800626e:	f7ff ffa5 	bl	80061bc <USB_OTG_InitFSLSPClkSel>
  }
  USB_OTG_ResetPort(pdev);
 8006272:	4620      	mov	r0, r4
 8006274:	f7ff ffd7 	bl	8006226 <USB_OTG_ResetPort>
  
  hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
 8006278:	6963      	ldr	r3, [r4, #20]
#endif
  
  uint32_t                        i = 0;
  
  nptxfifosize.d32 = 0;  
  ptxfifosize.d32 = 0;
 800627a:	462e      	mov	r6, r5
  {
    USB_OTG_InitFSLSPClkSel(pdev , HCFG_48_MHZ); 
  }
  USB_OTG_ResetPort(pdev);
  
  hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
 800627c:	681a      	ldr	r2, [r3, #0]
  hcfg.b.fslssupp = 0;
 800627e:	f36f 0282 	bfc	r2, #2, #1
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
 8006282:	601a      	str	r2, [r3, #0]
  
  /* Configure data FIFO sizes */
  /* Rx FIFO */
#ifdef USB_OTG_FS_CORE
  if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID)
 8006284:	7ae3      	ldrb	r3, [r4, #11]
 8006286:	2b01      	cmp	r3, #1
 8006288:	d10e      	bne.n	80062a8 <USB_OTG_CoreInitHost+0x56>
  {
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 800628a:	68e3      	ldr	r3, [r4, #12]
 800628c:	2280      	movs	r2, #128	; 0x80
 800628e:	625a      	str	r2, [r3, #36]	; 0x24
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;   
 8006290:	f362 050f 	bfi	r5, r2, #0, #16
    nptxfifosize.b.depth = TXH_NP_FS_FIFOSIZ;  
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
    
    ptxfifosize.b.startaddr = RX_FIFO_FS_SIZE + TXH_NP_FS_FIFOSIZ;
 8006294:	22e0      	movs	r2, #224	; 0xe0
 8006296:	f362 060f 	bfi	r6, r2, #0, #16
  if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID)
  {
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;   
    nptxfifosize.b.depth = TXH_NP_FS_FIFOSIZ;  
 800629a:	f2c0 0560 	movt	r5, #96	; 0x60
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
    
    ptxfifosize.b.startaddr = RX_FIFO_FS_SIZE + TXH_NP_FS_FIFOSIZ;
    ptxfifosize.b.depth     = TXH_P_FS_FIFOSIZ;
 800629e:	f2c0 0660 	movt	r6, #96	; 0x60
  {
    /* set Rx FIFO size */
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;   
    nptxfifosize.b.depth = TXH_NP_FS_FIFOSIZ;  
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
 80062a2:	629d      	str	r5, [r3, #40]	; 0x28
    
    ptxfifosize.b.startaddr = RX_FIFO_FS_SIZE + TXH_NP_FS_FIFOSIZ;
    ptxfifosize.b.depth     = TXH_P_FS_FIFOSIZ;
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
 80062a4:	f8c3 6100 	str.w	r6, [r3, #256]	; 0x100
  gotgctl.b.hstsethnpen = 1;
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GOTGCTL, gotgctl.d32, 0);
#endif
  
  /* Make sure the FIFOs are flushed. */
  USB_OTG_FlushTxFifo(pdev, 0x10 );         /* all Tx FIFOs */
 80062a8:	2110      	movs	r1, #16
 80062aa:	4620      	mov	r0, r4
 80062ac:	f7ff fef8 	bl	80060a0 <USB_OTG_FlushTxFifo>
  USB_OTG_FlushRxFifo(pdev);
 80062b0:	4620      	mov	r0, r4
 80062b2:	f7ff ff13 	bl	80060dc <USB_OTG_FlushRxFifo>
  
  
  /* Clear all pending HC Interrupts */
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80062b6:	2300      	movs	r3, #0
  {
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80062b8:	f04f 31ff 	mov.w	r1, #4294967295
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINTMSK, 0 );
 80062bc:	4618      	mov	r0, r3
  USB_OTG_FlushTxFifo(pdev, 0x10 );         /* all Tx FIFOs */
  USB_OTG_FlushRxFifo(pdev);
  
  
  /* Clear all pending HC Interrupts */
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80062be:	e006      	b.n	80062ce <USB_OTG_CoreInitHost+0x7c>
/**
* @brief  USB_OTG_CoreInitHost : Initializes USB_OTG controller for host mode
* @param  pdev : Selected device
* @retval status
*/
USB_OTG_STS USB_OTG_CoreInitHost(USB_OTG_CORE_HANDLE *pdev)
 80062c0:	eb04 0283 	add.w	r2, r4, r3, lsl #2
  
  
  /* Clear all pending HC Interrupts */
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80062c4:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
  USB_OTG_FlushTxFifo(pdev, 0x10 );         /* all Tx FIFOs */
  USB_OTG_FlushRxFifo(pdev);
  
  
  /* Clear all pending HC Interrupts */
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80062c8:	3301      	adds	r3, #1
  {
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 80062ca:	6091      	str	r1, [r2, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINTMSK, 0 );
 80062cc:	60d0      	str	r0, [r2, #12]
  USB_OTG_FlushTxFifo(pdev, 0x10 );         /* all Tx FIFOs */
  USB_OTG_FlushRxFifo(pdev);
  
  
  /* Clear all pending HC Interrupts */
  for (i = 0; i < pdev->cfg.host_channels; i++)
 80062ce:	7822      	ldrb	r2, [r4, #0]
 80062d0:	4293      	cmp	r3, r2
 80062d2:	d3f5      	bcc.n	80062c0 <USB_OTG_CoreInitHost+0x6e>
  {
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINTMSK, 0 );
  }
#ifndef USE_OTG_MODE
  USB_OTG_DriveVbus(pdev, 1);
 80062d4:	4620      	mov	r0, r4
 80062d6:	2101      	movs	r1, #1
 80062d8:	f7ff ff7c 	bl	80061d4 <USB_OTG_DriveVbus>
#endif
  
  USB_OTG_EnableHostInt(pdev);
 80062dc:	4620      	mov	r0, r4
 80062de:	f7ff ff4c 	bl	800617a <USB_OTG_EnableHostInt>
  return status;
}
 80062e2:	2000      	movs	r0, #0
 80062e4:	bd70      	pop	{r4, r5, r6, pc}

080062e6 <USB_OTG_HC_Init>:
* @param  pdev : Selected device
* @param  hc_num : channel number
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_HC_Init(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
{
 80062e6:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (pdev->cfg.dma_enable == 1)
  {
    hcintmsk.b.ahberr = 1;
  }
  
  switch (pdev->host.hc[hc_num].ep_type) 
 80062e8:	2624      	movs	r6, #36	; 0x24
  hcintmsk.d32 = 0;
  hcchar.d32 = 0;
  
  /* Clear old interrupt conditions for this host channel. */
  hcint.d32 = 0xFFFFFFFF;
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINT, hcint.d32);
 80062ea:	eb00 0381 	add.w	r3, r0, r1, lsl #2
  if (pdev->cfg.dma_enable == 1)
  {
    hcintmsk.b.ahberr = 1;
  }
  
  switch (pdev->host.hc[hc_num].ep_type) 
 80062ee:	fb06 0501 	mla	r5, r6, r1, r0
  hcintmsk.d32 = 0;
  hcchar.d32 = 0;
  
  /* Clear old interrupt conditions for this host channel. */
  hcint.d32 = 0xFFFFFFFF;
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINT, hcint.d32);
 80062f2:	f8d3 4090 	ldr.w	r4, [r3, #144]	; 0x90
 80062f6:	f04f 33ff 	mov.w	r3, #4294967295
 80062fa:	60a3      	str	r3, [r4, #8]
  
  /* Enable channel interrupts required for this transfer. */
  hcintmsk.d32 = 0;
  
  if (pdev->cfg.dma_enable == 1)
 80062fc:	78c3      	ldrb	r3, [r0, #3]
  {
    hcintmsk.b.ahberr = 1;
  }
  
  switch (pdev->host.hc[hc_num].ep_type) 
 80062fe:	f895 53b1 	ldrb.w	r5, [r5, #945]	; 0x3b1
  USB_OTG_HCINTn_TypeDef     hcint;
  
  
  gintmsk.d32 = 0;
  hcintmsk.d32 = 0;
  hcchar.d32 = 0;
 8006302:	2200      	movs	r2, #0
  /* Enable channel interrupts required for this transfer. */
  hcintmsk.d32 = 0;
  
  if (pdev->cfg.dma_enable == 1)
  {
    hcintmsk.b.ahberr = 1;
 8006304:	2b01      	cmp	r3, #1
 8006306:	bf0c      	ite	eq
 8006308:	2304      	moveq	r3, #4
 800630a:	4613      	movne	r3, r2
  }
  
  switch (pdev->host.hc[hc_num].ep_type) 
 800630c:	2d03      	cmp	r5, #3
 800630e:	d82f      	bhi.n	8006370 <USB_OTG_HC_Init+0x8a>
 8006310:	e8df f005 	tbb	[pc, r5]
 8006314:	16022302 	.word	0x16022302
    hcintmsk.b.xfercompl = 1;
    hcintmsk.b.stall = 1;
    hcintmsk.b.xacterr = 1;
    hcintmsk.b.datatglerr = 1;
    hcintmsk.b.nak = 1;  
    if (pdev->host.hc[hc_num].ep_is_in) 
 8006318:	2524      	movs	r5, #36	; 0x24
 800631a:	fb05 0501 	mla	r5, r5, r1, r0
 800631e:	f505 766a 	add.w	r6, r5, #936	; 0x3a8
 8006322:	f895 53ae 	ldrb.w	r5, [r5, #942]	; 0x3ae
  {
  case EP_TYPE_CTRL:
  case EP_TYPE_BULK:
    hcintmsk.b.xfercompl = 1;
    hcintmsk.b.stall = 1;
    hcintmsk.b.xacterr = 1;
 8006326:	f043 0389 	orr.w	r3, r3, #137	; 0x89
    hcintmsk.b.datatglerr = 1;
    hcintmsk.b.nak = 1;  
 800632a:	f443 6382 	orr.w	r3, r3, #1040	; 0x410
    if (pdev->host.hc[hc_num].ep_is_in) 
 800632e:	b105      	cbz	r5, 8006332 <USB_OTG_HC_Init+0x4c>
 8006330:	e010      	b.n	8006354 <USB_OTG_HC_Init+0x6e>
      hcintmsk.b.bblerr = 1;
    } 
    else 
    {
      hcintmsk.b.nyet = 1;
      if (pdev->host.hc[hc_num].do_ping) 
 8006332:	7a35      	ldrb	r5, [r6, #8]
    {
      hcintmsk.b.bblerr = 1;
    } 
    else 
    {
      hcintmsk.b.nyet = 1;
 8006334:	f043 0340 	orr.w	r3, r3, #64	; 0x40
      if (pdev->host.hc[hc_num].do_ping) 
 8006338:	b1d5      	cbz	r5, 8006370 <USB_OTG_HC_Init+0x8a>
      {
        hcintmsk.b.ack = 1;
 800633a:	f043 0320 	orr.w	r3, r3, #32
 800633e:	e017      	b.n	8006370 <USB_OTG_HC_Init+0x8a>
    hcintmsk.b.stall = 1;
    hcintmsk.b.xacterr = 1;
    hcintmsk.b.datatglerr = 1;
    hcintmsk.b.frmovrun = 1;
    
    if (pdev->host.hc[hc_num].ep_is_in) 
 8006340:	2524      	movs	r5, #36	; 0x24
 8006342:	fb05 0501 	mla	r5, r5, r1, r0
 8006346:	f895 53ae 	ldrb.w	r5, [r5, #942]	; 0x3ae
    break;
  case EP_TYPE_INTR:
    hcintmsk.b.xfercompl = 1;
    hcintmsk.b.nak = 1;
    hcintmsk.b.stall = 1;
    hcintmsk.b.xacterr = 1;
 800634a:	f043 0399 	orr.w	r3, r3, #153	; 0x99
    hcintmsk.b.datatglerr = 1;
    hcintmsk.b.frmovrun = 1;
 800634e:	f443 63c0 	orr.w	r3, r3, #1536	; 0x600
    
    if (pdev->host.hc[hc_num].ep_is_in) 
 8006352:	b16d      	cbz	r5, 8006370 <USB_OTG_HC_Init+0x8a>
    {
      hcintmsk.b.bblerr = 1;
 8006354:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8006358:	e00a      	b.n	8006370 <USB_OTG_HC_Init+0x8a>
  case EP_TYPE_ISOC:
    hcintmsk.b.xfercompl = 1;
    hcintmsk.b.frmovrun = 1;
    hcintmsk.b.ack = 1;
    
    if (pdev->host.hc[hc_num].ep_is_in) 
 800635a:	fb06 0601 	mla	r6, r6, r1, r0
 800635e:	f896 53ae 	ldrb.w	r5, [r6, #942]	; 0x3ae
      hcintmsk.b.bblerr = 1;
    }
    
    break;
  case EP_TYPE_ISOC:
    hcintmsk.b.xfercompl = 1;
 8006362:	f043 0301 	orr.w	r3, r3, #1
    hcintmsk.b.frmovrun = 1;
    hcintmsk.b.ack = 1;
 8006366:	f443 7308 	orr.w	r3, r3, #544	; 0x220
    
    if (pdev->host.hc[hc_num].ep_is_in) 
 800636a:	b10d      	cbz	r5, 8006370 <USB_OTG_HC_Init+0x8a>
    {
      hcintmsk.b.xacterr = 1;
      hcintmsk.b.bblerr = 1;
 800636c:	f443 73c0 	orr.w	r3, r3, #384	; 0x180
  
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINTMSK, hcintmsk.d32);
  
  
  /* Enable the top level host channel interrupt. */
  intr_enable = (1 << hc_num);
 8006370:	2501      	movs	r5, #1
 8006372:	fa05 f501 	lsl.w	r5, r5, r1
    }
    break;
  }
  
  
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINTMSK, hcintmsk.d32);
 8006376:	60e3      	str	r3, [r4, #12]
  
  
  /* Enable the top level host channel interrupt. */
  intr_enable = (1 << hc_num);
  USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
 8006378:	6943      	ldr	r3, [r0, #20]
 800637a:	699e      	ldr	r6, [r3, #24]
 800637c:	4335      	orrs	r5, r6
 800637e:	619d      	str	r5, [r3, #24]
  
  /* Make sure host channel interrupts are enabled. */
  gintmsk.b.hcintr = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
 8006380:	68c3      	ldr	r3, [r0, #12]
 8006382:	699d      	ldr	r5, [r3, #24]
 8006384:	f045 7500 	orr.w	r5, r5, #33554432	; 0x2000000
 8006388:	619d      	str	r5, [r3, #24]
  
  /* Program the HCCHAR register */
  hcchar.d32 = 0;
  hcchar.b.devaddr = pdev->host.hc[hc_num].dev_addr;
 800638a:	2324      	movs	r3, #36	; 0x24
 800638c:	fb03 0001 	mla	r0, r3, r1, r0
 8006390:	f890 33ac 	ldrb.w	r3, [r0, #940]	; 0x3ac
  hcchar.b.epnum   = pdev->host.hc[hc_num].ep_num;
  hcchar.b.epdir   = pdev->host.hc[hc_num].ep_is_in;
  hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
  hcchar.b.eptype  = pdev->host.hc[hc_num].ep_type;
  hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
 8006394:	f8b0 13b2 	ldrh.w	r1, [r0, #946]	; 0x3b2
  gintmsk.b.hcintr = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
  
  /* Program the HCCHAR register */
  hcchar.d32 = 0;
  hcchar.b.devaddr = pdev->host.hc[hc_num].dev_addr;
 8006398:	f363 529c 	bfi	r2, r3, #22, #7
  hcchar.b.epnum   = pdev->host.hc[hc_num].ep_num;
 800639c:	f890 33ad 	ldrb.w	r3, [r0, #941]	; 0x3ad
 80063a0:	f363 22ce 	bfi	r2, r3, #11, #4
  hcchar.b.epdir   = pdev->host.hc[hc_num].ep_is_in;
 80063a4:	f890 33ae 	ldrb.w	r3, [r0, #942]	; 0x3ae
 80063a8:	f363 32cf 	bfi	r2, r3, #15, #1
  hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
 80063ac:	f890 33af 	ldrb.w	r3, [r0, #943]	; 0x3af
 80063b0:	f1b3 0c02 	subs.w	ip, r3, #2
 80063b4:	f1dc 0300 	rsbs	r3, ip, #0
 80063b8:	eb53 030c 	adcs.w	r3, r3, ip
 80063bc:	f363 4251 	bfi	r2, r3, #17, #1
  hcchar.b.eptype  = pdev->host.hc[hc_num].ep_type;
 80063c0:	f890 33b1 	ldrb.w	r3, [r0, #945]	; 0x3b1
 80063c4:	f363 4293 	bfi	r2, r3, #18, #2
  hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
 80063c8:	f361 020a 	bfi	r2, r1, #0, #11
  if (pdev->host.hc[hc_num].ep_type == HCCHAR_INTR)
 80063cc:	2b03      	cmp	r3, #3
  {
    hcchar.b.oddfrm  = 1;
 80063ce:	bf08      	it	eq
 80063d0:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
  }
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 80063d4:	6022      	str	r2, [r4, #0]
  return status;
}
 80063d6:	2000      	movs	r0, #0
 80063d8:	bdf0      	pop	{r4, r5, r6, r7, pc}

080063da <USB_OTG_HC_StartXfer>:
* @param  pdev : Selected device
* @param  hc_num : channel number
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_HC_StartXfer(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
{
 80063da:	b570      	push	{r4, r5, r6, lr}
 80063dc:	460d      	mov	r5, r1
  hctsiz.d32 = 0;
  hcchar.d32 = 0;
  intmsk.d32 = 0;
  
  /* Compute the expected number of packets associated to the transfer */
  if (pdev->host.hc[hc_num].xfer_len > 0)
 80063de:	2124      	movs	r1, #36	; 0x24
 80063e0:	fb01 0105 	mla	r1, r1, r5, r0
 80063e4:	f8d1 33bc 	ldr.w	r3, [r1, #956]	; 0x3bc
* @param  pdev : Selected device
* @param  hc_num : channel number
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_HC_StartXfer(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
{
 80063e8:	b086      	sub	sp, #24
 80063ea:	4604      	mov	r4, r0
  
  uint16_t num_packets;
  uint16_t max_hc_pkt_count;
  
  max_hc_pkt_count = 256;
  hctsiz.d32 = 0;
 80063ec:	2200      	movs	r2, #0
  hcchar.d32 = 0;
  intmsk.d32 = 0;
  
  /* Compute the expected number of packets associated to the transfer */
  if (pdev->host.hc[hc_num].xfer_len > 0)
 80063ee:	b17b      	cbz	r3, 8006410 <USB_OTG_HC_StartXfer+0x36>
  {
    num_packets = (pdev->host.hc[hc_num].xfer_len + \
      pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
 80063f0:	f8b1 03b2 	ldrh.w	r0, [r1, #946]	; 0x3b2
  intmsk.d32 = 0;
  
  /* Compute the expected number of packets associated to the transfer */
  if (pdev->host.hc[hc_num].xfer_len > 0)
  {
    num_packets = (pdev->host.hc[hc_num].xfer_len + \
 80063f4:	3b01      	subs	r3, #1
      pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
 80063f6:	181b      	adds	r3, r3, r0
 80063f8:	fbb3 f3f0 	udiv	r3, r3, r0
  intmsk.d32 = 0;
  
  /* Compute the expected number of packets associated to the transfer */
  if (pdev->host.hc[hc_num].xfer_len > 0)
  {
    num_packets = (pdev->host.hc[hc_num].xfer_len + \
 80063fc:	b29b      	uxth	r3, r3
      pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
    
    if (num_packets > max_hc_pkt_count)
 80063fe:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8006402:	d906      	bls.n	8006412 <USB_OTG_HC_StartXfer+0x38>
    {
      num_packets = max_hc_pkt_count;
      pdev->host.hc[hc_num].xfer_len = num_packets * \
 8006404:	0200      	lsls	r0, r0, #8
 8006406:	f8c1 03bc 	str.w	r0, [r1, #956]	; 0x3bc
    num_packets = (pdev->host.hc[hc_num].xfer_len + \
      pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
    
    if (num_packets > max_hc_pkt_count)
    {
      num_packets = max_hc_pkt_count;
 800640a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800640e:	e000      	b.n	8006412 <USB_OTG_HC_StartXfer+0x38>
        pdev->host.hc[hc_num].max_packet;
    }
  }
  else
  {
    num_packets = 1;
 8006410:	2301      	movs	r3, #1
  }
  if (pdev->host.hc[hc_num].ep_is_in)
 8006412:	2124      	movs	r1, #36	; 0x24
 8006414:	fb01 4005 	mla	r0, r1, r5, r4
 8006418:	f890 63ae 	ldrb.w	r6, [r0, #942]	; 0x3ae
 800641c:	b126      	cbz	r6, 8006428 <USB_OTG_HC_StartXfer+0x4e>
  {
    pdev->host.hc[hc_num].xfer_len = num_packets * \
 800641e:	f8b0 63b2 	ldrh.w	r6, [r0, #946]	; 0x3b2
 8006422:	435e      	muls	r6, r3
 8006424:	f8c0 63bc 	str.w	r6, [r0, #956]	; 0x3bc
      pdev->host.hc[hc_num].max_packet;
  }
  /* Initialize the HCTSIZn register */
  hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
 8006428:	fb01 4105 	mla	r1, r1, r5, r4
 800642c:	f8d1 03bc 	ldr.w	r0, [r1, #956]	; 0x3bc
 8006430:	f360 0212 	bfi	r2, r0, #0, #19
  hctsiz.b.pktcnt = num_packets;
 8006434:	f363 42dc 	bfi	r2, r3, #19, #10
  hctsiz.b.pid = pdev->host.hc[hc_num].data_pid;
 8006438:	f891 33b4 	ldrb.w	r3, [r1, #948]	; 0x3b4
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
  }
  
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
  hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
 800643c:	4620      	mov	r0, r4
      pdev->host.hc[hc_num].max_packet;
  }
  /* Initialize the HCTSIZn register */
  hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
  hctsiz.b.pktcnt = num_packets;
  hctsiz.b.pid = pdev->host.hc[hc_num].data_pid;
 800643e:	f363 725e 	bfi	r2, r3, #29, #2
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
 8006442:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 8006446:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800644a:	611a      	str	r2, [r3, #16]
  
  if (pdev->cfg.dma_enable == 1)
 800644c:	78e2      	ldrb	r2, [r4, #3]
 800644e:	2a01      	cmp	r2, #1
  {
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
 8006450:	bf04      	itt	eq
 8006452:	f8d1 23b8 	ldreq.w	r2, [r1, #952]	; 0x3b8
 8006456:	615a      	streq	r2, [r3, #20]
  }
  
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 8006458:	681e      	ldr	r6, [r3, #0]
  hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
 800645a:	f7ff fe87 	bl	800616c <USB_OTG_IsEvenFrame>
  
  /* Set host channel enable */
  hcchar.b.chen = 1;
  hcchar.b.chdis = 0;
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 800645e:	eb04 0385 	add.w	r3, r4, r5, lsl #2
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
  }
  
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
  hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
 8006462:	f360 765d 	bfi	r6, r0, #29, #1
  
  /* Set host channel enable */
  hcchar.b.chen = 1;
  hcchar.b.chdis = 0;
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 8006466:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
  hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
  
  /* Set host channel enable */
  hcchar.b.chen = 1;
 800646a:	f046 4600 	orr.w	r6, r6, #2147483648	; 0x80000000
  hcchar.b.chdis = 0;
 800646e:	f36f 769e 	bfc	r6, #30, #1
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 8006472:	601e      	str	r6, [r3, #0]
  
  if (pdev->cfg.dma_enable == 0) /* Slave mode */
 8006474:	78e3      	ldrb	r3, [r4, #3]
 8006476:	2b00      	cmp	r3, #0
 8006478:	d136      	bne.n	80064e8 <USB_OTG_HC_StartXfer+0x10e>
  {  
    if((pdev->host.hc[hc_num].ep_is_in == 0) && 
 800647a:	2224      	movs	r2, #36	; 0x24
 800647c:	fb02 4205 	mla	r2, r2, r5, r4
 8006480:	f892 33ae 	ldrb.w	r3, [r2, #942]	; 0x3ae
 8006484:	2b00      	cmp	r3, #0
 8006486:	d12f      	bne.n	80064e8 <USB_OTG_HC_StartXfer+0x10e>
       (pdev->host.hc[hc_num].xfer_len > 0))
 8006488:	f8d2 33bc 	ldr.w	r3, [r2, #956]	; 0x3bc
  hcchar.b.chdis = 0;
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
  
  if (pdev->cfg.dma_enable == 0) /* Slave mode */
  {  
    if((pdev->host.hc[hc_num].ep_is_in == 0) && 
 800648c:	b363      	cbz	r3, 80064e8 <USB_OTG_HC_StartXfer+0x10e>
       (pdev->host.hc[hc_num].xfer_len > 0))
    {
      switch(pdev->host.hc[hc_num].ep_type) 
 800648e:	f892 23b1 	ldrb.w	r2, [r2, #945]	; 0x3b1
 8006492:	2a03      	cmp	r2, #3
 8006494:	d81e      	bhi.n	80064d4 <USB_OTG_HC_StartXfer+0xfa>
 8006496:	e8df f002 	tbb	[pc, r2]
 800649a:	0f02      	.short	0x0f02
 800649c:	0f02      	.short	0x0f02
      {
        /* Non periodic transfer */
      case EP_TYPE_CTRL:
      case EP_TYPE_BULK:
        
        hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 800649e:	68e2      	ldr	r2, [r4, #12]
        len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
 80064a0:	1cd8      	adds	r0, r3, #3
      {
        /* Non periodic transfer */
      case EP_TYPE_CTRL:
      case EP_TYPE_BULK:
        
        hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 80064a2:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
        len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
        
        /* check if there is enough space in FIFO space */
        if(len_words > hnptxsts.b.nptxfspcavail)
 80064a4:	f3c0 008f 	ubfx	r0, r0, #2, #16
      {
        /* Non periodic transfer */
      case EP_TYPE_CTRL:
      case EP_TYPE_BULK:
        
        hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 80064a8:	9103      	str	r1, [sp, #12]
        len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
        
        /* check if there is enough space in FIFO space */
        if(len_words > hnptxsts.b.nptxfspcavail)
 80064aa:	b289      	uxth	r1, r1
 80064ac:	4281      	cmp	r1, r0
 80064ae:	d211      	bcs.n	80064d4 <USB_OTG_HC_StartXfer+0xfa>
        {
          /* need to process data in nptxfempty interrupt */
          intmsk.b.nptxfempty = 1;
          USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
 80064b0:	6991      	ldr	r1, [r2, #24]
 80064b2:	f041 0120 	orr.w	r1, r1, #32
 80064b6:	e00c      	b.n	80064d2 <USB_OTG_HC_StartXfer+0xf8>
        
        break;
        /* Periodic transfer */
      case EP_TYPE_INTR:
      case EP_TYPE_ISOC:
        hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 80064b8:	6962      	ldr	r2, [r4, #20]
        len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
 80064ba:	1cd9      	adds	r1, r3, #3
        
        break;
        /* Periodic transfer */
      case EP_TYPE_INTR:
      case EP_TYPE_ISOC:
        hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 80064bc:	6912      	ldr	r2, [r2, #16]
        len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
        /* check if there is enough space in FIFO space */
        if(len_words > hptxsts.b.ptxfspcavail) /* split the transfer */
 80064be:	f3c1 018f 	ubfx	r1, r1, #2, #16
        
        break;
        /* Periodic transfer */
      case EP_TYPE_INTR:
      case EP_TYPE_ISOC:
        hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 80064c2:	9201      	str	r2, [sp, #4]
        len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
        /* check if there is enough space in FIFO space */
        if(len_words > hptxsts.b.ptxfspcavail) /* split the transfer */
 80064c4:	b292      	uxth	r2, r2
 80064c6:	428a      	cmp	r2, r1
 80064c8:	d204      	bcs.n	80064d4 <USB_OTG_HC_StartXfer+0xfa>
        {
          /* need to process data in ptxfempty interrupt */
          intmsk.b.ptxfempty = 1;
          USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
 80064ca:	68e2      	ldr	r2, [r4, #12]
 80064cc:	6991      	ldr	r1, [r2, #24]
 80064ce:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
 80064d2:	6191      	str	r1, [r2, #24]
      default:
        break;
      }
      
      /* Write packet into the Tx FIFO. */
      USB_OTG_WritePacket(pdev, 
 80064d4:	2224      	movs	r2, #36	; 0x24
 80064d6:	fb02 4205 	mla	r2, r2, r5, r4
 80064da:	4620      	mov	r0, r4
 80064dc:	f8d2 13b8 	ldr.w	r1, [r2, #952]	; 0x3b8
 80064e0:	b29b      	uxth	r3, r3
 80064e2:	462a      	mov	r2, r5
 80064e4:	f7ff fd04 	bl	8005ef0 <USB_OTG_WritePacket>
                          pdev->host.hc[hc_num].xfer_buff , 
                          hc_num, pdev->host.hc[hc_num].xfer_len);
    }
  }
  return status;
}
 80064e8:	2000      	movs	r0, #0
 80064ea:	b006      	add	sp, #24
 80064ec:	bd70      	pop	{r4, r5, r6, pc}

080064ee <USB_OTG_HC_Halt>:
  USB_OTG_HPTXSTS_TypeDef             hptxsts;
  USB_OTG_HCCHAR_TypeDef              hcchar;
  
  nptxsts.d32 = 0;
  hptxsts.d32 = 0;
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 80064ee:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 80064f2:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
* @param  pdev : Selected device
* @param  hc_num : channel number
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_HC_Halt(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
{
 80064f6:	b086      	sub	sp, #24
  USB_OTG_HPTXSTS_TypeDef             hptxsts;
  USB_OTG_HCCHAR_TypeDef              hcchar;
  
  nptxsts.d32 = 0;
  hptxsts.d32 = 0;
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 80064f8:	6813      	ldr	r3, [r2, #0]
  hcchar.b.chen = 1;
  hcchar.b.chdis = 1;
 80064fa:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
  
  /* Check for space in the request queue to issue the halt. */
  if (hcchar.b.eptype == HCCHAR_CTRL || hcchar.b.eptype == HCCHAR_BULK)
 80064fe:	f3c3 4107 	ubfx	r1, r3, #16, #8
 8006502:	f011 010c 	ands.w	r1, r1, #12
 8006506:	d001      	beq.n	800650c <USB_OTG_HC_Halt+0x1e>
 8006508:	2908      	cmp	r1, #8
 800650a:	d102      	bne.n	8006512 <USB_OTG_HC_Halt+0x24>
  {
    nptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 800650c:	68c1      	ldr	r1, [r0, #12]
 800650e:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 8006510:	e001      	b.n	8006516 <USB_OTG_HC_Halt+0x28>
      hcchar.b.chen = 0;
    }
  }
  else
  {
    hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 8006512:	6941      	ldr	r1, [r0, #20]
 8006514:	6909      	ldr	r1, [r1, #16]
    if (hptxsts.b.ptxqspcavail == 0)
 8006516:	f3c1 4107 	ubfx	r1, r1, #16, #8
 800651a:	b909      	cbnz	r1, 8006520 <USB_OTG_HC_Halt+0x32>
    {
      hcchar.b.chen = 0;
 800651c:	f361 73df 	bfi	r3, r1, #31, #1
    }
  }
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 8006520:	6013      	str	r3, [r2, #0]
  return status;
}
 8006522:	2000      	movs	r0, #0
 8006524:	b006      	add	sp, #24
 8006526:	4770      	bx	lr

08006528 <USB_OTG_HC_DoPing>:
* @brief  Issue a ping token
* @param  None
* @retval : None
*/
USB_OTG_STS USB_OTG_HC_DoPing(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
{
 8006528:	b510      	push	{r4, lr}
  USB_OTG_HCCHAR_TypeDef    hcchar;
  USB_OTG_HCTSIZn_TypeDef   hctsiz;  
  
  hctsiz.d32 = 0;
  hctsiz.b.dopng = 1;
  hctsiz.b.pktcnt = 1;
 800652a:	2301      	movs	r3, #1
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
 800652c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
  USB_OTG_STS               status = USB_OTG_OK;
  USB_OTG_HCCHAR_TypeDef    hcchar;
  USB_OTG_HCTSIZn_TypeDef   hctsiz;  
  
  hctsiz.d32 = 0;
  hctsiz.b.dopng = 1;
 8006530:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
  hctsiz.b.pktcnt = 1;
 8006534:	f363 44dc 	bfi	r4, r3, #19, #10
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
 8006538:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
  USB_OTG_STS               status = USB_OTG_OK;
  USB_OTG_HCCHAR_TypeDef    hcchar;
  USB_OTG_HCTSIZn_TypeDef   hctsiz;  
  
  hctsiz.d32 = 0;
  hctsiz.b.dopng = 1;
 800653c:	2200      	movs	r2, #0
  hctsiz.b.pktcnt = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
 800653e:	611c      	str	r4, [r3, #16]
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 8006540:	6819      	ldr	r1, [r3, #0]
  hcchar.b.chen = 1;
  hcchar.b.chdis = 0;
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
  return status;  
}
 8006542:	4610      	mov	r0, r2
  hctsiz.b.dopng = 1;
  hctsiz.b.pktcnt = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
  hcchar.b.chen = 1;
 8006544:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
  hcchar.b.chdis = 0;
 8006548:	f362 719e 	bfi	r1, r2, #30, #1
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 800654c:	6019      	str	r1, [r3, #0]
  return status;  
}
 800654e:	bd10      	pop	{r4, pc}

08006550 <USB_OTG_StopHost>:
void USB_OTG_StopHost(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_HCCHAR_TypeDef  hcchar;
  uint32_t                i;
  
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
 8006550:	6943      	ldr	r3, [r0, #20]
 8006552:	2200      	movs	r2, #0
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
 8006554:	f04f 31ff 	mov.w	r1, #4294967295
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopHost(USB_OTG_CORE_HANDLE *pdev)
{
 8006558:	b510      	push	{r4, lr}
  USB_OTG_HCCHAR_TypeDef  hcchar;
  uint32_t                i;
  
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
 800655a:	619a      	str	r2, [r3, #24]
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopHost(USB_OTG_CORE_HANDLE *pdev)
{
 800655c:	4604      	mov	r4, r0
  USB_OTG_HCCHAR_TypeDef  hcchar;
  uint32_t                i;
  
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
 800655e:	6159      	str	r1, [r3, #20]
  /* Flush out any leftover queued requests. */
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 8006560:	e00c      	b.n	800657c <USB_OTG_StopHost+0x2c>
/**
* @brief  Stop the device and clean up fifo's
* @param  None
* @retval : None
*/
void USB_OTG_StopHost(USB_OTG_CORE_HANDLE *pdev)
 8006562:	eb04 0382 	add.w	r3, r4, r2, lsl #2
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
  /* Flush out any leftover queued requests. */
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
  {
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 8006566:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
  
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
  /* Flush out any leftover queued requests. */
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 800656a:	3201      	adds	r2, #1
  {
    hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 800656c:	680b      	ldr	r3, [r1, #0]
    hcchar.b.chen = 0;
 800656e:	f36f 73df 	bfc	r3, #31, #1
    hcchar.b.chdis = 1;
 8006572:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    hcchar.b.epdir = 0;
 8006576:	f36f 33cf 	bfc	r3, #15, #1
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
 800657a:	600b      	str	r3, [r1, #0]
  
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
  /* Flush out any leftover queued requests. */
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 800657c:	7823      	ldrb	r3, [r4, #0]
 800657e:	429a      	cmp	r2, r3
 8006580:	d3ef      	bcc.n	8006562 <USB_OTG_StopHost+0x12>
    hcchar.b.epdir = 0;
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
  }
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
 8006582:	4620      	mov	r0, r4
 8006584:	f7ff fdaa 	bl	80060dc <USB_OTG_FlushRxFifo>
  USB_OTG_FlushTxFifo(pdev ,  0x10 );  
 8006588:	4620      	mov	r0, r4
 800658a:	2110      	movs	r1, #16
}
 800658c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
  }
  
  /* Flush the FIFO */
  USB_OTG_FlushRxFifo(pdev);
  USB_OTG_FlushTxFifo(pdev ,  0x10 );  
 8006590:	f7ff bd86 	b.w	80060a0 <USB_OTG_FlushTxFifo>

08006594 <HCD_Init>:
  */
uint32_t HCD_Init(USB_OTG_CORE_HANDLE *pdev , 
                  USB_OTG_CORE_ID_TypeDef coreID)
{
  uint8_t i = 0;
  pdev->host.ConnSts = 0;
 8006594:	2300      	movs	r3, #0
  * @param  base_address: OTG base address
  * @retval Status
  */
uint32_t HCD_Init(USB_OTG_CORE_HANDLE *pdev , 
                  USB_OTG_CORE_ID_TypeDef coreID)
{
 8006596:	b510      	push	{r4, lr}
  uint8_t i = 0;
  pdev->host.ConnSts = 0;
  
  for (i= 0; i< USB_OTG_MAX_TX_FIFOS; i++)
  {
  pdev->host.ErrCnt[i]  = 0;
 8006598:	461a      	mov	r2, r3
  * @param  base_address: OTG base address
  * @retval Status
  */
uint32_t HCD_Init(USB_OTG_CORE_HANDLE *pdev , 
                  USB_OTG_CORE_ID_TypeDef coreID)
{
 800659a:	4604      	mov	r4, r0
  uint8_t i = 0;
  pdev->host.ConnSts = 0;
 800659c:	f8c0 3310 	str.w	r3, [r0, #784]	; 0x310
  
  for (i= 0; i< USB_OTG_MAX_TX_FIFOS; i++)
  {
  pdev->host.ErrCnt[i]  = 0;
 80065a0:	f103 00c4 	add.w	r0, r3, #196	; 0xc4
 80065a4:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80065a8:	6042      	str	r2, [r0, #4]
  pdev->host.XferCnt[i]   = 0;
 80065aa:	f103 00d4 	add.w	r0, r3, #212	; 0xd4
 80065ae:	f844 2020 	str.w	r2, [r4, r0, lsl #2]
  pdev->host.HC_Status[i]   = HC_IDLE;
 80065b2:	18e0      	adds	r0, r4, r3
 80065b4:	3301      	adds	r3, #1
                  USB_OTG_CORE_ID_TypeDef coreID)
{
  uint8_t i = 0;
  pdev->host.ConnSts = 0;
  
  for (i= 0; i< USB_OTG_MAX_TX_FIFOS; i++)
 80065b6:	2b0f      	cmp	r3, #15
  {
  pdev->host.ErrCnt[i]  = 0;
  pdev->host.XferCnt[i]   = 0;
  pdev->host.HC_Status[i]   = HC_IDLE;
 80065b8:	f880 238c 	strb.w	r2, [r0, #908]	; 0x38c
                  USB_OTG_CORE_ID_TypeDef coreID)
{
  uint8_t i = 0;
  pdev->host.ConnSts = 0;
  
  for (i= 0; i< USB_OTG_MAX_TX_FIFOS; i++)
 80065bc:	d1f0      	bne.n	80065a0 <HCD_Init+0xc>
  {
  pdev->host.ErrCnt[i]  = 0;
  pdev->host.XferCnt[i]   = 0;
  pdev->host.HC_Status[i]   = HC_IDLE;
  }
  pdev->host.hc[0].max_packet  = 8; 
 80065be:	2308      	movs	r3, #8
 80065c0:	f8a4 33b2 	strh.w	r3, [r4, #946]	; 0x3b2

  USB_OTG_SelectCore(pdev, coreID);
 80065c4:	4620      	mov	r0, r4
 80065c6:	f7ff fcb7 	bl	8005f38 <USB_OTG_SelectCore>
#ifndef DUAL_ROLE_MODE_ENABLED
  USB_OTG_DisableGlobalInt(pdev);
 80065ca:	4620      	mov	r0, r4
 80065cc:	f7ff fd61 	bl	8006092 <USB_OTG_DisableGlobalInt>
  USB_OTG_CoreInit(pdev);
 80065d0:	4620      	mov	r0, r4
 80065d2:	f7ff fd11 	bl	8005ff8 <USB_OTG_CoreInit>

  /* Force Host Mode*/
  USB_OTG_SetCurrentMode(pdev , HOST_MODE);
 80065d6:	2101      	movs	r1, #1
 80065d8:	4620      	mov	r0, r4
 80065da:	f7ff fd99 	bl	8006110 <USB_OTG_SetCurrentMode>
  USB_OTG_CoreInitHost(pdev);
 80065de:	4620      	mov	r0, r4
 80065e0:	f7ff fe37 	bl	8006252 <USB_OTG_CoreInitHost>
  USB_OTG_EnableGlobalInt(pdev);
 80065e4:	4620      	mov	r0, r4
 80065e6:	f7ff fd4d 	bl	8006084 <USB_OTG_EnableGlobalInt>
#endif
   
  return 0;
}
 80065ea:	2000      	movs	r0, #0
 80065ec:	bd10      	pop	{r4, pc}

080065ee <HCD_GetCurrentSpeed>:
  */

uint32_t HCD_GetCurrentSpeed (USB_OTG_CORE_HANDLE *pdev)
{    
    USB_OTG_HPRT0_TypeDef  HPRT0;
    HPRT0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 80065ee:	f8d0 30cc 	ldr.w	r3, [r0, #204]	; 0xcc
 80065f2:	6818      	ldr	r0, [r3, #0]
    
    return HPRT0.b.prtspd;
}
 80065f4:	f3c0 4041 	ubfx	r0, r0, #17, #2
 80065f8:	4770      	bx	lr

080065fa <HCD_ResetPort>:
  *         Issues the reset command to device
  * @param  pdev : Selected device
  * @retval Status
  */
uint32_t HCD_ResetPort(USB_OTG_CORE_HANDLE *pdev)
{
 80065fa:	b508      	push	{r3, lr}
  interrupt triggered by the debounce done bit (DBCDNE bit in OTG_FS_GOTGINT), 
  which indicates that the bus is stable again after the electrical debounce 
  caused by the attachment of a pull-up resistor on DP (FS) or DM (LS).
  */
  
  USB_OTG_ResetPort(pdev); 
 80065fc:	f7ff fe13 	bl	8006226 <USB_OTG_ResetPort>
  return 0;
}
 8006600:	2000      	movs	r0, #0
 8006602:	bd08      	pop	{r3, pc}

08006604 <HCD_IsDeviceConnected>:
  * @retval Device connection status. 1 -> connected and 0 -> disconnected
  * 
  */
uint32_t HCD_IsDeviceConnected(USB_OTG_CORE_HANDLE *pdev)
{
  return (pdev->host.ConnSts);
 8006604:	f8d0 0310 	ldr.w	r0, [r0, #784]	; 0x310
}
 8006608:	4770      	bx	lr

0800660a <HCD_GetCurrentFrame>:
  * @retval Frame number
  * 
  */
uint32_t HCD_GetCurrentFrame (USB_OTG_CORE_HANDLE *pdev) 
{
 return (USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0xFFFF) ;
 800660a:	6943      	ldr	r3, [r0, #20]
 800660c:	6898      	ldr	r0, [r3, #8]
}
 800660e:	b280      	uxth	r0, r0
 8006610:	4770      	bx	lr

08006612 <HCD_GetURB_State>:
  * @retval URB_STATE
  * 
  */
URB_STATE HCD_GetURB_State (USB_OTG_CORE_HANDLE *pdev , uint8_t ch_num) 
{
  return pdev->host.URB_State[ch_num] ;
 8006612:	1841      	adds	r1, r0, r1
 8006614:	f891 039b 	ldrb.w	r0, [r1, #923]	; 0x39b
}
 8006618:	4770      	bx	lr

0800661a <HCD_GetXferCnt>:
  * @retval No. of data bytes transferred
  * 
  */
uint32_t HCD_GetXferCnt (USB_OTG_CORE_HANDLE *pdev, uint8_t ch_num) 
{
  return pdev->host.XferCnt[ch_num] ;
 800661a:	31d4      	adds	r1, #212	; 0xd4
 800661c:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
}
 8006620:	4770      	bx	lr

08006622 <HCD_GetHCState>:
  * @retval HC_STATUS
  * 
  */
HC_STATUS HCD_GetHCState (USB_OTG_CORE_HANDLE *pdev ,  uint8_t ch_num) 
{
  return pdev->host.HC_Status[ch_num] ;
 8006622:	1841      	adds	r1, r0, r1
 8006624:	f891 038c 	ldrb.w	r0, [r1, #908]	; 0x38c
}
 8006628:	4770      	bx	lr

0800662a <HCD_HC_Init>:
  * @param  pdev: Selected device
  * @param  hc_num: Channel number 
  * @retval status 
  */
uint32_t HCD_HC_Init (USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num) 
{
 800662a:	b508      	push	{r3, lr}
  return USB_OTG_HC_Init(pdev, hc_num);  
 800662c:	f7ff fe5b 	bl	80062e6 <USB_OTG_HC_Init>
}
 8006630:	bd08      	pop	{r3, pc}

08006632 <HCD_SubmitRequest>:
  * @param  pdev: Selected device
  * @param  hc_num: Channel number 
  * @retval status
  */
uint32_t HCD_SubmitRequest (USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num) 
{
 8006632:	b538      	push	{r3, r4, r5, lr}
  
  pdev->host.URB_State[hc_num] =   URB_IDLE;  
 8006634:	1845      	adds	r5, r0, r1
 8006636:	2300      	movs	r3, #0
 8006638:	f885 339b 	strb.w	r3, [r5, #923]	; 0x39b
  pdev->host.hc[hc_num].xfer_count = 0 ;
 800663c:	2524      	movs	r5, #36	; 0x24
 800663e:	fb05 0201 	mla	r2, r5, r1, r0
 8006642:	f8c2 33c0 	str.w	r3, [r2, #960]	; 0x3c0
  * @param  pdev: Selected device
  * @param  hc_num: Channel number 
  * @retval status
  */
uint32_t HCD_SubmitRequest (USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num) 
{
 8006646:	460c      	mov	r4, r1
  
  pdev->host.URB_State[hc_num] =   URB_IDLE;  
  pdev->host.hc[hc_num].xfer_count = 0 ;
  return USB_OTG_HC_StartXfer(pdev, hc_num);
 8006648:	f7ff fec7 	bl	80063da <USB_OTG_HC_StartXfer>
}
 800664c:	bd38      	pop	{r3, r4, r5, pc}
	...

08006650 <USB_OTG_USBH_handle_sof_ISR>:
*         Handles the start-of-frame interrupt in host mode.
* @param  pdev: Selected device
* @retval status 
*/
static uint32_t USB_OTG_USBH_handle_sof_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8006650:	b480      	push	{r7}
 8006652:	b085      	sub	sp, #20
 8006654:	af00      	add	r7, sp, #0
 8006656:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTSTS_TypeDef      gintsts;
  gintsts.d32 = 0;
 8006658:	f04f 0300 	mov.w	r3, #0
 800665c:	60fb      	str	r3, [r7, #12]
  
  //USBH_HCD_INT_fops->SOF(pdev);
  
  /* Clear interrupt */
  gintsts.b.sofintr = 1;
 800665e:	68fb      	ldr	r3, [r7, #12]
 8006660:	f043 0308 	orr.w	r3, r3, #8
 8006664:	60fb      	str	r3, [r7, #12]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8006666:	687b      	ldr	r3, [r7, #4]
 8006668:	68db      	ldr	r3, [r3, #12]
 800666a:	68fa      	ldr	r2, [r7, #12]
 800666c:	615a      	str	r2, [r3, #20]
  
  pdev->host.SofHits++;
 800666e:	687b      	ldr	r3, [r7, #4]
 8006670:	f8d3 35e8 	ldr.w	r3, [r3, #1512]	; 0x5e8
 8006674:	f103 0201 	add.w	r2, r3, #1
 8006678:	687b      	ldr	r3, [r7, #4]
 800667a:	f8c3 25e8 	str.w	r2, [r3, #1512]	; 0x5e8

  return 1;
 800667e:	f04f 0301 	mov.w	r3, #1
}
 8006682:	4618      	mov	r0, r3
 8006684:	f107 0714 	add.w	r7, r7, #20
 8006688:	46bd      	mov	sp, r7
 800668a:	bc80      	pop	{r7}
 800668c:	4770      	bx	lr
 800668e:	bf00      	nop

08006690 <USB_OTG_USBH_handle_Disconnect_ISR>:
*         Handles disconnect event.
* @param  pdev: Selected device
* @retval status 
*/
static uint32_t USB_OTG_USBH_handle_Disconnect_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8006690:	b480      	push	{r7}
 8006692:	b085      	sub	sp, #20
 8006694:	af00      	add	r7, sp, #0
 8006696:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTSTS_TypeDef      gintsts;
  
  gintsts.d32 = 0;
 8006698:	f04f 0300 	mov.w	r3, #0
 800669c:	60fb      	str	r3, [r7, #12]
  
  //USBH_HCD_INT_fops->DevDisconnected(pdev);
  pdev->host.ConnSts = 0;
 800669e:	687b      	ldr	r3, [r7, #4]
 80066a0:	f04f 0200 	mov.w	r2, #0
 80066a4:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310

  /* Clear interrupt */
  gintsts.b.disconnect = 1;
 80066a8:	68fb      	ldr	r3, [r7, #12]
 80066aa:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80066ae:	60fb      	str	r3, [r7, #12]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 80066b0:	687b      	ldr	r3, [r7, #4]
 80066b2:	68db      	ldr	r3, [r3, #12]
 80066b4:	68fa      	ldr	r2, [r7, #12]
 80066b6:	615a      	str	r2, [r3, #20]
  
  return 1;
 80066b8:	f04f 0301 	mov.w	r3, #1
}
 80066bc:	4618      	mov	r0, r3
 80066be:	f107 0714 	add.w	r7, r7, #20
 80066c2:	46bd      	mov	sp, r7
 80066c4:	bc80      	pop	{r7}
 80066c6:	4770      	bx	lr

080066c8 <USB_OTG_USBH_handle_nptxfempty_ISR>:
*         Handles non periodic tx fifo empty.
* @param  pdev: Selected device
* @retval status 
*/
static uint32_t USB_OTG_USBH_handle_nptxfempty_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 80066c8:	b580      	push	{r7, lr}
 80066ca:	b088      	sub	sp, #32
 80066cc:	af00      	add	r7, sp, #0
 80066ce:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTMSK_TypeDef      intmsk;
  USB_OTG_HNPTXSTS_TypeDef     hnptxsts; 
  uint16_t                     len_words , len; 
  
  hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 80066d0:	687b      	ldr	r3, [r7, #4]
 80066d2:	68db      	ldr	r3, [r3, #12]
 80066d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80066d6:	60fb      	str	r3, [r7, #12]
  
  len_words = (pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len + 3) / 4;
 80066d8:	7c3b      	ldrb	r3, [r7, #16]
 80066da:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 80066de:	b2db      	uxtb	r3, r3
 80066e0:	461a      	mov	r2, r3
 80066e2:	6879      	ldr	r1, [r7, #4]
 80066e4:	4613      	mov	r3, r2
 80066e6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80066ea:	189b      	adds	r3, r3, r2
 80066ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80066f0:	18cb      	adds	r3, r1, r3
 80066f2:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
 80066f6:	681b      	ldr	r3, [r3, #0]
 80066f8:	f103 0303 	add.w	r3, r3, #3
 80066fc:	ea4f 0393 	mov.w	r3, r3, lsr #2
 8006700:	83fb      	strh	r3, [r7, #30]
  
  while ((hnptxsts.b.nptxfspcavail > len_words)&&
 8006702:	e0d0      	b.n	80068a6 <USB_OTG_USBH_handle_nptxfempty_ISR+0x1de>
         (pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len != 0))
  {
    
    len = hnptxsts.b.nptxfspcavail * 4;
 8006704:	89bb      	ldrh	r3, [r7, #12]
 8006706:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800670a:	83bb      	strh	r3, [r7, #28]
    
    if (len > pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len)
 800670c:	8bb9      	ldrh	r1, [r7, #28]
 800670e:	7c3b      	ldrb	r3, [r7, #16]
 8006710:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 8006714:	b2db      	uxtb	r3, r3
 8006716:	461a      	mov	r2, r3
 8006718:	6878      	ldr	r0, [r7, #4]
 800671a:	4613      	mov	r3, r2
 800671c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006720:	189b      	adds	r3, r3, r2
 8006722:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006726:	18c3      	adds	r3, r0, r3
 8006728:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
 800672c:	681b      	ldr	r3, [r3, #0]
 800672e:	4299      	cmp	r1, r3
 8006730:	d921      	bls.n	8006776 <USB_OTG_USBH_handle_nptxfempty_ISR+0xae>
    {
      /* Last packet */
      len = pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len;
 8006732:	7c3b      	ldrb	r3, [r7, #16]
 8006734:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 8006738:	b2db      	uxtb	r3, r3
 800673a:	461a      	mov	r2, r3
 800673c:	6879      	ldr	r1, [r7, #4]
 800673e:	4613      	mov	r3, r2
 8006740:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006744:	189b      	adds	r3, r3, r2
 8006746:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800674a:	18cb      	adds	r3, r1, r3
 800674c:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
 8006750:	681b      	ldr	r3, [r3, #0]
 8006752:	83bb      	strh	r3, [r7, #28]
      
      intmsk.d32 = 0;
 8006754:	f04f 0300 	mov.w	r3, #0
 8006758:	61bb      	str	r3, [r7, #24]
      intmsk.b.nptxfempty = 1;
 800675a:	69bb      	ldr	r3, [r7, #24]
 800675c:	f043 0320 	orr.w	r3, r3, #32
 8006760:	61bb      	str	r3, [r7, #24]
      USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, 0);       
 8006762:	687b      	ldr	r3, [r7, #4]
 8006764:	68db      	ldr	r3, [r3, #12]
 8006766:	687a      	ldr	r2, [r7, #4]
 8006768:	68d2      	ldr	r2, [r2, #12]
 800676a:	6991      	ldr	r1, [r2, #24]
 800676c:	69ba      	ldr	r2, [r7, #24]
 800676e:	ea6f 0202 	mvn.w	r2, r2
 8006772:	400a      	ands	r2, r1
 8006774:	619a      	str	r2, [r3, #24]
    }
    
    len_words = (pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len + 3) / 4;
 8006776:	7c3b      	ldrb	r3, [r7, #16]
 8006778:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 800677c:	b2db      	uxtb	r3, r3
 800677e:	461a      	mov	r2, r3
 8006780:	6879      	ldr	r1, [r7, #4]
 8006782:	4613      	mov	r3, r2
 8006784:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006788:	189b      	adds	r3, r3, r2
 800678a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800678e:	18cb      	adds	r3, r1, r3
 8006790:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
 8006794:	681b      	ldr	r3, [r3, #0]
 8006796:	f103 0303 	add.w	r3, r3, #3
 800679a:	ea4f 0393 	mov.w	r3, r3, lsr #2
 800679e:	83fb      	strh	r3, [r7, #30]
    
    USB_OTG_WritePacket (pdev , pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_buff, hnptxsts.b.nptxqtop.chnum, len);
 80067a0:	7c3b      	ldrb	r3, [r7, #16]
 80067a2:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 80067a6:	b2db      	uxtb	r3, r3
 80067a8:	461a      	mov	r2, r3
 80067aa:	6879      	ldr	r1, [r7, #4]
 80067ac:	4613      	mov	r3, r2
 80067ae:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80067b2:	189b      	adds	r3, r3, r2
 80067b4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80067b8:	18cb      	adds	r3, r1, r3
 80067ba:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
 80067be:	6819      	ldr	r1, [r3, #0]
 80067c0:	7c3b      	ldrb	r3, [r7, #16]
 80067c2:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 80067c6:	b2db      	uxtb	r3, r3
 80067c8:	461a      	mov	r2, r3
 80067ca:	8bbb      	ldrh	r3, [r7, #28]
 80067cc:	6878      	ldr	r0, [r7, #4]
 80067ce:	f7ff fb8f 	bl	8005ef0 <USB_OTG_WritePacket>
    
    pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_buff  += len;
 80067d2:	7c3b      	ldrb	r3, [r7, #16]
 80067d4:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 80067d8:	b2db      	uxtb	r3, r3
 80067da:	461a      	mov	r2, r3
 80067dc:	7c3b      	ldrb	r3, [r7, #16]
 80067de:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 80067e2:	b2db      	uxtb	r3, r3
 80067e4:	4619      	mov	r1, r3
 80067e6:	6878      	ldr	r0, [r7, #4]
 80067e8:	460b      	mov	r3, r1
 80067ea:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80067ee:	185b      	adds	r3, r3, r1
 80067f0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80067f4:	18c3      	adds	r3, r0, r3
 80067f6:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
 80067fa:	6819      	ldr	r1, [r3, #0]
 80067fc:	8bbb      	ldrh	r3, [r7, #28]
 80067fe:	18c9      	adds	r1, r1, r3
 8006800:	6878      	ldr	r0, [r7, #4]
 8006802:	4613      	mov	r3, r2
 8006804:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006808:	189b      	adds	r3, r3, r2
 800680a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800680e:	18c3      	adds	r3, r0, r3
 8006810:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
 8006814:	6019      	str	r1, [r3, #0]
    pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len   -= len;
 8006816:	7c3b      	ldrb	r3, [r7, #16]
 8006818:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 800681c:	b2db      	uxtb	r3, r3
 800681e:	461a      	mov	r2, r3
 8006820:	7c3b      	ldrb	r3, [r7, #16]
 8006822:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 8006826:	b2db      	uxtb	r3, r3
 8006828:	4619      	mov	r1, r3
 800682a:	6878      	ldr	r0, [r7, #4]
 800682c:	460b      	mov	r3, r1
 800682e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006832:	185b      	adds	r3, r3, r1
 8006834:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006838:	18c3      	adds	r3, r0, r3
 800683a:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
 800683e:	6819      	ldr	r1, [r3, #0]
 8006840:	8bbb      	ldrh	r3, [r7, #28]
 8006842:	1ac9      	subs	r1, r1, r3
 8006844:	6878      	ldr	r0, [r7, #4]
 8006846:	4613      	mov	r3, r2
 8006848:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800684c:	189b      	adds	r3, r3, r2
 800684e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006852:	18c3      	adds	r3, r0, r3
 8006854:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
 8006858:	6019      	str	r1, [r3, #0]
    pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_count  += len; 
 800685a:	7c3b      	ldrb	r3, [r7, #16]
 800685c:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 8006860:	b2db      	uxtb	r3, r3
 8006862:	461a      	mov	r2, r3
 8006864:	7c3b      	ldrb	r3, [r7, #16]
 8006866:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 800686a:	b2db      	uxtb	r3, r3
 800686c:	4619      	mov	r1, r3
 800686e:	6878      	ldr	r0, [r7, #4]
 8006870:	460b      	mov	r3, r1
 8006872:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006876:	185b      	adds	r3, r3, r1
 8006878:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800687c:	18c3      	adds	r3, r0, r3
 800687e:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 8006882:	6819      	ldr	r1, [r3, #0]
 8006884:	8bbb      	ldrh	r3, [r7, #28]
 8006886:	18c9      	adds	r1, r1, r3
 8006888:	6878      	ldr	r0, [r7, #4]
 800688a:	4613      	mov	r3, r2
 800688c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006890:	189b      	adds	r3, r3, r2
 8006892:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006896:	18c3      	adds	r3, r0, r3
 8006898:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 800689c:	6019      	str	r1, [r3, #0]
    
    hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 800689e:	687b      	ldr	r3, [r7, #4]
 80068a0:	68db      	ldr	r3, [r3, #12]
 80068a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80068a4:	60fb      	str	r3, [r7, #12]
  
  hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
  
  len_words = (pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len + 3) / 4;
  
  while ((hnptxsts.b.nptxfspcavail > len_words)&&
 80068a6:	89bb      	ldrh	r3, [r7, #12]
 80068a8:	8bfa      	ldrh	r2, [r7, #30]
 80068aa:	429a      	cmp	r2, r3
 80068ac:	d212      	bcs.n	80068d4 <USB_OTG_USBH_handle_nptxfempty_ISR+0x20c>
         (pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len != 0))
 80068ae:	7c3b      	ldrb	r3, [r7, #16]
 80068b0:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 80068b4:	b2db      	uxtb	r3, r3
 80068b6:	461a      	mov	r2, r3
 80068b8:	6879      	ldr	r1, [r7, #4]
 80068ba:	4613      	mov	r3, r2
 80068bc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80068c0:	189b      	adds	r3, r3, r2
 80068c2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80068c6:	18cb      	adds	r3, r1, r3
 80068c8:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
 80068cc:	681b      	ldr	r3, [r3, #0]
  
  hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
  
  len_words = (pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len + 3) / 4;
  
  while ((hnptxsts.b.nptxfspcavail > len_words)&&
 80068ce:	2b00      	cmp	r3, #0
 80068d0:	f47f af18 	bne.w	8006704 <USB_OTG_USBH_handle_nptxfempty_ISR+0x3c>
    pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_count  += len; 
    
    hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
  }  
  
  return 1;
 80068d4:	f04f 0301 	mov.w	r3, #1
}
 80068d8:	4618      	mov	r0, r3
 80068da:	f107 0720 	add.w	r7, r7, #32
 80068de:	46bd      	mov	sp, r7
 80068e0:	bd80      	pop	{r7, pc}
 80068e2:	bf00      	nop

080068e4 <USB_OTG_USBH_handle_ptxfempty_ISR>:
*         Handles periodic tx fifo empty
* @param  pdev: Selected device
* @retval status 
*/
static uint32_t USB_OTG_USBH_handle_ptxfempty_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 80068e4:	b580      	push	{r7, lr}
 80068e6:	b086      	sub	sp, #24
 80068e8:	af00      	add	r7, sp, #0
 80068ea:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTMSK_TypeDef      intmsk;
  USB_OTG_HPTXSTS_TypeDef      hptxsts; 
  uint16_t                     len_words , len; 
  
  hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 80068ec:	687b      	ldr	r3, [r7, #4]
 80068ee:	695b      	ldr	r3, [r3, #20]
 80068f0:	691b      	ldr	r3, [r3, #16]
 80068f2:	60bb      	str	r3, [r7, #8]
  
  len_words = (pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len + 3) / 4;
 80068f4:	7b3b      	ldrb	r3, [r7, #12]
 80068f6:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 80068fa:	b2db      	uxtb	r3, r3
 80068fc:	461a      	mov	r2, r3
 80068fe:	6879      	ldr	r1, [r7, #4]
 8006900:	4613      	mov	r3, r2
 8006902:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006906:	189b      	adds	r3, r3, r2
 8006908:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800690c:	18cb      	adds	r3, r1, r3
 800690e:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
 8006912:	681b      	ldr	r3, [r3, #0]
 8006914:	f103 0303 	add.w	r3, r3, #3
 8006918:	ea4f 0393 	mov.w	r3, r3, lsr #2
 800691c:	82fb      	strh	r3, [r7, #22]
  
  while ((hptxsts.b.ptxfspcavail > len_words)&&
 800691e:	e0d0      	b.n	8006ac2 <USB_OTG_USBH_handle_ptxfempty_ISR+0x1de>
         (pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len != 0))    
  {
    
    len = hptxsts.b.ptxfspcavail * 4;
 8006920:	893b      	ldrh	r3, [r7, #8]
 8006922:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006926:	82bb      	strh	r3, [r7, #20]
    
    if (len > pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len)
 8006928:	8ab9      	ldrh	r1, [r7, #20]
 800692a:	7b3b      	ldrb	r3, [r7, #12]
 800692c:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 8006930:	b2db      	uxtb	r3, r3
 8006932:	461a      	mov	r2, r3
 8006934:	6878      	ldr	r0, [r7, #4]
 8006936:	4613      	mov	r3, r2
 8006938:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800693c:	189b      	adds	r3, r3, r2
 800693e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006942:	18c3      	adds	r3, r0, r3
 8006944:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
 8006948:	681b      	ldr	r3, [r3, #0]
 800694a:	4299      	cmp	r1, r3
 800694c:	d921      	bls.n	8006992 <USB_OTG_USBH_handle_ptxfempty_ISR+0xae>
    {
      len = pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len;
 800694e:	7b3b      	ldrb	r3, [r7, #12]
 8006950:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 8006954:	b2db      	uxtb	r3, r3
 8006956:	461a      	mov	r2, r3
 8006958:	6879      	ldr	r1, [r7, #4]
 800695a:	4613      	mov	r3, r2
 800695c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006960:	189b      	adds	r3, r3, r2
 8006962:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006966:	18cb      	adds	r3, r1, r3
 8006968:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
 800696c:	681b      	ldr	r3, [r3, #0]
 800696e:	82bb      	strh	r3, [r7, #20]
      /* Last packet */
      intmsk.d32 = 0;
 8006970:	f04f 0300 	mov.w	r3, #0
 8006974:	613b      	str	r3, [r7, #16]
      intmsk.b.ptxfempty = 1;
 8006976:	693b      	ldr	r3, [r7, #16]
 8006978:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800697c:	613b      	str	r3, [r7, #16]
      USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, 0); 
 800697e:	687b      	ldr	r3, [r7, #4]
 8006980:	68db      	ldr	r3, [r3, #12]
 8006982:	687a      	ldr	r2, [r7, #4]
 8006984:	68d2      	ldr	r2, [r2, #12]
 8006986:	6991      	ldr	r1, [r2, #24]
 8006988:	693a      	ldr	r2, [r7, #16]
 800698a:	ea6f 0202 	mvn.w	r2, r2
 800698e:	400a      	ands	r2, r1
 8006990:	619a      	str	r2, [r3, #24]
    }
    
    len_words = (pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len + 3) / 4;
 8006992:	7b3b      	ldrb	r3, [r7, #12]
 8006994:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 8006998:	b2db      	uxtb	r3, r3
 800699a:	461a      	mov	r2, r3
 800699c:	6879      	ldr	r1, [r7, #4]
 800699e:	4613      	mov	r3, r2
 80069a0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80069a4:	189b      	adds	r3, r3, r2
 80069a6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80069aa:	18cb      	adds	r3, r1, r3
 80069ac:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
 80069b0:	681b      	ldr	r3, [r3, #0]
 80069b2:	f103 0303 	add.w	r3, r3, #3
 80069b6:	ea4f 0393 	mov.w	r3, r3, lsr #2
 80069ba:	82fb      	strh	r3, [r7, #22]
    
    USB_OTG_WritePacket (pdev , pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_buff, hptxsts.b.ptxqtop.chnum, len);
 80069bc:	7b3b      	ldrb	r3, [r7, #12]
 80069be:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 80069c2:	b2db      	uxtb	r3, r3
 80069c4:	461a      	mov	r2, r3
 80069c6:	6879      	ldr	r1, [r7, #4]
 80069c8:	4613      	mov	r3, r2
 80069ca:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80069ce:	189b      	adds	r3, r3, r2
 80069d0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80069d4:	18cb      	adds	r3, r1, r3
 80069d6:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
 80069da:	6819      	ldr	r1, [r3, #0]
 80069dc:	7b3b      	ldrb	r3, [r7, #12]
 80069de:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 80069e2:	b2db      	uxtb	r3, r3
 80069e4:	461a      	mov	r2, r3
 80069e6:	8abb      	ldrh	r3, [r7, #20]
 80069e8:	6878      	ldr	r0, [r7, #4]
 80069ea:	f7ff fa81 	bl	8005ef0 <USB_OTG_WritePacket>
    
    pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_buff  += len;
 80069ee:	7b3b      	ldrb	r3, [r7, #12]
 80069f0:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 80069f4:	b2db      	uxtb	r3, r3
 80069f6:	461a      	mov	r2, r3
 80069f8:	7b3b      	ldrb	r3, [r7, #12]
 80069fa:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 80069fe:	b2db      	uxtb	r3, r3
 8006a00:	4619      	mov	r1, r3
 8006a02:	6878      	ldr	r0, [r7, #4]
 8006a04:	460b      	mov	r3, r1
 8006a06:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006a0a:	185b      	adds	r3, r3, r1
 8006a0c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006a10:	18c3      	adds	r3, r0, r3
 8006a12:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
 8006a16:	6819      	ldr	r1, [r3, #0]
 8006a18:	8abb      	ldrh	r3, [r7, #20]
 8006a1a:	18c9      	adds	r1, r1, r3
 8006a1c:	6878      	ldr	r0, [r7, #4]
 8006a1e:	4613      	mov	r3, r2
 8006a20:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006a24:	189b      	adds	r3, r3, r2
 8006a26:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006a2a:	18c3      	adds	r3, r0, r3
 8006a2c:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
 8006a30:	6019      	str	r1, [r3, #0]
    pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len   -= len;
 8006a32:	7b3b      	ldrb	r3, [r7, #12]
 8006a34:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 8006a38:	b2db      	uxtb	r3, r3
 8006a3a:	461a      	mov	r2, r3
 8006a3c:	7b3b      	ldrb	r3, [r7, #12]
 8006a3e:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 8006a42:	b2db      	uxtb	r3, r3
 8006a44:	4619      	mov	r1, r3
 8006a46:	6878      	ldr	r0, [r7, #4]
 8006a48:	460b      	mov	r3, r1
 8006a4a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006a4e:	185b      	adds	r3, r3, r1
 8006a50:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006a54:	18c3      	adds	r3, r0, r3
 8006a56:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
 8006a5a:	6819      	ldr	r1, [r3, #0]
 8006a5c:	8abb      	ldrh	r3, [r7, #20]
 8006a5e:	1ac9      	subs	r1, r1, r3
 8006a60:	6878      	ldr	r0, [r7, #4]
 8006a62:	4613      	mov	r3, r2
 8006a64:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006a68:	189b      	adds	r3, r3, r2
 8006a6a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006a6e:	18c3      	adds	r3, r0, r3
 8006a70:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
 8006a74:	6019      	str	r1, [r3, #0]
    pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_count  += len; 
 8006a76:	7b3b      	ldrb	r3, [r7, #12]
 8006a78:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 8006a7c:	b2db      	uxtb	r3, r3
 8006a7e:	461a      	mov	r2, r3
 8006a80:	7b3b      	ldrb	r3, [r7, #12]
 8006a82:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 8006a86:	b2db      	uxtb	r3, r3
 8006a88:	4619      	mov	r1, r3
 8006a8a:	6878      	ldr	r0, [r7, #4]
 8006a8c:	460b      	mov	r3, r1
 8006a8e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006a92:	185b      	adds	r3, r3, r1
 8006a94:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006a98:	18c3      	adds	r3, r0, r3
 8006a9a:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 8006a9e:	6819      	ldr	r1, [r3, #0]
 8006aa0:	8abb      	ldrh	r3, [r7, #20]
 8006aa2:	18c9      	adds	r1, r1, r3
 8006aa4:	6878      	ldr	r0, [r7, #4]
 8006aa6:	4613      	mov	r3, r2
 8006aa8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006aac:	189b      	adds	r3, r3, r2
 8006aae:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006ab2:	18c3      	adds	r3, r0, r3
 8006ab4:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 8006ab8:	6019      	str	r1, [r3, #0]
    
    hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 8006aba:	687b      	ldr	r3, [r7, #4]
 8006abc:	695b      	ldr	r3, [r3, #20]
 8006abe:	691b      	ldr	r3, [r3, #16]
 8006ac0:	60bb      	str	r3, [r7, #8]
  
  hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
  
  len_words = (pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len + 3) / 4;
  
  while ((hptxsts.b.ptxfspcavail > len_words)&&
 8006ac2:	893b      	ldrh	r3, [r7, #8]
 8006ac4:	8afa      	ldrh	r2, [r7, #22]
 8006ac6:	429a      	cmp	r2, r3
 8006ac8:	d212      	bcs.n	8006af0 <USB_OTG_USBH_handle_ptxfempty_ISR+0x20c>
         (pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len != 0))    
 8006aca:	7b3b      	ldrb	r3, [r7, #12]
 8006acc:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 8006ad0:	b2db      	uxtb	r3, r3
 8006ad2:	461a      	mov	r2, r3
 8006ad4:	6879      	ldr	r1, [r7, #4]
 8006ad6:	4613      	mov	r3, r2
 8006ad8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006adc:	189b      	adds	r3, r3, r2
 8006ade:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006ae2:	18cb      	adds	r3, r1, r3
 8006ae4:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
 8006ae8:	681b      	ldr	r3, [r3, #0]
  
  hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
  
  len_words = (pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len + 3) / 4;
  
  while ((hptxsts.b.ptxfspcavail > len_words)&&
 8006aea:	2b00      	cmp	r3, #0
 8006aec:	f47f af18 	bne.w	8006920 <USB_OTG_USBH_handle_ptxfempty_ISR+0x3c>
    pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_count  += len; 
    
    hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
  }  
  
  return 1;
 8006af0:	f04f 0301 	mov.w	r3, #1
}
 8006af4:	4618      	mov	r0, r3
 8006af6:	f107 0718 	add.w	r7, r7, #24
 8006afa:	46bd      	mov	sp, r7
 8006afc:	bd80      	pop	{r7, pc}
 8006afe:	bf00      	nop

08006b00 <USB_OTG_USBH_handle_port_ISR>:
*/
#if defined ( __ICCARM__ ) /*!< IAR Compiler */
#pragma optimize = none
#endif /* __CC_ARM */
static uint32_t USB_OTG_USBH_handle_port_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8006b00:	b580      	push	{r7, lr}
 8006b02:	b088      	sub	sp, #32
 8006b04:	af00      	add	r7, sp, #0
 8006b06:	6078      	str	r0, [r7, #4]
  USB_OTG_HPRT0_TypeDef  hprt0;
  USB_OTG_HPRT0_TypeDef  hprt0_dup;
  USB_OTG_HCFG_TypeDef   hcfg;    
  uint32_t do_reset = 0;
 8006b08:	f04f 0300 	mov.w	r3, #0
 8006b0c:	61fb      	str	r3, [r7, #28]
  uint32_t retval = 0;
 8006b0e:	f04f 0300 	mov.w	r3, #0
 8006b12:	61bb      	str	r3, [r7, #24]
  
  hcfg.d32 = 0;
 8006b14:	f04f 0300 	mov.w	r3, #0
 8006b18:	60fb      	str	r3, [r7, #12]
  hprt0.d32 = 0;
 8006b1a:	f04f 0300 	mov.w	r3, #0
 8006b1e:	617b      	str	r3, [r7, #20]
  hprt0_dup.d32 = 0;
 8006b20:	f04f 0300 	mov.w	r3, #0
 8006b24:	613b      	str	r3, [r7, #16]
  
  hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 8006b26:	687b      	ldr	r3, [r7, #4]
 8006b28:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8006b2c:	681b      	ldr	r3, [r3, #0]
 8006b2e:	617b      	str	r3, [r7, #20]
  hprt0_dup.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 8006b30:	687b      	ldr	r3, [r7, #4]
 8006b32:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8006b36:	681b      	ldr	r3, [r3, #0]
 8006b38:	613b      	str	r3, [r7, #16]
  
  /* Clear the interrupt bits in GINTSTS */
  
  hprt0_dup.b.prtena = 0;
 8006b3a:	693b      	ldr	r3, [r7, #16]
 8006b3c:	f36f 0382 	bfc	r3, #2, #1
 8006b40:	613b      	str	r3, [r7, #16]
  hprt0_dup.b.prtconndet = 0;
 8006b42:	693b      	ldr	r3, [r7, #16]
 8006b44:	f36f 0341 	bfc	r3, #1, #1
 8006b48:	613b      	str	r3, [r7, #16]
  hprt0_dup.b.prtenchng = 0;
 8006b4a:	693b      	ldr	r3, [r7, #16]
 8006b4c:	f36f 03c3 	bfc	r3, #3, #1
 8006b50:	613b      	str	r3, [r7, #16]
  hprt0_dup.b.prtovrcurrchng = 0;
 8006b52:	693b      	ldr	r3, [r7, #16]
 8006b54:	f36f 1345 	bfc	r3, #5, #1
 8006b58:	613b      	str	r3, [r7, #16]
  
  /* Port Connect Detected */
  if (hprt0.b.prtconndet)
 8006b5a:	7d3b      	ldrb	r3, [r7, #20]
 8006b5c:	f003 0302 	and.w	r3, r3, #2
 8006b60:	b2db      	uxtb	r3, r3
 8006b62:	2b00      	cmp	r3, #0
 8006b64:	d00c      	beq.n	8006b80 <USB_OTG_USBH_handle_port_ISR+0x80>
  {

    hprt0_dup.b.prtconndet = 1;
 8006b66:	693b      	ldr	r3, [r7, #16]
 8006b68:	f043 0302 	orr.w	r3, r3, #2
 8006b6c:	613b      	str	r3, [r7, #16]
    //USBH_HCD_INT_fops->DevConnected(pdev);
	pdev->host.ConnSts = 1;
 8006b6e:	687b      	ldr	r3, [r7, #4]
 8006b70:	f04f 0201 	mov.w	r2, #1
 8006b74:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310
    retval |= 1;
 8006b78:	69bb      	ldr	r3, [r7, #24]
 8006b7a:	f043 0301 	orr.w	r3, r3, #1
 8006b7e:	61bb      	str	r3, [r7, #24]
  }
  
  /* Port Enable Changed */
  if (hprt0.b.prtenchng)
 8006b80:	7d3b      	ldrb	r3, [r7, #20]
 8006b82:	f003 0308 	and.w	r3, r3, #8
 8006b86:	b2db      	uxtb	r3, r3
 8006b88:	2b00      	cmp	r3, #0
 8006b8a:	d055      	beq.n	8006c38 <USB_OTG_USBH_handle_port_ISR+0x138>
  {
    hprt0_dup.b.prtenchng = 1;
 8006b8c:	693b      	ldr	r3, [r7, #16]
 8006b8e:	f043 0308 	orr.w	r3, r3, #8
 8006b92:	613b      	str	r3, [r7, #16]
    
    if (hprt0.b.prtena == 1)
 8006b94:	7d3b      	ldrb	r3, [r7, #20]
 8006b96:	f003 0304 	and.w	r3, r3, #4
 8006b9a:	b2db      	uxtb	r3, r3
 8006b9c:	2b00      	cmp	r3, #0
 8006b9e:	d04b      	beq.n	8006c38 <USB_OTG_USBH_handle_port_ISR+0x138>
    {
      
      //USBH_HCD_INT_fops->DevConnected(pdev);
      pdev->host.ConnSts = 1;
 8006ba0:	687b      	ldr	r3, [r7, #4]
 8006ba2:	f04f 0201 	mov.w	r2, #1
 8006ba6:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310
      
      if ((hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED) ||
 8006baa:	7dbb      	ldrb	r3, [r7, #22]
 8006bac:	f003 0306 	and.w	r3, r3, #6
 8006bb0:	b2db      	uxtb	r3, r3
 8006bb2:	2b04      	cmp	r3, #4
 8006bb4:	d005      	beq.n	8006bc2 <USB_OTG_USBH_handle_port_ISR+0xc2>
          (hprt0.b.prtspd == HPRT0_PRTSPD_FULL_SPEED))
 8006bb6:	7dbb      	ldrb	r3, [r7, #22]
 8006bb8:	f003 0306 	and.w	r3, r3, #6
 8006bbc:	b2db      	uxtb	r3, r3
    {
      
      //USBH_HCD_INT_fops->DevConnected(pdev);
      pdev->host.ConnSts = 1;
      
      if ((hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED) ||
 8006bbe:	2b02      	cmp	r3, #2
 8006bc0:	d135      	bne.n	8006c2e <USB_OTG_USBH_handle_port_ISR+0x12e>
          (hprt0.b.prtspd == HPRT0_PRTSPD_FULL_SPEED))
      {
        
        hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
 8006bc2:	687b      	ldr	r3, [r7, #4]
 8006bc4:	695b      	ldr	r3, [r3, #20]
 8006bc6:	681b      	ldr	r3, [r3, #0]
 8006bc8:	60fb      	str	r3, [r7, #12]
        
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 8006bca:	7dbb      	ldrb	r3, [r7, #22]
 8006bcc:	f003 0306 	and.w	r3, r3, #6
 8006bd0:	b2db      	uxtb	r3, r3
 8006bd2:	2b04      	cmp	r3, #4
 8006bd4:	d117      	bne.n	8006c06 <USB_OTG_USBH_handle_port_ISR+0x106>
        {
          USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HFIR, 6000 );
 8006bd6:	687b      	ldr	r3, [r7, #4]
 8006bd8:	695b      	ldr	r3, [r3, #20]
 8006bda:	f241 7270 	movw	r2, #6000	; 0x1770
 8006bde:	605a      	str	r2, [r3, #4]
          if (hcfg.b.fslspclksel != HCFG_6_MHZ)
 8006be0:	7b3b      	ldrb	r3, [r7, #12]
 8006be2:	f003 0303 	and.w	r3, r3, #3
 8006be6:	b2db      	uxtb	r3, r3
 8006be8:	2b02      	cmp	r3, #2
 8006bea:	d024      	beq.n	8006c36 <USB_OTG_USBH_handle_port_ISR+0x136>
          {
            if(pdev->cfg.phy_itface  == USB_OTG_EMBEDDED_PHY)
 8006bec:	687b      	ldr	r3, [r7, #4]
 8006bee:	7a1b      	ldrb	r3, [r3, #8]
 8006bf0:	2b02      	cmp	r3, #2
 8006bf2:	d104      	bne.n	8006bfe <USB_OTG_USBH_handle_port_ISR+0xfe>
            {
              USB_OTG_InitFSLSPClkSel(pdev ,HCFG_6_MHZ );
 8006bf4:	6878      	ldr	r0, [r7, #4]
 8006bf6:	f04f 0102 	mov.w	r1, #2
 8006bfa:	f7ff fadf 	bl	80061bc <USB_OTG_InitFSLSPClkSel>
            }
            do_reset = 1;
 8006bfe:	f04f 0301 	mov.w	r3, #1
 8006c02:	61fb      	str	r3, [r7, #28]
          (hprt0.b.prtspd == HPRT0_PRTSPD_FULL_SPEED))
      {
        
        hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
        
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 8006c04:	e017      	b.n	8006c36 <USB_OTG_USBH_handle_port_ISR+0x136>
          }
        }
        else
        {
          
          USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HFIR, 48000 );            
 8006c06:	687b      	ldr	r3, [r7, #4]
 8006c08:	695b      	ldr	r3, [r3, #20]
 8006c0a:	f64b 3280 	movw	r2, #48000	; 0xbb80
 8006c0e:	605a      	str	r2, [r3, #4]
          if (hcfg.b.fslspclksel != HCFG_48_MHZ)
 8006c10:	7b3b      	ldrb	r3, [r7, #12]
 8006c12:	f003 0303 	and.w	r3, r3, #3
 8006c16:	b2db      	uxtb	r3, r3
 8006c18:	2b01      	cmp	r3, #1
 8006c1a:	d00c      	beq.n	8006c36 <USB_OTG_USBH_handle_port_ISR+0x136>
          {
            USB_OTG_InitFSLSPClkSel(pdev ,HCFG_48_MHZ );
 8006c1c:	6878      	ldr	r0, [r7, #4]
 8006c1e:	f04f 0101 	mov.w	r1, #1
 8006c22:	f7ff facb 	bl	80061bc <USB_OTG_InitFSLSPClkSel>
            do_reset = 1;
 8006c26:	f04f 0301 	mov.w	r3, #1
 8006c2a:	61fb      	str	r3, [r7, #28]
          (hprt0.b.prtspd == HPRT0_PRTSPD_FULL_SPEED))
      {
        
        hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
        
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 8006c2c:	e003      	b.n	8006c36 <USB_OTG_USBH_handle_port_ISR+0x136>
          }
        }
      }
      else
      {
        do_reset = 1;
 8006c2e:	f04f 0301 	mov.w	r3, #1
 8006c32:	61fb      	str	r3, [r7, #28]
 8006c34:	e000      	b.n	8006c38 <USB_OTG_USBH_handle_port_ISR+0x138>
          (hprt0.b.prtspd == HPRT0_PRTSPD_FULL_SPEED))
      {
        
        hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
        
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 8006c36:	bf00      	nop
        do_reset = 1;
      }
    }
  }
  /* Overcurrent Change Interrupt */
  if (hprt0.b.prtovrcurrchng)
 8006c38:	7d3b      	ldrb	r3, [r7, #20]
 8006c3a:	f003 0320 	and.w	r3, r3, #32
 8006c3e:	b2db      	uxtb	r3, r3
 8006c40:	2b00      	cmp	r3, #0
 8006c42:	d007      	beq.n	8006c54 <USB_OTG_USBH_handle_port_ISR+0x154>
  {
    hprt0_dup.b.prtovrcurrchng = 1;
 8006c44:	693b      	ldr	r3, [r7, #16]
 8006c46:	f043 0320 	orr.w	r3, r3, #32
 8006c4a:	613b      	str	r3, [r7, #16]
    retval |= 1;
 8006c4c:	69bb      	ldr	r3, [r7, #24]
 8006c4e:	f043 0301 	orr.w	r3, r3, #1
 8006c52:	61bb      	str	r3, [r7, #24]
  }
  if (do_reset)
 8006c54:	69fb      	ldr	r3, [r7, #28]
 8006c56:	2b00      	cmp	r3, #0
 8006c58:	d004      	beq.n	8006c64 <USB_OTG_USBH_handle_port_ISR+0x164>
  {
    //USB_OTG_ResetPort(pdev);
	pdev->host.port_need_reset = 1;	// todo: need refactoring later.
 8006c5a:	687b      	ldr	r3, [r7, #4]
 8006c5c:	f04f 0201 	mov.w	r2, #1
 8006c60:	f8c3 25ec 	str.w	r2, [r3, #1516]	; 0x5ec

  }
  /* Clear Port Interrupts */
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0_dup.d32);
 8006c64:	687b      	ldr	r3, [r7, #4]
 8006c66:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8006c6a:	693a      	ldr	r2, [r7, #16]
 8006c6c:	601a      	str	r2, [r3, #0]
  
  return retval;
 8006c6e:	69bb      	ldr	r3, [r7, #24]
}
 8006c70:	4618      	mov	r0, r3
 8006c72:	f107 0720 	add.w	r7, r7, #32
 8006c76:	46bd      	mov	sp, r7
 8006c78:	bd80      	pop	{r7, pc}
 8006c7a:	bf00      	nop

08006c7c <USB_OTG_USBH_handle_hc_n_Out_ISR>:
* @param  pdev: Selected device
* @param  hc_num: Channel number
* @retval status 
*/
uint32_t USB_OTG_USBH_handle_hc_n_Out_ISR (USB_OTG_CORE_HANDLE *pdev , uint32_t num)
{
 8006c7c:	b580      	push	{r7, lr}
 8006c7e:	b09a      	sub	sp, #104	; 0x68
 8006c80:	af00      	add	r7, sp, #0
 8006c82:	6078      	str	r0, [r7, #4]
 8006c84:	6039      	str	r1, [r7, #0]
  USB_OTG_HCINTn_TypeDef     hcint;
  USB_OTG_HCINTMSK_TypeDef  hcintmsk;
  USB_OTG_HC_REGS *hcreg;
  USB_OTG_HCCHAR_TypeDef     hcchar; 
  
  hcreg = pdev->regs.HC_REGS[num];
 8006c86:	687a      	ldr	r2, [r7, #4]
 8006c88:	683b      	ldr	r3, [r7, #0]
 8006c8a:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006c8e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006c92:	18d3      	adds	r3, r2, r3
 8006c94:	689b      	ldr	r3, [r3, #8]
 8006c96:	667b      	str	r3, [r7, #100]	; 0x64
  hcint.d32 = USB_OTG_READ_REG32(&hcreg->HCINT);
 8006c98:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8006c9a:	689b      	ldr	r3, [r3, #8]
 8006c9c:	663b      	str	r3, [r7, #96]	; 0x60
  hcintmsk.d32 = USB_OTG_READ_REG32(&hcreg->HCINTMSK);
 8006c9e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8006ca0:	68db      	ldr	r3, [r3, #12]
 8006ca2:	65fb      	str	r3, [r7, #92]	; 0x5c
  hcint.d32 = hcint.d32 & hcintmsk.d32;
 8006ca4:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8006ca6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8006ca8:	4013      	ands	r3, r2
 8006caa:	663b      	str	r3, [r7, #96]	; 0x60
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[num]->HCCHAR);
 8006cac:	687a      	ldr	r2, [r7, #4]
 8006cae:	683b      	ldr	r3, [r7, #0]
 8006cb0:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006cb4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006cb8:	18d3      	adds	r3, r2, r3
 8006cba:	689b      	ldr	r3, [r3, #8]
 8006cbc:	681b      	ldr	r3, [r3, #0]
 8006cbe:	65bb      	str	r3, [r7, #88]	; 0x58
  
  if (hcint.b.ahberr)
 8006cc0:	f897 3060 	ldrb.w	r3, [r7, #96]	; 0x60
 8006cc4:	f003 0304 	and.w	r3, r3, #4
 8006cc8:	b2db      	uxtb	r3, r3
 8006cca:	2b00      	cmp	r3, #0
 8006ccc:	d022      	beq.n	8006d14 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x98>
  {
    CLEAR_HC_INT(hcreg ,ahberr);
 8006cce:	f04f 0300 	mov.w	r3, #0
 8006cd2:	657b      	str	r3, [r7, #84]	; 0x54
 8006cd4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006cd6:	f043 0304 	orr.w	r3, r3, #4
 8006cda:	657b      	str	r3, [r7, #84]	; 0x54
 8006cdc:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8006cde:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8006ce0:	609a      	str	r2, [r3, #8]
    UNMASK_HOST_INT_CHH (num);
 8006ce2:	687a      	ldr	r2, [r7, #4]
 8006ce4:	683b      	ldr	r3, [r7, #0]
 8006ce6:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006cea:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006cee:	18d3      	adds	r3, r2, r3
 8006cf0:	689b      	ldr	r3, [r3, #8]
 8006cf2:	68db      	ldr	r3, [r3, #12]
 8006cf4:	653b      	str	r3, [r7, #80]	; 0x50
 8006cf6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006cf8:	f043 0302 	orr.w	r3, r3, #2
 8006cfc:	653b      	str	r3, [r7, #80]	; 0x50
 8006cfe:	687a      	ldr	r2, [r7, #4]
 8006d00:	683b      	ldr	r3, [r7, #0]
 8006d02:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006d06:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006d0a:	18d3      	adds	r3, r2, r3
 8006d0c:	689b      	ldr	r3, [r3, #8]
 8006d0e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8006d10:	60da      	str	r2, [r3, #12]
 8006d12:	e29a      	b.n	800724a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ce>
  } 
  else if (hcint.b.ack)
 8006d14:	f897 3060 	ldrb.w	r3, [r7, #96]	; 0x60
 8006d18:	f003 0320 	and.w	r3, r3, #32
 8006d1c:	b2db      	uxtb	r3, r3
 8006d1e:	2b00      	cmp	r3, #0
 8006d20:	d00a      	beq.n	8006d38 <USB_OTG_USBH_handle_hc_n_Out_ISR+0xbc>
  {
    CLEAR_HC_INT(hcreg , ack);
 8006d22:	f04f 0300 	mov.w	r3, #0
 8006d26:	64fb      	str	r3, [r7, #76]	; 0x4c
 8006d28:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006d2a:	f043 0320 	orr.w	r3, r3, #32
 8006d2e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8006d30:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006d32:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8006d34:	609a      	str	r2, [r3, #8]
 8006d36:	e288      	b.n	800724a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ce>
  }
  else if (hcint.b.frmovrun)
 8006d38:	f897 3061 	ldrb.w	r3, [r7, #97]	; 0x61
 8006d3c:	f003 0302 	and.w	r3, r3, #2
 8006d40:	b2db      	uxtb	r3, r3
 8006d42:	2b00      	cmp	r3, #0
 8006d44:	d028      	beq.n	8006d98 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x11c>
  {
    UNMASK_HOST_INT_CHH (num);
 8006d46:	687a      	ldr	r2, [r7, #4]
 8006d48:	683b      	ldr	r3, [r7, #0]
 8006d4a:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006d4e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006d52:	18d3      	adds	r3, r2, r3
 8006d54:	689b      	ldr	r3, [r3, #8]
 8006d56:	68db      	ldr	r3, [r3, #12]
 8006d58:	64bb      	str	r3, [r7, #72]	; 0x48
 8006d5a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8006d5c:	f043 0302 	orr.w	r3, r3, #2
 8006d60:	64bb      	str	r3, [r7, #72]	; 0x48
 8006d62:	687a      	ldr	r2, [r7, #4]
 8006d64:	683b      	ldr	r3, [r7, #0]
 8006d66:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006d6a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006d6e:	18d3      	adds	r3, r2, r3
 8006d70:	689b      	ldr	r3, [r3, #8]
 8006d72:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8006d74:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 8006d76:	683b      	ldr	r3, [r7, #0]
 8006d78:	b2db      	uxtb	r3, r3
 8006d7a:	6878      	ldr	r0, [r7, #4]
 8006d7c:	4619      	mov	r1, r3
 8006d7e:	f7ff fbb6 	bl	80064ee <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg ,frmovrun);
 8006d82:	f04f 0300 	mov.w	r3, #0
 8006d86:	647b      	str	r3, [r7, #68]	; 0x44
 8006d88:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006d8a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8006d8e:	647b      	str	r3, [r7, #68]	; 0x44
 8006d90:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8006d92:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8006d94:	609a      	str	r2, [r3, #8]
 8006d96:	e258      	b.n	800724a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ce>
  }
  else if (hcint.b.xfercompl)
 8006d98:	f897 3060 	ldrb.w	r3, [r7, #96]	; 0x60
 8006d9c:	f003 0301 	and.w	r3, r3, #1
 8006da0:	b2db      	uxtb	r3, r3
 8006da2:	2b00      	cmp	r3, #0
 8006da4:	d03a      	beq.n	8006e1c <USB_OTG_USBH_handle_hc_n_Out_ISR+0x1a0>
  {
    pdev->host.ErrCnt[num] = 0;
 8006da6:	687a      	ldr	r2, [r7, #4]
 8006da8:	683b      	ldr	r3, [r7, #0]
 8006daa:	f103 03c4 	add.w	r3, r3, #196	; 0xc4
 8006dae:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006db2:	18d3      	adds	r3, r2, r3
 8006db4:	f04f 0200 	mov.w	r2, #0
 8006db8:	605a      	str	r2, [r3, #4]
    UNMASK_HOST_INT_CHH (num);
 8006dba:	687a      	ldr	r2, [r7, #4]
 8006dbc:	683b      	ldr	r3, [r7, #0]
 8006dbe:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006dc2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006dc6:	18d3      	adds	r3, r2, r3
 8006dc8:	689b      	ldr	r3, [r3, #8]
 8006dca:	68db      	ldr	r3, [r3, #12]
 8006dcc:	643b      	str	r3, [r7, #64]	; 0x40
 8006dce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8006dd0:	f043 0302 	orr.w	r3, r3, #2
 8006dd4:	643b      	str	r3, [r7, #64]	; 0x40
 8006dd6:	687a      	ldr	r2, [r7, #4]
 8006dd8:	683b      	ldr	r3, [r7, #0]
 8006dda:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006dde:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006de2:	18d3      	adds	r3, r2, r3
 8006de4:	689b      	ldr	r3, [r3, #8]
 8006de6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8006de8:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 8006dea:	683b      	ldr	r3, [r7, #0]
 8006dec:	b2db      	uxtb	r3, r3
 8006dee:	6878      	ldr	r0, [r7, #4]
 8006df0:	4619      	mov	r1, r3
 8006df2:	f7ff fb7c 	bl	80064ee <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , xfercompl);
 8006df6:	f04f 0300 	mov.w	r3, #0
 8006dfa:	63fb      	str	r3, [r7, #60]	; 0x3c
 8006dfc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006dfe:	f043 0301 	orr.w	r3, r3, #1
 8006e02:	63fb      	str	r3, [r7, #60]	; 0x3c
 8006e04:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8006e06:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8006e08:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_XFRC;            
 8006e0a:	687a      	ldr	r2, [r7, #4]
 8006e0c:	683b      	ldr	r3, [r7, #0]
 8006e0e:	18d3      	adds	r3, r2, r3
 8006e10:	f503 7362 	add.w	r3, r3, #904	; 0x388
 8006e14:	f04f 0201 	mov.w	r2, #1
 8006e18:	711a      	strb	r2, [r3, #4]
 8006e1a:	e216      	b.n	800724a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ce>
  }
  
  else if (hcint.b.stall)
 8006e1c:	f897 3060 	ldrb.w	r3, [r7, #96]	; 0x60
 8006e20:	f003 0308 	and.w	r3, r3, #8
 8006e24:	b2db      	uxtb	r3, r3
 8006e26:	2b00      	cmp	r3, #0
 8006e28:	d030      	beq.n	8006e8c <USB_OTG_USBH_handle_hc_n_Out_ISR+0x210>
  {
    CLEAR_HC_INT(hcreg , stall);
 8006e2a:	f04f 0300 	mov.w	r3, #0
 8006e2e:	63bb      	str	r3, [r7, #56]	; 0x38
 8006e30:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006e32:	f043 0308 	orr.w	r3, r3, #8
 8006e36:	63bb      	str	r3, [r7, #56]	; 0x38
 8006e38:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8006e3a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8006e3c:	609a      	str	r2, [r3, #8]
    UNMASK_HOST_INT_CHH (num);
 8006e3e:	687a      	ldr	r2, [r7, #4]
 8006e40:	683b      	ldr	r3, [r7, #0]
 8006e42:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006e46:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006e4a:	18d3      	adds	r3, r2, r3
 8006e4c:	689b      	ldr	r3, [r3, #8]
 8006e4e:	68db      	ldr	r3, [r3, #12]
 8006e50:	637b      	str	r3, [r7, #52]	; 0x34
 8006e52:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8006e54:	f043 0302 	orr.w	r3, r3, #2
 8006e58:	637b      	str	r3, [r7, #52]	; 0x34
 8006e5a:	687a      	ldr	r2, [r7, #4]
 8006e5c:	683b      	ldr	r3, [r7, #0]
 8006e5e:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006e62:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006e66:	18d3      	adds	r3, r2, r3
 8006e68:	689b      	ldr	r3, [r3, #8]
 8006e6a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8006e6c:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 8006e6e:	683b      	ldr	r3, [r7, #0]
 8006e70:	b2db      	uxtb	r3, r3
 8006e72:	6878      	ldr	r0, [r7, #4]
 8006e74:	4619      	mov	r1, r3
 8006e76:	f7ff fb3a 	bl	80064ee <USB_OTG_HC_Halt>
    pdev->host.HC_Status[num] = HC_STALL;      
 8006e7a:	687a      	ldr	r2, [r7, #4]
 8006e7c:	683b      	ldr	r3, [r7, #0]
 8006e7e:	18d3      	adds	r3, r2, r3
 8006e80:	f503 7362 	add.w	r3, r3, #904	; 0x388
 8006e84:	f04f 0205 	mov.w	r2, #5
 8006e88:	711a      	strb	r2, [r3, #4]
 8006e8a:	e1de      	b.n	800724a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ce>
  }
  
  else if (hcint.b.nak)
 8006e8c:	f897 3060 	ldrb.w	r3, [r7, #96]	; 0x60
 8006e90:	f003 0310 	and.w	r3, r3, #16
 8006e94:	b2db      	uxtb	r3, r3
 8006e96:	2b00      	cmp	r3, #0
 8006e98:	d03a      	beq.n	8006f10 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x294>
  {
    pdev->host.ErrCnt[num] = 0;
 8006e9a:	687a      	ldr	r2, [r7, #4]
 8006e9c:	683b      	ldr	r3, [r7, #0]
 8006e9e:	f103 03c4 	add.w	r3, r3, #196	; 0xc4
 8006ea2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006ea6:	18d3      	adds	r3, r2, r3
 8006ea8:	f04f 0200 	mov.w	r2, #0
 8006eac:	605a      	str	r2, [r3, #4]
    UNMASK_HOST_INT_CHH (num);
 8006eae:	687a      	ldr	r2, [r7, #4]
 8006eb0:	683b      	ldr	r3, [r7, #0]
 8006eb2:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006eb6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006eba:	18d3      	adds	r3, r2, r3
 8006ebc:	689b      	ldr	r3, [r3, #8]
 8006ebe:	68db      	ldr	r3, [r3, #12]
 8006ec0:	633b      	str	r3, [r7, #48]	; 0x30
 8006ec2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8006ec4:	f043 0302 	orr.w	r3, r3, #2
 8006ec8:	633b      	str	r3, [r7, #48]	; 0x30
 8006eca:	687a      	ldr	r2, [r7, #4]
 8006ecc:	683b      	ldr	r3, [r7, #0]
 8006ece:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006ed2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006ed6:	18d3      	adds	r3, r2, r3
 8006ed8:	689b      	ldr	r3, [r3, #8]
 8006eda:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8006edc:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 8006ede:	683b      	ldr	r3, [r7, #0]
 8006ee0:	b2db      	uxtb	r3, r3
 8006ee2:	6878      	ldr	r0, [r7, #4]
 8006ee4:	4619      	mov	r1, r3
 8006ee6:	f7ff fb02 	bl	80064ee <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , nak);
 8006eea:	f04f 0300 	mov.w	r3, #0
 8006eee:	62fb      	str	r3, [r7, #44]	; 0x2c
 8006ef0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006ef2:	f043 0310 	orr.w	r3, r3, #16
 8006ef6:	62fb      	str	r3, [r7, #44]	; 0x2c
 8006ef8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006efa:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8006efc:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_NAK;      
 8006efe:	687a      	ldr	r2, [r7, #4]
 8006f00:	683b      	ldr	r3, [r7, #0]
 8006f02:	18d3      	adds	r3, r2, r3
 8006f04:	f503 7362 	add.w	r3, r3, #904	; 0x388
 8006f08:	f04f 0203 	mov.w	r2, #3
 8006f0c:	711a      	strb	r2, [r3, #4]
 8006f0e:	e19c      	b.n	800724a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ce>
  }
  
  else if (hcint.b.xacterr)
 8006f10:	f897 3060 	ldrb.w	r3, [r7, #96]	; 0x60
 8006f14:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8006f18:	b2db      	uxtb	r3, r3
 8006f1a:	2b00      	cmp	r3, #0
 8006f1c:	d042      	beq.n	8006fa4 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x328>
  {
    UNMASK_HOST_INT_CHH (num);
 8006f1e:	687a      	ldr	r2, [r7, #4]
 8006f20:	683b      	ldr	r3, [r7, #0]
 8006f22:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006f26:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006f2a:	18d3      	adds	r3, r2, r3
 8006f2c:	689b      	ldr	r3, [r3, #8]
 8006f2e:	68db      	ldr	r3, [r3, #12]
 8006f30:	62bb      	str	r3, [r7, #40]	; 0x28
 8006f32:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f34:	f043 0302 	orr.w	r3, r3, #2
 8006f38:	62bb      	str	r3, [r7, #40]	; 0x28
 8006f3a:	687a      	ldr	r2, [r7, #4]
 8006f3c:	683b      	ldr	r3, [r7, #0]
 8006f3e:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006f42:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006f46:	18d3      	adds	r3, r2, r3
 8006f48:	689b      	ldr	r3, [r3, #8]
 8006f4a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8006f4c:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 8006f4e:	683b      	ldr	r3, [r7, #0]
 8006f50:	b2db      	uxtb	r3, r3
 8006f52:	6878      	ldr	r0, [r7, #4]
 8006f54:	4619      	mov	r1, r3
 8006f56:	f7ff faca 	bl	80064ee <USB_OTG_HC_Halt>
    pdev->host.ErrCnt[num] ++;
 8006f5a:	687a      	ldr	r2, [r7, #4]
 8006f5c:	683b      	ldr	r3, [r7, #0]
 8006f5e:	f103 03c4 	add.w	r3, r3, #196	; 0xc4
 8006f62:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006f66:	18d3      	adds	r3, r2, r3
 8006f68:	685b      	ldr	r3, [r3, #4]
 8006f6a:	f103 0201 	add.w	r2, r3, #1
 8006f6e:	6879      	ldr	r1, [r7, #4]
 8006f70:	683b      	ldr	r3, [r7, #0]
 8006f72:	f103 03c4 	add.w	r3, r3, #196	; 0xc4
 8006f76:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006f7a:	18cb      	adds	r3, r1, r3
 8006f7c:	605a      	str	r2, [r3, #4]
    pdev->host.HC_Status[num] = HC_XACTERR;
 8006f7e:	687a      	ldr	r2, [r7, #4]
 8006f80:	683b      	ldr	r3, [r7, #0]
 8006f82:	18d3      	adds	r3, r2, r3
 8006f84:	f503 7362 	add.w	r3, r3, #904	; 0x388
 8006f88:	f04f 0206 	mov.w	r2, #6
 8006f8c:	711a      	strb	r2, [r3, #4]
    CLEAR_HC_INT(hcreg , xacterr);
 8006f8e:	f04f 0300 	mov.w	r3, #0
 8006f92:	627b      	str	r3, [r7, #36]	; 0x24
 8006f94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006f96:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006f9a:	627b      	str	r3, [r7, #36]	; 0x24
 8006f9c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006f9e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8006fa0:	609a      	str	r2, [r3, #8]
 8006fa2:	e152      	b.n	800724a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ce>
  }
  else if (hcint.b.nyet)
 8006fa4:	f897 3060 	ldrb.w	r3, [r7, #96]	; 0x60
 8006fa8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006fac:	b2db      	uxtb	r3, r3
 8006fae:	2b00      	cmp	r3, #0
 8006fb0:	d03a      	beq.n	8007028 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x3ac>
  {
    pdev->host.ErrCnt[num] = 0;
 8006fb2:	687a      	ldr	r2, [r7, #4]
 8006fb4:	683b      	ldr	r3, [r7, #0]
 8006fb6:	f103 03c4 	add.w	r3, r3, #196	; 0xc4
 8006fba:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006fbe:	18d3      	adds	r3, r2, r3
 8006fc0:	f04f 0200 	mov.w	r2, #0
 8006fc4:	605a      	str	r2, [r3, #4]
    UNMASK_HOST_INT_CHH (num);
 8006fc6:	687a      	ldr	r2, [r7, #4]
 8006fc8:	683b      	ldr	r3, [r7, #0]
 8006fca:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006fce:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006fd2:	18d3      	adds	r3, r2, r3
 8006fd4:	689b      	ldr	r3, [r3, #8]
 8006fd6:	68db      	ldr	r3, [r3, #12]
 8006fd8:	623b      	str	r3, [r7, #32]
 8006fda:	6a3b      	ldr	r3, [r7, #32]
 8006fdc:	f043 0302 	orr.w	r3, r3, #2
 8006fe0:	623b      	str	r3, [r7, #32]
 8006fe2:	687a      	ldr	r2, [r7, #4]
 8006fe4:	683b      	ldr	r3, [r7, #0]
 8006fe6:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8006fea:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8006fee:	18d3      	adds	r3, r2, r3
 8006ff0:	689b      	ldr	r3, [r3, #8]
 8006ff2:	6a3a      	ldr	r2, [r7, #32]
 8006ff4:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 8006ff6:	683b      	ldr	r3, [r7, #0]
 8006ff8:	b2db      	uxtb	r3, r3
 8006ffa:	6878      	ldr	r0, [r7, #4]
 8006ffc:	4619      	mov	r1, r3
 8006ffe:	f7ff fa76 	bl	80064ee <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , nyet);
 8007002:	f04f 0300 	mov.w	r3, #0
 8007006:	61fb      	str	r3, [r7, #28]
 8007008:	69fb      	ldr	r3, [r7, #28]
 800700a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800700e:	61fb      	str	r3, [r7, #28]
 8007010:	69fa      	ldr	r2, [r7, #28]
 8007012:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007014:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_NYET;    
 8007016:	687a      	ldr	r2, [r7, #4]
 8007018:	683b      	ldr	r3, [r7, #0]
 800701a:	18d3      	adds	r3, r2, r3
 800701c:	f503 7362 	add.w	r3, r3, #904	; 0x388
 8007020:	f04f 0204 	mov.w	r2, #4
 8007024:	711a      	strb	r2, [r3, #4]
 8007026:	e110      	b.n	800724a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ce>
  }
  else if (hcint.b.datatglerr)
 8007028:	f897 3061 	ldrb.w	r3, [r7, #97]	; 0x61
 800702c:	f003 0304 	and.w	r3, r3, #4
 8007030:	b2db      	uxtb	r3, r3
 8007032:	2b00      	cmp	r3, #0
 8007034:	d03a      	beq.n	80070ac <USB_OTG_USBH_handle_hc_n_Out_ISR+0x430>
  {
    
    UNMASK_HOST_INT_CHH (num);
 8007036:	687a      	ldr	r2, [r7, #4]
 8007038:	683b      	ldr	r3, [r7, #0]
 800703a:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800703e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007042:	18d3      	adds	r3, r2, r3
 8007044:	689b      	ldr	r3, [r3, #8]
 8007046:	68db      	ldr	r3, [r3, #12]
 8007048:	61bb      	str	r3, [r7, #24]
 800704a:	69bb      	ldr	r3, [r7, #24]
 800704c:	f043 0302 	orr.w	r3, r3, #2
 8007050:	61bb      	str	r3, [r7, #24]
 8007052:	687a      	ldr	r2, [r7, #4]
 8007054:	683b      	ldr	r3, [r7, #0]
 8007056:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800705a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800705e:	18d3      	adds	r3, r2, r3
 8007060:	689b      	ldr	r3, [r3, #8]
 8007062:	69ba      	ldr	r2, [r7, #24]
 8007064:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 8007066:	683b      	ldr	r3, [r7, #0]
 8007068:	b2db      	uxtb	r3, r3
 800706a:	6878      	ldr	r0, [r7, #4]
 800706c:	4619      	mov	r1, r3
 800706e:	f7ff fa3e 	bl	80064ee <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , nak);   
 8007072:	f04f 0300 	mov.w	r3, #0
 8007076:	617b      	str	r3, [r7, #20]
 8007078:	697b      	ldr	r3, [r7, #20]
 800707a:	f043 0310 	orr.w	r3, r3, #16
 800707e:	617b      	str	r3, [r7, #20]
 8007080:	697a      	ldr	r2, [r7, #20]
 8007082:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007084:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_DATATGLERR;
 8007086:	687a      	ldr	r2, [r7, #4]
 8007088:	683b      	ldr	r3, [r7, #0]
 800708a:	18d3      	adds	r3, r2, r3
 800708c:	f503 7362 	add.w	r3, r3, #904	; 0x388
 8007090:	f04f 0208 	mov.w	r2, #8
 8007094:	711a      	strb	r2, [r3, #4]
    
    CLEAR_HC_INT(hcreg , datatglerr);
 8007096:	f04f 0300 	mov.w	r3, #0
 800709a:	613b      	str	r3, [r7, #16]
 800709c:	693b      	ldr	r3, [r7, #16]
 800709e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80070a2:	613b      	str	r3, [r7, #16]
 80070a4:	693a      	ldr	r2, [r7, #16]
 80070a6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80070a8:	609a      	str	r2, [r3, #8]
 80070aa:	e0ce      	b.n	800724a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ce>
  }  
  else if (hcint.b.chhltd)
 80070ac:	f897 3060 	ldrb.w	r3, [r7, #96]	; 0x60
 80070b0:	f003 0302 	and.w	r3, r3, #2
 80070b4:	b2db      	uxtb	r3, r3
 80070b6:	2b00      	cmp	r3, #0
 80070b8:	f000 80c7 	beq.w	800724a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ce>
  {
    MASK_HOST_INT_CHH (num);
 80070bc:	687a      	ldr	r2, [r7, #4]
 80070be:	683b      	ldr	r3, [r7, #0]
 80070c0:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80070c4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80070c8:	18d3      	adds	r3, r2, r3
 80070ca:	689b      	ldr	r3, [r3, #8]
 80070cc:	68db      	ldr	r3, [r3, #12]
 80070ce:	60fb      	str	r3, [r7, #12]
 80070d0:	68fb      	ldr	r3, [r7, #12]
 80070d2:	f36f 0341 	bfc	r3, #1, #1
 80070d6:	60fb      	str	r3, [r7, #12]
 80070d8:	687a      	ldr	r2, [r7, #4]
 80070da:	683b      	ldr	r3, [r7, #0]
 80070dc:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80070e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80070e4:	18d3      	adds	r3, r2, r3
 80070e6:	689b      	ldr	r3, [r3, #8]
 80070e8:	68fa      	ldr	r2, [r7, #12]
 80070ea:	60da      	str	r2, [r3, #12]
    
    if(pdev->host.HC_Status[num] == HC_XFRC)
 80070ec:	687a      	ldr	r2, [r7, #4]
 80070ee:	683b      	ldr	r3, [r7, #0]
 80070f0:	18d3      	adds	r3, r2, r3
 80070f2:	f503 7362 	add.w	r3, r3, #904	; 0x388
 80070f6:	791b      	ldrb	r3, [r3, #4]
 80070f8:	b2db      	uxtb	r3, r3
 80070fa:	2b01      	cmp	r3, #1
 80070fc:	d12c      	bne.n	8007158 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4dc>
    {
      pdev->host.URB_State[num] = URB_DONE;  
 80070fe:	687a      	ldr	r2, [r7, #4]
 8007100:	683b      	ldr	r3, [r7, #0]
 8007102:	18d3      	adds	r3, r2, r3
 8007104:	f503 7366 	add.w	r3, r3, #920	; 0x398
 8007108:	f04f 0201 	mov.w	r2, #1
 800710c:	70da      	strb	r2, [r3, #3]
      
      if (hcchar.b.eptype == EP_TYPE_BULK)
 800710e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8007112:	f003 030c 	and.w	r3, r3, #12
 8007116:	b2db      	uxtb	r3, r3
 8007118:	2b08      	cmp	r3, #8
 800711a:	f040 808c 	bne.w	8007236 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ba>
      {
        pdev->host.hc[num].toggle_out ^= 1; 
 800711e:	6879      	ldr	r1, [r7, #4]
 8007120:	683a      	ldr	r2, [r7, #0]
 8007122:	4613      	mov	r3, r2
 8007124:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8007128:	189b      	adds	r3, r3, r2
 800712a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800712e:	18cb      	adds	r3, r1, r3
 8007130:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 8007134:	795b      	ldrb	r3, [r3, #5]
 8007136:	f083 0301 	eor.w	r3, r3, #1
 800713a:	b2d9      	uxtb	r1, r3
 800713c:	6878      	ldr	r0, [r7, #4]
 800713e:	683a      	ldr	r2, [r7, #0]
 8007140:	4613      	mov	r3, r2
 8007142:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8007146:	189b      	adds	r3, r3, r2
 8007148:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800714c:	18c3      	adds	r3, r0, r3
 800714e:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 8007152:	460a      	mov	r2, r1
 8007154:	715a      	strb	r2, [r3, #5]
 8007156:	e06e      	b.n	8007236 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ba>
      }
    }
    else if(pdev->host.HC_Status[num] == HC_NAK)
 8007158:	687a      	ldr	r2, [r7, #4]
 800715a:	683b      	ldr	r3, [r7, #0]
 800715c:	18d3      	adds	r3, r2, r3
 800715e:	f503 7362 	add.w	r3, r3, #904	; 0x388
 8007162:	791b      	ldrb	r3, [r3, #4]
 8007164:	b2db      	uxtb	r3, r3
 8007166:	2b03      	cmp	r3, #3
 8007168:	d108      	bne.n	800717c <USB_OTG_USBH_handle_hc_n_Out_ISR+0x500>
    {
      pdev->host.URB_State[num] = URB_NOTREADY;      
 800716a:	687a      	ldr	r2, [r7, #4]
 800716c:	683b      	ldr	r3, [r7, #0]
 800716e:	18d3      	adds	r3, r2, r3
 8007170:	f503 7366 	add.w	r3, r3, #920	; 0x398
 8007174:	f04f 0202 	mov.w	r2, #2
 8007178:	70da      	strb	r2, [r3, #3]
 800717a:	e05c      	b.n	8007236 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ba>
    }    
    else if(pdev->host.HC_Status[num] == HC_NYET)
 800717c:	687a      	ldr	r2, [r7, #4]
 800717e:	683b      	ldr	r3, [r7, #0]
 8007180:	18d3      	adds	r3, r2, r3
 8007182:	f503 7362 	add.w	r3, r3, #904	; 0x388
 8007186:	791b      	ldrb	r3, [r3, #4]
 8007188:	b2db      	uxtb	r3, r3
 800718a:	2b04      	cmp	r3, #4
 800718c:	d11c      	bne.n	80071c8 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x54c>
    {
      if(pdev->host.hc[num].do_ping == 1)
 800718e:	6879      	ldr	r1, [r7, #4]
 8007190:	683a      	ldr	r2, [r7, #0]
 8007192:	4613      	mov	r3, r2
 8007194:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8007198:	189b      	adds	r3, r3, r2
 800719a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800719e:	18cb      	adds	r3, r1, r3
 80071a0:	f503 736a 	add.w	r3, r3, #936	; 0x3a8
 80071a4:	7a1b      	ldrb	r3, [r3, #8]
 80071a6:	2b01      	cmp	r3, #1
 80071a8:	d105      	bne.n	80071b6 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x53a>
      {
        USB_OTG_HC_DoPing(pdev, num);
 80071aa:	683b      	ldr	r3, [r7, #0]
 80071ac:	b2db      	uxtb	r3, r3
 80071ae:	6878      	ldr	r0, [r7, #4]
 80071b0:	4619      	mov	r1, r3
 80071b2:	f7ff f9b9 	bl	8006528 <USB_OTG_HC_DoPing>
      }
      pdev->host.URB_State[num] = URB_NOTREADY;      
 80071b6:	687a      	ldr	r2, [r7, #4]
 80071b8:	683b      	ldr	r3, [r7, #0]
 80071ba:	18d3      	adds	r3, r2, r3
 80071bc:	f503 7366 	add.w	r3, r3, #920	; 0x398
 80071c0:	f04f 0202 	mov.w	r2, #2
 80071c4:	70da      	strb	r2, [r3, #3]
 80071c6:	e036      	b.n	8007236 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ba>
    }      
    else if(pdev->host.HC_Status[num] == HC_STALL)
 80071c8:	687a      	ldr	r2, [r7, #4]
 80071ca:	683b      	ldr	r3, [r7, #0]
 80071cc:	18d3      	adds	r3, r2, r3
 80071ce:	f503 7362 	add.w	r3, r3, #904	; 0x388
 80071d2:	791b      	ldrb	r3, [r3, #4]
 80071d4:	b2db      	uxtb	r3, r3
 80071d6:	2b05      	cmp	r3, #5
 80071d8:	d108      	bne.n	80071ec <USB_OTG_USBH_handle_hc_n_Out_ISR+0x570>
    {
      pdev->host.URB_State[num] = URB_STALL;      
 80071da:	687a      	ldr	r2, [r7, #4]
 80071dc:	683b      	ldr	r3, [r7, #0]
 80071de:	18d3      	adds	r3, r2, r3
 80071e0:	f503 7366 	add.w	r3, r3, #920	; 0x398
 80071e4:	f04f 0204 	mov.w	r2, #4
 80071e8:	70da      	strb	r2, [r3, #3]
 80071ea:	e024      	b.n	8007236 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ba>
    }  
    else if(pdev->host.HC_Status[num] == HC_XACTERR)
 80071ec:	687a      	ldr	r2, [r7, #4]
 80071ee:	683b      	ldr	r3, [r7, #0]
 80071f0:	18d3      	adds	r3, r2, r3
 80071f2:	f503 7362 	add.w	r3, r3, #904	; 0x388
 80071f6:	791b      	ldrb	r3, [r3, #4]
 80071f8:	b2db      	uxtb	r3, r3
 80071fa:	2b06      	cmp	r3, #6
 80071fc:	d11b      	bne.n	8007236 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ba>
    {
      if (pdev->host.ErrCnt[num] == 3)
 80071fe:	687a      	ldr	r2, [r7, #4]
 8007200:	683b      	ldr	r3, [r7, #0]
 8007202:	f103 03c4 	add.w	r3, r3, #196	; 0xc4
 8007206:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800720a:	18d3      	adds	r3, r2, r3
 800720c:	685b      	ldr	r3, [r3, #4]
 800720e:	2b03      	cmp	r3, #3
 8007210:	d111      	bne.n	8007236 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x5ba>
      {
        pdev->host.URB_State[num] = URB_ERROR;  
 8007212:	687a      	ldr	r2, [r7, #4]
 8007214:	683b      	ldr	r3, [r7, #0]
 8007216:	18d3      	adds	r3, r2, r3
 8007218:	f503 7366 	add.w	r3, r3, #920	; 0x398
 800721c:	f04f 0203 	mov.w	r2, #3
 8007220:	70da      	strb	r2, [r3, #3]
        pdev->host.ErrCnt[num] = 0;
 8007222:	687a      	ldr	r2, [r7, #4]
 8007224:	683b      	ldr	r3, [r7, #0]
 8007226:	f103 03c4 	add.w	r3, r3, #196	; 0xc4
 800722a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800722e:	18d3      	adds	r3, r2, r3
 8007230:	f04f 0200 	mov.w	r2, #0
 8007234:	605a      	str	r2, [r3, #4]
      }
    }
    CLEAR_HC_INT(hcreg , chhltd);    
 8007236:	f04f 0300 	mov.w	r3, #0
 800723a:	60bb      	str	r3, [r7, #8]
 800723c:	68bb      	ldr	r3, [r7, #8]
 800723e:	f043 0302 	orr.w	r3, r3, #2
 8007242:	60bb      	str	r3, [r7, #8]
 8007244:	68ba      	ldr	r2, [r7, #8]
 8007246:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007248:	609a      	str	r2, [r3, #8]
  }
  
  
  return 1;
 800724a:	f04f 0301 	mov.w	r3, #1
}
 800724e:	4618      	mov	r0, r3
 8007250:	f107 0768 	add.w	r7, r7, #104	; 0x68
 8007254:	46bd      	mov	sp, r7
 8007256:	bd80      	pop	{r7, pc}

08007258 <USB_OTG_USBH_handle_hc_n_In_ISR>:
* @param  pdev: Selected device
* @param  hc_num: Channel number
* @retval status 
*/
uint32_t USB_OTG_USBH_handle_hc_n_In_ISR (USB_OTG_CORE_HANDLE *pdev , uint32_t num)
{
 8007258:	b580      	push	{r7, lr}
 800725a:	b09c      	sub	sp, #112	; 0x70
 800725c:	af00      	add	r7, sp, #0
 800725e:	6078      	str	r0, [r7, #4]
 8007260:	6039      	str	r1, [r7, #0]
  USB_OTG_HCCHAR_TypeDef     hcchar; 
  USB_OTG_HCTSIZn_TypeDef  hctsiz;
  USB_OTG_HC_REGS *hcreg;
  
  
  hcreg = pdev->regs.HC_REGS[num];
 8007262:	687a      	ldr	r2, [r7, #4]
 8007264:	683b      	ldr	r3, [r7, #0]
 8007266:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800726a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800726e:	18d3      	adds	r3, r2, r3
 8007270:	689b      	ldr	r3, [r3, #8]
 8007272:	66fb      	str	r3, [r7, #108]	; 0x6c
  hcint.d32 = USB_OTG_READ_REG32(&hcreg->HCINT);
 8007274:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8007276:	689b      	ldr	r3, [r3, #8]
 8007278:	66bb      	str	r3, [r7, #104]	; 0x68
  hcintmsk.d32 = USB_OTG_READ_REG32(&hcreg->HCINTMSK);
 800727a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800727c:	68db      	ldr	r3, [r3, #12]
 800727e:	667b      	str	r3, [r7, #100]	; 0x64
  hcint.d32 = hcint.d32 & hcintmsk.d32;
 8007280:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8007282:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8007284:	4013      	ands	r3, r2
 8007286:	66bb      	str	r3, [r7, #104]	; 0x68
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[num]->HCCHAR);
 8007288:	687a      	ldr	r2, [r7, #4]
 800728a:	683b      	ldr	r3, [r7, #0]
 800728c:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8007290:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007294:	18d3      	adds	r3, r2, r3
 8007296:	689b      	ldr	r3, [r3, #8]
 8007298:	681b      	ldr	r3, [r3, #0]
 800729a:	663b      	str	r3, [r7, #96]	; 0x60
  hcintmsk.d32 = 0;
 800729c:	f04f 0300 	mov.w	r3, #0
 80072a0:	667b      	str	r3, [r7, #100]	; 0x64
  
  
  if (hcint.b.ahberr)
 80072a2:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 80072a6:	f003 0304 	and.w	r3, r3, #4
 80072aa:	b2db      	uxtb	r3, r3
 80072ac:	2b00      	cmp	r3, #0
 80072ae:	d022      	beq.n	80072f6 <USB_OTG_USBH_handle_hc_n_In_ISR+0x9e>
  {
    CLEAR_HC_INT(hcreg ,ahberr);
 80072b0:	f04f 0300 	mov.w	r3, #0
 80072b4:	65bb      	str	r3, [r7, #88]	; 0x58
 80072b6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80072b8:	f043 0304 	orr.w	r3, r3, #4
 80072bc:	65bb      	str	r3, [r7, #88]	; 0x58
 80072be:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80072c0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80072c2:	609a      	str	r2, [r3, #8]
    UNMASK_HOST_INT_CHH (num);
 80072c4:	687a      	ldr	r2, [r7, #4]
 80072c6:	683b      	ldr	r3, [r7, #0]
 80072c8:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80072cc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80072d0:	18d3      	adds	r3, r2, r3
 80072d2:	689b      	ldr	r3, [r3, #8]
 80072d4:	68db      	ldr	r3, [r3, #12]
 80072d6:	657b      	str	r3, [r7, #84]	; 0x54
 80072d8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80072da:	f043 0302 	orr.w	r3, r3, #2
 80072de:	657b      	str	r3, [r7, #84]	; 0x54
 80072e0:	687a      	ldr	r2, [r7, #4]
 80072e2:	683b      	ldr	r3, [r7, #0]
 80072e4:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80072e8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80072ec:	18d3      	adds	r3, r2, r3
 80072ee:	689b      	ldr	r3, [r3, #8]
 80072f0:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80072f2:	60da      	str	r2, [r3, #12]
 80072f4:	e098      	b.n	8007428 <USB_OTG_USBH_handle_hc_n_In_ISR+0x1d0>
  }  
  else if (hcint.b.ack)
 80072f6:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 80072fa:	f003 0320 	and.w	r3, r3, #32
 80072fe:	b2db      	uxtb	r3, r3
 8007300:	2b00      	cmp	r3, #0
 8007302:	d00a      	beq.n	800731a <USB_OTG_USBH_handle_hc_n_In_ISR+0xc2>
  {
    CLEAR_HC_INT(hcreg ,ack);
 8007304:	f04f 0300 	mov.w	r3, #0
 8007308:	653b      	str	r3, [r7, #80]	; 0x50
 800730a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800730c:	f043 0320 	orr.w	r3, r3, #32
 8007310:	653b      	str	r3, [r7, #80]	; 0x50
 8007312:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8007314:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8007316:	609a      	str	r2, [r3, #8]
 8007318:	e086      	b.n	8007428 <USB_OTG_USBH_handle_hc_n_In_ISR+0x1d0>
  }
  
  else if (hcint.b.stall)  
 800731a:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 800731e:	f003 0308 	and.w	r3, r3, #8
 8007322:	b2db      	uxtb	r3, r3
 8007324:	2b00      	cmp	r3, #0
 8007326:	d03e      	beq.n	80073a6 <USB_OTG_USBH_handle_hc_n_In_ISR+0x14e>
  {
    UNMASK_HOST_INT_CHH (num);
 8007328:	687a      	ldr	r2, [r7, #4]
 800732a:	683b      	ldr	r3, [r7, #0]
 800732c:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8007330:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007334:	18d3      	adds	r3, r2, r3
 8007336:	689b      	ldr	r3, [r3, #8]
 8007338:	68db      	ldr	r3, [r3, #12]
 800733a:	64fb      	str	r3, [r7, #76]	; 0x4c
 800733c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800733e:	f043 0302 	orr.w	r3, r3, #2
 8007342:	64fb      	str	r3, [r7, #76]	; 0x4c
 8007344:	687a      	ldr	r2, [r7, #4]
 8007346:	683b      	ldr	r3, [r7, #0]
 8007348:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800734c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007350:	18d3      	adds	r3, r2, r3
 8007352:	689b      	ldr	r3, [r3, #8]
 8007354:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8007356:	60da      	str	r2, [r3, #12]
    pdev->host.HC_Status[num] = HC_STALL; 
 8007358:	687a      	ldr	r2, [r7, #4]
 800735a:	683b      	ldr	r3, [r7, #0]
 800735c:	18d3      	adds	r3, r2, r3
 800735e:	f503 7362 	add.w	r3, r3, #904	; 0x388
 8007362:	f04f 0205 	mov.w	r2, #5
 8007366:	711a      	strb	r2, [r3, #4]
    CLEAR_HC_INT(hcreg , nak);   /* Clear the NAK Condition */
 8007368:	f04f 0300 	mov.w	r3, #0
 800736c:	64bb      	str	r3, [r7, #72]	; 0x48
 800736e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007370:	f043 0310 	orr.w	r3, r3, #16
 8007374:	64bb      	str	r3, [r7, #72]	; 0x48
 8007376:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8007378:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800737a:	609a      	str	r2, [r3, #8]
    CLEAR_HC_INT(hcreg , stall); /* Clear the STALL Condition */
 800737c:	f04f 0300 	mov.w	r3, #0
 8007380:	647b      	str	r3, [r7, #68]	; 0x44
 8007382:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007384:	f043 0308 	orr.w	r3, r3, #8
 8007388:	647b      	str	r3, [r7, #68]	; 0x44
 800738a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800738c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800738e:	609a      	str	r2, [r3, #8]
    hcint.b.nak = 0;           /* NOTE: When there is a 'stall', reset also nak, 
 8007390:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8007392:	f36f 1304 	bfc	r3, #4, #1
 8007396:	66bb      	str	r3, [r7, #104]	; 0x68
                                  else, the pdev->host.HC_Status = HC_STALL
    will be overwritten by 'nak' in code below */
    USB_OTG_HC_Halt(pdev, num);    
 8007398:	683b      	ldr	r3, [r7, #0]
 800739a:	b2db      	uxtb	r3, r3
 800739c:	6878      	ldr	r0, [r7, #4]
 800739e:	4619      	mov	r1, r3
 80073a0:	f7ff f8a5 	bl	80064ee <USB_OTG_HC_Halt>
 80073a4:	e040      	b.n	8007428 <USB_OTG_USBH_handle_hc_n_In_ISR+0x1d0>
  }
  else if (hcint.b.datatglerr)
 80073a6:	f897 3069 	ldrb.w	r3, [r7, #105]	; 0x69
 80073aa:	f003 0304 	and.w	r3, r3, #4
 80073ae:	b2db      	uxtb	r3, r3
 80073b0:	2b00      	cmp	r3, #0
 80073b2:	d039      	beq.n	8007428 <USB_OTG_USBH_handle_hc_n_In_ISR+0x1d0>
  {
    
    UNMASK_HOST_INT_CHH (num);
 80073b4:	687a      	ldr	r2, [r7, #4]
 80073b6:	683b      	ldr	r3, [r7, #0]
 80073b8:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80073bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80073c0:	18d3      	adds	r3, r2, r3
 80073c2:	689b      	ldr	r3, [r3, #8]
 80073c4:	68db      	ldr	r3, [r3, #12]
 80073c6:	643b      	str	r3, [r7, #64]	; 0x40
 80073c8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80073ca:	f043 0302 	orr.w	r3, r3, #2
 80073ce:	643b      	str	r3, [r7, #64]	; 0x40
 80073d0:	687a      	ldr	r2, [r7, #4]
 80073d2:	683b      	ldr	r3, [r7, #0]
 80073d4:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80073d8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80073dc:	18d3      	adds	r3, r2, r3
 80073de:	689b      	ldr	r3, [r3, #8]
 80073e0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80073e2:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 80073e4:	683b      	ldr	r3, [r7, #0]
 80073e6:	b2db      	uxtb	r3, r3
 80073e8:	6878      	ldr	r0, [r7, #4]
 80073ea:	4619      	mov	r1, r3
 80073ec:	f7ff f87f 	bl	80064ee <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , nak);   
 80073f0:	f04f 0300 	mov.w	r3, #0
 80073f4:	63fb      	str	r3, [r7, #60]	; 0x3c
 80073f6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80073f8:	f043 0310 	orr.w	r3, r3, #16
 80073fc:	63fb      	str	r3, [r7, #60]	; 0x3c
 80073fe:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8007400:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8007402:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_DATATGLERR; 
 8007404:	687a      	ldr	r2, [r7, #4]
 8007406:	683b      	ldr	r3, [r7, #0]
 8007408:	18d3      	adds	r3, r2, r3
 800740a:	f503 7362 	add.w	r3, r3, #904	; 0x388
 800740e:	f04f 0208 	mov.w	r2, #8
 8007412:	711a      	strb	r2, [r3, #4]
    CLEAR_HC_INT(hcreg , datatglerr);
 8007414:	f04f 0300 	mov.w	r3, #0
 8007418:	63bb      	str	r3, [r7, #56]	; 0x38
 800741a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800741c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8007420:	63bb      	str	r3, [r7, #56]	; 0x38
 8007422:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8007424:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8007426:	609a      	str	r2, [r3, #8]
  }    
  
  if (hcint.b.frmovrun)
 8007428:	f897 3069 	ldrb.w	r3, [r7, #105]	; 0x69
 800742c:	f003 0302 	and.w	r3, r3, #2
 8007430:	b2db      	uxtb	r3, r3
 8007432:	2b00      	cmp	r3, #0
 8007434:	d028      	beq.n	8007488 <USB_OTG_USBH_handle_hc_n_In_ISR+0x230>
  {
    UNMASK_HOST_INT_CHH (num);
 8007436:	687a      	ldr	r2, [r7, #4]
 8007438:	683b      	ldr	r3, [r7, #0]
 800743a:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800743e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007442:	18d3      	adds	r3, r2, r3
 8007444:	689b      	ldr	r3, [r3, #8]
 8007446:	68db      	ldr	r3, [r3, #12]
 8007448:	637b      	str	r3, [r7, #52]	; 0x34
 800744a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800744c:	f043 0302 	orr.w	r3, r3, #2
 8007450:	637b      	str	r3, [r7, #52]	; 0x34
 8007452:	687a      	ldr	r2, [r7, #4]
 8007454:	683b      	ldr	r3, [r7, #0]
 8007456:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800745a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800745e:	18d3      	adds	r3, r2, r3
 8007460:	689b      	ldr	r3, [r3, #8]
 8007462:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8007464:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 8007466:	683b      	ldr	r3, [r7, #0]
 8007468:	b2db      	uxtb	r3, r3
 800746a:	6878      	ldr	r0, [r7, #4]
 800746c:	4619      	mov	r1, r3
 800746e:	f7ff f83e 	bl	80064ee <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg ,frmovrun);
 8007472:	f04f 0300 	mov.w	r3, #0
 8007476:	633b      	str	r3, [r7, #48]	; 0x30
 8007478:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800747a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800747e:	633b      	str	r3, [r7, #48]	; 0x30
 8007480:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8007482:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8007484:	609a      	str	r2, [r3, #8]
 8007486:	e1fb      	b.n	8007880 <USB_OTG_USBH_handle_hc_n_In_ISR+0x628>
  }
  
  else if (hcint.b.xfercompl)
 8007488:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 800748c:	f003 0301 	and.w	r3, r3, #1
 8007490:	b2db      	uxtb	r3, r3
 8007492:	2b00      	cmp	r3, #0
 8007494:	f000 80b2 	beq.w	80075fc <USB_OTG_USBH_handle_hc_n_In_ISR+0x3a4>
  {
    
    if (pdev->cfg.dma_enable == 1)
 8007498:	687b      	ldr	r3, [r7, #4]
 800749a:	78db      	ldrb	r3, [r3, #3]
 800749c:	2b01      	cmp	r3, #1
 800749e:	d11f      	bne.n	80074e0 <USB_OTG_USBH_handle_hc_n_In_ISR+0x288>
    {
      hctsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[num]->HCTSIZ);
 80074a0:	687a      	ldr	r2, [r7, #4]
 80074a2:	683b      	ldr	r3, [r7, #0]
 80074a4:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80074a8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80074ac:	18d3      	adds	r3, r2, r3
 80074ae:	689b      	ldr	r3, [r3, #8]
 80074b0:	691b      	ldr	r3, [r3, #16]
 80074b2:	65fb      	str	r3, [r7, #92]	; 0x5c
      pdev->host.XferCnt[num] =  pdev->host.hc[num].xfer_len - hctsiz.b.xfersize;
 80074b4:	6879      	ldr	r1, [r7, #4]
 80074b6:	683a      	ldr	r2, [r7, #0]
 80074b8:	4613      	mov	r3, r2
 80074ba:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80074be:	189b      	adds	r3, r3, r2
 80074c0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80074c4:	18cb      	adds	r3, r1, r3
 80074c6:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
 80074ca:	681a      	ldr	r2, [r3, #0]
 80074cc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80074ce:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80074d2:	1ad1      	subs	r1, r2, r3
 80074d4:	687b      	ldr	r3, [r7, #4]
 80074d6:	683a      	ldr	r2, [r7, #0]
 80074d8:	f102 02d4 	add.w	r2, r2, #212	; 0xd4
 80074dc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }
    
    pdev->host.HC_Status[num] = HC_XFRC;     
 80074e0:	687a      	ldr	r2, [r7, #4]
 80074e2:	683b      	ldr	r3, [r7, #0]
 80074e4:	18d3      	adds	r3, r2, r3
 80074e6:	f503 7362 	add.w	r3, r3, #904	; 0x388
 80074ea:	f04f 0201 	mov.w	r2, #1
 80074ee:	711a      	strb	r2, [r3, #4]
    pdev->host.ErrCnt [num]= 0;
 80074f0:	687a      	ldr	r2, [r7, #4]
 80074f2:	683b      	ldr	r3, [r7, #0]
 80074f4:	f103 03c4 	add.w	r3, r3, #196	; 0xc4
 80074f8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80074fc:	18d3      	adds	r3, r2, r3
 80074fe:	f04f 0200 	mov.w	r2, #0
 8007502:	605a      	str	r2, [r3, #4]
    CLEAR_HC_INT(hcreg , xfercompl);
 8007504:	f04f 0300 	mov.w	r3, #0
 8007508:	62fb      	str	r3, [r7, #44]	; 0x2c
 800750a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800750c:	f043 0301 	orr.w	r3, r3, #1
 8007510:	62fb      	str	r3, [r7, #44]	; 0x2c
 8007512:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8007514:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8007516:	609a      	str	r2, [r3, #8]
    
    if ((hcchar.b.eptype == EP_TYPE_CTRL)||
 8007518:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 800751c:	f003 030c 	and.w	r3, r3, #12
 8007520:	b2db      	uxtb	r3, r3
 8007522:	2b00      	cmp	r3, #0
 8007524:	d006      	beq.n	8007534 <USB_OTG_USBH_handle_hc_n_In_ISR+0x2dc>
        (hcchar.b.eptype == EP_TYPE_BULK))
 8007526:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 800752a:	f003 030c 	and.w	r3, r3, #12
 800752e:	b2db      	uxtb	r3, r3
    
    pdev->host.HC_Status[num] = HC_XFRC;     
    pdev->host.ErrCnt [num]= 0;
    CLEAR_HC_INT(hcreg , xfercompl);
    
    if ((hcchar.b.eptype == EP_TYPE_CTRL)||
 8007530:	2b08      	cmp	r3, #8
 8007532:	d144      	bne.n	80075be <USB_OTG_USBH_handle_hc_n_In_ISR+0x366>
        (hcchar.b.eptype == EP_TYPE_BULK))
    {
      UNMASK_HOST_INT_CHH (num);
 8007534:	687a      	ldr	r2, [r7, #4]
 8007536:	683b      	ldr	r3, [r7, #0]
 8007538:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800753c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007540:	18d3      	adds	r3, r2, r3
 8007542:	689b      	ldr	r3, [r3, #8]
 8007544:	68db      	ldr	r3, [r3, #12]
 8007546:	62bb      	str	r3, [r7, #40]	; 0x28
 8007548:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800754a:	f043 0302 	orr.w	r3, r3, #2
 800754e:	62bb      	str	r3, [r7, #40]	; 0x28
 8007550:	687a      	ldr	r2, [r7, #4]
 8007552:	683b      	ldr	r3, [r7, #0]
 8007554:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8007558:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800755c:	18d3      	adds	r3, r2, r3
 800755e:	689b      	ldr	r3, [r3, #8]
 8007560:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007562:	60da      	str	r2, [r3, #12]
      USB_OTG_HC_Halt(pdev, num);
 8007564:	683b      	ldr	r3, [r7, #0]
 8007566:	b2db      	uxtb	r3, r3
 8007568:	6878      	ldr	r0, [r7, #4]
 800756a:	4619      	mov	r1, r3
 800756c:	f7fe ffbf 	bl	80064ee <USB_OTG_HC_Halt>
      CLEAR_HC_INT(hcreg , nak); 
 8007570:	f04f 0300 	mov.w	r3, #0
 8007574:	627b      	str	r3, [r7, #36]	; 0x24
 8007576:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007578:	f043 0310 	orr.w	r3, r3, #16
 800757c:	627b      	str	r3, [r7, #36]	; 0x24
 800757e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007580:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8007582:	609a      	str	r2, [r3, #8]
      pdev->host.hc[num].toggle_in ^= 1;
 8007584:	6879      	ldr	r1, [r7, #4]
 8007586:	683a      	ldr	r2, [r7, #0]
 8007588:	4613      	mov	r3, r2
 800758a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800758e:	189b      	adds	r3, r3, r2
 8007590:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007594:	18cb      	adds	r3, r1, r3
 8007596:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 800759a:	791b      	ldrb	r3, [r3, #4]
 800759c:	f083 0301 	eor.w	r3, r3, #1
 80075a0:	b2d9      	uxtb	r1, r3
 80075a2:	6878      	ldr	r0, [r7, #4]
 80075a4:	683a      	ldr	r2, [r7, #0]
 80075a6:	4613      	mov	r3, r2
 80075a8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80075ac:	189b      	adds	r3, r3, r2
 80075ae:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80075b2:	18c3      	adds	r3, r0, r3
 80075b4:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 80075b8:	460a      	mov	r2, r1
 80075ba:	711a      	strb	r2, [r3, #4]
 80075bc:	e160      	b.n	8007880 <USB_OTG_USBH_handle_hc_n_In_ISR+0x628>
      
    }
    else if(hcchar.b.eptype == EP_TYPE_INTR)
 80075be:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 80075c2:	f003 030c 	and.w	r3, r3, #12
 80075c6:	b2db      	uxtb	r3, r3
 80075c8:	2b0c      	cmp	r3, #12
 80075ca:	f040 8158 	bne.w	800787e <USB_OTG_USBH_handle_hc_n_In_ISR+0x626>
    {
      hcchar.b.oddfrm  = 1;
 80075ce:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80075d0:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80075d4:	663b      	str	r3, [r7, #96]	; 0x60
      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[num]->HCCHAR, hcchar.d32); 
 80075d6:	687a      	ldr	r2, [r7, #4]
 80075d8:	683b      	ldr	r3, [r7, #0]
 80075da:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80075de:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80075e2:	18d3      	adds	r3, r2, r3
 80075e4:	689b      	ldr	r3, [r3, #8]
 80075e6:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80075e8:	601a      	str	r2, [r3, #0]
      pdev->host.URB_State[num] = URB_DONE;  
 80075ea:	687a      	ldr	r2, [r7, #4]
 80075ec:	683b      	ldr	r3, [r7, #0]
 80075ee:	18d3      	adds	r3, r2, r3
 80075f0:	f503 7366 	add.w	r3, r3, #920	; 0x398
 80075f4:	f04f 0201 	mov.w	r2, #1
 80075f8:	70da      	strb	r2, [r3, #3]
 80075fa:	e140      	b.n	800787e <USB_OTG_USBH_handle_hc_n_In_ISR+0x626>
    }
    
  }
  else if (hcint.b.chhltd)
 80075fc:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 8007600:	f003 0302 	and.w	r3, r3, #2
 8007604:	b2db      	uxtb	r3, r3
 8007606:	2b00      	cmp	r3, #0
 8007608:	f000 808f 	beq.w	800772a <USB_OTG_USBH_handle_hc_n_In_ISR+0x4d2>
  {
    MASK_HOST_INT_CHH (num);
 800760c:	687a      	ldr	r2, [r7, #4]
 800760e:	683b      	ldr	r3, [r7, #0]
 8007610:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8007614:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007618:	18d3      	adds	r3, r2, r3
 800761a:	689b      	ldr	r3, [r3, #8]
 800761c:	68db      	ldr	r3, [r3, #12]
 800761e:	623b      	str	r3, [r7, #32]
 8007620:	6a3b      	ldr	r3, [r7, #32]
 8007622:	f36f 0341 	bfc	r3, #1, #1
 8007626:	623b      	str	r3, [r7, #32]
 8007628:	687a      	ldr	r2, [r7, #4]
 800762a:	683b      	ldr	r3, [r7, #0]
 800762c:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8007630:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007634:	18d3      	adds	r3, r2, r3
 8007636:	689b      	ldr	r3, [r3, #8]
 8007638:	6a3a      	ldr	r2, [r7, #32]
 800763a:	60da      	str	r2, [r3, #12]
    
    if(pdev->host.HC_Status[num] == HC_XFRC)
 800763c:	687a      	ldr	r2, [r7, #4]
 800763e:	683b      	ldr	r3, [r7, #0]
 8007640:	18d3      	adds	r3, r2, r3
 8007642:	f503 7362 	add.w	r3, r3, #904	; 0x388
 8007646:	791b      	ldrb	r3, [r3, #4]
 8007648:	b2db      	uxtb	r3, r3
 800764a:	2b01      	cmp	r3, #1
 800764c:	d108      	bne.n	8007660 <USB_OTG_USBH_handle_hc_n_In_ISR+0x408>
    {
      pdev->host.URB_State[num] = URB_DONE;      
 800764e:	687a      	ldr	r2, [r7, #4]
 8007650:	683b      	ldr	r3, [r7, #0]
 8007652:	18d3      	adds	r3, r2, r3
 8007654:	f503 7366 	add.w	r3, r3, #920	; 0x398
 8007658:	f04f 0201 	mov.w	r2, #1
 800765c:	70da      	strb	r2, [r3, #3]
 800765e:	e059      	b.n	8007714 <USB_OTG_USBH_handle_hc_n_In_ISR+0x4bc>
    }
    
    else if (pdev->host.HC_Status[num] == HC_STALL) 
 8007660:	687a      	ldr	r2, [r7, #4]
 8007662:	683b      	ldr	r3, [r7, #0]
 8007664:	18d3      	adds	r3, r2, r3
 8007666:	f503 7362 	add.w	r3, r3, #904	; 0x388
 800766a:	791b      	ldrb	r3, [r3, #4]
 800766c:	b2db      	uxtb	r3, r3
 800766e:	2b05      	cmp	r3, #5
 8007670:	d108      	bne.n	8007684 <USB_OTG_USBH_handle_hc_n_In_ISR+0x42c>
    {
      pdev->host.URB_State[num] = URB_STALL;
 8007672:	687a      	ldr	r2, [r7, #4]
 8007674:	683b      	ldr	r3, [r7, #0]
 8007676:	18d3      	adds	r3, r2, r3
 8007678:	f503 7366 	add.w	r3, r3, #920	; 0x398
 800767c:	f04f 0204 	mov.w	r2, #4
 8007680:	70da      	strb	r2, [r3, #3]
 8007682:	e047      	b.n	8007714 <USB_OTG_USBH_handle_hc_n_In_ISR+0x4bc>
    }   
    
    else if((pdev->host.HC_Status[num] == HC_XACTERR) ||
 8007684:	687a      	ldr	r2, [r7, #4]
 8007686:	683b      	ldr	r3, [r7, #0]
 8007688:	18d3      	adds	r3, r2, r3
 800768a:	f503 7362 	add.w	r3, r3, #904	; 0x388
 800768e:	791b      	ldrb	r3, [r3, #4]
 8007690:	b2db      	uxtb	r3, r3
 8007692:	2b06      	cmp	r3, #6
 8007694:	d008      	beq.n	80076a8 <USB_OTG_USBH_handle_hc_n_In_ISR+0x450>
            (pdev->host.HC_Status[num] == HC_DATATGLERR))
 8007696:	687a      	ldr	r2, [r7, #4]
 8007698:	683b      	ldr	r3, [r7, #0]
 800769a:	18d3      	adds	r3, r2, r3
 800769c:	f503 7362 	add.w	r3, r3, #904	; 0x388
 80076a0:	791b      	ldrb	r3, [r3, #4]
 80076a2:	b2db      	uxtb	r3, r3
    else if (pdev->host.HC_Status[num] == HC_STALL) 
    {
      pdev->host.URB_State[num] = URB_STALL;
    }   
    
    else if((pdev->host.HC_Status[num] == HC_XACTERR) ||
 80076a4:	2b08      	cmp	r3, #8
 80076a6:	d112      	bne.n	80076ce <USB_OTG_USBH_handle_hc_n_In_ISR+0x476>
            (pdev->host.HC_Status[num] == HC_DATATGLERR))
    {
      pdev->host.ErrCnt[num] = 0;
 80076a8:	687a      	ldr	r2, [r7, #4]
 80076aa:	683b      	ldr	r3, [r7, #0]
 80076ac:	f103 03c4 	add.w	r3, r3, #196	; 0xc4
 80076b0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80076b4:	18d3      	adds	r3, r2, r3
 80076b6:	f04f 0200 	mov.w	r2, #0
 80076ba:	605a      	str	r2, [r3, #4]
      pdev->host.URB_State[num] = URB_ERROR;  
 80076bc:	687a      	ldr	r2, [r7, #4]
 80076be:	683b      	ldr	r3, [r7, #0]
 80076c0:	18d3      	adds	r3, r2, r3
 80076c2:	f503 7366 	add.w	r3, r3, #920	; 0x398
 80076c6:	f04f 0203 	mov.w	r2, #3
 80076ca:	70da      	strb	r2, [r3, #3]
 80076cc:	e022      	b.n	8007714 <USB_OTG_USBH_handle_hc_n_In_ISR+0x4bc>
      
    }
    else if(hcchar.b.eptype == EP_TYPE_INTR)
 80076ce:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 80076d2:	f003 030c 	and.w	r3, r3, #12
 80076d6:	b2db      	uxtb	r3, r3
 80076d8:	2b0c      	cmp	r3, #12
 80076da:	d11b      	bne.n	8007714 <USB_OTG_USBH_handle_hc_n_In_ISR+0x4bc>
    {
      pdev->host.hc[num].toggle_in ^= 1;
 80076dc:	6879      	ldr	r1, [r7, #4]
 80076de:	683a      	ldr	r2, [r7, #0]
 80076e0:	4613      	mov	r3, r2
 80076e2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80076e6:	189b      	adds	r3, r3, r2
 80076e8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80076ec:	18cb      	adds	r3, r1, r3
 80076ee:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 80076f2:	791b      	ldrb	r3, [r3, #4]
 80076f4:	f083 0301 	eor.w	r3, r3, #1
 80076f8:	b2d9      	uxtb	r1, r3
 80076fa:	6878      	ldr	r0, [r7, #4]
 80076fc:	683a      	ldr	r2, [r7, #0]
 80076fe:	4613      	mov	r3, r2
 8007700:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8007704:	189b      	adds	r3, r3, r2
 8007706:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800770a:	18c3      	adds	r3, r0, r3
 800770c:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 8007710:	460a      	mov	r2, r1
 8007712:	711a      	strb	r2, [r3, #4]
    }
    
    CLEAR_HC_INT(hcreg , chhltd);    
 8007714:	f04f 0300 	mov.w	r3, #0
 8007718:	61fb      	str	r3, [r7, #28]
 800771a:	69fb      	ldr	r3, [r7, #28]
 800771c:	f043 0302 	orr.w	r3, r3, #2
 8007720:	61fb      	str	r3, [r7, #28]
 8007722:	69fa      	ldr	r2, [r7, #28]
 8007724:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8007726:	609a      	str	r2, [r3, #8]
 8007728:	e0aa      	b.n	8007880 <USB_OTG_USBH_handle_hc_n_In_ISR+0x628>
    
  }    
  else if (hcint.b.xacterr)
 800772a:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 800772e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8007732:	b2db      	uxtb	r3, r3
 8007734:	2b00      	cmp	r3, #0
 8007736:	d042      	beq.n	80077be <USB_OTG_USBH_handle_hc_n_In_ISR+0x566>
  {
    UNMASK_HOST_INT_CHH (num);
 8007738:	687a      	ldr	r2, [r7, #4]
 800773a:	683b      	ldr	r3, [r7, #0]
 800773c:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8007740:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007744:	18d3      	adds	r3, r2, r3
 8007746:	689b      	ldr	r3, [r3, #8]
 8007748:	68db      	ldr	r3, [r3, #12]
 800774a:	61bb      	str	r3, [r7, #24]
 800774c:	69bb      	ldr	r3, [r7, #24]
 800774e:	f043 0302 	orr.w	r3, r3, #2
 8007752:	61bb      	str	r3, [r7, #24]
 8007754:	687a      	ldr	r2, [r7, #4]
 8007756:	683b      	ldr	r3, [r7, #0]
 8007758:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800775c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007760:	18d3      	adds	r3, r2, r3
 8007762:	689b      	ldr	r3, [r3, #8]
 8007764:	69ba      	ldr	r2, [r7, #24]
 8007766:	60da      	str	r2, [r3, #12]
    pdev->host.ErrCnt[num] ++;
 8007768:	687a      	ldr	r2, [r7, #4]
 800776a:	683b      	ldr	r3, [r7, #0]
 800776c:	f103 03c4 	add.w	r3, r3, #196	; 0xc4
 8007770:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007774:	18d3      	adds	r3, r2, r3
 8007776:	685b      	ldr	r3, [r3, #4]
 8007778:	f103 0201 	add.w	r2, r3, #1
 800777c:	6879      	ldr	r1, [r7, #4]
 800777e:	683b      	ldr	r3, [r7, #0]
 8007780:	f103 03c4 	add.w	r3, r3, #196	; 0xc4
 8007784:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007788:	18cb      	adds	r3, r1, r3
 800778a:	605a      	str	r2, [r3, #4]
    pdev->host.HC_Status[num] = HC_XACTERR;
 800778c:	687a      	ldr	r2, [r7, #4]
 800778e:	683b      	ldr	r3, [r7, #0]
 8007790:	18d3      	adds	r3, r2, r3
 8007792:	f503 7362 	add.w	r3, r3, #904	; 0x388
 8007796:	f04f 0206 	mov.w	r2, #6
 800779a:	711a      	strb	r2, [r3, #4]
    USB_OTG_HC_Halt(pdev, num);
 800779c:	683b      	ldr	r3, [r7, #0]
 800779e:	b2db      	uxtb	r3, r3
 80077a0:	6878      	ldr	r0, [r7, #4]
 80077a2:	4619      	mov	r1, r3
 80077a4:	f7fe fea3 	bl	80064ee <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , xacterr);    
 80077a8:	f04f 0300 	mov.w	r3, #0
 80077ac:	617b      	str	r3, [r7, #20]
 80077ae:	697b      	ldr	r3, [r7, #20]
 80077b0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80077b4:	617b      	str	r3, [r7, #20]
 80077b6:	697a      	ldr	r2, [r7, #20]
 80077b8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80077ba:	609a      	str	r2, [r3, #8]
 80077bc:	e060      	b.n	8007880 <USB_OTG_USBH_handle_hc_n_In_ISR+0x628>
    
  }
  else if (hcint.b.nak)  
 80077be:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 80077c2:	f003 0310 	and.w	r3, r3, #16
 80077c6:	b2db      	uxtb	r3, r3
 80077c8:	2b00      	cmp	r3, #0
 80077ca:	d059      	beq.n	8007880 <USB_OTG_USBH_handle_hc_n_In_ISR+0x628>
  {  
    if(hcchar.b.eptype == EP_TYPE_INTR)
 80077cc:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 80077d0:	f003 030c 	and.w	r3, r3, #12
 80077d4:	b2db      	uxtb	r3, r3
 80077d6:	2b0c      	cmp	r3, #12
 80077d8:	d11e      	bne.n	8007818 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5c0>
    {
      UNMASK_HOST_INT_CHH (num);
 80077da:	687a      	ldr	r2, [r7, #4]
 80077dc:	683b      	ldr	r3, [r7, #0]
 80077de:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80077e2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80077e6:	18d3      	adds	r3, r2, r3
 80077e8:	689b      	ldr	r3, [r3, #8]
 80077ea:	68db      	ldr	r3, [r3, #12]
 80077ec:	613b      	str	r3, [r7, #16]
 80077ee:	693b      	ldr	r3, [r7, #16]
 80077f0:	f043 0302 	orr.w	r3, r3, #2
 80077f4:	613b      	str	r3, [r7, #16]
 80077f6:	687a      	ldr	r2, [r7, #4]
 80077f8:	683b      	ldr	r3, [r7, #0]
 80077fa:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80077fe:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007802:	18d3      	adds	r3, r2, r3
 8007804:	689b      	ldr	r3, [r3, #8]
 8007806:	693a      	ldr	r2, [r7, #16]
 8007808:	60da      	str	r2, [r3, #12]
      USB_OTG_HC_Halt(pdev, num);
 800780a:	683b      	ldr	r3, [r7, #0]
 800780c:	b2db      	uxtb	r3, r3
 800780e:	6878      	ldr	r0, [r7, #4]
 8007810:	4619      	mov	r1, r3
 8007812:	f7fe fe6c 	bl	80064ee <USB_OTG_HC_Halt>
 8007816:	e01f      	b.n	8007858 <USB_OTG_USBH_handle_hc_n_In_ISR+0x600>
    }
    else if  ((hcchar.b.eptype == EP_TYPE_CTRL)||
 8007818:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 800781c:	f003 030c 	and.w	r3, r3, #12
 8007820:	b2db      	uxtb	r3, r3
 8007822:	2b00      	cmp	r3, #0
 8007824:	d006      	beq.n	8007834 <USB_OTG_USBH_handle_hc_n_In_ISR+0x5dc>
              (hcchar.b.eptype == EP_TYPE_BULK))
 8007826:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
 800782a:	f003 030c 	and.w	r3, r3, #12
 800782e:	b2db      	uxtb	r3, r3
    if(hcchar.b.eptype == EP_TYPE_INTR)
    {
      UNMASK_HOST_INT_CHH (num);
      USB_OTG_HC_Halt(pdev, num);
    }
    else if  ((hcchar.b.eptype == EP_TYPE_CTRL)||
 8007830:	2b08      	cmp	r3, #8
 8007832:	d111      	bne.n	8007858 <USB_OTG_USBH_handle_hc_n_In_ISR+0x600>
              (hcchar.b.eptype == EP_TYPE_BULK))
    {
      /* re-activate the channel  */
      hcchar.b.chen = 1;
 8007834:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8007836:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800783a:	663b      	str	r3, [r7, #96]	; 0x60
      hcchar.b.chdis = 0;
 800783c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800783e:	f36f 739e 	bfc	r3, #30, #1
 8007842:	663b      	str	r3, [r7, #96]	; 0x60
      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[num]->HCCHAR, hcchar.d32); 
 8007844:	687a      	ldr	r2, [r7, #4]
 8007846:	683b      	ldr	r3, [r7, #0]
 8007848:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800784c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007850:	18d3      	adds	r3, r2, r3
 8007852:	689b      	ldr	r3, [r3, #8]
 8007854:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8007856:	601a      	str	r2, [r3, #0]
    }
    pdev->host.HC_Status[num] = HC_NAK;
 8007858:	687a      	ldr	r2, [r7, #4]
 800785a:	683b      	ldr	r3, [r7, #0]
 800785c:	18d3      	adds	r3, r2, r3
 800785e:	f503 7362 	add.w	r3, r3, #904	; 0x388
 8007862:	f04f 0203 	mov.w	r2, #3
 8007866:	711a      	strb	r2, [r3, #4]
    CLEAR_HC_INT(hcreg , nak);   
 8007868:	f04f 0300 	mov.w	r3, #0
 800786c:	60fb      	str	r3, [r7, #12]
 800786e:	68fb      	ldr	r3, [r7, #12]
 8007870:	f043 0310 	orr.w	r3, r3, #16
 8007874:	60fb      	str	r3, [r7, #12]
 8007876:	68fa      	ldr	r2, [r7, #12]
 8007878:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800787a:	609a      	str	r2, [r3, #8]
 800787c:	e000      	b.n	8007880 <USB_OTG_USBH_handle_hc_n_In_ISR+0x628>
    }
    else if(hcchar.b.eptype == EP_TYPE_INTR)
    {
      hcchar.b.oddfrm  = 1;
      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[num]->HCCHAR, hcchar.d32); 
      pdev->host.URB_State[num] = URB_DONE;  
 800787e:	bf00      	nop
    pdev->host.HC_Status[num] = HC_NAK;
    CLEAR_HC_INT(hcreg , nak);   
  }
  
  
  return 1;
 8007880:	f04f 0301 	mov.w	r3, #1
  
}
 8007884:	4618      	mov	r0, r3
 8007886:	f107 0770 	add.w	r7, r7, #112	; 0x70
 800788a:	46bd      	mov	sp, r7
 800788c:	bd80      	pop	{r7, pc}
 800788e:	bf00      	nop

08007890 <USB_OTG_USBH_handle_hc_ISR>:
*         This function indicates that one or more host channels has a pending
* @param  pdev: Selected device
* @retval status 
*/
static uint32_t USB_OTG_USBH_handle_hc_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8007890:	b580      	push	{r7, lr}
 8007892:	b086      	sub	sp, #24
 8007894:	af00      	add	r7, sp, #0
 8007896:	6078      	str	r0, [r7, #4]
  USB_OTG_HAINT_TypeDef        haint;
  USB_OTG_HCCHAR_TypeDef       hcchar;
  uint32_t i = 0;
 8007898:	f04f 0300 	mov.w	r3, #0
 800789c:	617b      	str	r3, [r7, #20]
  uint32_t retval = 0;
 800789e:	f04f 0300 	mov.w	r3, #0
 80078a2:	613b      	str	r3, [r7, #16]
  
  /* Clear appropriate bits in HCINTn to clear the interrupt bit in
  * GINTSTS */
  
  haint.d32 = USB_OTG_ReadHostAllChannels_intr(pdev);
 80078a4:	6878      	ldr	r0, [r7, #4]
 80078a6:	f7fe fcbb 	bl	8006220 <USB_OTG_ReadHostAllChannels_intr>
 80078aa:	4603      	mov	r3, r0
 80078ac:	60fb      	str	r3, [r7, #12]
  
  for (i = 0; i < pdev->cfg.host_channels ; i++)
 80078ae:	f04f 0300 	mov.w	r3, #0
 80078b2:	617b      	str	r3, [r7, #20]
 80078b4:	e02d      	b.n	8007912 <USB_OTG_USBH_handle_hc_ISR+0x82>
  {
    if (haint.b.chint & (1 << i))
 80078b6:	89bb      	ldrh	r3, [r7, #12]
 80078b8:	461a      	mov	r2, r3
 80078ba:	697b      	ldr	r3, [r7, #20]
 80078bc:	fa42 f303 	asr.w	r3, r2, r3
 80078c0:	f003 0301 	and.w	r3, r3, #1
 80078c4:	2b00      	cmp	r3, #0
 80078c6:	d020      	beq.n	800790a <USB_OTG_USBH_handle_hc_ISR+0x7a>
    {
      hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 80078c8:	687a      	ldr	r2, [r7, #4]
 80078ca:	697b      	ldr	r3, [r7, #20]
 80078cc:	f103 0322 	add.w	r3, r3, #34	; 0x22
 80078d0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80078d4:	18d3      	adds	r3, r2, r3
 80078d6:	689b      	ldr	r3, [r3, #8]
 80078d8:	681b      	ldr	r3, [r3, #0]
 80078da:	60bb      	str	r3, [r7, #8]
      
      if (hcchar.b.epdir)
 80078dc:	7a7b      	ldrb	r3, [r7, #9]
 80078de:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80078e2:	b2db      	uxtb	r3, r3
 80078e4:	2b00      	cmp	r3, #0
 80078e6:	d008      	beq.n	80078fa <USB_OTG_USBH_handle_hc_ISR+0x6a>
      {
        retval |= USB_OTG_USBH_handle_hc_n_In_ISR (pdev, i);
 80078e8:	6878      	ldr	r0, [r7, #4]
 80078ea:	6979      	ldr	r1, [r7, #20]
 80078ec:	f7ff fcb4 	bl	8007258 <USB_OTG_USBH_handle_hc_n_In_ISR>
 80078f0:	4603      	mov	r3, r0
 80078f2:	693a      	ldr	r2, [r7, #16]
 80078f4:	4313      	orrs	r3, r2
 80078f6:	613b      	str	r3, [r7, #16]
 80078f8:	e007      	b.n	800790a <USB_OTG_USBH_handle_hc_ISR+0x7a>
      }
      else
      {
        retval |=  USB_OTG_USBH_handle_hc_n_Out_ISR (pdev, i);
 80078fa:	6878      	ldr	r0, [r7, #4]
 80078fc:	6979      	ldr	r1, [r7, #20]
 80078fe:	f7ff f9bd 	bl	8006c7c <USB_OTG_USBH_handle_hc_n_Out_ISR>
 8007902:	4603      	mov	r3, r0
 8007904:	693a      	ldr	r2, [r7, #16]
 8007906:	4313      	orrs	r3, r2
 8007908:	613b      	str	r3, [r7, #16]
  /* Clear appropriate bits in HCINTn to clear the interrupt bit in
  * GINTSTS */
  
  haint.d32 = USB_OTG_ReadHostAllChannels_intr(pdev);
  
  for (i = 0; i < pdev->cfg.host_channels ; i++)
 800790a:	697b      	ldr	r3, [r7, #20]
 800790c:	f103 0301 	add.w	r3, r3, #1
 8007910:	617b      	str	r3, [r7, #20]
 8007912:	687b      	ldr	r3, [r7, #4]
 8007914:	781b      	ldrb	r3, [r3, #0]
 8007916:	461a      	mov	r2, r3
 8007918:	697b      	ldr	r3, [r7, #20]
 800791a:	429a      	cmp	r2, r3
 800791c:	d8cb      	bhi.n	80078b6 <USB_OTG_USBH_handle_hc_ISR+0x26>
        retval |=  USB_OTG_USBH_handle_hc_n_Out_ISR (pdev, i);
      }
    }
  }
  
  return retval;
 800791e:	693b      	ldr	r3, [r7, #16]
}
 8007920:	4618      	mov	r0, r3
 8007922:	f107 0718 	add.w	r7, r7, #24
 8007926:	46bd      	mov	sp, r7
 8007928:	bd80      	pop	{r7, pc}
 800792a:	bf00      	nop

0800792c <USB_OTG_USBH_handle_rx_qlvl_ISR>:
*/
#if defined ( __ICCARM__ ) /*!< IAR Compiler */
#pragma optimize = none
#endif /* __CC_ARM */
static uint32_t USB_OTG_USBH_handle_rx_qlvl_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 800792c:	b580      	push	{r7, lr}
 800792e:	b088      	sub	sp, #32
 8007930:	af00      	add	r7, sp, #0
 8007932:	6078      	str	r0, [r7, #4]
  USB_OTG_GRXFSTS_TypeDef       grxsts;
  USB_OTG_GINTMSK_TypeDef       intmsk;
  USB_OTG_HCTSIZn_TypeDef       hctsiz; 
  USB_OTG_HCCHAR_TypeDef        hcchar;
  __IO uint8_t                  channelnum =0;  
 8007934:	f04f 0300 	mov.w	r3, #0
 8007938:	72fb      	strb	r3, [r7, #11]
  uint32_t                      count;    
  
  /* Disable the Rx Status Queue Level interrupt */
  intmsk.d32 = 0;
 800793a:	f04f 0300 	mov.w	r3, #0
 800793e:	617b      	str	r3, [r7, #20]
  intmsk.b.rxstsqlvl = 1;
 8007940:	697b      	ldr	r3, [r7, #20]
 8007942:	f043 0310 	orr.w	r3, r3, #16
 8007946:	617b      	str	r3, [r7, #20]
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, 0);
 8007948:	687b      	ldr	r3, [r7, #4]
 800794a:	68db      	ldr	r3, [r3, #12]
 800794c:	687a      	ldr	r2, [r7, #4]
 800794e:	68d2      	ldr	r2, [r2, #12]
 8007950:	6991      	ldr	r1, [r2, #24]
 8007952:	697a      	ldr	r2, [r7, #20]
 8007954:	ea6f 0202 	mvn.w	r2, r2
 8007958:	400a      	ands	r2, r1
 800795a:	619a      	str	r2, [r3, #24]
  
  grxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRXSTSP);
 800795c:	687b      	ldr	r3, [r7, #4]
 800795e:	68db      	ldr	r3, [r3, #12]
 8007960:	6a1b      	ldr	r3, [r3, #32]
 8007962:	61bb      	str	r3, [r7, #24]
  channelnum = grxsts.b.chnum;  
 8007964:	69bb      	ldr	r3, [r7, #24]
 8007966:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800796a:	b2db      	uxtb	r3, r3
 800796c:	72fb      	strb	r3, [r7, #11]
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[channelnum]->HCCHAR);
 800796e:	7afb      	ldrb	r3, [r7, #11]
 8007970:	b2db      	uxtb	r3, r3
 8007972:	687a      	ldr	r2, [r7, #4]
 8007974:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8007978:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800797c:	18d3      	adds	r3, r2, r3
 800797e:	689b      	ldr	r3, [r3, #8]
 8007980:	681b      	ldr	r3, [r3, #0]
 8007982:	60fb      	str	r3, [r7, #12]
  
  switch (grxsts.b.pktsts)
 8007984:	69bb      	ldr	r3, [r7, #24]
 8007986:	f3c3 4343 	ubfx	r3, r3, #17, #4
 800798a:	b2db      	uxtb	r3, r3
 800798c:	2b02      	cmp	r3, #2
 800798e:	f040 80b6 	bne.w	8007afe <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1d2>
  {
  case GRXSTS_PKTSTS_IN:
    /* Read the data into the host buffer. */
    if ((grxsts.b.bcnt > 0) && (pdev->host.hc[channelnum].xfer_buff != (void  *)0))
 8007992:	69bb      	ldr	r3, [r7, #24]
 8007994:	f3c3 130a 	ubfx	r3, r3, #4, #11
 8007998:	b29b      	uxth	r3, r3
 800799a:	2b00      	cmp	r3, #0
 800799c:	f340 80b0 	ble.w	8007b00 <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1d4>
 80079a0:	7afb      	ldrb	r3, [r7, #11]
 80079a2:	b2db      	uxtb	r3, r3
 80079a4:	461a      	mov	r2, r3
 80079a6:	6879      	ldr	r1, [r7, #4]
 80079a8:	4613      	mov	r3, r2
 80079aa:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80079ae:	189b      	adds	r3, r3, r2
 80079b0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80079b4:	18cb      	adds	r3, r1, r3
 80079b6:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
 80079ba:	681b      	ldr	r3, [r3, #0]
 80079bc:	2b00      	cmp	r3, #0
 80079be:	f000 809f 	beq.w	8007b00 <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1d4>
    {  
      
      USB_OTG_ReadPacket(pdev, pdev->host.hc[channelnum].xfer_buff, grxsts.b.bcnt);
 80079c2:	7afb      	ldrb	r3, [r7, #11]
 80079c4:	b2db      	uxtb	r3, r3
 80079c6:	461a      	mov	r2, r3
 80079c8:	6879      	ldr	r1, [r7, #4]
 80079ca:	4613      	mov	r3, r2
 80079cc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80079d0:	189b      	adds	r3, r3, r2
 80079d2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80079d6:	18cb      	adds	r3, r1, r3
 80079d8:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
 80079dc:	681a      	ldr	r2, [r3, #0]
 80079de:	69bb      	ldr	r3, [r7, #24]
 80079e0:	f3c3 130a 	ubfx	r3, r3, #4, #11
 80079e4:	b29b      	uxth	r3, r3
 80079e6:	6878      	ldr	r0, [r7, #4]
 80079e8:	4611      	mov	r1, r2
 80079ea:	461a      	mov	r2, r3
 80079ec:	f7fe fa93 	bl	8005f16 <USB_OTG_ReadPacket>
      /*manage multiple Xfer */
      pdev->host.hc[grxsts.b.chnum].xfer_buff += grxsts.b.bcnt;           
 80079f0:	69bb      	ldr	r3, [r7, #24]
 80079f2:	f3c3 0303 	ubfx	r3, r3, #0, #4
 80079f6:	b2db      	uxtb	r3, r3
 80079f8:	461a      	mov	r2, r3
 80079fa:	69bb      	ldr	r3, [r7, #24]
 80079fc:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8007a00:	b2db      	uxtb	r3, r3
 8007a02:	4619      	mov	r1, r3
 8007a04:	6878      	ldr	r0, [r7, #4]
 8007a06:	460b      	mov	r3, r1
 8007a08:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8007a0c:	185b      	adds	r3, r3, r1
 8007a0e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007a12:	18c3      	adds	r3, r0, r3
 8007a14:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
 8007a18:	6819      	ldr	r1, [r3, #0]
 8007a1a:	69bb      	ldr	r3, [r7, #24]
 8007a1c:	f3c3 130a 	ubfx	r3, r3, #4, #11
 8007a20:	b29b      	uxth	r3, r3
 8007a22:	18c9      	adds	r1, r1, r3
 8007a24:	6878      	ldr	r0, [r7, #4]
 8007a26:	4613      	mov	r3, r2
 8007a28:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8007a2c:	189b      	adds	r3, r3, r2
 8007a2e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007a32:	18c3      	adds	r3, r0, r3
 8007a34:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
 8007a38:	6019      	str	r1, [r3, #0]
      pdev->host.hc[grxsts.b.chnum].xfer_count  += grxsts.b.bcnt;
 8007a3a:	69bb      	ldr	r3, [r7, #24]
 8007a3c:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8007a40:	b2db      	uxtb	r3, r3
 8007a42:	461a      	mov	r2, r3
 8007a44:	69bb      	ldr	r3, [r7, #24]
 8007a46:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8007a4a:	b2db      	uxtb	r3, r3
 8007a4c:	4619      	mov	r1, r3
 8007a4e:	6878      	ldr	r0, [r7, #4]
 8007a50:	460b      	mov	r3, r1
 8007a52:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8007a56:	185b      	adds	r3, r3, r1
 8007a58:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007a5c:	18c3      	adds	r3, r0, r3
 8007a5e:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 8007a62:	6819      	ldr	r1, [r3, #0]
 8007a64:	69bb      	ldr	r3, [r7, #24]
 8007a66:	f3c3 130a 	ubfx	r3, r3, #4, #11
 8007a6a:	b29b      	uxth	r3, r3
 8007a6c:	18c9      	adds	r1, r1, r3
 8007a6e:	6878      	ldr	r0, [r7, #4]
 8007a70:	4613      	mov	r3, r2
 8007a72:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8007a76:	189b      	adds	r3, r3, r2
 8007a78:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007a7c:	18c3      	adds	r3, r0, r3
 8007a7e:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 8007a82:	6019      	str	r1, [r3, #0]
      
      
      count = pdev->host.hc[channelnum].xfer_count;
 8007a84:	7afb      	ldrb	r3, [r7, #11]
 8007a86:	b2db      	uxtb	r3, r3
 8007a88:	461a      	mov	r2, r3
 8007a8a:	6879      	ldr	r1, [r7, #4]
 8007a8c:	4613      	mov	r3, r2
 8007a8e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8007a92:	189b      	adds	r3, r3, r2
 8007a94:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007a98:	18cb      	adds	r3, r1, r3
 8007a9a:	f503 7370 	add.w	r3, r3, #960	; 0x3c0
 8007a9e:	681b      	ldr	r3, [r3, #0]
 8007aa0:	61fb      	str	r3, [r7, #28]
      pdev->host.XferCnt[channelnum]  = count;
 8007aa2:	7afb      	ldrb	r3, [r7, #11]
 8007aa4:	b2db      	uxtb	r3, r3
 8007aa6:	461a      	mov	r2, r3
 8007aa8:	687b      	ldr	r3, [r7, #4]
 8007aaa:	f102 02d4 	add.w	r2, r2, #212	; 0xd4
 8007aae:	69f9      	ldr	r1, [r7, #28]
 8007ab0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      
      hctsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[channelnum]->HCTSIZ);
 8007ab4:	7afb      	ldrb	r3, [r7, #11]
 8007ab6:	b2db      	uxtb	r3, r3
 8007ab8:	687a      	ldr	r2, [r7, #4]
 8007aba:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8007abe:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007ac2:	18d3      	adds	r3, r2, r3
 8007ac4:	689b      	ldr	r3, [r3, #8]
 8007ac6:	691b      	ldr	r3, [r3, #16]
 8007ac8:	613b      	str	r3, [r7, #16]
      if(hctsiz.b.pktcnt > 0)
 8007aca:	693b      	ldr	r3, [r7, #16]
 8007acc:	f3c3 43c9 	ubfx	r3, r3, #19, #10
 8007ad0:	b29b      	uxth	r3, r3
 8007ad2:	2b00      	cmp	r3, #0
 8007ad4:	dd14      	ble.n	8007b00 <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1d4>
      {
        /* re-activate the channel when more packets are expected */
        hcchar.b.chen = 1;
 8007ad6:	68fb      	ldr	r3, [r7, #12]
 8007ad8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8007adc:	60fb      	str	r3, [r7, #12]
        hcchar.b.chdis = 0;
 8007ade:	68fb      	ldr	r3, [r7, #12]
 8007ae0:	f36f 739e 	bfc	r3, #30, #1
 8007ae4:	60fb      	str	r3, [r7, #12]
        USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[channelnum]->HCCHAR, hcchar.d32);
 8007ae6:	7afb      	ldrb	r3, [r7, #11]
 8007ae8:	b2db      	uxtb	r3, r3
 8007aea:	687a      	ldr	r2, [r7, #4]
 8007aec:	f103 0322 	add.w	r3, r3, #34	; 0x22
 8007af0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8007af4:	18d3      	adds	r3, r2, r3
 8007af6:	689b      	ldr	r3, [r3, #8]
 8007af8:	68fa      	ldr	r2, [r7, #12]
 8007afa:	601a      	str	r2, [r3, #0]
      }
    }
    break;
 8007afc:	e000      	b.n	8007b00 <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1d4>
  case GRXSTS_PKTSTS_IN_XFER_COMP:
    
  case GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
  case GRXSTS_PKTSTS_CH_HALTED:
  default:
    break;
 8007afe:	e000      	b.n	8007b02 <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1d6>
        hcchar.b.chen = 1;
        hcchar.b.chdis = 0;
        USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[channelnum]->HCCHAR, hcchar.d32);
      }
    }
    break;
 8007b00:	bf00      	nop
  default:
    break;
  }
  
  /* Enable the Rx Status Queue Level interrupt */
  intmsk.b.rxstsqlvl = 1;
 8007b02:	697b      	ldr	r3, [r7, #20]
 8007b04:	f043 0310 	orr.w	r3, r3, #16
 8007b08:	617b      	str	r3, [r7, #20]
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);
 8007b0a:	687b      	ldr	r3, [r7, #4]
 8007b0c:	68db      	ldr	r3, [r3, #12]
 8007b0e:	687a      	ldr	r2, [r7, #4]
 8007b10:	68d2      	ldr	r2, [r2, #12]
 8007b12:	6991      	ldr	r1, [r2, #24]
 8007b14:	697a      	ldr	r2, [r7, #20]
 8007b16:	430a      	orrs	r2, r1
 8007b18:	619a      	str	r2, [r3, #24]
  return 1;
 8007b1a:	f04f 0301 	mov.w	r3, #1
}
 8007b1e:	4618      	mov	r0, r3
 8007b20:	f107 0720 	add.w	r7, r7, #32
 8007b24:	46bd      	mov	sp, r7
 8007b26:	bd80      	pop	{r7, pc}

08007b28 <USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR>:
*/
#if defined ( __ICCARM__ ) /*!< IAR Compiler */
#pragma optimize = none
#endif /* __CC_ARM */
static uint32_t USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 8007b28:	b480      	push	{r7}
 8007b2a:	b085      	sub	sp, #20
 8007b2c:	af00      	add	r7, sp, #0
 8007b2e:	6078      	str	r0, [r7, #4]
  USB_OTG_HCCHAR_TypeDef        hcchar; 
  
  
  
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[0]->HCCHAR);
 8007b30:	687b      	ldr	r3, [r7, #4]
 8007b32:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007b36:	681b      	ldr	r3, [r3, #0]
 8007b38:	60bb      	str	r3, [r7, #8]
  hcchar.b.chen = 1;
 8007b3a:	68bb      	ldr	r3, [r7, #8]
 8007b3c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8007b40:	60bb      	str	r3, [r7, #8]
  hcchar.b.chdis = 1;
 8007b42:	68bb      	ldr	r3, [r7, #8]
 8007b44:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8007b48:	60bb      	str	r3, [r7, #8]
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[0]->HCCHAR, hcchar.d32);  
 8007b4a:	687b      	ldr	r3, [r7, #4]
 8007b4c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007b50:	68ba      	ldr	r2, [r7, #8]
 8007b52:	601a      	str	r2, [r3, #0]
  
  gintsts.d32 = 0;
 8007b54:	f04f 0300 	mov.w	r3, #0
 8007b58:	60fb      	str	r3, [r7, #12]
  /* Clear interrupt */
  gintsts.b.incomplisoout = 1;
 8007b5a:	68fb      	ldr	r3, [r7, #12]
 8007b5c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8007b60:	60fb      	str	r3, [r7, #12]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 8007b62:	687b      	ldr	r3, [r7, #4]
 8007b64:	68db      	ldr	r3, [r3, #12]
 8007b66:	68fa      	ldr	r2, [r7, #12]
 8007b68:	615a      	str	r2, [r3, #20]
  
  return 1;
 8007b6a:	f04f 0301 	mov.w	r3, #1
}
 8007b6e:	4618      	mov	r0, r3
 8007b70:	f107 0714 	add.w	r7, r7, #20
 8007b74:	46bd      	mov	sp, r7
 8007b76:	bc80      	pop	{r7}
 8007b78:	4770      	bx	lr
 8007b7a:	bf00      	nop

08007b7c <USBH_OTG_ISR_Handler>:
* @param  pdev: Selected device
* @retval status 
*/

uint32_t USBH_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
{
 8007b7c:	b580      	push	{r7, lr}
 8007b7e:	b084      	sub	sp, #16
 8007b80:	af00      	add	r7, sp, #0
 8007b82:	6078      	str	r0, [r7, #4]
  USB_OTG_GINTSTS_TypeDef  gintsts;
  uint32_t retval = 0;
 8007b84:	f04f 0300 	mov.w	r3, #0
 8007b88:	60fb      	str	r3, [r7, #12]
  
  gintsts.d32 = 0;
 8007b8a:	f04f 0300 	mov.w	r3, #0
 8007b8e:	60bb      	str	r3, [r7, #8]
  
  /* Check if HOST Mode */
  if (USB_OTG_IsHostMode(pdev))
 8007b90:	6878      	ldr	r0, [r7, #4]
 8007b92:	f7fe fade 	bl	8006152 <USB_OTG_IsHostMode>
 8007b96:	4603      	mov	r3, r0
 8007b98:	2b00      	cmp	r3, #0
 8007b9a:	d072      	beq.n	8007c82 <USBH_OTG_ISR_Handler+0x106>
  {
    gintsts.d32 = USB_OTG_ReadCoreItr(pdev);
 8007b9c:	6878      	ldr	r0, [r7, #4]
 8007b9e:	f7fe fadd 	bl	800615c <USB_OTG_ReadCoreItr>
 8007ba2:	4603      	mov	r3, r0
 8007ba4:	60bb      	str	r3, [r7, #8]
    if (!gintsts.d32)
 8007ba6:	68bb      	ldr	r3, [r7, #8]
 8007ba8:	2b00      	cmp	r3, #0
 8007baa:	d102      	bne.n	8007bb2 <USBH_OTG_ISR_Handler+0x36>
    {
      return 0;
 8007bac:	f04f 0300 	mov.w	r3, #0
 8007bb0:	e068      	b.n	8007c84 <USBH_OTG_ISR_Handler+0x108>
    }
    
    if (gintsts.b.sofintr)
 8007bb2:	7a3b      	ldrb	r3, [r7, #8]
 8007bb4:	f003 0308 	and.w	r3, r3, #8
 8007bb8:	b2db      	uxtb	r3, r3
 8007bba:	2b00      	cmp	r3, #0
 8007bbc:	d006      	beq.n	8007bcc <USBH_OTG_ISR_Handler+0x50>
    {
      retval |= USB_OTG_USBH_handle_sof_ISR (pdev);
 8007bbe:	6878      	ldr	r0, [r7, #4]
 8007bc0:	f7fe fd46 	bl	8006650 <USB_OTG_USBH_handle_sof_ISR>
 8007bc4:	4603      	mov	r3, r0
 8007bc6:	68fa      	ldr	r2, [r7, #12]
 8007bc8:	4313      	orrs	r3, r2
 8007bca:	60fb      	str	r3, [r7, #12]
    }
    
    if (gintsts.b.rxstsqlvl)
 8007bcc:	7a3b      	ldrb	r3, [r7, #8]
 8007bce:	f003 0310 	and.w	r3, r3, #16
 8007bd2:	b2db      	uxtb	r3, r3
 8007bd4:	2b00      	cmp	r3, #0
 8007bd6:	d006      	beq.n	8007be6 <USBH_OTG_ISR_Handler+0x6a>
    {
      retval |= USB_OTG_USBH_handle_rx_qlvl_ISR (pdev);
 8007bd8:	6878      	ldr	r0, [r7, #4]
 8007bda:	f7ff fea7 	bl	800792c <USB_OTG_USBH_handle_rx_qlvl_ISR>
 8007bde:	4603      	mov	r3, r0
 8007be0:	68fa      	ldr	r2, [r7, #12]
 8007be2:	4313      	orrs	r3, r2
 8007be4:	60fb      	str	r3, [r7, #12]
    }
    
    if (gintsts.b.nptxfempty)
 8007be6:	7a3b      	ldrb	r3, [r7, #8]
 8007be8:	f003 0320 	and.w	r3, r3, #32
 8007bec:	b2db      	uxtb	r3, r3
 8007bee:	2b00      	cmp	r3, #0
 8007bf0:	d006      	beq.n	8007c00 <USBH_OTG_ISR_Handler+0x84>
    {
      retval |= USB_OTG_USBH_handle_nptxfempty_ISR (pdev);
 8007bf2:	6878      	ldr	r0, [r7, #4]
 8007bf4:	f7fe fd68 	bl	80066c8 <USB_OTG_USBH_handle_nptxfempty_ISR>
 8007bf8:	4603      	mov	r3, r0
 8007bfa:	68fa      	ldr	r2, [r7, #12]
 8007bfc:	4313      	orrs	r3, r2
 8007bfe:	60fb      	str	r3, [r7, #12]
    }
    
    if (gintsts.b.ptxfempty)
 8007c00:	7afb      	ldrb	r3, [r7, #11]
 8007c02:	f003 0304 	and.w	r3, r3, #4
 8007c06:	b2db      	uxtb	r3, r3
 8007c08:	2b00      	cmp	r3, #0
 8007c0a:	d006      	beq.n	8007c1a <USBH_OTG_ISR_Handler+0x9e>
    {
      retval |= USB_OTG_USBH_handle_ptxfempty_ISR (pdev);
 8007c0c:	6878      	ldr	r0, [r7, #4]
 8007c0e:	f7fe fe69 	bl	80068e4 <USB_OTG_USBH_handle_ptxfempty_ISR>
 8007c12:	4603      	mov	r3, r0
 8007c14:	68fa      	ldr	r2, [r7, #12]
 8007c16:	4313      	orrs	r3, r2
 8007c18:	60fb      	str	r3, [r7, #12]
    }    
    
    if (gintsts.b.hcintr)
 8007c1a:	7afb      	ldrb	r3, [r7, #11]
 8007c1c:	f003 0302 	and.w	r3, r3, #2
 8007c20:	b2db      	uxtb	r3, r3
 8007c22:	2b00      	cmp	r3, #0
 8007c24:	d006      	beq.n	8007c34 <USBH_OTG_ISR_Handler+0xb8>
    {
      retval |= USB_OTG_USBH_handle_hc_ISR (pdev);
 8007c26:	6878      	ldr	r0, [r7, #4]
 8007c28:	f7ff fe32 	bl	8007890 <USB_OTG_USBH_handle_hc_ISR>
 8007c2c:	4603      	mov	r3, r0
 8007c2e:	68fa      	ldr	r2, [r7, #12]
 8007c30:	4313      	orrs	r3, r2
 8007c32:	60fb      	str	r3, [r7, #12]
    }
    
    if (gintsts.b.portintr)
 8007c34:	7afb      	ldrb	r3, [r7, #11]
 8007c36:	f003 0301 	and.w	r3, r3, #1
 8007c3a:	b2db      	uxtb	r3, r3
 8007c3c:	2b00      	cmp	r3, #0
 8007c3e:	d006      	beq.n	8007c4e <USBH_OTG_ISR_Handler+0xd2>
    {
      retval |= USB_OTG_USBH_handle_port_ISR (pdev);
 8007c40:	6878      	ldr	r0, [r7, #4]
 8007c42:	f7fe ff5d 	bl	8006b00 <USB_OTG_USBH_handle_port_ISR>
 8007c46:	4603      	mov	r3, r0
 8007c48:	68fa      	ldr	r2, [r7, #12]
 8007c4a:	4313      	orrs	r3, r2
 8007c4c:	60fb      	str	r3, [r7, #12]
    }
    
    if (gintsts.b.disconnect)
 8007c4e:	7afb      	ldrb	r3, [r7, #11]
 8007c50:	f003 0320 	and.w	r3, r3, #32
 8007c54:	b2db      	uxtb	r3, r3
 8007c56:	2b00      	cmp	r3, #0
 8007c58:	d006      	beq.n	8007c68 <USBH_OTG_ISR_Handler+0xec>
    {
      retval |= USB_OTG_USBH_handle_Disconnect_ISR (pdev);  
 8007c5a:	6878      	ldr	r0, [r7, #4]
 8007c5c:	f7fe fd18 	bl	8006690 <USB_OTG_USBH_handle_Disconnect_ISR>
 8007c60:	4603      	mov	r3, r0
 8007c62:	68fa      	ldr	r2, [r7, #12]
 8007c64:	4313      	orrs	r3, r2
 8007c66:	60fb      	str	r3, [r7, #12]
      
    }
    
    if (gintsts.b.incomplisoout)
 8007c68:	7abb      	ldrb	r3, [r7, #10]
 8007c6a:	f003 0320 	and.w	r3, r3, #32
 8007c6e:	b2db      	uxtb	r3, r3
 8007c70:	2b00      	cmp	r3, #0
 8007c72:	d006      	beq.n	8007c82 <USBH_OTG_ISR_Handler+0x106>
    {
      retval |= USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR (pdev);
 8007c74:	6878      	ldr	r0, [r7, #4]
 8007c76:	f7ff ff57 	bl	8007b28 <USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR>
 8007c7a:	4603      	mov	r3, r0
 8007c7c:	68fa      	ldr	r2, [r7, #12]
 8007c7e:	4313      	orrs	r3, r2
 8007c80:	60fb      	str	r3, [r7, #12]
    }
    
    
  }
  return retval;
 8007c82:	68fb      	ldr	r3, [r7, #12]
}
 8007c84:	4618      	mov	r0, r3
 8007c86:	f107 0710 	add.w	r7, r7, #16
 8007c8a:	46bd      	mov	sp, r7
 8007c8c:	bd80      	pop	{r7, pc}
 8007c8e:	bf00      	nop

08007c90 <USBH_Open_Channel>:
                            uint8_t dev_address,
                            uint8_t speed,
                            uint8_t ep_type,
                            uint16_t mps,
                            uint8_t nak_limit)
{
 8007c90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  pdev->host.hc[hc_num].ep_num = pdev->host.channel[hc_num]& 0x7F;
 8007c92:	f501 7439 	add.w	r4, r1, #740	; 0x2e4
 8007c96:	f830 6014 	ldrh.w	r6, [r0, r4, lsl #1]
 8007c9a:	2424      	movs	r4, #36	; 0x24
 8007c9c:	fb04 0401 	mla	r4, r4, r1, r0
  pdev->host.hc[hc_num].ep_is_in = (pdev->host.channel[hc_num] & 0x80 ) == 0x80;  
  pdev->host.hc[hc_num].dev_addr = dev_address;  
 8007ca0:	f884 23ac 	strb.w	r2, [r4, #940]	; 0x3ac
  pdev->host.hc[hc_num].ep_type = ep_type;  
 8007ca4:	f89d 2018 	ldrb.w	r2, [sp, #24]
                            uint8_t ep_type,
                            uint16_t mps,
                            uint8_t nak_limit)
{

  pdev->host.hc[hc_num].ep_num = pdev->host.channel[hc_num]& 0x7F;
 8007ca8:	f006 077f 	and.w	r7, r6, #127	; 0x7f
  pdev->host.hc[hc_num].ep_is_in = (pdev->host.channel[hc_num] & 0x80 ) == 0x80;  
  pdev->host.hc[hc_num].dev_addr = dev_address;  
  pdev->host.hc[hc_num].ep_type = ep_type;  
 8007cac:	f884 23b1 	strb.w	r2, [r4, #945]	; 0x3b1
  pdev->host.hc[hc_num].max_packet = mps; 
 8007cb0:	f8bd 201c 	ldrh.w	r2, [sp, #28]
                            uint16_t mps,
                            uint8_t nak_limit)
{

  pdev->host.hc[hc_num].ep_num = pdev->host.channel[hc_num]& 0x7F;
  pdev->host.hc[hc_num].ep_is_in = (pdev->host.channel[hc_num] & 0x80 ) == 0x80;  
 8007cb4:	f3c6 16c0 	ubfx	r6, r6, #7, #1
  pdev->host.hc[hc_num].dev_addr = dev_address;  
  pdev->host.hc[hc_num].ep_type = ep_type;  
  pdev->host.hc[hc_num].max_packet = mps; 
 8007cb8:	f8a4 23b2 	strh.w	r2, [r4, #946]	; 0x3b2
  pdev->host.hc[hc_num].speed = speed; 
  pdev->host.hc[hc_num].toggle_in = 0; 
 8007cbc:	2200      	movs	r2, #0
 8007cbe:	f884 23c4 	strb.w	r2, [r4, #964]	; 0x3c4
  pdev->host.hc[hc_num].toggle_out = 0;   
 8007cc2:	f884 23c5 	strb.w	r2, [r4, #965]	; 0x3c5
  pdev->host.hc[hc_num].isEvenTimesToggle = 0;
 8007cc6:	f884 23cc 	strb.w	r2, [r4, #972]	; 0x3cc
  pdev->host.hc[hc_num].nak_limit = nak_limit;
 8007cca:	f89d 2020 	ldrb.w	r2, [sp, #32]
                            uint16_t mps,
                            uint8_t nak_limit)
{

  pdev->host.hc[hc_num].ep_num = pdev->host.channel[hc_num]& 0x7F;
  pdev->host.hc[hc_num].ep_is_in = (pdev->host.channel[hc_num] & 0x80 ) == 0x80;  
 8007cce:	f884 63ae 	strb.w	r6, [r4, #942]	; 0x3ae
                            uint8_t ep_type,
                            uint16_t mps,
                            uint8_t nak_limit)
{

  pdev->host.hc[hc_num].ep_num = pdev->host.channel[hc_num]& 0x7F;
 8007cd2:	f504 756a 	add.w	r5, r4, #936	; 0x3a8
 8007cd6:	f884 73ad 	strb.w	r7, [r4, #941]	; 0x3ad
  pdev->host.hc[hc_num].ep_is_in = (pdev->host.channel[hc_num] & 0x80 ) == 0x80;  
  pdev->host.hc[hc_num].dev_addr = dev_address;  
  pdev->host.hc[hc_num].ep_type = ep_type;  
  pdev->host.hc[hc_num].max_packet = mps; 
  pdev->host.hc[hc_num].speed = speed; 
 8007cda:	f884 33af 	strb.w	r3, [r4, #943]	; 0x3af
  pdev->host.hc[hc_num].toggle_in = 0; 
  pdev->host.hc[hc_num].toggle_out = 0;   
  pdev->host.hc[hc_num].isEvenTimesToggle = 0;
 8007cde:	f504 7672 	add.w	r6, r4, #968	; 0x3c8
  pdev->host.hc[hc_num].nak_limit = nak_limit;
 8007ce2:	f8a4 23ce 	strh.w	r2, [r4, #974]	; 0x3ce

  if(speed == HPRT0_PRTSPD_HIGH_SPEED)
 8007ce6:	b913      	cbnz	r3, 8007cee <USBH_Open_Channel+0x5e>
  {
    pdev->host.hc[hc_num].do_ping = 1;
 8007ce8:	2301      	movs	r3, #1
 8007cea:	f884 33b0 	strb.w	r3, [r4, #944]	; 0x3b0
  }
  
  USB_OTG_HC_Init(pdev, hc_num) ;
 8007cee:	f7fe fafa 	bl	80062e6 <USB_OTG_HC_Init>
  
  return HC_OK; 

}
 8007cf2:	2000      	movs	r0, #0
 8007cf4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08007cf6 <USBH_Modify_Channel>:
                            uint8_t hc_num,
                            uint8_t dev_address,
                            uint8_t speed,
                            uint8_t ep_type,
                            uint16_t mps)
{
 8007cf6:	b570      	push	{r4, r5, r6, lr}
 8007cf8:	f8bd 4014 	ldrh.w	r4, [sp, #20]
  
  if(dev_address != 0)
 8007cfc:	b122      	cbz	r2, 8007d08 <USBH_Modify_Channel+0x12>
  {
    pdev->host.hc[hc_num].dev_addr = dev_address;  
 8007cfe:	2524      	movs	r5, #36	; 0x24
 8007d00:	fb05 0501 	mla	r5, r5, r1, r0
 8007d04:	f885 23ac 	strb.w	r2, [r5, #940]	; 0x3ac
  }
  
  if((pdev->host.hc[hc_num].max_packet != mps) && (mps != 0))
 8007d08:	2224      	movs	r2, #36	; 0x24
 8007d0a:	fb02 0501 	mla	r5, r2, r1, r0
 8007d0e:	f8b5 63b2 	ldrh.w	r6, [r5, #946]	; 0x3b2
 8007d12:	42a6      	cmp	r6, r4
 8007d14:	d002      	beq.n	8007d1c <USBH_Modify_Channel+0x26>
 8007d16:	b10c      	cbz	r4, 8007d1c <USBH_Modify_Channel+0x26>
  {
    pdev->host.hc[hc_num].max_packet = mps; 
 8007d18:	f8a5 43b2 	strh.w	r4, [r5, #946]	; 0x3b2
  }
  
  if((pdev->host.hc[hc_num].speed != speed ) && (speed != 0 )) 
 8007d1c:	fb02 0201 	mla	r2, r2, r1, r0
 8007d20:	f892 43af 	ldrb.w	r4, [r2, #943]	; 0x3af
 8007d24:	429c      	cmp	r4, r3
 8007d26:	d002      	beq.n	8007d2e <USBH_Modify_Channel+0x38>
 8007d28:	b10b      	cbz	r3, 8007d2e <USBH_Modify_Channel+0x38>
  {
    pdev->host.hc[hc_num].speed = speed; 
 8007d2a:	f882 33af 	strb.w	r3, [r2, #943]	; 0x3af
  }
  
  USB_OTG_HC_Init(pdev, hc_num);
 8007d2e:	f7fe fada 	bl	80062e6 <USB_OTG_HC_Init>
  return HC_OK; 

}
 8007d32:	2000      	movs	r0, #0
 8007d34:	bd70      	pop	{r4, r5, r6, pc}

08007d36 <USBH_Alloc_Channel>:
  *         Allocate a new channel for the pipe
  * @param  ep_addr: End point for which the channel to be allocated
  * @retval hc_num: Host channel number
  */
uint8_t USBH_Alloc_Channel  (USB_OTG_CORE_HANDLE *pdev, uint8_t ep_addr)
{
 8007d36:	b510      	push	{r4, lr}
 8007d38:	2300      	movs	r3, #0
  * @brief  USBH_Alloc_Channel
  *         Allocate a new channel for the pipe
  * @param  ep_addr: End point for which the channel to be allocated
  * @retval hc_num: Host channel number
  */
uint8_t USBH_Alloc_Channel  (USB_OTG_CORE_HANDLE *pdev, uint8_t ep_addr)
 8007d3a:	eb00 0443 	add.w	r4, r0, r3, lsl #1
{
  uint8_t idx = 0;
  
  for (idx = 0 ; idx < HC_MAX ; idx++)
  {
	if ((pdev->host.channel[idx] & HC_USED) == 0)
 8007d3e:	f9b4 45c8 	ldrsh.w	r4, [r4, #1480]	; 0x5c8
 8007d42:	b2da      	uxtb	r2, r3
 8007d44:	2c00      	cmp	r4, #0
 8007d46:	db08      	blt.n	8007d5a <USBH_Alloc_Channel+0x24>
  
  hc_num =  USBH_GetFreeChannel(pdev);

  if (hc_num != HC_ERROR)
  {
	pdev->host.channel[hc_num] = HC_USED | ep_addr;
 8007d48:	ea6f 4141 	mvn.w	r1, r1, lsl #17
 8007d4c:	f503 7339 	add.w	r3, r3, #740	; 0x2e4
 8007d50:	ea6f 4151 	mvn.w	r1, r1, lsr #17
 8007d54:	f820 1013 	strh.w	r1, [r0, r3, lsl #1]
 8007d58:	e004      	b.n	8007d64 <USBH_Alloc_Channel+0x2e>
 8007d5a:	3301      	adds	r3, #1
  */
static uint16_t USBH_GetFreeChannel (USB_OTG_CORE_HANDLE *pdev)
{
  uint8_t idx = 0;
  
  for (idx = 0 ; idx < HC_MAX ; idx++)
 8007d5c:	2b08      	cmp	r3, #8
 8007d5e:	d1ec      	bne.n	8007d3a <USBH_Alloc_Channel+0x4>
	if ((pdev->host.channel[idx] & HC_USED) == 0)
	{
	   return idx;
	} 
  }
  return HC_ERROR;
 8007d60:	f64f 72ff 	movw	r2, #65535	; 0xffff
  if (hc_num != HC_ERROR)
  {
	pdev->host.channel[hc_num] = HC_USED | ep_addr;
  }
  return hc_num;
}
 8007d64:	b2d0      	uxtb	r0, r2
 8007d66:	bd10      	pop	{r4, pc}

08007d68 <USBH_Free_Channel>:
  * @param  idx: Channel number to be freed 
  * @retval Status
  */
uint8_t USBH_Free_Channel  (USB_OTG_CORE_HANDLE *pdev, uint8_t idx)
{
   if(idx < HC_MAX)
 8007d68:	2907      	cmp	r1, #7
 8007d6a:	d807      	bhi.n	8007d7c <USBH_Free_Channel+0x14>
   {
	 pdev->host.channel[idx] &= HC_USED_MASK;
 8007d6c:	f501 7139 	add.w	r1, r1, #740	; 0x2e4
 8007d70:	f830 3011 	ldrh.w	r3, [r0, r1, lsl #1]
 8007d74:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8007d78:	f820 3011 	strh.w	r3, [r0, r1, lsl #1]
   }
   return USBH_OK;
}
 8007d7c:	2000      	movs	r0, #0
 8007d7e:	4770      	bx	lr

08007d80 <USBH_DeAllocate_AllChannel>:
{
   uint8_t idx;
   
   for (idx = 2; idx < HC_MAX ; idx ++)
   {
	 pdev->host.channel[idx] = 0;
 8007d80:	2300      	movs	r3, #0
 8007d82:	f8a0 35cc 	strh.w	r3, [r0, #1484]	; 0x5cc
 8007d86:	f8a0 35ce 	strh.w	r3, [r0, #1486]	; 0x5ce
 8007d8a:	f8a0 35d0 	strh.w	r3, [r0, #1488]	; 0x5d0
 8007d8e:	f8a0 35d2 	strh.w	r3, [r0, #1490]	; 0x5d2
 8007d92:	f8a0 35d4 	strh.w	r3, [r0, #1492]	; 0x5d4
 8007d96:	f8a0 35d6 	strh.w	r3, [r0, #1494]	; 0x5d6
   }
   return USBH_OK;
}
 8007d9a:	4618      	mov	r0, r3
 8007d9c:	4770      	bx	lr

08007d9e <USBH_CtlReq>:
                             uint16_t            length)
{
  USBH_Status status;
  status = USBH_BUSY;
  
  switch (phost->RequestState)
 8007d9e:	78c8      	ldrb	r0, [r1, #3]
  */
USBH_Status USBH_CtlReq     (USB_OTG_CORE_HANDLE *pdev, 
                             USBH_HOST           *phost, 
                             uint8_t             *buff,
                             uint16_t            length)
{
 8007da0:	b510      	push	{r4, lr}
  USBH_Status status;
  status = USBH_BUSY;
  
  switch (phost->RequestState)
 8007da2:	2801      	cmp	r0, #1
 8007da4:	d004      	beq.n	8007db0 <USBH_CtlReq+0x12>
 8007da6:	2802      	cmp	r0, #2
 8007da8:	f04f 0301 	mov.w	r3, #1
 8007dac:	d119      	bne.n	8007de2 <USBH_CtlReq+0x44>
 8007dae:	e008      	b.n	8007dc2 <USBH_CtlReq+0x24>
                                           uint8_t* buff, 
                                           uint16_t length)
{
  
  /* Save Global State */
  phost->gStateBkp =   phost->gState; 
 8007db0:	780c      	ldrb	r4, [r1, #0]
  
  /* Prepare the Transactions */
  phost->gState = HOST_CTRL_XFER;
  phost->Control.buff = buff; 
  phost->Control.length = length;
 8007db2:	818b      	strh	r3, [r1, #12]
                                           uint8_t* buff, 
                                           uint16_t length)
{
  
  /* Save Global State */
  phost->gStateBkp =   phost->gState; 
 8007db4:	704c      	strb	r4, [r1, #1]
  
  /* Prepare the Transactions */
  phost->gState = HOST_CTRL_XFER;
 8007db6:	2407      	movs	r4, #7
 8007db8:	700c      	strb	r4, [r1, #0]
  phost->Control.buff = buff; 
 8007dba:	608a      	str	r2, [r1, #8]
  phost->Control.length = length;
  phost->Control.state = CTRL_SETUP;  
 8007dbc:	7708      	strb	r0, [r1, #28]
  switch (phost->RequestState)
  {
  case CMD_SEND:
    /* Start a SETUP transfer */
    USBH_SubmitSetupRequest(phost, buff, length);
    phost->RequestState = CMD_WAIT;
 8007dbe:	2302      	movs	r3, #2
 8007dc0:	e008      	b.n	8007dd4 <USBH_CtlReq+0x36>
    status = USBH_BUSY;
    break;
    
  case CMD_WAIT:
     if (phost->Control.state == CTRL_COMPLETE ) 
 8007dc2:	7f0a      	ldrb	r2, [r1, #28]
 8007dc4:	2a0d      	cmp	r2, #13
 8007dc6:	d103      	bne.n	8007dd0 <USBH_CtlReq+0x32>
    {
      /* Commands successfully sent and Response Received  */       
      phost->RequestState = CMD_SEND;
      phost->Control.state =CTRL_IDLE;  
 8007dc8:	2000      	movs	r0, #0
    
  case CMD_WAIT:
     if (phost->Control.state == CTRL_COMPLETE ) 
    {
      /* Commands successfully sent and Response Received  */       
      phost->RequestState = CMD_SEND;
 8007dca:	70cb      	strb	r3, [r1, #3]
      phost->Control.state =CTRL_IDLE;  
 8007dcc:	7708      	strb	r0, [r1, #28]
 8007dce:	bd10      	pop	{r4, pc}
      status = USBH_OK;      
    }
    else if  (phost->Control.state == CTRL_ERROR)
 8007dd0:	2a0b      	cmp	r2, #11
 8007dd2:	d101      	bne.n	8007dd8 <USBH_CtlReq+0x3a>
    {
      /* Failure Mode */
      phost->RequestState = CMD_SEND;
 8007dd4:	70cb      	strb	r3, [r1, #3]
 8007dd6:	bd10      	pop	{r4, pc}
      status = USBH_FAIL;
    }   
     else if  (phost->Control.state == CTRL_STALLED )
 8007dd8:	2a0c      	cmp	r2, #12
 8007dda:	d102      	bne.n	8007de2 <USBH_CtlReq+0x44>
    {
      /* Commands successfully sent and Response Received  */       
      phost->RequestState = CMD_SEND;
 8007ddc:	70cb      	strb	r3, [r1, #3]
      status = USBH_NOT_SUPPORTED;
 8007dde:	2003      	movs	r0, #3
 8007de0:	bd10      	pop	{r4, pc}
                             USBH_HOST           *phost, 
                             uint8_t             *buff,
                             uint16_t            length)
{
  USBH_Status status;
  status = USBH_BUSY;
 8007de2:	4618      	mov	r0, r3
    
  default:
    break; 
  }
  return status;
}
 8007de4:	bd10      	pop	{r4, pc}

08007de6 <USBH_CtlSendSetup>:
  * @retval Status
  */
USBH_Status USBH_CtlSendSetup ( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint8_t hc_num){
  pdev->host.hc[hc_num].ep_is_in = 0;
 8007de6:	2324      	movs	r3, #36	; 0x24
 8007de8:	fb03 0302 	mla	r3, r3, r2, r0
  * @param  hc_num: Host channel Number
  * @retval Status
  */
USBH_Status USBH_CtlSendSetup ( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint8_t hc_num){
 8007dec:	b510      	push	{r4, lr}
  pdev->host.hc[hc_num].ep_is_in = 0;
 8007dee:	2400      	movs	r4, #0
 8007df0:	f883 43ae 	strb.w	r4, [r3, #942]	; 0x3ae
  pdev->host.hc[hc_num].data_pid = HC_PID_SETUP;   
  pdev->host.hc[hc_num].xfer_buff = buff;
 8007df4:	f8c3 13b8 	str.w	r1, [r3, #952]	; 0x3b8
  */
USBH_Status USBH_CtlSendSetup ( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint8_t hc_num){
  pdev->host.hc[hc_num].ep_is_in = 0;
  pdev->host.hc[hc_num].data_pid = HC_PID_SETUP;   
 8007df8:	2403      	movs	r4, #3
  pdev->host.hc[hc_num].xfer_buff = buff;
  pdev->host.hc[hc_num].xfer_len = USBH_SETUP_PKT_SIZE;   
 8007dfa:	2108      	movs	r1, #8
 8007dfc:	f8c3 13bc 	str.w	r1, [r3, #956]	; 0x3bc
  */
USBH_Status USBH_CtlSendSetup ( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint8_t hc_num){
  pdev->host.hc[hc_num].ep_is_in = 0;
  pdev->host.hc[hc_num].data_pid = HC_PID_SETUP;   
 8007e00:	f883 43b4 	strb.w	r4, [r3, #948]	; 0x3b4
  pdev->host.hc[hc_num].xfer_buff = buff;
  pdev->host.hc[hc_num].xfer_len = USBH_SETUP_PKT_SIZE;   

  return (USBH_Status)HCD_SubmitRequest (pdev , hc_num);   
 8007e04:	4611      	mov	r1, r2
 8007e06:	f7fe fc14 	bl	8006632 <HCD_SubmitRequest>
}
 8007e0a:	b2c0      	uxtb	r0, r0
 8007e0c:	bd10      	pop	{r4, pc}

08007e0e <USBH_CtlSendData>:
  */
USBH_Status USBH_CtlSendData ( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint16_t length,
                                uint8_t hc_num)
{
 8007e0e:	b570      	push	{r4, r5, r6, lr}
  pdev->host.hc[hc_num].ep_is_in = 0;
 8007e10:	2524      	movs	r5, #36	; 0x24
 8007e12:	fb05 0403 	mla	r4, r5, r3, r0
 8007e16:	2600      	movs	r6, #0
 8007e18:	f884 63ae 	strb.w	r6, [r4, #942]	; 0x3ae
  pdev->host.hc[hc_num].xfer_buff = buff;
 8007e1c:	f8c4 13b8 	str.w	r1, [r4, #952]	; 0x3b8
  pdev->host.hc[hc_num].xfer_len = length;
 8007e20:	f8c4 23bc 	str.w	r2, [r4, #956]	; 0x3bc
 
  if ( length == 0 )
 8007e24:	b912      	cbnz	r2, 8007e2c <USBH_CtlSendData+0x1e>
  { /* For Status OUT stage, Length==0, Status Out PID = 1 */
    pdev->host.hc[hc_num].toggle_out = 1;   
 8007e26:	2201      	movs	r2, #1
 8007e28:	f884 23c5 	strb.w	r2, [r4, #965]	; 0x3c5
  }
 
 /* Set the Data Toggle bit as per the Flag */
  if ( pdev->host.hc[hc_num].toggle_out == 0)
 8007e2c:	fb05 0503 	mla	r5, r5, r3, r0
 8007e30:	f895 23c5 	ldrb.w	r2, [r5, #965]	; 0x3c5
 8007e34:	f505 756c 	add.w	r5, r5, #944	; 0x3b0
 8007e38:	b902      	cbnz	r2, 8007e3c <USBH_CtlSendData+0x2e>
 8007e3a:	e000      	b.n	8007e3e <USBH_CtlSendData+0x30>
  { /* Put the PID 0 */
      pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;    
  }
 else
 { /* Put the PID 1 */
      pdev->host.hc[hc_num].data_pid = HC_PID_DATA1 ;
 8007e3c:	2202      	movs	r2, #2
 8007e3e:	712a      	strb	r2, [r5, #4]
 }

  HCD_SubmitRequest (pdev , hc_num);   
 8007e40:	4619      	mov	r1, r3
 8007e42:	f7fe fbf6 	bl	8006632 <HCD_SubmitRequest>
   
  return USBH_OK;
}
 8007e46:	2000      	movs	r0, #0
 8007e48:	bd70      	pop	{r4, r5, r6, pc}

08007e4a <USBH_CtlReceiveData>:
  */
USBH_Status USBH_CtlReceiveData(USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t* buff, 
                                uint16_t length,
                                uint8_t hc_num)
{
 8007e4a:	b538      	push	{r3, r4, r5, lr}

  pdev->host.hc[hc_num].ep_is_in = 1;
 8007e4c:	2424      	movs	r4, #36	; 0x24
 8007e4e:	fb04 0403 	mla	r4, r4, r3, r0
 8007e52:	2501      	movs	r5, #1
 8007e54:	f884 53ae 	strb.w	r5, [r4, #942]	; 0x3ae
  pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 8007e58:	2502      	movs	r5, #2
  pdev->host.hc[hc_num].xfer_buff = buff;
 8007e5a:	f8c4 13b8 	str.w	r1, [r4, #952]	; 0x3b8
                                uint16_t length,
                                uint8_t hc_num)
{

  pdev->host.hc[hc_num].ep_is_in = 1;
  pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 8007e5e:	f884 53b4 	strb.w	r5, [r4, #948]	; 0x3b4
  pdev->host.hc[hc_num].xfer_buff = buff;
  pdev->host.hc[hc_num].xfer_len = length;  
 8007e62:	f8c4 23bc 	str.w	r2, [r4, #956]	; 0x3bc

  HCD_SubmitRequest (pdev , hc_num);   
 8007e66:	4619      	mov	r1, r3
 8007e68:	f7fe fbe3 	bl	8006632 <HCD_SubmitRequest>
  
  return USBH_OK;
  
}
 8007e6c:	2000      	movs	r0, #0
 8007e6e:	bd38      	pop	{r3, r4, r5, pc}

08007e70 <USBH_BulkSendData>:
  */
USBH_Status USBH_BulkSendData ( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint16_t length,
                                uint8_t hc_num)
{ 
 8007e70:	b538      	push	{r3, r4, r5, lr}
  pdev->host.hc[hc_num].ep_is_in = 0;
 8007e72:	2424      	movs	r4, #36	; 0x24
 8007e74:	fb04 0403 	mla	r4, r4, r3, r0
  pdev->host.hc[hc_num].xfer_buff = buff;
  pdev->host.hc[hc_num].xfer_len = length;  
 8007e78:	f8c4 23bc 	str.w	r2, [r4, #956]	; 0x3bc

 /* Set the Data Toggle bit as per the Flag */
  if ( pdev->host.hc[hc_num].toggle_out == 0)
 8007e7c:	f894 23c5 	ldrb.w	r2, [r4, #965]	; 0x3c5
USBH_Status USBH_BulkSendData ( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint16_t length,
                                uint8_t hc_num)
{ 
  pdev->host.hc[hc_num].ep_is_in = 0;
 8007e80:	2500      	movs	r5, #0
 8007e82:	f884 53ae 	strb.w	r5, [r4, #942]	; 0x3ae
  pdev->host.hc[hc_num].xfer_buff = buff;
 8007e86:	f8c4 13b8 	str.w	r1, [r4, #952]	; 0x3b8
 8007e8a:	f504 746c 	add.w	r4, r4, #944	; 0x3b0
  pdev->host.hc[hc_num].xfer_len = length;  

 /* Set the Data Toggle bit as per the Flag */
  if ( pdev->host.hc[hc_num].toggle_out == 0)
 8007e8e:	b902      	cbnz	r2, 8007e92 <USBH_BulkSendData+0x22>
 8007e90:	e000      	b.n	8007e94 <USBH_BulkSendData+0x24>
  { /* Put the PID 0 */
      pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;    
  }
 else
 { /* Put the PID 1 */
      pdev->host.hc[hc_num].data_pid = HC_PID_DATA1 ;
 8007e92:	2202      	movs	r2, #2
 8007e94:	7122      	strb	r2, [r4, #4]
 }

  HCD_SubmitRequest (pdev , hc_num);   
 8007e96:	4619      	mov	r1, r3
 8007e98:	f7fe fbcb 	bl	8006632 <HCD_SubmitRequest>
  return USBH_OK;
}
 8007e9c:	2000      	movs	r0, #0
 8007e9e:	bd38      	pop	{r3, r4, r5, pc}

08007ea0 <USBH_BulkReceiveData>:
  */
USBH_Status USBH_BulkReceiveData( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint16_t length,
                                uint8_t hc_num)
{
 8007ea0:	b538      	push	{r3, r4, r5, lr}
  pdev->host.hc[hc_num].ep_is_in = 1;   
 8007ea2:	2424      	movs	r4, #36	; 0x24
 8007ea4:	fb04 0403 	mla	r4, r4, r3, r0
  pdev->host.hc[hc_num].xfer_buff = buff;
  pdev->host.hc[hc_num].xfer_len = length;
 8007ea8:	f8c4 23bc 	str.w	r2, [r4, #956]	; 0x3bc
  

  if( pdev->host.hc[hc_num].toggle_in == 0)
 8007eac:	f894 23c4 	ldrb.w	r2, [r4, #964]	; 0x3c4
USBH_Status USBH_BulkReceiveData( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint16_t length,
                                uint8_t hc_num)
{
  pdev->host.hc[hc_num].ep_is_in = 1;   
 8007eb0:	2501      	movs	r5, #1
 8007eb2:	f884 53ae 	strb.w	r5, [r4, #942]	; 0x3ae
  pdev->host.hc[hc_num].xfer_buff = buff;
 8007eb6:	f8c4 13b8 	str.w	r1, [r4, #952]	; 0x3b8
 8007eba:	f504 746c 	add.w	r4, r4, #944	; 0x3b0
  pdev->host.hc[hc_num].xfer_len = length;
  

  if( pdev->host.hc[hc_num].toggle_in == 0)
 8007ebe:	b902      	cbnz	r2, 8007ec2 <USBH_BulkReceiveData+0x22>
 8007ec0:	e000      	b.n	8007ec4 <USBH_BulkReceiveData+0x24>
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
  }
  else
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 8007ec2:	2202      	movs	r2, #2
 8007ec4:	7122      	strb	r2, [r4, #4]
  }

  HCD_SubmitRequest (pdev , hc_num);  
 8007ec6:	4619      	mov	r1, r3
 8007ec8:	f7fe fbb3 	bl	8006632 <HCD_SubmitRequest>
  return USBH_OK;
}
 8007ecc:	2000      	movs	r0, #0
 8007ece:	bd38      	pop	{r3, r4, r5, pc}

08007ed0 <USBH_InterruptReceiveData>:
  */
USBH_Status USBH_InterruptReceiveData( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint8_t length,
                                uint8_t hc_num)
{
 8007ed0:	b570      	push	{r4, r5, r6, lr}

  pdev->host.hc[hc_num].ep_is_in = 1;  
 8007ed2:	2524      	movs	r5, #36	; 0x24
 8007ed4:	fb05 0403 	mla	r4, r5, r3, r0
  pdev->host.hc[hc_num].xfer_buff = buff;
  pdev->host.hc[hc_num].xfer_len = length;
 8007ed8:	f8c4 23bc 	str.w	r2, [r4, #956]	; 0x3bc
  

  
  if(pdev->host.hc[hc_num].toggle_in == 0)
 8007edc:	f894 23c4 	ldrb.w	r2, [r4, #964]	; 0x3c4
                                uint8_t *buff, 
                                uint8_t length,
                                uint8_t hc_num)
{

  pdev->host.hc[hc_num].ep_is_in = 1;  
 8007ee0:	2601      	movs	r6, #1
 8007ee2:	f884 63ae 	strb.w	r6, [r4, #942]	; 0x3ae
  pdev->host.hc[hc_num].xfer_buff = buff;
 8007ee6:	f8c4 13b8 	str.w	r1, [r4, #952]	; 0x3b8
 8007eea:	f504 746c 	add.w	r4, r4, #944	; 0x3b0
  pdev->host.hc[hc_num].xfer_len = length;
  

  
  if(pdev->host.hc[hc_num].toggle_in == 0)
 8007eee:	b902      	cbnz	r2, 8007ef2 <USBH_InterruptReceiveData+0x22>
 8007ef0:	e000      	b.n	8007ef4 <USBH_InterruptReceiveData+0x24>
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
  }
  else
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 8007ef2:	2202      	movs	r2, #2
  }

  /* toggle DATA PID */
  pdev->host.hc[hc_num].toggle_in ^= 1;  
 8007ef4:	fb05 0503 	mla	r5, r5, r3, r0
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
  }
  else
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 8007ef8:	7122      	strb	r2, [r4, #4]
  }

  /* toggle DATA PID */
  pdev->host.hc[hc_num].toggle_in ^= 1;  
 8007efa:	f895 23c4 	ldrb.w	r2, [r5, #964]	; 0x3c4
  
  HCD_SubmitRequest (pdev , hc_num);  
 8007efe:	4619      	mov	r1, r3
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
  }

  /* toggle DATA PID */
  pdev->host.hc[hc_num].toggle_in ^= 1;  
 8007f00:	f082 0201 	eor.w	r2, r2, #1
 8007f04:	f885 23c4 	strb.w	r2, [r5, #964]	; 0x3c4
  
  HCD_SubmitRequest (pdev , hc_num);  
 8007f08:	f7fe fb93 	bl	8006632 <HCD_SubmitRequest>
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
  }

  /* toggle DATA PID */
  pdev->host.hc[hc_num].toggle_in ^= 1;  
 8007f0c:	f505 7570 	add.w	r5, r5, #960	; 0x3c0
  
  HCD_SubmitRequest (pdev , hc_num);  
  
  return USBH_OK;
}
 8007f10:	2000      	movs	r0, #0
 8007f12:	bd70      	pop	{r4, r5, r6, pc}

08007f14 <USBH_InterruptSendData>:
  */
USBH_Status USBH_InterruptSendData( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint8_t length,
                                uint8_t hc_num)
{
 8007f14:	b570      	push	{r4, r5, r6, lr}

  pdev->host.hc[hc_num].ep_is_in = 0;  
 8007f16:	2524      	movs	r5, #36	; 0x24
 8007f18:	fb05 0403 	mla	r4, r5, r3, r0
  pdev->host.hc[hc_num].xfer_buff = buff;
  pdev->host.hc[hc_num].xfer_len = length;
 8007f1c:	f8c4 23bc 	str.w	r2, [r4, #956]	; 0x3bc
  
  if(pdev->host.hc[hc_num].toggle_in == 0)
 8007f20:	f894 23c4 	ldrb.w	r2, [r4, #964]	; 0x3c4
                                uint8_t *buff, 
                                uint8_t length,
                                uint8_t hc_num)
{

  pdev->host.hc[hc_num].ep_is_in = 0;  
 8007f24:	2600      	movs	r6, #0
 8007f26:	f884 63ae 	strb.w	r6, [r4, #942]	; 0x3ae
  pdev->host.hc[hc_num].xfer_buff = buff;
 8007f2a:	f8c4 13b8 	str.w	r1, [r4, #952]	; 0x3b8
 8007f2e:	f504 746c 	add.w	r4, r4, #944	; 0x3b0
  pdev->host.hc[hc_num].xfer_len = length;
  
  if(pdev->host.hc[hc_num].toggle_in == 0)
 8007f32:	b902      	cbnz	r2, 8007f36 <USBH_InterruptSendData+0x22>
 8007f34:	e000      	b.n	8007f38 <USBH_InterruptSendData+0x24>
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
  }
  else
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 8007f36:	2202      	movs	r2, #2
  }

  pdev->host.hc[hc_num].toggle_in ^= 1;  
 8007f38:	fb05 0503 	mla	r5, r5, r3, r0
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
  }
  else
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 8007f3c:	7122      	strb	r2, [r4, #4]
  }

  pdev->host.hc[hc_num].toggle_in ^= 1;  
 8007f3e:	f895 23c4 	ldrb.w	r2, [r5, #964]	; 0x3c4
  
  HCD_SubmitRequest (pdev , hc_num);  
 8007f42:	4619      	mov	r1, r3
  else
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
  }

  pdev->host.hc[hc_num].toggle_in ^= 1;  
 8007f44:	f082 0201 	eor.w	r2, r2, #1
 8007f48:	f885 23c4 	strb.w	r2, [r5, #964]	; 0x3c4
  
  HCD_SubmitRequest (pdev , hc_num);  
 8007f4c:	f7fe fb71 	bl	8006632 <HCD_SubmitRequest>
  else
  {
    pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
  }

  pdev->host.hc[hc_num].toggle_in ^= 1;  
 8007f50:	f505 7570 	add.w	r5, r5, #960	; 0x3c0
  
  HCD_SubmitRequest (pdev , hc_num);  
  
  return USBH_OK;
}
 8007f54:	2000      	movs	r0, #0
 8007f56:	bd70      	pop	{r4, r5, r6, pc}

08007f58 <USBH_IsocReceiveData>:
  */
USBH_Status USBH_IsocReceiveData( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint32_t length,
                                uint8_t hc_num)
{    
 8007f58:	b538      	push	{r3, r4, r5, lr}
  
  pdev->host.hc[hc_num].ep_is_in = 1;  
 8007f5a:	2424      	movs	r4, #36	; 0x24
 8007f5c:	fb04 0403 	mla	r4, r4, r3, r0
 8007f60:	2501      	movs	r5, #1
 8007f62:	f884 53ae 	strb.w	r5, [r4, #942]	; 0x3ae
  pdev->host.hc[hc_num].xfer_buff = buff;
  pdev->host.hc[hc_num].xfer_len = length;
  pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
 8007f66:	2500      	movs	r5, #0
                                uint32_t length,
                                uint8_t hc_num)
{    
  
  pdev->host.hc[hc_num].ep_is_in = 1;  
  pdev->host.hc[hc_num].xfer_buff = buff;
 8007f68:	f8c4 13b8 	str.w	r1, [r4, #952]	; 0x3b8
  pdev->host.hc[hc_num].xfer_len = length;
 8007f6c:	f8c4 23bc 	str.w	r2, [r4, #956]	; 0x3bc
  pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
 8007f70:	f884 53b4 	strb.w	r5, [r4, #948]	; 0x3b4
  

  HCD_SubmitRequest (pdev , hc_num);  
 8007f74:	4619      	mov	r1, r3
 8007f76:	f7fe fb5c 	bl	8006632 <HCD_SubmitRequest>
{    
  
  pdev->host.hc[hc_num].ep_is_in = 1;  
  pdev->host.hc[hc_num].xfer_buff = buff;
  pdev->host.hc[hc_num].xfer_len = length;
  pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
 8007f7a:	f504 746c 	add.w	r4, r4, #944	; 0x3b0
  

  HCD_SubmitRequest (pdev , hc_num);  
  
  return USBH_OK;
}
 8007f7e:	4628      	mov	r0, r5
 8007f80:	bd38      	pop	{r3, r4, r5, pc}

08007f82 <USBH_IsocSendData>:
  */
USBH_Status USBH_IsocSendData( USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t *buff, 
                                uint32_t length,
                                uint8_t hc_num)
{
 8007f82:	b538      	push	{r3, r4, r5, lr}
  
  pdev->host.hc[hc_num].ep_is_in = 0;  
 8007f84:	2424      	movs	r4, #36	; 0x24
 8007f86:	fb04 0403 	mla	r4, r4, r3, r0
 8007f8a:	2500      	movs	r5, #0
 8007f8c:	f884 53ae 	strb.w	r5, [r4, #942]	; 0x3ae
  pdev->host.hc[hc_num].xfer_buff = buff;
 8007f90:	f8c4 13b8 	str.w	r1, [r4, #952]	; 0x3b8
  pdev->host.hc[hc_num].xfer_len = length;
 8007f94:	f8c4 23bc 	str.w	r2, [r4, #956]	; 0x3bc
  pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
 8007f98:	f884 53b4 	strb.w	r5, [r4, #948]	; 0x3b4
  
  HCD_SubmitRequest (pdev , hc_num);  
 8007f9c:	4619      	mov	r1, r3
 8007f9e:	f7fe fb48 	bl	8006632 <HCD_SubmitRequest>
{
  
  pdev->host.hc[hc_num].ep_is_in = 0;  
  pdev->host.hc[hc_num].xfer_buff = buff;
  pdev->host.hc[hc_num].xfer_len = length;
  pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
 8007fa2:	f504 746c 	add.w	r4, r4, #944	; 0x3b0
  
  HCD_SubmitRequest (pdev , hc_num);  
  
  return USBH_OK;
}
 8007fa6:	4628      	mov	r0, r5
 8007fa8:	bd38      	pop	{r3, r4, r5, pc}

08007faa <BSP_init>:
 *      Author: kiya
 */

#include "bsp.h"

void BSP_init(void) {
 8007faa:	b508      	push	{r3, lr}
	/* Configure the system ready to run the demo.  The clock configuration
	can be done here if it was not done before main() was called. */

	GPIO_Configuration();
 8007fac:	f000 f9a8 	bl	8008300 <GPIO_Configuration>

#ifdef USE_SDCARD
	comm_init();
 8007fb0:	f000 f852 	bl	8008058 <comm_init>
	rtc_init();
#endif
}
 8007fb4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

	GPIO_Configuration();

#ifdef USE_SDCARD
	comm_init();
	rtc_init();
 8007fb8:	f000 bad2 	b.w	8008560 <rtc_init>

08007fbc <__cxa_pure_virtual>:
#endif
}

void __cxa_pure_virtual(void) { while (1); }
 8007fbc:	e7fe      	b.n	8007fbc <__cxa_pure_virtual>
	...

08007fc0 <comm_test>:
static uint8_t avai_of_rxbuf = 0;
const uint8_t NbrOfDataToRead2 = sizeof(RxBuffer2) / sizeof(uint8_t);

int comm_test(void)
{
	return ( USART_GetFlagStatus(USARTx, USART_FLAG_RXNE) == RESET ) ? 0 : 1;
 8007fc0:	2120      	movs	r1, #32
static uint8_t head_of_rxbuf = 0;
static uint8_t avai_of_rxbuf = 0;
const uint8_t NbrOfDataToRead2 = sizeof(RxBuffer2) / sizeof(uint8_t);

int comm_test(void)
{
 8007fc2:	b508      	push	{r3, lr}
	return ( USART_GetFlagStatus(USARTx, USART_FLAG_RXNE) == RESET ) ? 0 : 1;
 8007fc4:	4803      	ldr	r0, [pc, #12]	; (8007fd4 <comm_test+0x14>)
 8007fc6:	f7fd fe12 	bl	8005bee <USART_GetFlagStatus>
}
 8007fca:	3000      	adds	r0, #0
 8007fcc:	bf18      	it	ne
 8007fce:	2001      	movne	r0, #1
 8007fd0:	bd08      	pop	{r3, pc}
 8007fd2:	bf00      	nop
 8007fd4:	40013800 	.word	0x40013800

08007fd8 <comm_get>:

char comm_get(void)
{
 8007fd8:	b508      	push	{r3, lr}
	while(USART_GetFlagStatus(USARTx, USART_FLAG_RXNE) == RESET) { ; }
 8007fda:	4805      	ldr	r0, [pc, #20]	; (8007ff0 <comm_get+0x18>)
 8007fdc:	2120      	movs	r1, #32
 8007fde:	f7fd fe06 	bl	8005bee <USART_GetFlagStatus>
 8007fe2:	2800      	cmp	r0, #0
 8007fe4:	d0f9      	beq.n	8007fda <comm_get+0x2>
	return (char)USART_ReceiveData(USARTx);
 8007fe6:	4802      	ldr	r0, [pc, #8]	; (8007ff0 <comm_get+0x18>)
 8007fe8:	f7fd fd92 	bl	8005b10 <USART_ReceiveData>
}
 8007fec:	b2c0      	uxtb	r0, r0
 8007fee:	bd08      	pop	{r3, pc}
 8007ff0:	40013800 	.word	0x40013800

08007ff4 <comm_getc>:

char comm_getc(void) {
	char c = 0;

	__disable_irq();
 8007ff4:	b672      	cpsid	i
	if(avai_of_rxbuf) {
 8007ff6:	4b09      	ldr	r3, [pc, #36]	; (800801c <comm_getc+0x28>)
 8007ff8:	781a      	ldrb	r2, [r3, #0]
 8007ffa:	b162      	cbz	r2, 8008016 <comm_getc+0x22>
		c = RxBuffer2[head_of_rxbuf++];
 8007ffc:	7859      	ldrb	r1, [r3, #1]
 8007ffe:	4808      	ldr	r0, [pc, #32]	; (8008020 <comm_getc+0x2c>)
		avai_of_rxbuf--;
 8008000:	3a01      	subs	r2, #1
char comm_getc(void) {
	char c = 0;

	__disable_irq();
	if(avai_of_rxbuf) {
		c = RxBuffer2[head_of_rxbuf++];
 8008002:	5c40      	ldrb	r0, [r0, r1]
 8008004:	3101      	adds	r1, #1
 8008006:	b2c9      	uxtb	r1, r1
		avai_of_rxbuf--;
		if(head_of_rxbuf > NbrOfDataToRead2)
 8008008:	2964      	cmp	r1, #100	; 0x64
char comm_getc(void) {
	char c = 0;

	__disable_irq();
	if(avai_of_rxbuf) {
		c = RxBuffer2[head_of_rxbuf++];
 800800a:	7059      	strb	r1, [r3, #1]
		avai_of_rxbuf--;
 800800c:	701a      	strb	r2, [r3, #0]
		if(head_of_rxbuf > NbrOfDataToRead2)
 800800e:	d903      	bls.n	8008018 <comm_getc+0x24>
			head_of_rxbuf = 0;
 8008010:	2200      	movs	r2, #0
 8008012:	705a      	strb	r2, [r3, #1]
 8008014:	e000      	b.n	8008018 <comm_getc+0x24>
	while(USART_GetFlagStatus(USARTx, USART_FLAG_RXNE) == RESET) { ; }
	return (char)USART_ReceiveData(USARTx);
}

char comm_getc(void) {
	char c = 0;
 8008016:	4610      	mov	r0, r2
		c = RxBuffer2[head_of_rxbuf++];
		avai_of_rxbuf--;
		if(head_of_rxbuf > NbrOfDataToRead2)
			head_of_rxbuf = 0;
	}
	__enable_irq();
 8008018:	b662      	cpsie	i

	return c;
}
 800801a:	4770      	bx	lr
 800801c:	20000b40 	.word	0x20000b40
 8008020:	20001c65 	.word	0x20001c65

08008024 <comm_put>:

void comm_put(char d)
{
 8008024:	b510      	push	{r4, lr}
 8008026:	4604      	mov	r4, r0
	while(USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET) { ; }
 8008028:	4805      	ldr	r0, [pc, #20]	; (8008040 <comm_put+0x1c>)
 800802a:	2180      	movs	r1, #128	; 0x80
 800802c:	f7fd fddf 	bl	8005bee <USART_GetFlagStatus>
 8008030:	2800      	cmp	r0, #0
 8008032:	d0f9      	beq.n	8008028 <comm_put+0x4>
	USART_SendData(USARTx, (uint16_t)d);
 8008034:	4802      	ldr	r0, [pc, #8]	; (8008040 <comm_put+0x1c>)
 8008036:	4621      	mov	r1, r4
}
 8008038:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

void comm_put(char d)
{
	while(USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET) { ; }
	USART_SendData(USARTx, (uint16_t)d);
 800803c:	f7fd bd64 	b.w	8005b08 <USART_SendData>
 8008040:	40013800 	.word	0x40013800

08008044 <comm_puts>:
}

void comm_puts(const char* s)
{
 8008044:	b510      	push	{r4, lr}
 8008046:	4604      	mov	r4, r0
	char c;
	while ( ( c = *s++) != '\0' ) {
 8008048:	e001      	b.n	800804e <comm_puts+0xa>
		comm_put(c);
 800804a:	f7ff ffeb 	bl	8008024 <comm_put>
}

void comm_puts(const char* s)
{
	char c;
	while ( ( c = *s++) != '\0' ) {
 800804e:	f814 0b01 	ldrb.w	r0, [r4], #1
 8008052:	2800      	cmp	r0, #0
 8008054:	d1f9      	bne.n	800804a <comm_puts+0x6>
		comm_put(c);
	}
}
 8008056:	bd10      	pop	{r4, pc}

08008058 <comm_init>:

void comm_init (void)
{
 8008058:	b570      	push	{r4, r5, r6, lr}
	USART_InitTypeDef USART_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	/* Configure the NVIC Preemption Priority Bits */
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
 800805a:	f44f 60e0 	mov.w	r0, #1792	; 0x700
		comm_put(c);
	}
}

void comm_init (void)
{
 800805e:	b086      	sub	sp, #24
	USART_InitTypeDef USART_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	/* Configure the NVIC Preemption Priority Bits */
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
 8008060:	f7fb fbbc 	bl	80037dc <NVIC_PriorityGroupConfig>

	/* Enable the USART Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = COM_USART_INT[COM1];
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 8008064:	2500      	movs	r5, #0
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8008066:	2401      	movs	r4, #1

	/* Configure the NVIC Preemption Priority Bits */
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);

	/* Enable the USART Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = COM_USART_INT[COM1];
 8008068:	2326      	movs	r3, #38	; 0x26
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 800806a:	4668      	mov	r0, sp

	/* Configure the NVIC Preemption Priority Bits */
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);

	/* Enable the USART Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = COM_USART_INT[COM1];
 800806c:	f88d 3000 	strb.w	r3, [sp]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 8008070:	f88d 5002 	strb.w	r5, [sp, #2]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8008074:	f88d 4003 	strb.w	r4, [sp, #3]
	NVIC_Init(&NVIC_InitStructure);
 8008078:	f7fb fbba 	bl	80037f0 <NVIC_Init>

	USART_InitStructure.USART_BaudRate = 115200;
 800807c:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 8008080:	9302      	str	r3, [sp, #8]
{
  GPIO_InitTypeDef GPIO_InitStructure;

  /* Enable GPIO clock */
  //RCC_APB2PeriphClockCmd(COM_TX_PORT_CLK[COM] | COM_RX_PORT_CLK[COM] | RCC_APB2Periph_AFIO, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
 8008082:	2004      	movs	r0, #4
	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8008084:	230c      	movs	r3, #12
{
  GPIO_InitTypeDef GPIO_InitStructure;

  /* Enable GPIO clock */
  //RCC_APB2PeriphClockCmd(COM_TX_PORT_CLK[COM] | COM_RX_PORT_CLK[COM] | RCC_APB2Periph_AFIO, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
 8008086:	4621      	mov	r1, r4
	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8008088:	f8ad 3012 	strh.w	r3, [sp, #18]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 800808c:	f8ad 500c 	strh.w	r5, [sp, #12]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8008090:	f8ad 500e 	strh.w	r5, [sp, #14]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 8008094:	f8ad 5010 	strh.w	r5, [sp, #16]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8008098:	f8ad 5014 	strh.w	r5, [sp, #20]
{
  GPIO_InitTypeDef GPIO_InitStructure;

  /* Enable GPIO clock */
  //RCC_APB2PeriphClockCmd(COM_TX_PORT_CLK[COM] | COM_RX_PORT_CLK[COM] | RCC_APB2Periph_AFIO, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
 800809c:	f7fc fae8 	bl	8004670 <RCC_APB2PeriphClockCmd>
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
 80080a0:	4621      	mov	r1, r4
 80080a2:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80080a6:	f7fc faef 	bl	8004688 <RCC_APB1PeriphClockCmd>

  /* Configure USART Tx as alternate function push-pull */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  GPIO_InitStructure.GPIO_Pin = COM_TX_PIN[COM];
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(COM_TX_PORT[COM], &GPIO_InitStructure);
 80080aa:	4d14      	ldr	r5, [pc, #80]	; (80080fc <comm_init+0xa4>)
//    GPIO_PinRemapConfig(GPIO_Remap_USART2, ENABLE);
//    RCC_APB1PeriphClockCmd(COM_USART_CLK[COM], ENABLE);
//  }

  /* Configure USART Tx as alternate function push-pull */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 80080ac:	2318      	movs	r3, #24
 80080ae:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Pin = COM_TX_PIN[COM];
 80080b2:	2304      	movs	r3, #4
 80080b4:	461e      	mov	r6, r3
 80080b6:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(COM_TX_PORT[COM], &GPIO_InitStructure);
 80080ba:	6828      	ldr	r0, [r5, #0]
//  }

  /* Configure USART Tx as alternate function push-pull */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  GPIO_InitStructure.GPIO_Pin = COM_TX_PIN[COM];
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80080bc:	2303      	movs	r3, #3
  GPIO_Init(COM_TX_PORT[COM], &GPIO_InitStructure);
 80080be:	a901      	add	r1, sp, #4
//  }

  /* Configure USART Tx as alternate function push-pull */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  GPIO_InitStructure.GPIO_Pin = COM_TX_PIN[COM];
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80080c0:	f88d 3006 	strb.w	r3, [sp, #6]
  GPIO_Init(COM_TX_PORT[COM], &GPIO_InitStructure);
 80080c4:	f7fb fdff 	bl	8003cc6 <GPIO_Init>

  /* Configure USART Rx as input floating */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  GPIO_InitStructure.GPIO_Pin = COM_RX_PIN[COM];
 80080c8:	2308      	movs	r3, #8
  GPIO_Init(COM_RX_PORT[COM], &GPIO_InitStructure);
 80080ca:	6868      	ldr	r0, [r5, #4]
 80080cc:	a901      	add	r1, sp, #4
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(COM_TX_PORT[COM], &GPIO_InitStructure);

  /* Configure USART Rx as input floating */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  GPIO_InitStructure.GPIO_Pin = COM_RX_PIN[COM];
 80080ce:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_InitStructure.GPIO_Pin = COM_TX_PIN[COM];
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(COM_TX_PORT[COM], &GPIO_InitStructure);

  /* Configure USART Rx as input floating */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 80080d2:	f88d 6007 	strb.w	r6, [sp, #7]
  GPIO_InitStructure.GPIO_Pin = COM_RX_PIN[COM];
  GPIO_Init(COM_RX_PORT[COM], &GPIO_InitStructure);
 80080d6:	f7fb fdf6 	bl	8003cc6 <GPIO_Init>

  /* USART configuration */
  USART_Init(COM_USART[COM], USART_InitStruct);
 80080da:	68a8      	ldr	r0, [r5, #8]
 80080dc:	a902      	add	r1, sp, #8
 80080de:	f7fd fc35 	bl	800594c <USART_Init>

	/* Enable USARTy Receive and Transmit interrupts */
	USART_ITConfig(COM_USART[COM], USART_IT_RXNE, ENABLE);
 80080e2:	68a8      	ldr	r0, [r5, #8]
 80080e4:	f240 5125 	movw	r1, #1317	; 0x525
 80080e8:	4622      	mov	r2, r4
 80080ea:	f7fd fcb2 	bl	8005a52 <USART_ITConfig>
	//USART_ITConfig(COM_USART[COM1], USART_IT_TXE, ENABLE);

  /* Enable USART */
  USART_Cmd(COM_USART[COM], ENABLE);
 80080ee:	68a8      	ldr	r0, [r5, #8]
 80080f0:	4621      	mov	r1, r4
 80080f2:	f7fd fca2 	bl	8005a3a <USART_Cmd>
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	STM_EVAL_COMInit(COM1, &USART_InitStructure);	// RX in INT mode
}
 80080f6:	b006      	add	sp, #24
 80080f8:	bd70      	pop	{r4, r5, r6, pc}
 80080fa:	bf00      	nop
 80080fc:	20000098 	.word	0x20000098

08008100 <__uart_putchar>:
  /* Enable USART */
  USART_Cmd(COM_USART[COM], ENABLE);
}


void __uart_putchar(int ch) {
 8008100:	b510      	push	{r4, lr}
 8008102:	4604      	mov	r4, r0
	/* Loop until the end of transmission */
	while (USART_GetFlagStatus(EVAL_COM1, USART_FLAG_TC) == RESET)
	{}

#else
	while(USART_GetFlagStatus(EVAL_COM1, USART_FLAG_TC) == RESET) { ; }
 8008104:	4805      	ldr	r0, [pc, #20]	; (800811c <__uart_putchar+0x1c>)
 8008106:	2140      	movs	r1, #64	; 0x40
 8008108:	f7fd fd71 	bl	8005bee <USART_GetFlagStatus>
 800810c:	2800      	cmp	r0, #0
 800810e:	d0f9      	beq.n	8008104 <__uart_putchar+0x4>
	USART_SendData(EVAL_COM1, (uint16_t)ch);
 8008110:	4802      	ldr	r0, [pc, #8]	; (800811c <__uart_putchar+0x1c>)
 8008112:	b2a1      	uxth	r1, r4
#endif
}
 8008114:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	while (USART_GetFlagStatus(EVAL_COM1, USART_FLAG_TC) == RESET)
	{}

#else
	while(USART_GetFlagStatus(EVAL_COM1, USART_FLAG_TC) == RESET) { ; }
	USART_SendData(EVAL_COM1, (uint16_t)ch);
 8008118:	f7fd bcf6 	b.w	8005b08 <USART_SendData>
 800811c:	40004400 	.word	0x40004400

08008120 <GetKey>:
uint8_t GetKey(void)
{
	uint8_t RetVal;

	RetVal = 0;
	if (EVAL_COM1->SR & USART_FLAG_RXNE) {
 8008120:	4806      	ldr	r0, [pc, #24]	; (800813c <GetKey+0x1c>)
	USART_SendData(EVAL_COM1, (uint16_t)ch);
#endif
}

uint8_t GetKey(void)
{
 8008122:	b508      	push	{r3, lr}
	uint8_t RetVal;

	RetVal = 0;
	if (EVAL_COM1->SR & USART_FLAG_RXNE) {
 8008124:	8803      	ldrh	r3, [r0, #0]
 8008126:	f003 0320 	and.w	r3, r3, #32
 800812a:	b29b      	uxth	r3, r3
 800812c:	b11b      	cbz	r3, 8008136 <GetKey+0x16>
		RetVal = 0xFF & USART_ReceiveData(EVAL_COM1);
 800812e:	f7fd fcef 	bl	8005b10 <USART_ReceiveData>
 8008132:	b2c0      	uxtb	r0, r0
 8008134:	bd08      	pop	{r3, pc}

uint8_t GetKey(void)
{
	uint8_t RetVal;

	RetVal = 0;
 8008136:	4618      	mov	r0, r3
	if (EVAL_COM1->SR & USART_FLAG_RXNE) {
		RetVal = 0xFF & USART_ReceiveData(EVAL_COM1);
	}

	return(RetVal);
}
 8008138:	bd08      	pop	{r3, pc}
 800813a:	bf00      	nop
 800813c:	40004400 	.word	0x40004400

08008140 <USART2_IRQHandler>:
  * @param  None
  * @retval None
  */

void USART2_IRQHandler(void)
{
 8008140:	b570      	push	{r4, r5, r6, lr}

  if(USART_GetITStatus(COM_USART[COM1], USART_IT_RXNE) != RESET)
 8008142:	4d0c      	ldr	r5, [pc, #48]	; (8008174 <USART2_IRQHandler+0x34>)
 8008144:	f240 5125 	movw	r1, #1317	; 0x525
 8008148:	68a8      	ldr	r0, [r5, #8]
 800814a:	f7fd fd5a 	bl	8005c02 <USART_GetITStatus>
 800814e:	b180      	cbz	r0, 8008172 <USART2_IRQHandler+0x32>
  {
    /* Read one byte from the receive data register */
    RxBuffer2[RxCounter2++] = USART_ReceiveData(COM_USART[COM1]);
 8008150:	4c09      	ldr	r4, [pc, #36]	; (8008178 <USART2_IRQHandler+0x38>)
 8008152:	68a8      	ldr	r0, [r5, #8]
 8008154:	78a6      	ldrb	r6, [r4, #2]
 8008156:	f7fd fcdb 	bl	8005b10 <USART_ReceiveData>
 800815a:	4b08      	ldr	r3, [pc, #32]	; (800817c <USART2_IRQHandler+0x3c>)
 800815c:	5598      	strb	r0, [r3, r6]
 800815e:	3601      	adds	r6, #1
    avai_of_rxbuf++;
 8008160:	7823      	ldrb	r3, [r4, #0]
{

  if(USART_GetITStatus(COM_USART[COM1], USART_IT_RXNE) != RESET)
  {
    /* Read one byte from the receive data register */
    RxBuffer2[RxCounter2++] = USART_ReceiveData(COM_USART[COM1]);
 8008162:	b2f6      	uxtb	r6, r6
    avai_of_rxbuf++;
 8008164:	3301      	adds	r3, #1
    if(RxCounter2 > NbrOfDataToRead2)
 8008166:	2e64      	cmp	r6, #100	; 0x64
{

  if(USART_GetITStatus(COM_USART[COM1], USART_IT_RXNE) != RESET)
  {
    /* Read one byte from the receive data register */
    RxBuffer2[RxCounter2++] = USART_ReceiveData(COM_USART[COM1]);
 8008168:	70a6      	strb	r6, [r4, #2]
    avai_of_rxbuf++;
 800816a:	7023      	strb	r3, [r4, #0]
    if(RxCounter2 > NbrOfDataToRead2)
 800816c:	d901      	bls.n	8008172 <USART2_IRQHandler+0x32>
    {
      /* Disable the USARTz Receive interrupt */
      //USART_ITConfig(COM_USART[COM1], USART_IT_RXNE, DISABLE);
    	RxCounter2 = 0;
 800816e:	2300      	movs	r3, #0
 8008170:	70a3      	strb	r3, [r4, #2]
 8008172:	bd70      	pop	{r4, r5, r6, pc}
 8008174:	20000098 	.word	0x20000098
 8008178:	20000b40 	.word	0x20000b40
 800817c:	20001c65 	.word	0x20001c65

08008180 <millis>:
static uint32_t s_tick_time = 0;

uint32_t millis(void)
{
	return s_tick_time;
}
 8008180:	4b01      	ldr	r3, [pc, #4]	; (8008188 <millis+0x8>)
 8008182:	6818      	ldr	r0, [r3, #0]
 8008184:	4770      	bx	lr
 8008186:	bf00      	nop
 8008188:	20000b44 	.word	0x20000b44

0800818c <delay_tick_calc>:

void delay_tick_calc(void)
{
	s_tick_time++;
 800818c:	4b02      	ldr	r3, [pc, #8]	; (8008198 <delay_tick_calc+0xc>)
 800818e:	681a      	ldr	r2, [r3, #0]
 8008190:	3201      	adds	r2, #1
 8008192:	601a      	str	r2, [r3, #0]
 8008194:	4770      	bx	lr
 8008196:	bf00      	nop
 8008198:	20000b44 	.word	0x20000b44

0800819c <delay_ms>:
*/

void delay_ms(uint32_t count)
{
	uint32_t end_time = millis() + count;	// + (count >> 1);
	while(end_time - millis());
 800819c:	b100      	cbz	r0, 80081a0 <delay_ms+0x4>
 800819e:	e7fe      	b.n	800819e <delay_ms+0x2>
 80081a0:	4770      	bx	lr

080081a2 <delay_us>:
}

__inline void delay_us(uint32_t count)
{
 80081a2:	4770      	bx	lr

080081a4 <STM_EVAL_LEDInit>:
  *     @arg LED3
  *     @arg LED4
  * @retval None
  */
void STM_EVAL_LEDInit(Led_TypeDef Led)
{
 80081a4:	b537      	push	{r0, r1, r2, r4, r5, lr}
  GPIO_InitTypeDef  GPIO_InitStructure;

  /* Enable the GPIO_LED Clock */
  RCC_APB2PeriphClockCmd(GPIO_CLK[Led], ENABLE);
 80081a6:	4d0c      	ldr	r5, [pc, #48]	; (80081d8 <STM_EVAL_LEDInit+0x34>)
  *     @arg LED3
  *     @arg LED4
  * @retval None
  */
void STM_EVAL_LEDInit(Led_TypeDef Led)
{
 80081a8:	4604      	mov	r4, r0
  GPIO_InitTypeDef  GPIO_InitStructure;

  /* Enable the GPIO_LED Clock */
  RCC_APB2PeriphClockCmd(GPIO_CLK[Led], ENABLE);
 80081aa:	2101      	movs	r1, #1
 80081ac:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
 80081b0:	eb05 0544 	add.w	r5, r5, r4, lsl #1
void STM_EVAL_LEDInit(Led_TypeDef Led)
{
  GPIO_InitTypeDef  GPIO_InitStructure;

  /* Enable the GPIO_LED Clock */
  RCC_APB2PeriphClockCmd(GPIO_CLK[Led], ENABLE);
 80081b4:	f7fc fa5c 	bl	8004670 <RCC_APB2PeriphClockCmd>

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
 80081b8:	89ab      	ldrh	r3, [r5, #12]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

  GPIO_Init(GPIO_PORT[Led], &GPIO_InitStructure);
 80081ba:	a901      	add	r1, sp, #4

  /* Enable the GPIO_LED Clock */
  RCC_APB2PeriphClockCmd(GPIO_CLK[Led], ENABLE);

  /* Configure the GPIO_LED pin */
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN[Led];
 80081bc:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80081c0:	2310      	movs	r3, #16
 80081c2:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80081c6:	2303      	movs	r3, #3
 80081c8:	f88d 3006 	strb.w	r3, [sp, #6]

  GPIO_Init(GPIO_PORT[Led], &GPIO_InitStructure);
 80081cc:	4b03      	ldr	r3, [pc, #12]	; (80081dc <STM_EVAL_LEDInit+0x38>)
 80081ce:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 80081d2:	f7fb fd78 	bl	8003cc6 <GPIO_Init>
}
 80081d6:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 80081d8:	0801e640 	.word	0x0801e640
 80081dc:	200000a4 	.word	0x200000a4

080081e0 <STM_EVAL_LEDOn>:
  *     @arg LED4
  * @retval None
  */
void STM_EVAL_LEDOn(Led_TypeDef Led)
{
  GPIO_PORT[Led]->BSRR = GPIO_PIN[Led];
 80081e0:	4a04      	ldr	r2, [pc, #16]	; (80081f4 <STM_EVAL_LEDOn+0x14>)
 80081e2:	4b05      	ldr	r3, [pc, #20]	; (80081f8 <STM_EVAL_LEDOn+0x18>)
 80081e4:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80081e8:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 80081ec:	8982      	ldrh	r2, [r0, #12]
 80081ee:	611a      	str	r2, [r3, #16]
 80081f0:	4770      	bx	lr
 80081f2:	bf00      	nop
 80081f4:	0801e640 	.word	0x0801e640
 80081f8:	200000a4 	.word	0x200000a4

080081fc <STM_EVAL_LEDOff>:
  *     @arg LED4
  * @retval None
  */
void STM_EVAL_LEDOff(Led_TypeDef Led)
{
  GPIO_PORT[Led]->BRR = GPIO_PIN[Led];
 80081fc:	4a04      	ldr	r2, [pc, #16]	; (8008210 <STM_EVAL_LEDOff+0x14>)
 80081fe:	4b05      	ldr	r3, [pc, #20]	; (8008214 <STM_EVAL_LEDOff+0x18>)
 8008200:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008204:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 8008208:	8982      	ldrh	r2, [r0, #12]
 800820a:	615a      	str	r2, [r3, #20]
 800820c:	4770      	bx	lr
 800820e:	bf00      	nop
 8008210:	0801e640 	.word	0x0801e640
 8008214:	200000a4 	.word	0x200000a4

08008218 <STM_EVAL_LEDToggle>:
  *     @arg LED4
  * @retval None
  */
void STM_EVAL_LEDToggle(Led_TypeDef Led)
{
  GPIO_PORT[Led]->ODR ^= GPIO_PIN[Led];
 8008218:	4b05      	ldr	r3, [pc, #20]	; (8008230 <STM_EVAL_LEDToggle+0x18>)
 800821a:	4906      	ldr	r1, [pc, #24]	; (8008234 <STM_EVAL_LEDToggle+0x1c>)
 800821c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008220:	eb01 0040 	add.w	r0, r1, r0, lsl #1
 8008224:	68da      	ldr	r2, [r3, #12]
 8008226:	8981      	ldrh	r1, [r0, #12]
 8008228:	404a      	eors	r2, r1
 800822a:	60da      	str	r2, [r3, #12]
 800822c:	4770      	bx	lr
 800822e:	bf00      	nop
 8008230:	200000a4 	.word	0x200000a4
 8008234:	0801e640 	.word	0x0801e640

08008238 <LEDOn>:
}

void LEDOn(Led_TypeDef Led)
{
	GPIO_SetBits(GPIO_PORT[Led], GPIO_PIN[Led]);
 8008238:	4b04      	ldr	r3, [pc, #16]	; (800824c <LEDOn+0x14>)
 800823a:	4a05      	ldr	r2, [pc, #20]	; (8008250 <LEDOn+0x18>)
 800823c:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 8008240:	8999      	ldrh	r1, [r3, #12]
 8008242:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
 8008246:	f7fb bdac 	b.w	8003da2 <GPIO_SetBits>
 800824a:	bf00      	nop
 800824c:	0801e640 	.word	0x0801e640
 8008250:	200000a4 	.word	0x200000a4

08008254 <LEDOff>:
}

void LEDOff(Led_TypeDef Led)
{
	GPIO_ResetBits(GPIO_PORT[Led], GPIO_PIN[Led]);
 8008254:	4b04      	ldr	r3, [pc, #16]	; (8008268 <LEDOff+0x14>)
 8008256:	4a05      	ldr	r2, [pc, #20]	; (800826c <LEDOff+0x18>)
 8008258:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 800825c:	8999      	ldrh	r1, [r3, #12]
 800825e:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
 8008262:	f7fb bda0 	b.w	8003da6 <GPIO_ResetBits>
 8008266:	bf00      	nop
 8008268:	0801e640 	.word	0x0801e640
 800826c:	200000a4 	.word	0x200000a4

08008270 <LEDToggle>:
}

void LEDToggle(Led_TypeDef Led)
{
	GPIO_PORT[Led]->ODR ^= GPIO_PIN[Led];
 8008270:	4b05      	ldr	r3, [pc, #20]	; (8008288 <LEDToggle+0x18>)
 8008272:	4906      	ldr	r1, [pc, #24]	; (800828c <LEDToggle+0x1c>)
 8008274:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8008278:	eb01 0040 	add.w	r0, r1, r0, lsl #1
 800827c:	68da      	ldr	r2, [r3, #12]
 800827e:	8981      	ldrh	r1, [r0, #12]
 8008280:	404a      	eors	r2, r1
 8008282:	60da      	str	r2, [r3, #12]
 8008284:	4770      	bx	lr
 8008286:	bf00      	nop
 8008288:	200000a4 	.word	0x200000a4
 800828c:	0801e640 	.word	0x0801e640

08008290 <Button_Init>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                     generation capability  
  * @retval None
  */
void Button_Init(ButtonMode_TypeDef Button_Mode)
{
 8008290:	b530      	push	{r4, r5, lr}
  GPIO_InitTypeDef GPIO_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;

  /* Enable the BUTTON Clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
 8008292:	2101      	movs	r1, #1
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                     generation capability  
  * @retval None
  */
void Button_Init(ButtonMode_TypeDef Button_Mode)
{
 8008294:	b085      	sub	sp, #20
 8008296:	4604      	mov	r4, r0
  GPIO_InitTypeDef GPIO_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;

  /* Enable the BUTTON Clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
 8008298:	2005      	movs	r0, #5
 800829a:	f7fc f9e9 	bl	8004670 <RCC_APB2PeriphClockCmd>

  /* Configure Button pin as input floating */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 800829e:	2304      	movs	r3, #4
 80082a0:	f88d 3003 	strb.w	r3, [sp, #3]
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
 80082a4:	a904      	add	r1, sp, #16
 80082a6:	2301      	movs	r3, #1
 80082a8:	f821 3d10 	strh.w	r3, [r1, #-16]!
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80082ac:	4813      	ldr	r0, [pc, #76]	; (80082fc <Button_Init+0x6c>)
 80082ae:	4669      	mov	r1, sp
  /* Enable the BUTTON Clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);

  /* Configure Button pin as input floating */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
 80082b0:	461d      	mov	r5, r3
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80082b2:	f7fb fd08 	bl	8003cc6 <GPIO_Init>


  if (Button_Mode == BUTTON_MODE_EXTI)
 80082b6:	2c01      	cmp	r4, #1
 80082b8:	d11d      	bne.n	80082f6 <Button_Init+0x66>
  {
    /* Connect Button EXTI Line to Button GPIO Pin */
    GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0);
 80082ba:	2000      	movs	r0, #0
 80082bc:	4601      	mov	r1, r0
 80082be:	f7fb fdc9 	bl	8003e54 <GPIO_EXTILineConfig>

    /* Configure Button EXTI line */
    EXTI_InitStructure.EXTI_Line = EXTI_Line0;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 80082c2:	2300      	movs	r3, #0
 80082c4:	f88d 300c 	strb.w	r3, [sp, #12]
//    {
//      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
//    }
//    else
//    {
      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  
 80082c8:	2308      	movs	r3, #8
//    }
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_Init(&EXTI_InitStructure);
 80082ca:	eb0d 0003 	add.w	r0, sp, r3
//    {
//      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
//    }
//    else
//    {
      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  
 80082ce:	f88d 300d 	strb.w	r3, [sp, #13]
  {
    /* Connect Button EXTI Line to Button GPIO Pin */
    GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0);

    /* Configure Button EXTI line */
    EXTI_InitStructure.EXTI_Line = EXTI_Line0;
 80082d2:	9402      	str	r4, [sp, #8]
//    }
//    else
//    {
      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  
//    }
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 80082d4:	f88d 500e 	strb.w	r5, [sp, #14]
    EXTI_Init(&EXTI_InitStructure);
 80082d8:	f7fb fc26 	bl	8003b28 <EXTI_Init>

    /* Enable and set Button EXTI Interrupt to the lowest priority */
    NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;
 80082dc:	2306      	movs	r3, #6
 80082de:	f88d 3004 	strb.w	r3, [sp, #4]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

    NVIC_Init(&NVIC_InitStructure); 
 80082e2:	a801      	add	r0, sp, #4
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_Init(&EXTI_InitStructure);

    /* Enable and set Button EXTI Interrupt to the lowest priority */
    NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
 80082e4:	230f      	movs	r3, #15
 80082e6:	f88d 3005 	strb.w	r3, [sp, #5]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
 80082ea:	f88d 3006 	strb.w	r3, [sp, #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80082ee:	f88d 4007 	strb.w	r4, [sp, #7]

    NVIC_Init(&NVIC_InitStructure); 
 80082f2:	f7fb fa7d 	bl	80037f0 <NVIC_Init>
  }
}
 80082f6:	b005      	add	sp, #20
 80082f8:	bd30      	pop	{r4, r5, pc}
 80082fa:	bf00      	nop
 80082fc:	40010800 	.word	0x40010800

08008300 <GPIO_Configuration>:
const uint32_t GPIO_CLK[LEDn] = {LED1_GPIO_CLK, LED2_GPIO_CLK, LED3_GPIO_CLK};

void Button_Init(ButtonMode_TypeDef Button_Mode);

void GPIO_Configuration(void)
{
 8008300:	b507      	push	{r0, r1, r2, lr}
	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
 8008302:	2010      	movs	r0, #16
 8008304:	2101      	movs	r1, #1
 8008306:	f7fc f9b3 	bl	8004670 <RCC_APB2PeriphClockCmd>
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8;
 800830a:	f240 13ff 	movw	r3, #511	; 0x1ff
 800830e:	f8ad 3004 	strh.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8008312:	2303      	movs	r3, #3
 8008314:	f88d 3006 	strb.w	r3, [sp, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8008318:	4805      	ldr	r0, [pc, #20]	; (8008330 <GPIO_Configuration+0x30>)

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 800831a:	2310      	movs	r3, #16
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 800831c:	a901      	add	r1, sp, #4

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 800831e:	f88d 3007 	strb.w	r3, [sp, #7]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8008322:	f7fb fcd0 	bl	8003cc6 <GPIO_Init>
	
	Button_Init(BUTTON_MODE_GPIO);
 8008326:	2000      	movs	r0, #0
 8008328:	f7ff ffb2 	bl	8008290 <Button_Init>

}
 800832c:	bd0e      	pop	{r1, r2, r3, pc}
 800832e:	bf00      	nop
 8008330:	40011000 	.word	0x40011000

08008334 <Button_GetState>:
  *     @arg BUTTON_DOWN: Joystick Down Push Button
  *     @arg BUTTON_SEL: Joystick Sel Push Button    
  * @retval The Button GPIO pin value.
  */
uint32_t Button_GetState(void)
{
 8008334:	b508      	push	{r3, lr}
  return GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0);
 8008336:	2101      	movs	r1, #1
 8008338:	4801      	ldr	r0, [pc, #4]	; (8008340 <Button_GetState+0xc>)
 800833a:	f7fb fd20 	bl	8003d7e <GPIO_ReadInputDataBit>
}
 800833e:	bd08      	pop	{r3, pc}
 8008340:	40010800 	.word	0x40010800

08008344 <isDST>:
*******************************************************************************/
static bool isDST( const RTC_t *t )
{
	uint8_t wday, month;		// locals for faster access

	month = t->month;
 8008344:	7883      	ldrb	r3, [r0, #2]

	if( month < 3 || month > 10 ) {		// month 1, 2, 11, 12
 8008346:	1eda      	subs	r2, r3, #3
 8008348:	2a07      	cmp	r2, #7
 800834a:	d80e      	bhi.n	800836a <isDST+0x26>
		return false;					// -> Winter
	}

	wday  = t->wday;
 800834c:	7902      	ldrb	r2, [r0, #4]

	if( t->mday - wday >= 25 && (wday || t->hour >= 2) ) { // after last Sunday 2:00
 800834e:	78c1      	ldrb	r1, [r0, #3]
 8008350:	1a89      	subs	r1, r1, r2
 8008352:	2918      	cmp	r1, #24
 8008354:	dd07      	ble.n	8008366 <isDST+0x22>
 8008356:	b912      	cbnz	r2, 800835e <isDST+0x1a>
 8008358:	7942      	ldrb	r2, [r0, #5]
 800835a:	2a01      	cmp	r2, #1
 800835c:	d903      	bls.n	8008366 <isDST+0x22>
		if( month == 10 ) {				// October -> Winter
 800835e:	2b0a      	cmp	r3, #10
 8008360:	d003      	beq.n	800836a <isDST+0x26>
		if( month == 3 ) {				// March -> Winter
			return false;
		}
	}

	return true;
 8008362:	2001      	movs	r0, #1
 8008364:	4770      	bx	lr
	if( t->mday - wday >= 25 && (wday || t->hour >= 2) ) { // after last Sunday 2:00
		if( month == 10 ) {				// October -> Winter
			return false;
		}
	} else {							// before last Sunday 2:00
		if( month == 3 ) {				// March -> Winter
 8008366:	2b03      	cmp	r3, #3
 8008368:	e7fa      	b.n	8008360 <isDST+0x1c>
	uint8_t wday, month;		// locals for faster access

	month = t->month;

	if( month < 3 || month > 10 ) {		// month 1, 2, 11, 12
		return false;					// -> Winter
 800836a:	2000      	movs	r0, #0
			return false;
		}
	}

	return true;
}
 800836c:	4770      	bx	lr

0800836e <counter_to_struct>:
	uint8_t year;
	uint16_t dayofyear;
	uint8_t leap400;
	uint8_t month;

	t->sec = sec % 60;
 800836e:	233c      	movs	r3, #60	; 0x3c
 8008370:	fbb0 f2f3 	udiv	r2, r0, r3
 8008374:	fb03 0012 	mls	r0, r3, r2, r0
 8008378:	71c8      	strb	r0, [r1, #7]
	sec /= 60;
	t->min = sec % 60;
 800837a:	fbb2 f0f3 	udiv	r0, r2, r3
 800837e:	fb03 2310 	mls	r3, r3, r0, r2
 8008382:	718b      	strb	r3, [r1, #6]
	sec /= 60;
	t->hour = sec % 24;
 8008384:	2318      	movs	r3, #24
 8008386:	fbb0 f2f3 	udiv	r2, r0, r3
 800838a:	fb03 0012 	mls	r0, r3, r2, r0
	day = (uint16_t)(sec / 24);
 800838e:	b293      	uxth	r3, r2

	t->sec = sec % 60;
	sec /= 60;
	t->min = sec % 60;
	sec /= 60;
	t->hour = sec % 24;
 8008390:	7148      	strb	r0, [r1, #5]
	day = (uint16_t)(sec / 24);

	t->wday = (day + FIRSTDAY) % 7;		// weekday
 8008392:	3206      	adds	r2, #6
 8008394:	2007      	movs	r0, #7
* Output         : time-struct gets populated, DST not taken into account here
* Return         : none
*  Based on code from Peter Dannegger found in the mikrocontroller.net forum.
*******************************************************************************/
static void counter_to_struct( uint32_t sec, RTC_t *t )
{
 8008396:	b530      	push	{r4, r5, lr}
	t->min = sec % 60;
	sec /= 60;
	t->hour = sec % 24;
	day = (uint16_t)(sec / 24);

	t->wday = (day + FIRSTDAY) % 7;		// weekday
 8008398:	fb92 f4f0 	sdiv	r4, r2, r0
 800839c:	fb00 2214 	mls	r2, r0, r4, r2

	year = FIRSTYEAR % 100;				// 0..99
	leap400 = 4 - ((FIRSTYEAR - 1) / 100 & 3);	// 4, 3, 2, 1

	for(;;) {
		dayofyear = 365;
 80083a0:	f240 156d 	movw	r5, #365	; 0x16d
	t->min = sec % 60;
	sec /= 60;
	t->hour = sec % 24;
	day = (uint16_t)(sec / 24);

	t->wday = (day + FIRSTDAY) % 7;		// weekday
 80083a4:	710a      	strb	r2, [r1, #4]

	year = FIRSTYEAR % 100;				// 0..99
	leap400 = 4 - ((FIRSTYEAR - 1) / 100 & 3);	// 4, 3, 2, 1
 80083a6:	2401      	movs	r4, #1
	t->hour = sec % 24;
	day = (uint16_t)(sec / 24);

	t->wday = (day + FIRSTDAY) % 7;		// weekday

	year = FIRSTYEAR % 100;				// 0..99
 80083a8:	2200      	movs	r2, #0
	leap400 = 4 - ((FIRSTYEAR - 1) / 100 & 3);	// 4, 3, 2, 1

	for(;;) {
		dayofyear = 365;
		if( (year & 3) == 0 ) {
 80083aa:	0790      	lsls	r0, r2, #30
 80083ac:	d10c      	bne.n	80083c8 <counter_to_struct+0x5a>
			dayofyear = 366;					// leap year
			if( year == 0 || year == 100 || year == 200 ) {	// 100 year exception
 80083ae:	b11a      	cbz	r2, 80083b8 <counter_to_struct+0x4a>
 80083b0:	2a64      	cmp	r2, #100	; 0x64
 80083b2:	d001      	beq.n	80083b8 <counter_to_struct+0x4a>
 80083b4:	2ac8      	cmp	r2, #200	; 0xc8
 80083b6:	d10a      	bne.n	80083ce <counter_to_struct+0x60>
				if( --leap400 ) {					// 400 year exception
 80083b8:	3c01      	subs	r4, #1
	leap400 = 4 - ((FIRSTYEAR - 1) / 100 & 3);	// 4, 3, 2, 1

	for(;;) {
		dayofyear = 365;
		if( (year & 3) == 0 ) {
			dayofyear = 366;					// leap year
 80083ba:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 80083be:	bf14      	ite	ne
 80083c0:	4628      	movne	r0, r5
 80083c2:	f44f 70b7 	moveq.w	r0, #366	; 0x16e
 80083c6:	e004      	b.n	80083d2 <counter_to_struct+0x64>

	year = FIRSTYEAR % 100;				// 0..99
	leap400 = 4 - ((FIRSTYEAR - 1) / 100 & 3);	// 4, 3, 2, 1

	for(;;) {
		dayofyear = 365;
 80083c8:	f240 106d 	movw	r0, #365	; 0x16d
 80083cc:	e001      	b.n	80083d2 <counter_to_struct+0x64>
		if( (year & 3) == 0 ) {
			dayofyear = 366;					// leap year
 80083ce:	f44f 70b7 	mov.w	r0, #366	; 0x16e
				if( --leap400 ) {					// 400 year exception
					dayofyear = 365;
				}
			}
		}
		if( day < dayofyear ) {
 80083d2:	4283      	cmp	r3, r0
 80083d4:	d304      	bcc.n	80083e0 <counter_to_struct+0x72>
			break;
		}
		day -= dayofyear;
 80083d6:	1a1b      	subs	r3, r3, r0
		year++;					// 00..136 / 99..235
 80083d8:	3201      	adds	r2, #1
			}
		}
		if( day < dayofyear ) {
			break;
		}
		day -= dayofyear;
 80083da:	b29b      	uxth	r3, r3
		year++;					// 00..136 / 99..235
 80083dc:	b2d2      	uxtb	r2, r2
	}
 80083de:	e7e4      	b.n	80083aa <counter_to_struct+0x3c>
	t->year = year + FIRSTYEAR / 100 * 100;	// + century
 80083e0:	f502 62fa 	add.w	r2, r2, #2000	; 0x7d0
 80083e4:	800a      	strh	r2, [r1, #0]

	if( dayofyear & 1 && day > 58 ) { 	// no leap year and after 28.2.
 80083e6:	07c2      	lsls	r2, r0, #31
 80083e8:	d503      	bpl.n	80083f2 <counter_to_struct+0x84>
 80083ea:	2b3a      	cmp	r3, #58	; 0x3a
 80083ec:	d901      	bls.n	80083f2 <counter_to_struct+0x84>
		day++;					// skip 29.2.
 80083ee:	3301      	adds	r3, #1
 80083f0:	b29b      	uxth	r3, r3
				if( --leap400 ) {					// 400 year exception
					dayofyear = 365;
				}
			}
		}
		if( day < dayofyear ) {
 80083f2:	2201      	movs	r2, #1

	if( dayofyear & 1 && day > 58 ) { 	// no leap year and after 28.2.
		day++;					// skip 29.2.
	}

	for( month = 1; day >= DaysInMonth[month-1]; month++ ) {
 80083f4:	4c07      	ldr	r4, [pc, #28]	; (8008414 <counter_to_struct+0xa6>)
 80083f6:	e003      	b.n	8008400 <counter_to_struct+0x92>
		day -= DaysInMonth[month-1];
 80083f8:	1a1b      	subs	r3, r3, r0

	if( dayofyear & 1 && day > 58 ) { 	// no leap year and after 28.2.
		day++;					// skip 29.2.
	}

	for( month = 1; day >= DaysInMonth[month-1]; month++ ) {
 80083fa:	3201      	adds	r2, #1
		day -= DaysInMonth[month-1];
 80083fc:	b29b      	uxth	r3, r3

	if( dayofyear & 1 && day > 58 ) { 	// no leap year and after 28.2.
		day++;					// skip 29.2.
	}

	for( month = 1; day >= DaysInMonth[month-1]; month++ ) {
 80083fe:	b2d2      	uxtb	r2, r2
 8008400:	18a0      	adds	r0, r4, r2
 8008402:	f810 0c01 	ldrb.w	r0, [r0, #-1]
 8008406:	4283      	cmp	r3, r0
 8008408:	d2f6      	bcs.n	80083f8 <counter_to_struct+0x8a>
		day -= DaysInMonth[month-1];
	}

	t->month = month;				// 1..12
	t->mday = day + 1;				// 1..31
 800840a:	3301      	adds	r3, #1

	for( month = 1; day >= DaysInMonth[month-1]; month++ ) {
		day -= DaysInMonth[month-1];
	}

	t->month = month;				// 1..12
 800840c:	708a      	strb	r2, [r1, #2]
	t->mday = day + 1;				// 1..31
 800840e:	70cb      	strb	r3, [r1, #3]
 8008410:	bd30      	pop	{r4, r5, pc}
 8008412:	bf00      	nop
 8008414:	0801e654 	.word	0x0801e654

08008418 <rtc_gettime>:
* Input          : None
* Output         : time-struct gets modified
* Return         : always true/not used
*******************************************************************************/
bool rtc_gettime (RTC_t *rtc)
{
 8008418:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800841c:	4604      	mov	r4, r0
	uint32_t t;

	while ( ( t = RTC_GetCounter() ) != RTC_GetCounter() ) { ; }
 800841e:	f7fc f9d7 	bl	80047d0 <RTC_GetCounter>
 8008422:	4605      	mov	r5, r0
 8008424:	f7fc f9d4 	bl	80047d0 <RTC_GetCounter>
 8008428:	4285      	cmp	r5, r0
 800842a:	d1f8      	bne.n	800841e <rtc_gettime+0x6>
	counter_to_struct( t, rtc ); // get non DST time
 800842c:	4621      	mov	r1, r4
 800842e:	f7ff ff9e 	bl	800836e <counter_to_struct>
	hour  = t->hour;
	day   = t->mday;
	wday  = t->wday;
	month = t->month;

	if ( isDST(t) ) {
 8008432:	4620      	mov	r0, r4
*******************************************************************************/
static bool adjustDST( RTC_t *t )
{
	uint8_t hour, day, wday, month;			// locals for faster access

	hour  = t->hour;
 8008434:	f894 8005 	ldrb.w	r8, [r4, #5]
	day   = t->mday;
 8008438:	78e6      	ldrb	r6, [r4, #3]
	wday  = t->wday;
 800843a:	7925      	ldrb	r5, [r4, #4]
	month = t->month;
 800843c:	78a7      	ldrb	r7, [r4, #2]

	if ( isDST(t) ) {
 800843e:	f7ff ff81 	bl	8008344 <isDST>
 8008442:	b1d8      	cbz	r0, 800847c <rtc_gettime+0x64>
		t->dst = 1;
 8008444:	2301      	movs	r3, #1
 8008446:	7223      	strb	r3, [r4, #8]
		hour++;								// add one hour
 8008448:	4443      	add	r3, r8
 800844a:	b2db      	uxtb	r3, r3
		if( hour == 24 ){					// next day
 800844c:	2b18      	cmp	r3, #24
 800844e:	d110      	bne.n	8008472 <rtc_gettime+0x5a>
			hour = 0;
			wday++;							// next weekday
			if( wday == 7 ) {
				wday = 0;
			}
			if( day == DaysInMonth[month-1] ) {		// next month
 8008450:	4b0c      	ldr	r3, [pc, #48]	; (8008484 <rtc_gettime+0x6c>)
	if ( isDST(t) ) {
		t->dst = 1;
		hour++;								// add one hour
		if( hour == 24 ){					// next day
			hour = 0;
			wday++;							// next weekday
 8008452:	3501      	adds	r5, #1
			if( wday == 7 ) {
				wday = 0;
			}
			if( day == DaysInMonth[month-1] ) {		// next month
 8008454:	19db      	adds	r3, r3, r7
 8008456:	f813 3c01 	ldrb.w	r3, [r3, #-1]
	if ( isDST(t) ) {
		t->dst = 1;
		hour++;								// add one hour
		if( hour == 24 ){					// next day
			hour = 0;
			wday++;							// next weekday
 800845a:	b2ed      	uxtb	r5, r5
			if( wday == 7 ) {
				wday = 0;
 800845c:	2d07      	cmp	r5, #7
 800845e:	bf08      	it	eq
 8008460:	2500      	moveq	r5, #0
			}
			if( day == DaysInMonth[month-1] ) {		// next month
 8008462:	42b3      	cmp	r3, r6
 8008464:	d102      	bne.n	800846c <rtc_gettime+0x54>
				day = 0;
				month++;
 8008466:	3701      	adds	r7, #1
 8008468:	b2ff      	uxtb	r7, r7
			wday++;							// next weekday
			if( wday == 7 ) {
				wday = 0;
			}
			if( day == DaysInMonth[month-1] ) {		// next month
				day = 0;
 800846a:	2600      	movs	r6, #0
				month++;
			}
			day++;
 800846c:	3601      	adds	r6, #1
 800846e:	b2f6      	uxtb	r6, r6

	if ( isDST(t) ) {
		t->dst = 1;
		hour++;								// add one hour
		if( hour == 24 ){					// next day
			hour = 0;
 8008470:	2300      	movs	r3, #0
				day = 0;
				month++;
			}
			day++;
		}
		t->month = month;
 8008472:	70a7      	strb	r7, [r4, #2]
		t->hour  = hour;
 8008474:	7163      	strb	r3, [r4, #5]
		t->mday  = day;
 8008476:	70e6      	strb	r6, [r4, #3]
		t->wday  = wday;
 8008478:	7125      	strb	r5, [r4, #4]
 800847a:	e000      	b.n	800847e <rtc_gettime+0x66>
		return true;
	} else {
		t->dst = 0;
 800847c:	7220      	strb	r0, [r4, #8]
	while ( ( t = RTC_GetCounter() ) != RTC_GetCounter() ) { ; }
	counter_to_struct( t, rtc ); // get non DST time
	adjustDST( rtc );

	return true;
}
 800847e:	2001      	movs	r0, #1
 8008480:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008484:	0801e654 	.word	0x0801e654

08008488 <rtc_settime>:
* Input          : None
* Output         : None
* Return         : not used
*******************************************************************************/
bool rtc_settime (const RTC_t *rtc)
{
 8008488:	b5f0      	push	{r4, r5, r6, r7, lr}
{
	uint8_t i;
	uint32_t result = 0;
	uint16_t idx, year;

	year = t->year;
 800848a:	8803      	ldrh	r3, [r0, #0]

	/* Calculate days of years before */
	result = (uint32_t)year * 365;
 800848c:	f240 126d 	movw	r2, #365	; 0x16d
* Input          : None
* Output         : None
* Return         : not used
*******************************************************************************/
bool rtc_settime (const RTC_t *rtc)
{
 8008490:	b085      	sub	sp, #20
	uint16_t idx, year;

	year = t->year;

	/* Calculate days of years before */
	result = (uint32_t)year * 365;
 8008492:	435a      	muls	r2, r3
	if (t->year >= 1) {
 8008494:	b17b      	cbz	r3, 80084b6 <rtc_settime+0x2e>
		result += (year + 3) / 4;
 8008496:	1cdd      	adds	r5, r3, #3
 8008498:	2404      	movs	r4, #4
		result -= (year - 1) / 100;
 800849a:	1e59      	subs	r1, r3, #1
	year = t->year;

	/* Calculate days of years before */
	result = (uint32_t)year * 365;
	if (t->year >= 1) {
		result += (year + 3) / 4;
 800849c:	fb95 f4f4 	sdiv	r4, r5, r4
		result -= (year - 1) / 100;
 80084a0:	f06f 0563 	mvn.w	r5, #99	; 0x63
 80084a4:	fb91 f5f5 	sdiv	r5, r1, r5
	year = t->year;

	/* Calculate days of years before */
	result = (uint32_t)year * 365;
	if (t->year >= 1) {
		result += (year + 3) / 4;
 80084a8:	1964      	adds	r4, r4, r5
		result -= (year - 1) / 100;
 80084aa:	18a2      	adds	r2, r4, r2
		result += (year - 1) / 400;
 80084ac:	f44f 74c8 	mov.w	r4, #400	; 0x190
 80084b0:	fb91 f1f4 	sdiv	r1, r1, r4
 80084b4:	1852      	adds	r2, r2, r1

	/* Start with 2000 a.d. */
	result -= 730485UL;

	/* Make month an array index */
	idx = t->month - 1;
 80084b6:	7884      	ldrb	r4, [r0, #2]
		result -= (year - 1) / 100;
		result += (year - 1) / 400;
	}

	/* Start with 2000 a.d. */
	result -= 730485UL;
 80084b8:	f5a2 2232 	sub.w	r2, r2, #729088	; 0xb2000

	/* Make month an array index */
	idx = t->month - 1;
 80084bc:	1e65      	subs	r5, r4, #1
		result -= (year - 1) / 100;
		result += (year - 1) / 400;
	}

	/* Start with 2000 a.d. */
	result -= 730485UL;
 80084be:	f2a2 5275 	subw	r2, r2, #1397	; 0x575

	/* Make month an array index */
	idx = t->month - 1;
 80084c2:	b2ad      	uxth	r5, r5

	/* Loop thru each month, adding the days */
	for (i = 0; i < idx; i++) {
 80084c4:	2100      	movs	r1, #0
		result += DaysInMonth[i];
 80084c6:	4e24      	ldr	r6, [pc, #144]	; (8008558 <rtc_settime+0xd0>)
 80084c8:	e003      	b.n	80084d2 <rtc_settime+0x4a>
 80084ca:	5c77      	ldrb	r7, [r6, r1]

	/* Make month an array index */
	idx = t->month - 1;

	/* Loop thru each month, adding the days */
	for (i = 0; i < idx; i++) {
 80084cc:	3101      	adds	r1, #1
		result += DaysInMonth[i];
 80084ce:	19d2      	adds	r2, r2, r7

	/* Make month an array index */
	idx = t->month - 1;

	/* Loop thru each month, adding the days */
	for (i = 0; i < idx; i++) {
 80084d0:	b2c9      	uxtb	r1, r1
 80084d2:	42a9      	cmp	r1, r5
 80084d4:	d3f9      	bcc.n	80084ca <rtc_settime+0x42>
		result += DaysInMonth[i];
	}

	/* Leap year? adjust February */
	if (year%400 == 0 || (year%4 == 0 && year%100 !=0)) {
 80084d6:	f44f 71c8 	mov.w	r1, #400	; 0x190
 80084da:	fbb3 f5f1 	udiv	r5, r3, r1
 80084de:	fb01 3115 	mls	r1, r1, r5, r3
 80084e2:	b289      	uxth	r1, r1
 80084e4:	b159      	cbz	r1, 80084fe <rtc_settime+0x76>
 80084e6:	079d      	lsls	r5, r3, #30
 80084e8:	d106      	bne.n	80084f8 <rtc_settime+0x70>
 80084ea:	2164      	movs	r1, #100	; 0x64
 80084ec:	fbb3 f5f1 	udiv	r5, r3, r1
 80084f0:	fb01 3315 	mls	r3, r1, r5, r3
 80084f4:	b29b      	uxth	r3, r3
 80084f6:	b913      	cbnz	r3, 80084fe <rtc_settime+0x76>
		;
	} else {
		if (t->month > 1) {
 80084f8:	2c01      	cmp	r4, #1
			result--;
 80084fa:	bf88      	it	hi
 80084fc:	3a01      	subhi	r2, #1
	/* Add remaining days */
	result += t->mday;

	/* Convert to seconds, add all the other stuff */
	result = (result-1) * 86400L + (uint32_t)t->hour * 3600 +
		(uint32_t)t->min * 60 + t->sec;
 80084fe:	79c5      	ldrb	r5, [r0, #7]

	/* Add remaining days */
	result += t->mday;

	/* Convert to seconds, add all the other stuff */
	result = (result-1) * 86400L + (uint32_t)t->hour * 3600 +
 8008500:	7943      	ldrb	r3, [r0, #5]
 8008502:	f5a5 35a8 	sub.w	r5, r5, #86016	; 0x15000
 8008506:	f5a5 75c0 	sub.w	r5, r5, #384	; 0x180
 800850a:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 800850e:	fb01 5103 	mla	r1, r1, r3, r5
		(uint32_t)t->min * 60 + t->sec;
 8008512:	7983      	ldrb	r3, [r0, #6]
 8008514:	243c      	movs	r4, #60	; 0x3c
 8008516:	fb04 1303 	mla	r3, r4, r3, r1
			result--;
		}
	}

	/* Add remaining days */
	result += t->mday;
 800851a:	78c4      	ldrb	r4, [r0, #3]
{
	uint32_t cnt;
	RTC_t ts;

	cnt = struct_to_counter( rtc ); // non-DST counter-value
	counter_to_struct( cnt, &ts );  // normalize struct (for weekday)
 800851c:	a901      	add	r1, sp, #4
			result--;
		}
	}

	/* Add remaining days */
	result += t->mday;
 800851e:	1912      	adds	r2, r2, r4

	/* Convert to seconds, add all the other stuff */
	result = (result-1) * 86400L + (uint32_t)t->hour * 3600 +
 8008520:	4c0e      	ldr	r4, [pc, #56]	; (800855c <rtc_settime+0xd4>)
 8008522:	fb04 3402 	mla	r4, r4, r2, r3
{
	uint32_t cnt;
	RTC_t ts;

	cnt = struct_to_counter( rtc ); // non-DST counter-value
	counter_to_struct( cnt, &ts );  // normalize struct (for weekday)
 8008526:	4620      	mov	r0, r4
 8008528:	f7ff ff21 	bl	800836e <counter_to_struct>
	if ( isDST( &ts ) ) {
 800852c:	a801      	add	r0, sp, #4
 800852e:	f7ff ff09 	bl	8008344 <isDST>
 8008532:	b108      	cbz	r0, 8008538 <rtc_settime+0xb0>
		cnt -= 60*60; // Subtract one hour
 8008534:	f5a4 6461 	sub.w	r4, r4, #3600	; 0xe10
	}
	PWR_BackupAccessCmd(ENABLE);
 8008538:	2001      	movs	r0, #1
 800853a:	f7fb febc 	bl	80042b6 <PWR_BackupAccessCmd>
* Return         : None
*******************************************************************************/
static void my_RTC_SetCounter(uint32_t cnt)
{
	/* Wait until last write operation on RTC registers has finished */
	RTC_WaitForLastTask();
 800853e:	f7fc f997 	bl	8004870 <RTC_WaitForLastTask>
	/* Change the current time */
	RTC_SetCounter(cnt);
 8008542:	4620      	mov	r0, r4
 8008544:	f7fc f958 	bl	80047f8 <RTC_SetCounter>
	/* Wait until last write operation on RTC registers has finished */
	RTC_WaitForLastTask();
 8008548:	f7fc f992 	bl	8004870 <RTC_WaitForLastTask>
	if ( isDST( &ts ) ) {
		cnt -= 60*60; // Subtract one hour
	}
	PWR_BackupAccessCmd(ENABLE);
	my_RTC_SetCounter( cnt );
	PWR_BackupAccessCmd(DISABLE);
 800854c:	2000      	movs	r0, #0
 800854e:	f7fb feb2 	bl	80042b6 <PWR_BackupAccessCmd>

	return true;
}
 8008552:	2001      	movs	r0, #1
 8008554:	b005      	add	sp, #20
 8008556:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008558:	0801e654 	.word	0x0801e654
 800855c:	00015180 	.word	0x00015180

08008560 <rtc_init>:
* Output         : None
* Return         : not used
*  Based on code from a STM RTC example in the StdPeriph-Library package
*******************************************************************************/
int rtc_init(void)
{
 8008560:	b507      	push	{r0, r1, r2, lr}
	volatile uint16_t i;

	/* Enable PWR and BKP clocks */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
 8008562:	f04f 50c0 	mov.w	r0, #402653184	; 0x18000000
 8008566:	2101      	movs	r1, #1
 8008568:	f7fc f88e 	bl	8004688 <RCC_APB1PeriphClockCmd>

	/* LSI clock stabilization time */
	for(i=0;i<5000;i++) { ; }
 800856c:	2300      	movs	r3, #0
 800856e:	f8ad 3006 	strh.w	r3, [sp, #6]
 8008572:	f241 3387 	movw	r3, #4999	; 0x1387
 8008576:	e005      	b.n	8008584 <rtc_init+0x24>
 8008578:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 800857c:	3201      	adds	r2, #1
 800857e:	b292      	uxth	r2, r2
 8008580:	f8ad 2006 	strh.w	r2, [sp, #6]
 8008584:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8008588:	b292      	uxth	r2, r2
 800858a:	429a      	cmp	r2, r3
 800858c:	d9f4      	bls.n	8008578 <rtc_init+0x18>

	//if (BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5) {
	if(BKP->DR1 != 0xA5A5) {
 800858e:	4b1a      	ldr	r3, [pc, #104]	; (80085f8 <rtc_init+0x98>)
 8008590:	889a      	ldrh	r2, [r3, #4]
 8008592:	f24a 53a5 	movw	r3, #42405	; 0xa5a5
 8008596:	b292      	uxth	r2, r2
 8008598:	429a      	cmp	r2, r3
 800859a:	d029      	beq.n	80085f0 <rtc_init+0x90>
		/* Backup data register value is not correct or not yet programmed (when
		   the first time the program is executed) */

		/* Allow access to BKP Domain */
		PWR_BackupAccessCmd(ENABLE);
 800859c:	2001      	movs	r0, #1
 800859e:	f7fb fe8a 	bl	80042b6 <PWR_BackupAccessCmd>

		/* Reset Backup Domain */
		//BKP_DeInit();		//todo : not found

		/* Enable LSE */
		RCC_LSEConfig(RCC_LSE_ON);
 80085a2:	2001      	movs	r0, #1
 80085a4:	f7fb ffd2 	bl	800454c <RCC_LSEConfig>

		/* Wait till LSE is ready */
		while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET) { ; }
 80085a8:	2041      	movs	r0, #65	; 0x41
 80085aa:	f7fc f8af 	bl	800470c <RCC_GetFlagStatus>
 80085ae:	2800      	cmp	r0, #0
 80085b0:	d0fa      	beq.n	80085a8 <rtc_init+0x48>

		/* Select LSE as RTC Clock Source */
		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
 80085b2:	f44f 7080 	mov.w	r0, #256	; 0x100
 80085b6:	f7fb ffdf 	bl	8004578 <RCC_RTCCLKConfig>

		/* Enable RTC Clock */
		RCC_RTCCLKCmd(ENABLE);
 80085ba:	2001      	movs	r0, #1
 80085bc:	f7fb ffe4 	bl	8004588 <RCC_RTCCLKCmd>

		/* Wait for RTC registers synchronization */
		RTC_WaitForSynchro();
 80085c0:	f7fc f960 	bl	8004884 <RTC_WaitForSynchro>

		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
 80085c4:	f7fc f954 	bl	8004870 <RTC_WaitForLastTask>

		/* Set RTC prescaler: set RTC period to 1sec */
		RTC_SetPrescaler(32767); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */
 80085c8:	f647 70ff 	movw	r0, #32767	; 0x7fff
 80085cc:	f7fc f924 	bl	8004818 <RTC_SetPrescaler>

		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
 80085d0:	f7fc f94e 	bl	8004870 <RTC_WaitForLastTask>

		/* Set initial value */
		RTC_SetCounter( (uint32_t)((11*60+55)*60) ); // here: 1st January 2000 11:55:00
 80085d4:	f24a 7094 	movw	r0, #42900	; 0xa794
 80085d8:	f7fc f90e 	bl	80047f8 <RTC_SetCounter>

		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
 80085dc:	f7fc f948 	bl	8004870 <RTC_WaitForLastTask>

		//BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);
		BKP->DR1 = 0xA5A5;
 80085e0:	4b05      	ldr	r3, [pc, #20]	; (80085f8 <rtc_init+0x98>)
 80085e2:	f24a 52a5 	movw	r2, #42405	; 0xa5a5
 80085e6:	809a      	strh	r2, [r3, #4]

		/* Lock access to BKP Domain */
		PWR_BackupAccessCmd(DISABLE);
 80085e8:	2000      	movs	r0, #0
 80085ea:	f7fb fe64 	bl	80042b6 <PWR_BackupAccessCmd>
 80085ee:	e001      	b.n	80085f4 <rtc_init+0x94>

	} else {

		/* Wait for RTC registers synchronization */
		RTC_WaitForSynchro();
 80085f0:	f7fc f948 	bl	8004884 <RTC_WaitForSynchro>

	}

	return 0;
}
 80085f4:	2000      	movs	r0, #0
 80085f6:	bd0e      	pop	{r1, r2, r3, pc}
 80085f8:	40006c00 	.word	0x40006c00

080085fc <SWO_PrintChar>:
*/
void SWO_PrintChar(char c) {
  //
  // Check if ITM_TCR.ITMENA is set
  //
  if ((ITM_TCR & 1) == 0) {
 80085fc:	4b08      	ldr	r3, [pc, #32]	; (8008620 <SWO_PrintChar+0x24>)
 80085fe:	681b      	ldr	r3, [r3, #0]
 8008600:	07d9      	lsls	r1, r3, #31
 8008602:	d50b      	bpl.n	800861c <SWO_PrintChar+0x20>
    return;
  }
  //
  // Check if stimulus port is enabled
  //
  if ((ITM_ENA & 1) == 0) {
 8008604:	4b07      	ldr	r3, [pc, #28]	; (8008624 <SWO_PrintChar+0x28>)
 8008606:	681b      	ldr	r3, [r3, #0]
 8008608:	07da      	lsls	r2, r3, #31
 800860a:	d507      	bpl.n	800861c <SWO_PrintChar+0x20>
  }
  //
  // Wait until STIMx is ready,
  // then send data
  //
  while ((ITM_STIM_U8 & 1) == 0);
 800860c:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 8008610:	7813      	ldrb	r3, [r2, #0]
 8008612:	07db      	lsls	r3, r3, #31
 8008614:	d5fc      	bpl.n	8008610 <SWO_PrintChar+0x14>
  ITM_STIM_U8 = c;
 8008616:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
 800861a:	7018      	strb	r0, [r3, #0]
 800861c:	4770      	bx	lr
 800861e:	bf00      	nop
 8008620:	e0000e80 	.word	0xe0000e80
 8008624:	e0000e00 	.word	0xe0000e00

08008628 <SWO_PrintString>:
*
* Function description
*   Print a string via SWO.
*
*/
void SWO_PrintString(const char *s) {
 8008628:	b510      	push	{r4, lr}
 800862a:	1e44      	subs	r4, r0, #1
  //
  // Print out character per character
  //
  while (*s) {
 800862c:	e001      	b.n	8008632 <SWO_PrintString+0xa>
    SWO_PrintChar(*s++);
 800862e:	f7ff ffe5 	bl	80085fc <SWO_PrintChar>
*/
void SWO_PrintString(const char *s) {
  //
  // Print out character per character
  //
  while (*s) {
 8008632:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 8008636:	2800      	cmp	r0, #0
 8008638:	d1f9      	bne.n	800862e <SWO_PrintString+0x6>
    SWO_PrintChar(*s++);
  }
}
 800863a:	bd10      	pop	{r4, pc}

0800863c <__aeabi_memclr>:
#endif


/* Clear memory.  */
void __aeabi_memclr (void *dest, size_t n)
{
 800863c:	460a      	mov	r2, r1
    memset (dest, 0, n);
 800863e:	2100      	movs	r1, #0
 8008640:	f009 bc88 	b.w	8011f54 <memset>

08008644 <_sbrk>:
{
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end,*min_stack_ptr;

	if (heap_end == 0)
 8008644:	4b0b      	ldr	r3, [pc, #44]	; (8008674 <_sbrk+0x30>)
 8008646:	681a      	ldr	r2, [r3, #0]
 8008648:	b90a      	cbnz	r2, 800864e <_sbrk+0xa>
		heap_end = &end;
 800864a:	4a0b      	ldr	r2, [pc, #44]	; (8008678 <_sbrk+0x34>)
 800864c:	601a      	str	r2, [r3, #0]

	prev_heap_end = heap_end;

#ifdef FreeRTOS
	/* Use the NVIC offset register to locate the main stack pointer. */
	min_stack_ptr = (char*)(*(unsigned int *)*(unsigned int *)0xE000ED08);
 800864e:	4a0b      	ldr	r2, [pc, #44]	; (800867c <_sbrk+0x38>)
	char *prev_heap_end,*min_stack_ptr;

	if (heap_end == 0)
		heap_end = &end;

	prev_heap_end = heap_end;
 8008650:	681b      	ldr	r3, [r3, #0]

#ifdef FreeRTOS
	/* Use the NVIC offset register to locate the main stack pointer. */
	min_stack_ptr = (char*)(*(unsigned int *)*(unsigned int *)0xE000ED08);
 8008652:	6812      	ldr	r2, [r2, #0]
	/* Locate the STACK bottom address */
	min_stack_ptr -= MAX_STACK_SIZE;

	if (heap_end + incr > min_stack_ptr)
 8008654:	1818      	adds	r0, r3, r0

	prev_heap_end = heap_end;

#ifdef FreeRTOS
	/* Use the NVIC offset register to locate the main stack pointer. */
	min_stack_ptr = (char*)(*(unsigned int *)*(unsigned int *)0xE000ED08);
 8008656:	6812      	ldr	r2, [r2, #0]
	/* Locate the STACK bottom address */
	min_stack_ptr -= MAX_STACK_SIZE;
 8008658:	f5a2 7200 	sub.w	r2, r2, #512	; 0x200

	if (heap_end + incr > min_stack_ptr)
 800865c:	4290      	cmp	r0, r2
 800865e:	d905      	bls.n	800866c <_sbrk+0x28>
	if (heap_end + incr > stack_ptr)
#endif
	{
//		write(1, "Heap and stack collision\n", 25);
//		abort();
		errno = ENOMEM;
 8008660:	4b07      	ldr	r3, [pc, #28]	; (8008680 <_sbrk+0x3c>)
 8008662:	220c      	movs	r2, #12
 8008664:	601a      	str	r2, [r3, #0]
		return (caddr_t) -1;
 8008666:	f04f 33ff 	mov.w	r3, #4294967295
 800866a:	e001      	b.n	8008670 <_sbrk+0x2c>
	}

	heap_end += incr;
 800866c:	4a01      	ldr	r2, [pc, #4]	; (8008674 <_sbrk+0x30>)
 800866e:	6010      	str	r0, [r2, #0]

	return (caddr_t) prev_heap_end;
}
 8008670:	4618      	mov	r0, r3
 8008672:	4770      	bx	lr
 8008674:	20000b48 	.word	0x20000b48
 8008678:	2000361c 	.word	0x2000361c
 800867c:	e000ed08 	.word	0xe000ed08
 8008680:	20003618 	.word	0x20003618

08008684 <_gettimeofday>:
 * _gettimeofday primitive (Stub function)
 * */
int _gettimeofday (struct timeval * tp, struct timezone * tzp)
{
  /* Return fixed data for the timezone.  */
  if (tzp)
 8008684:	b111      	cbz	r1, 800868c <_gettimeofday+0x8>
    {
      tzp->tz_minuteswest = 0;
 8008686:	2300      	movs	r3, #0
 8008688:	600b      	str	r3, [r1, #0]
      tzp->tz_dsttime = 0;
 800868a:	604b      	str	r3, [r1, #4]
    }

  return 0;
}
 800868c:	2000      	movs	r0, #0
 800868e:	4770      	bx	lr

08008690 <initialise_monitor_handles>:
void initialise_monitor_handles()
{
 8008690:	4770      	bx	lr

08008692 <_getpid>:
}

int _getpid(void)
{
	return 1;
}
 8008692:	2001      	movs	r0, #1
 8008694:	4770      	bx	lr

08008696 <_kill>:

int _kill(int pid, int sig)
{
	errno = EINVAL;
 8008696:	4b03      	ldr	r3, [pc, #12]	; (80086a4 <_kill+0xe>)
 8008698:	2216      	movs	r2, #22
 800869a:	601a      	str	r2, [r3, #0]
	return -1;
}
 800869c:	f04f 30ff 	mov.w	r0, #4294967295
 80086a0:	4770      	bx	lr
 80086a2:	bf00      	nop
 80086a4:	20003618 	.word	0x20003618

080086a8 <_exit>:
	return 1;
}

int _kill(int pid, int sig)
{
	errno = EINVAL;
 80086a8:	4b01      	ldr	r3, [pc, #4]	; (80086b0 <_exit+0x8>)
 80086aa:	2216      	movs	r2, #22
 80086ac:	601a      	str	r2, [r3, #0]
 80086ae:	e7fe      	b.n	80086ae <_exit+0x6>
 80086b0:	20003618 	.word	0x20003618

080086b4 <_write>:
	_kill(status, -1);
	while (1) {}
}

int _write(int file, char *ptr, int len)
{
 80086b4:	b570      	push	{r4, r5, r6, lr}
 80086b6:	460e      	mov	r6, r1
 80086b8:	4615      	mov	r5, r2
	int i;
	char ch;

	for (i=0; i<len; i++)
 80086ba:	2400      	movs	r4, #0
 80086bc:	e003      	b.n	80086c6 <_write+0x12>
	{
		ch = *(ptr++);
		__uart_putchar(ch);
 80086be:	5d30      	ldrb	r0, [r6, r4]
 80086c0:	f7ff fd1e 	bl	8008100 <__uart_putchar>
int _write(int file, char *ptr, int len)
{
	int i;
	char ch;

	for (i=0; i<len; i++)
 80086c4:	3401      	adds	r4, #1
 80086c6:	42ac      	cmp	r4, r5
 80086c8:	dbf9      	blt.n	80086be <_write+0xa>
		__uart_putchar(ch);
		//SWO_PrintChar(ch);

	}
	return len;
}
 80086ca:	4628      	mov	r0, r5
 80086cc:	bd70      	pop	{r4, r5, r6, pc}

080086ce <_close>:

int _close(int file)
{
	return -1;
}
 80086ce:	f04f 30ff 	mov.w	r0, #4294967295
 80086d2:	4770      	bx	lr

080086d4 <_fstat>:

int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 80086d4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80086d8:	604b      	str	r3, [r1, #4]
	return 0;
}
 80086da:	2000      	movs	r0, #0
 80086dc:	4770      	bx	lr

080086de <_isatty>:

int _isatty(int file)
{
	return 1;
}
 80086de:	2001      	movs	r0, #1
 80086e0:	4770      	bx	lr

080086e2 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 80086e2:	2000      	movs	r0, #0
 80086e4:	4770      	bx	lr

080086e6 <_read>:

int _read(int file, char *ptr, int len)
{
	return 0;
}
 80086e6:	2000      	movs	r0, #0
 80086e8:	4770      	bx	lr

080086ea <_open>:

int _open(char *path, int flags, ...)
{
 80086ea:	b40e      	push	{r1, r2, r3}
	/* Pretend like we always fail */
	return -1;
}
 80086ec:	f04f 30ff 	mov.w	r0, #4294967295
 80086f0:	b003      	add	sp, #12
 80086f2:	4770      	bx	lr

080086f4 <_wait>:

int _wait(int *status)
{
	errno = ECHILD;
 80086f4:	4b02      	ldr	r3, [pc, #8]	; (8008700 <_wait+0xc>)
 80086f6:	220a      	movs	r2, #10
 80086f8:	601a      	str	r2, [r3, #0]
	return -1;
}
 80086fa:	f04f 30ff 	mov.w	r0, #4294967295
 80086fe:	4770      	bx	lr
 8008700:	20003618 	.word	0x20003618

08008704 <_unlink>:

int _unlink(char *name)
{
	errno = ENOENT;
 8008704:	4b02      	ldr	r3, [pc, #8]	; (8008710 <_unlink+0xc>)
 8008706:	2202      	movs	r2, #2
 8008708:	601a      	str	r2, [r3, #0]
	return -1;
}
 800870a:	f04f 30ff 	mov.w	r0, #4294967295
 800870e:	4770      	bx	lr
 8008710:	20003618 	.word	0x20003618

08008714 <_times>:

int _times(struct tms *buf)
{
	return -1;
}
 8008714:	f04f 30ff 	mov.w	r0, #4294967295
 8008718:	4770      	bx	lr

0800871a <_stat>:

int _stat(char *file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 800871a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800871e:	604b      	str	r3, [r1, #4]
	return 0;
}
 8008720:	2000      	movs	r0, #0
 8008722:	4770      	bx	lr

08008724 <_link>:

int _link(char *old, char *new)
{
	errno = EMLINK;
 8008724:	4b02      	ldr	r3, [pc, #8]	; (8008730 <_link+0xc>)
 8008726:	221f      	movs	r2, #31
 8008728:	601a      	str	r2, [r3, #0]
	return -1;
}
 800872a:	f04f 30ff 	mov.w	r0, #4294967295
 800872e:	4770      	bx	lr
 8008730:	20003618 	.word	0x20003618

08008734 <_fork>:

int _fork(void)
{
	errno = EAGAIN;
 8008734:	4b02      	ldr	r3, [pc, #8]	; (8008740 <_fork+0xc>)
 8008736:	220b      	movs	r2, #11
 8008738:	601a      	str	r2, [r3, #0]
	return -1;
}
 800873a:	f04f 30ff 	mov.w	r0, #4294967295
 800873e:	4770      	bx	lr
 8008740:	20003618 	.word	0x20003618

08008744 <_execve>:

int _execve(char *name, char **argv, char **env)
{
	errno = ENOMEM;
 8008744:	4b02      	ldr	r3, [pc, #8]	; (8008750 <_execve+0xc>)
 8008746:	220c      	movs	r2, #12
 8008748:	601a      	str	r2, [r3, #0]
	return -1;
}
 800874a:	f04f 30ff 	mov.w	r0, #4294967295
 800874e:	4770      	bx	lr
 8008750:	20003618 	.word	0x20003618

08008754 <ts_itoa>:
**  Abstract: Convert integer to ascii
**  Returns:  void
**---------------------------------------------------------------------------
*/
void ts_itoa(char **buf, unsigned int d, int base)
{
 8008754:	b530      	push	{r4, r5, lr}
	int div = 1;
 8008756:	2301      	movs	r3, #1
	while (d/div >= base)
 8008758:	e000      	b.n	800875c <ts_itoa+0x8>
		div *= base;
 800875a:	4353      	muls	r3, r2
**---------------------------------------------------------------------------
*/
void ts_itoa(char **buf, unsigned int d, int base)
{
	int div = 1;
	while (d/div >= base)
 800875c:	fbb1 f4f3 	udiv	r4, r1, r3
 8008760:	4294      	cmp	r4, r2
 8008762:	d2fa      	bcs.n	800875a <ts_itoa+0x6>
 8008764:	e00e      	b.n	8008784 <ts_itoa+0x30>
		div *= base;

	while (div != 0)
	{
		int num = d/div;
 8008766:	fbb1 f4f3 	udiv	r4, r1, r3
		d = d%div;
		div /= base;
		if (num > 9)
 800876a:	2c09      	cmp	r4, #9
		div *= base;

	while (div != 0)
	{
		int num = d/div;
		d = d%div;
 800876c:	fb03 1114 	mls	r1, r3, r4, r1
 8008770:	6805      	ldr	r5, [r0, #0]
		div /= base;
 8008772:	fb93 f3f2 	sdiv	r3, r3, r2
		if (num > 9)
 8008776:	dd01      	ble.n	800877c <ts_itoa+0x28>
			*((*buf)++) = (num-10) + 'A';
 8008778:	3437      	adds	r4, #55	; 0x37
 800877a:	e000      	b.n	800877e <ts_itoa+0x2a>
		else
			*((*buf)++) = num + '0';
 800877c:	3430      	adds	r4, #48	; 0x30
 800877e:	f805 4b01 	strb.w	r4, [r5], #1
 8008782:	6005      	str	r5, [r0, #0]
{
	int div = 1;
	while (d/div >= base)
		div *= base;

	while (div != 0)
 8008784:	2b00      	cmp	r3, #0
 8008786:	d1ee      	bne.n	8008766 <ts_itoa+0x12>
		if (num > 9)
			*((*buf)++) = (num-10) + 'A';
		else
			*((*buf)++) = num + '0';
	}
}
 8008788:	bd30      	pop	{r4, r5, pc}

0800878a <ts_formatstring>:
**  Abstract: Writes arguments va to buffer buf according to format fmt
**  Returns:  Length of string
**---------------------------------------------------------------------------
*/
int ts_formatstring(char *buf, const char *fmt, va_list va)
{
 800878a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 800878e:	ad02      	add	r5, sp, #8
 8008790:	f845 0d04 	str.w	r0, [r5, #-4]!
 8008794:	460c      	mov	r4, r1
	char *start_buf = buf;
 8008796:	4606      	mov	r6, r0
				{
					signed int val = va_arg(va, signed int);
					if (val < 0)
					{
						val *= -1;
						*buf++ = '-';
 8008798:	272d      	movs	r7, #45	; 0x2d
**---------------------------------------------------------------------------
*/
int ts_formatstring(char *buf, const char *fmt, va_list va)
{
	char *start_buf = buf;
	while(*fmt)
 800879a:	e052      	b.n	8008842 <ts_formatstring+0xb8>
	{
		/* Character needs formating? */
		if (*fmt == '%')
 800879c:	2b25      	cmp	r3, #37	; 0x25
 800879e:	d14b      	bne.n	8008838 <ts_formatstring+0xae>
		{
			switch (*(++fmt))
 80087a0:	7863      	ldrb	r3, [r4, #1]
 80087a2:	2b69      	cmp	r3, #105	; 0x69
 80087a4:	d019      	beq.n	80087da <ts_formatstring+0x50>
 80087a6:	d80a      	bhi.n	80087be <ts_formatstring+0x34>
 80087a8:	2b63      	cmp	r3, #99	; 0x63
 80087aa:	d00f      	beq.n	80087cc <ts_formatstring+0x42>
 80087ac:	d804      	bhi.n	80087b8 <ts_formatstring+0x2e>
 80087ae:	2b25      	cmp	r3, #37	; 0x25
 80087b0:	d03c      	beq.n	800882c <ts_formatstring+0xa2>
 80087b2:	2b58      	cmp	r3, #88	; 0x58
 80087b4:	d13e      	bne.n	8008834 <ts_formatstring+0xaa>
 80087b6:	e030      	b.n	800881a <ts_formatstring+0x90>
 80087b8:	2b64      	cmp	r3, #100	; 0x64
 80087ba:	d13b      	bne.n	8008834 <ts_formatstring+0xaa>
 80087bc:	e00d      	b.n	80087da <ts_formatstring+0x50>
 80087be:	2b75      	cmp	r3, #117	; 0x75
 80087c0:	d025      	beq.n	800880e <ts_formatstring+0x84>
 80087c2:	2b78      	cmp	r3, #120	; 0x78
 80087c4:	d029      	beq.n	800881a <ts_formatstring+0x90>
 80087c6:	2b73      	cmp	r3, #115	; 0x73
 80087c8:	d134      	bne.n	8008834 <ts_formatstring+0xaa>
 80087ca:	e012      	b.n	80087f2 <ts_formatstring+0x68>
			{
			  case 'c':
				*buf++ = va_arg(va, int);
 80087cc:	6811      	ldr	r1, [r2, #0]
 80087ce:	9b01      	ldr	r3, [sp, #4]
 80087d0:	3204      	adds	r2, #4
 80087d2:	f803 1b01 	strb.w	r1, [r3], #1
 80087d6:	9301      	str	r3, [sp, #4]
				break;
 80087d8:	e02c      	b.n	8008834 <ts_formatstring+0xaa>
			  case 'd':
			  case 'i':
				{
					signed int val = va_arg(va, signed int);
 80087da:	6811      	ldr	r1, [r2, #0]
 80087dc:	f102 0804 	add.w	r8, r2, #4
					if (val < 0)
 80087e0:	2900      	cmp	r1, #0
 80087e2:	da04      	bge.n	80087ee <ts_formatstring+0x64>
					{
						val *= -1;
						*buf++ = '-';
 80087e4:	9b01      	ldr	r3, [sp, #4]
			  case 'i':
				{
					signed int val = va_arg(va, signed int);
					if (val < 0)
					{
						val *= -1;
 80087e6:	4249      	negs	r1, r1
						*buf++ = '-';
 80087e8:	f803 7b01 	strb.w	r7, [r3], #1
 80087ec:	9301      	str	r3, [sp, #4]
					}
					ts_itoa(&buf, val, 10);
 80087ee:	4628      	mov	r0, r5
 80087f0:	e011      	b.n	8008816 <ts_formatstring+0x8c>
**---------------------------------------------------------------------------
**  Abstract: Writes arguments va to buffer buf according to format fmt
**  Returns:  Length of string
**---------------------------------------------------------------------------
*/
int ts_formatstring(char *buf, const char *fmt, va_list va)
 80087f2:	6811      	ldr	r1, [r2, #0]
					ts_itoa(&buf, val, 10);
				}
				break;
			  case 's':
				{
					char * arg = va_arg(va, char *);
 80087f4:	1d10      	adds	r0, r2, #4
**---------------------------------------------------------------------------
**  Abstract: Writes arguments va to buffer buf according to format fmt
**  Returns:  Length of string
**---------------------------------------------------------------------------
*/
int ts_formatstring(char *buf, const char *fmt, va_list va)
 80087f6:	3901      	subs	r1, #1
				}
				break;
			  case 's':
				{
					char * arg = va_arg(va, char *);
					while (*arg)
 80087f8:	e003      	b.n	8008802 <ts_formatstring+0x78>
					{
						*buf++ = *arg++;
 80087fa:	9b01      	ldr	r3, [sp, #4]
 80087fc:	f803 2b01 	strb.w	r2, [r3], #1
 8008800:	9301      	str	r3, [sp, #4]
				}
				break;
			  case 's':
				{
					char * arg = va_arg(va, char *);
					while (*arg)
 8008802:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 8008806:	2a00      	cmp	r2, #0
 8008808:	d1f7      	bne.n	80087fa <ts_formatstring+0x70>
					ts_itoa(&buf, val, 10);
				}
				break;
			  case 's':
				{
					char * arg = va_arg(va, char *);
 800880a:	4602      	mov	r2, r0
 800880c:	e012      	b.n	8008834 <ts_formatstring+0xaa>
						*buf++ = *arg++;
					}
				}
				break;
			  case 'u':
					ts_itoa(&buf, va_arg(va, unsigned int), 10);
 800880e:	6811      	ldr	r1, [r2, #0]
 8008810:	f102 0804 	add.w	r8, r2, #4
 8008814:	4628      	mov	r0, r5
 8008816:	220a      	movs	r2, #10
 8008818:	e004      	b.n	8008824 <ts_formatstring+0x9a>
				break;
			  case 'x':
			  case 'X':
					ts_itoa(&buf, va_arg(va, int), 16);
 800881a:	f102 0804 	add.w	r8, r2, #4
 800881e:	6811      	ldr	r1, [r2, #0]
 8008820:	4628      	mov	r0, r5
 8008822:	2210      	movs	r2, #16
 8008824:	f7ff ff96 	bl	8008754 <ts_itoa>
 8008828:	4642      	mov	r2, r8
				break;
 800882a:	e003      	b.n	8008834 <ts_formatstring+0xaa>
			  case '%':
				  *buf++ = '%';
 800882c:	9901      	ldr	r1, [sp, #4]
 800882e:	f801 3b01 	strb.w	r3, [r1], #1
 8008832:	9101      	str	r1, [sp, #4]
				  break;
			}
			fmt++;
 8008834:	3402      	adds	r4, #2
 8008836:	e004      	b.n	8008842 <ts_formatstring+0xb8>
		}
		/* Else just copy */
		else
		{
			*buf++ = *fmt++;
 8008838:	9901      	ldr	r1, [sp, #4]
 800883a:	3401      	adds	r4, #1
 800883c:	f801 3b01 	strb.w	r3, [r1], #1
 8008840:	9101      	str	r1, [sp, #4]
**---------------------------------------------------------------------------
*/
int ts_formatstring(char *buf, const char *fmt, va_list va)
{
	char *start_buf = buf;
	while(*fmt)
 8008842:	7823      	ldrb	r3, [r4, #0]
 8008844:	2b00      	cmp	r3, #0
 8008846:	d1a9      	bne.n	800879c <ts_formatstring+0x12>
		else
		{
			*buf++ = *fmt++;
		}
	}
	*buf = 0;
 8008848:	9a01      	ldr	r2, [sp, #4]
 800884a:	7013      	strb	r3, [r2, #0]

	return (int)(buf - start_buf);
}
 800884c:	9801      	ldr	r0, [sp, #4]
 800884e:	1b80      	subs	r0, r0, r6
 8008850:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}

08008854 <ts_formatlength>:
**            format string and va_list va
**  Returns:  Maximum length
**---------------------------------------------------------------------------
*/
int ts_formatlength(const char *fmt, va_list va)
{
 8008854:	b510      	push	{r4, lr}
	int length = 0;
 8008856:	2300      	movs	r3, #0
	while (*fmt)
 8008858:	e02d      	b.n	80088b6 <ts_formatlength+0x62>
	{
		if (*fmt == '%')
 800885a:	2a25      	cmp	r2, #37	; 0x25
 800885c:	d126      	bne.n	80088ac <ts_formatlength+0x58>
		{
			++fmt;
			switch (*fmt)
 800885e:	7842      	ldrb	r2, [r0, #1]
	int length = 0;
	while (*fmt)
	{
		if (*fmt == '%')
		{
			++fmt;
 8008860:	1c44      	adds	r4, r0, #1
			switch (*fmt)
 8008862:	2a69      	cmp	r2, #105	; 0x69
 8008864:	d011      	beq.n	800888a <ts_formatlength+0x36>
 8008866:	d806      	bhi.n	8008876 <ts_formatlength+0x22>
 8008868:	2a63      	cmp	r2, #99	; 0x63
 800886a:	d00b      	beq.n	8008884 <ts_formatlength+0x30>
 800886c:	2a64      	cmp	r2, #100	; 0x64
 800886e:	d00c      	beq.n	800888a <ts_formatlength+0x36>
 8008870:	2a58      	cmp	r2, #88	; 0x58
 8008872:	d118      	bne.n	80088a6 <ts_formatlength+0x52>
 8008874:	e014      	b.n	80088a0 <ts_formatlength+0x4c>
 8008876:	2a75      	cmp	r2, #117	; 0x75
 8008878:	d007      	beq.n	800888a <ts_formatlength+0x36>
 800887a:	2a78      	cmp	r2, #120	; 0x78
 800887c:	d010      	beq.n	80088a0 <ts_formatlength+0x4c>
 800887e:	2a73      	cmp	r2, #115	; 0x73
 8008880:	d111      	bne.n	80088a6 <ts_formatlength+0x52>
 8008882:	e004      	b.n	800888e <ts_formatlength+0x3a>
			{
			  case 'c':
		  		  va_arg(va, int);
 8008884:	1d0a      	adds	r2, r1, #4
				  ++length;
 8008886:	3301      	adds	r3, #1
				  break;
 8008888:	e013      	b.n	80088b2 <ts_formatlength+0x5e>
			  case 'd':
			  case 'i':
			  case 'u':
				  /* 32 bits integer is max 11 characters with minus sign */
				  length += 11;
 800888a:	330b      	adds	r3, #11
 800888c:	e009      	b.n	80088a2 <ts_formatlength+0x4e>
				  va_arg(va, int);
				  break;
			  case 's':
			  	  {
			  		  char * str = va_arg(va, char *);
 800888e:	6808      	ldr	r0, [r1, #0]
 8008890:	1d0a      	adds	r2, r1, #4
**  Abstract: Calculate maximum length of the resulting string from the
**            format string and va_list va
**  Returns:  Maximum length
**---------------------------------------------------------------------------
*/
int ts_formatlength(const char *fmt, va_list va)
 8008892:	1ac0      	subs	r0, r0, r3
				  va_arg(va, int);
				  break;
			  case 's':
			  	  {
			  		  char * str = va_arg(va, char *);
			  		  while (*str++)
 8008894:	e000      	b.n	8008898 <ts_formatlength+0x44>
			  			  ++length;
 8008896:	3301      	adds	r3, #1
				  va_arg(va, int);
				  break;
			  case 's':
			  	  {
			  		  char * str = va_arg(va, char *);
			  		  while (*str++)
 8008898:	5cc1      	ldrb	r1, [r0, r3]
 800889a:	2900      	cmp	r1, #0
 800889c:	d1fb      	bne.n	8008896 <ts_formatlength+0x42>
 800889e:	e008      	b.n	80088b2 <ts_formatlength+0x5e>
			  	  }
				  break;
			  case 'x':
			  case 'X':
				  /* 32 bits integer as hex is max 8 characters */
				  length += 8;
 80088a0:	3308      	adds	r3, #8
				  va_arg(va, unsigned int);
 80088a2:	1d0a      	adds	r2, r1, #4
				  break;
 80088a4:	e005      	b.n	80088b2 <ts_formatlength+0x5e>
			  default:
				  ++length;
 80088a6:	3301      	adds	r3, #1
				  break;
 80088a8:	460a      	mov	r2, r1
 80088aa:	e002      	b.n	80088b2 <ts_formatlength+0x5e>
			}
		}
		else
		{
			++length;
 80088ac:	3301      	adds	r3, #1
 80088ae:	460a      	mov	r2, r1
 80088b0:	4604      	mov	r4, r0
		}
		++fmt;
 80088b2:	1c60      	adds	r0, r4, #1
 80088b4:	4611      	mov	r1, r2
**---------------------------------------------------------------------------
*/
int ts_formatlength(const char *fmt, va_list va)
{
	int length = 0;
	while (*fmt)
 80088b6:	7802      	ldrb	r2, [r0, #0]
 80088b8:	2a00      	cmp	r2, #0
 80088ba:	d1ce      	bne.n	800885a <ts_formatlength+0x6>
			++length;
		}
		++fmt;
	}
	return length;
}
 80088bc:	4618      	mov	r0, r3
 80088be:	bd10      	pop	{r4, pc}

080088c0 <sprintf>:
**            given character string according to the format parameter.
**  Returns:  Number of bytes written
**===========================================================================
*/
int sprintf(char *buf, const char *fmt, ...)
{
 80088c0:	b40e      	push	{r1, r2, r3}
 80088c2:	b503      	push	{r0, r1, lr}
 80088c4:	aa03      	add	r2, sp, #12
 80088c6:	f852 1b04 	ldr.w	r1, [r2], #4
	int length;
	va_list va;
	va_start(va, fmt);
 80088ca:	9201      	str	r2, [sp, #4]
	length = ts_formatstring(buf, fmt, va);
 80088cc:	f7ff ff5d 	bl	800878a <ts_formatstring>
	va_end(va);
	return length;
}
 80088d0:	e8bd 400c 	ldmia.w	sp!, {r2, r3, lr}
 80088d4:	b003      	add	sp, #12
 80088d6:	4770      	bx	lr

080088d8 <fprintf>:
**            given file stream according to the format parameter.
**  Returns:  Number of bytes written
**===========================================================================
*/
int fprintf(FILE * stream, const char *fmt, ...)
{
 80088d8:	b40e      	push	{r1, r2, r3}
 80088da:	b5f0      	push	{r4, r5, r6, r7, lr}
 80088dc:	b082      	sub	sp, #8
 80088de:	af00      	add	r7, sp, #0
 80088e0:	f107 041c 	add.w	r4, r7, #28
 80088e4:	f854 5b04 	ldr.w	r5, [r4], #4
 80088e8:	4606      	mov	r6, r0
	int length = 0;
	va_list va;
	va_start(va, fmt);
	length = ts_formatlength(fmt, va);
 80088ea:	4621      	mov	r1, r4
 80088ec:	4628      	mov	r0, r5
*/
int fprintf(FILE * stream, const char *fmt, ...)
{
	int length = 0;
	va_list va;
	va_start(va, fmt);
 80088ee:	607c      	str	r4, [r7, #4]
	length = ts_formatlength(fmt, va);
 80088f0:	f7ff ffb0 	bl	8008854 <ts_formatlength>
	va_end(va);
	{
		char buf[length];
 80088f4:	3007      	adds	r0, #7
 80088f6:	f020 0007 	bic.w	r0, r0, #7
 80088fa:	ebad 0d00 	sub.w	sp, sp, r0
		va_start(va, fmt);
		length = ts_formatstring(buf, fmt, va);
 80088fe:	4629      	mov	r1, r5
 8008900:	4622      	mov	r2, r4
 8008902:	4668      	mov	r0, sp
	va_start(va, fmt);
	length = ts_formatlength(fmt, va);
	va_end(va);
	{
		char buf[length];
		va_start(va, fmt);
 8008904:	607c      	str	r4, [r7, #4]
		length = ts_formatstring(buf, fmt, va);
 8008906:	f7ff ff40 	bl	800878a <ts_formatstring>
		length = _write(stream->_file, buf, length);
 800890a:	4669      	mov	r1, sp
	length = ts_formatlength(fmt, va);
	va_end(va);
	{
		char buf[length];
		va_start(va, fmt);
		length = ts_formatstring(buf, fmt, va);
 800890c:	4602      	mov	r2, r0
		length = _write(stream->_file, buf, length);
 800890e:	f9b6 000e 	ldrsh.w	r0, [r6, #14]
 8008912:	f7ff fecf 	bl	80086b4 <_write>
		va_end(va);
	}
	return length;
}
 8008916:	f107 0708 	add.w	r7, r7, #8
 800891a:	46bd      	mov	sp, r7
 800891c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8008920:	b003      	add	sp, #12
 8008922:	4770      	bx	lr

08008924 <printf>:
**  Returns:  Number of bytes written
**
**===========================================================================
*/
int printf(const char *fmt, ...)
{
 8008924:	b40f      	push	{r0, r1, r2, r3}
 8008926:	b5b0      	push	{r4, r5, r7, lr}
 8008928:	b082      	sub	sp, #8
 800892a:	af00      	add	r7, sp, #0
 800892c:	f107 0418 	add.w	r4, r7, #24
 8008930:	f854 5b04 	ldr.w	r5, [r4], #4
	int length = 0;
	va_list va;
	va_start(va, fmt);
	length = ts_formatlength(fmt, va);
 8008934:	4621      	mov	r1, r4
 8008936:	4628      	mov	r0, r5
*/
int printf(const char *fmt, ...)
{
	int length = 0;
	va_list va;
	va_start(va, fmt);
 8008938:	607c      	str	r4, [r7, #4]
	length = ts_formatlength(fmt, va);
 800893a:	f7ff ff8b 	bl	8008854 <ts_formatlength>
	va_end(va);
	{
		char buf[length];
 800893e:	3007      	adds	r0, #7
 8008940:	f020 0007 	bic.w	r0, r0, #7
 8008944:	ebad 0d00 	sub.w	sp, sp, r0
		va_start(va, fmt);
		length = ts_formatstring(buf, fmt, va);
 8008948:	4629      	mov	r1, r5
 800894a:	4622      	mov	r2, r4
 800894c:	4668      	mov	r0, sp
	va_start(va, fmt);
	length = ts_formatlength(fmt, va);
	va_end(va);
	{
		char buf[length];
		va_start(va, fmt);
 800894e:	607c      	str	r4, [r7, #4]
		length = ts_formatstring(buf, fmt, va);
 8008950:	f7ff ff1b 	bl	800878a <ts_formatstring>
		length = _write(1, buf, length);
 8008954:	4669      	mov	r1, sp
	length = ts_formatlength(fmt, va);
	va_end(va);
	{
		char buf[length];
		va_start(va, fmt);
		length = ts_formatstring(buf, fmt, va);
 8008956:	4602      	mov	r2, r0
		length = _write(1, buf, length);
 8008958:	2001      	movs	r0, #1
 800895a:	f7ff feab 	bl	80086b4 <_write>
		va_end(va);
	}
	return length;
}
 800895e:	f107 0708 	add.w	r7, r7, #8
 8008962:	46bd      	mov	sp, r7
 8008964:	e8bd 40b0 	ldmia.w	sp!, {r4, r5, r7, lr}
 8008968:	b004      	add	sp, #16
 800896a:	4770      	bx	lr

0800896c <put_rc>:



static
void put_rc (FRESULT rc)
{
 800896c:	4601      	mov	r1, r0
		"OK\0" "NOT_READY\0" "NO_FILE\0" "FR_NO_PATH\0" "INVALID_NAME\0" "INVALID_DRIVE\0"
		"DENIED\0" "EXIST\0" "RW_ERROR\0" "WRITE_PROTECTED\0" "NOT_ENABLED\0"
		"NO_FILESYSTEM\0" "INVALID_OBJECT\0" "MKFS_ABORTED\0";
	FRESULT i;

	for (p = str, i = 0; i != rc && *p; i++) {
 800896e:	2300      	movs	r3, #0
 8008970:	4a08      	ldr	r2, [pc, #32]	; (8008994 <put_rc+0x28>)
 8008972:	e005      	b.n	8008980 <put_rc+0x14>
		while(*p++);
 8008974:	f812 0b01 	ldrb.w	r0, [r2], #1
 8008978:	2800      	cmp	r0, #0
 800897a:	d1fb      	bne.n	8008974 <put_rc+0x8>
		"OK\0" "NOT_READY\0" "NO_FILE\0" "FR_NO_PATH\0" "INVALID_NAME\0" "INVALID_DRIVE\0"
		"DENIED\0" "EXIST\0" "RW_ERROR\0" "WRITE_PROTECTED\0" "NOT_ENABLED\0"
		"NO_FILESYSTEM\0" "INVALID_OBJECT\0" "MKFS_ABORTED\0";
	FRESULT i;

	for (p = str, i = 0; i != rc && *p; i++) {
 800897c:	3301      	adds	r3, #1
 800897e:	b2db      	uxtb	r3, r3
 8008980:	428b      	cmp	r3, r1
 8008982:	d102      	bne.n	800898a <put_rc+0x1e>
		while(*p++);
	}
	xprintf("rc=%u FR_%s\n", (UINT)rc, p);
 8008984:	4804      	ldr	r0, [pc, #16]	; (8008998 <put_rc+0x2c>)
 8008986:	f000 bfbf 	b.w	8009908 <xprintf>
		"OK\0" "NOT_READY\0" "NO_FILE\0" "FR_NO_PATH\0" "INVALID_NAME\0" "INVALID_DRIVE\0"
		"DENIED\0" "EXIST\0" "RW_ERROR\0" "WRITE_PROTECTED\0" "NOT_ENABLED\0"
		"NO_FILESYSTEM\0" "INVALID_OBJECT\0" "MKFS_ABORTED\0";
	FRESULT i;

	for (p = str, i = 0; i != rc && *p; i++) {
 800898a:	7810      	ldrb	r0, [r2, #0]
 800898c:	2800      	cmp	r0, #0
 800898e:	d1f1      	bne.n	8008974 <put_rc+0x8>
 8008990:	e7f8      	b.n	8008984 <put_rc+0x18>
 8008992:	bf00      	nop
 8008994:	0801e660 	.word	0x0801e660
 8008998:	0801ffec 	.word	0x0801ffec

0800899c <scan_files>:
	Timer++;
}

static
FRESULT scan_files (char* path)
{
 800899c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800899e:	4604      	mov	r4, r0
 80089a0:	b08b      	sub	sp, #44	; 0x2c
	FRESULT res;
	BYTE i;
	char *fn;


	if ((res = f_opendir(&dirs, path)) == FR_OK) {
 80089a2:	a801      	add	r0, sp, #4
 80089a4:	4621      	mov	r1, r4
 80089a6:	f7f9 faaa 	bl	8001efe <f_opendir>
 80089aa:	2800      	cmp	r0, #0
 80089ac:	d134      	bne.n	8008a18 <scan_files+0x7c>
		i = strlen(path);
 80089ae:	4620      	mov	r0, r4
 80089b0:	f00a f8e2 	bl	8012b78 <strlen>
#else
				fn = Finfo.fname;
#endif
			if (Finfo.fattrib & AM_DIR) {
				acc_dirs++;
				*(path+i) = '/'; strcpy(path+i+1, fn);
 80089b4:	b2c6      	uxtb	r6, r0
 80089b6:	1c77      	adds	r7, r6, #1
 80089b8:	19e7      	adds	r7, r4, r7
	char *fn;


	if ((res = f_opendir(&dirs, path)) == FR_OK) {
		i = strlen(path);
		while (((res = f_readdir(&dirs, &Finfo)) == FR_OK) && Finfo.fname[0]) {
 80089ba:	e024      	b.n	8008a06 <scan_files+0x6a>
#if _USE_LFN
				fn = *Finfo.lfname ? Finfo.lfname : Finfo.fname;
 80089bc:	69a9      	ldr	r1, [r5, #24]
 80089be:	f105 0309 	add.w	r3, r5, #9
 80089c2:	780a      	ldrb	r2, [r1, #0]
 80089c4:	2a00      	cmp	r2, #0
 80089c6:	bf08      	it	eq
 80089c8:	4619      	moveq	r1, r3
#else
				fn = Finfo.fname;
#endif
			if (Finfo.fattrib & AM_DIR) {
 80089ca:	7a2b      	ldrb	r3, [r5, #8]
 80089cc:	f003 0310 	and.w	r3, r3, #16
 80089d0:	b2db      	uxtb	r3, r3
 80089d2:	b17b      	cbz	r3, 80089f4 <scan_files+0x58>
				acc_dirs++;
 80089d4:	4b11      	ldr	r3, [pc, #68]	; (8008a1c <scan_files+0x80>)
				*(path+i) = '/'; strcpy(path+i+1, fn);
 80089d6:	4638      	mov	r0, r7
				fn = *Finfo.lfname ? Finfo.lfname : Finfo.fname;
#else
				fn = Finfo.fname;
#endif
			if (Finfo.fattrib & AM_DIR) {
				acc_dirs++;
 80089d8:	881a      	ldrh	r2, [r3, #0]
 80089da:	3201      	adds	r2, #1
 80089dc:	801a      	strh	r2, [r3, #0]
				*(path+i) = '/'; strcpy(path+i+1, fn);
 80089de:	232f      	movs	r3, #47	; 0x2f
 80089e0:	55a3      	strb	r3, [r4, r6]
 80089e2:	f00a f86b 	bl	8012abc <strcpy>
				res = scan_files(path);
 80089e6:	4620      	mov	r0, r4
 80089e8:	f7ff ffd8 	bl	800899c <scan_files>
				*(path+i) = '\0';
 80089ec:	2300      	movs	r3, #0
 80089ee:	55a3      	strb	r3, [r4, r6]
				if (res != FR_OK) break;
 80089f0:	b148      	cbz	r0, 8008a06 <scan_files+0x6a>
 80089f2:	e011      	b.n	8008a18 <scan_files+0x7c>
			} else {
//				xprintf("%s/%s\n", path, fn);
				acc_files++;
 80089f4:	4b0a      	ldr	r3, [pc, #40]	; (8008a20 <scan_files+0x84>)
				acc_size += Finfo.fsize;
 80089f6:	6829      	ldr	r1, [r5, #0]
				res = scan_files(path);
				*(path+i) = '\0';
				if (res != FR_OK) break;
			} else {
//				xprintf("%s/%s\n", path, fn);
				acc_files++;
 80089f8:	881a      	ldrh	r2, [r3, #0]
 80089fa:	3201      	adds	r2, #1
 80089fc:	801a      	strh	r2, [r3, #0]
				acc_size += Finfo.fsize;
 80089fe:	4b09      	ldr	r3, [pc, #36]	; (8008a24 <scan_files+0x88>)
 8008a00:	681a      	ldr	r2, [r3, #0]
 8008a02:	188a      	adds	r2, r1, r2
 8008a04:	601a      	str	r2, [r3, #0]
	char *fn;


	if ((res = f_opendir(&dirs, path)) == FR_OK) {
		i = strlen(path);
		while (((res = f_readdir(&dirs, &Finfo)) == FR_OK) && Finfo.fname[0]) {
 8008a06:	4d08      	ldr	r5, [pc, #32]	; (8008a28 <scan_files+0x8c>)
 8008a08:	a801      	add	r0, sp, #4
 8008a0a:	4629      	mov	r1, r5
 8008a0c:	f7f9 fab0 	bl	8001f70 <f_readdir>
 8008a10:	b910      	cbnz	r0, 8008a18 <scan_files+0x7c>
 8008a12:	7a6b      	ldrb	r3, [r5, #9]
 8008a14:	2b00      	cmp	r3, #0
 8008a16:	d1d1      	bne.n	80089bc <scan_files+0x20>
			}
		}
	}

	return res;
}
 8008a18:	b00b      	add	sp, #44	; 0x2c
 8008a1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008a1c:	200021b8 	.word	0x200021b8
 8008a20:	200021ba 	.word	0x200021ba
 8008a24:	20003608 	.word	0x20003608
 8008a28:	20002198 	.word	0x20002198

08008a2c <ff_test_term>:
	xprintf("rc=%u FR_%s\n", (UINT)rc, p);
}


int ff_test_term (void)
{
 8008a2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	UINT s1, s2, cnt, blen = sizeof(Buff);
	DWORD ofs = 0, sect = 0;
	FATFS *fs;				/* Pointer to file system object */
	RTC_t rtc;

	xputs("\nFatFs module test terminal\n");
 8008a30:	48a7      	ldr	r0, [pc, #668]	; (8008cd0 <ff_test_term+0x2a4>)
	xprintf("rc=%u FR_%s\n", (UINT)rc, p);
}


int ff_test_term (void)
{
 8008a32:	b097      	sub	sp, #92	; 0x5c
	UINT s1, s2, cnt, blen = sizeof(Buff);
	DWORD ofs = 0, sect = 0;
	FATFS *fs;				/* Pointer to file system object */
	RTC_t rtc;

	xputs("\nFatFs module test terminal\n");
 8008a34:	f000 ff18 	bl	8009868 <xputs>
				res = f_opendir(&Dir, ptr);
				if (res) { put_rc(res); break; }
				p1 = s1 = s2 = 0;
				for(;;) {
#if _USE_LFN
					Finfo.lfname = Lfname;
 8008a38:	4ca6      	ldr	r4, [pc, #664]	; (8008cd4 <ff_test_term+0x2a8>)

	xputs("\nFatFs module test terminal\n");

	for (;;) {
		xputc('>');
		ptr = linebuf;
 8008a3a:	4ea7      	ldr	r6, [pc, #668]	; (8008cd8 <ff_test_term+0x2ac>)
	char *ptr, *ptr2;
	long p1, p2, p3;
	BYTE res, b1;
	WORD w1;
	UINT s1, s2, cnt, blen = sizeof(Buff);
	DWORD ofs = 0, sect = 0;
 8008a3c:	2700      	movs	r7, #0
{
	char *ptr, *ptr2;
	long p1, p2, p3;
	BYTE res, b1;
	WORD w1;
	UINT s1, s2, cnt, blen = sizeof(Buff);
 8008a3e:	f44f 5580 	mov.w	r5, #4096	; 0x1000
					if (Finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s",
 8008a42:	f104 0809 	add.w	r8, r4, #9
	RTC_t rtc;

	xputs("\nFatFs module test terminal\n");

	for (;;) {
		xputc('>');
 8008a46:	203e      	movs	r0, #62	; 0x3e
 8008a48:	f000 fefc 	bl	8009844 <xputc>
		ptr = linebuf;
		get_line(ptr, sizeof(linebuf));
 8008a4c:	2178      	movs	r1, #120	; 0x78
 8008a4e:	48a2      	ldr	r0, [pc, #648]	; (8008cd8 <ff_test_term+0x2ac>)

	xputs("\nFatFs module test terminal\n");

	for (;;) {
		xputc('>');
		ptr = linebuf;
 8008a50:	960b      	str	r6, [sp, #44]	; 0x2c
		get_line(ptr, sizeof(linebuf));
 8008a52:	f000 ffdf 	bl	8009a14 <get_line>

		switch (*ptr++) {
 8008a56:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008a58:	4619      	mov	r1, r3
 8008a5a:	f811 2b01 	ldrb.w	r2, [r1], #1
 8008a5e:	2a6d      	cmp	r2, #109	; 0x6d
 8008a60:	910b      	str	r1, [sp, #44]	; 0x2c
 8008a62:	d012      	beq.n	8008a8a <ff_test_term+0x5e>
 8008a64:	d807      	bhi.n	8008a76 <ff_test_term+0x4a>
 8008a66:	2a64      	cmp	r2, #100	; 0x64
 8008a68:	d039      	beq.n	8008ade <ff_test_term+0xb2>
 8008a6a:	2a66      	cmp	r2, #102	; 0x66
 8008a6c:	f000 81d4 	beq.w	8008e18 <ff_test_term+0x3ec>
 8008a70:	2a62      	cmp	r2, #98	; 0x62
 8008a72:	d1e8      	bne.n	8008a46 <ff_test_term+0x1a>
 8008a74:	e0f8      	b.n	8008c68 <ff_test_term+0x23c>
 8008a76:	2a74      	cmp	r2, #116	; 0x74
 8008a78:	f000 8533 	beq.w	80094e2 <ff_test_term+0xab6>
 8008a7c:	2a78      	cmp	r2, #120	; 0x78
 8008a7e:	f000 85a1 	beq.w	80095c4 <ff_test_term+0xb98>
 8008a82:	2a70      	cmp	r2, #112	; 0x70
 8008a84:	d1df      	bne.n	8008a46 <ff_test_term+0x1a>
 8008a86:	f000 bd74 	b.w	8009572 <ff_test_term+0xb46>

		case 'm' :
			switch (*ptr++) {
 8008a8a:	785a      	ldrb	r2, [r3, #1]
 8008a8c:	3302      	adds	r3, #2
 8008a8e:	2a64      	cmp	r2, #100	; 0x64
 8008a90:	930b      	str	r3, [sp, #44]	; 0x2c
 8008a92:	d1d8      	bne.n	8008a46 <ff_test_term+0x1a>
			case 'd' :	/* md <address> [<count>] - Dump memory */
				if (!xatoi(&ptr, &p1)) break;
 8008a94:	a80b      	add	r0, sp, #44	; 0x2c
 8008a96:	a90c      	add	r1, sp, #48	; 0x30
 8008a98:	f000 fe80 	bl	800979c <xatoi>
 8008a9c:	2800      	cmp	r0, #0
 8008a9e:	d0d2      	beq.n	8008a46 <ff_test_term+0x1a>
				if (!xatoi(&ptr, &p2)) p2 = 128;
 8008aa0:	a80b      	add	r0, sp, #44	; 0x2c
 8008aa2:	a90d      	add	r1, sp, #52	; 0x34
 8008aa4:	f000 fe7a 	bl	800979c <xatoi>
 8008aa8:	b908      	cbnz	r0, 8008aae <ff_test_term+0x82>
 8008aaa:	2380      	movs	r3, #128	; 0x80
 8008aac:	930d      	str	r3, [sp, #52]	; 0x34
				for (ptr=(char*)p1; p2 >= 16; ptr += 16, p2 -= 16)
 8008aae:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008ab0:	930b      	str	r3, [sp, #44]	; 0x2c
 8008ab2:	e00a      	b.n	8008aca <ff_test_term+0x9e>
					put_dump((BYTE*)ptr, (UINT)ptr, 16);
 8008ab4:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8008ab6:	2210      	movs	r2, #16
 8008ab8:	4601      	mov	r1, r0
 8008aba:	f000 ff80 	bl	80099be <put_dump>
		case 'm' :
			switch (*ptr++) {
			case 'd' :	/* md <address> [<count>] - Dump memory */
				if (!xatoi(&ptr, &p1)) break;
				if (!xatoi(&ptr, &p2)) p2 = 128;
				for (ptr=(char*)p1; p2 >= 16; ptr += 16, p2 -= 16)
 8008abe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008ac0:	3310      	adds	r3, #16
 8008ac2:	930b      	str	r3, [sp, #44]	; 0x2c
 8008ac4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008ac6:	3b10      	subs	r3, #16
 8008ac8:	930d      	str	r3, [sp, #52]	; 0x34
 8008aca:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8008acc:	2a0f      	cmp	r2, #15
 8008ace:	dcf1      	bgt.n	8008ab4 <ff_test_term+0x88>
					put_dump((BYTE*)ptr, (UINT)ptr, 16);
				if (p2) put_dump((BYTE*)ptr, (UINT)ptr, p2);
 8008ad0:	2a00      	cmp	r2, #0
 8008ad2:	d0b8      	beq.n	8008a46 <ff_test_term+0x1a>
 8008ad4:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8008ad6:	4601      	mov	r1, r0
 8008ad8:	f000 ff71 	bl	80099be <put_dump>
 8008adc:	e7b3      	b.n	8008a46 <ff_test_term+0x1a>
				break;
			}
			break;

		case 'd' :
			switch (*ptr++) {
 8008ade:	785a      	ldrb	r2, [r3, #1]
 8008ae0:	3302      	adds	r3, #2
 8008ae2:	2a69      	cmp	r2, #105	; 0x69
 8008ae4:	930b      	str	r3, [sp, #44]	; 0x2c
 8008ae6:	d02b      	beq.n	8008b40 <ff_test_term+0x114>
 8008ae8:	2a73      	cmp	r2, #115	; 0x73
 8008aea:	d031      	beq.n	8008b50 <ff_test_term+0x124>
 8008aec:	2a64      	cmp	r2, #100	; 0x64
 8008aee:	d1aa      	bne.n	8008a46 <ff_test_term+0x1a>
			case 'd' :	/* dd [<lba>] - Dump sector */
				if (!xatoi(&ptr, &p2)) p2 = sect;
 8008af0:	a80b      	add	r0, sp, #44	; 0x2c
 8008af2:	a90d      	add	r1, sp, #52	; 0x34
 8008af4:	f000 fe52 	bl	800979c <xatoi>
 8008af8:	b900      	cbnz	r0, 8008afc <ff_test_term+0xd0>
 8008afa:	970d      	str	r7, [sp, #52]	; 0x34
				res = disk_read(0, Buff, p2, 1);
 8008afc:	f8df a200 	ldr.w	sl, [pc, #512]	; 8008d00 <ff_test_term+0x2d4>
 8008b00:	2000      	movs	r0, #0
 8008b02:	4651      	mov	r1, sl
 8008b04:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8008b06:	2301      	movs	r3, #1
 8008b08:	f7fa fb3c 	bl	8003184 <disk_read>
				if (res) { xprintf("rc=%d\n", (WORD)res); break; }
 8008b0c:	4681      	mov	r9, r0
 8008b0e:	b110      	cbz	r0, 8008b16 <ff_test_term+0xea>
 8008b10:	4872      	ldr	r0, [pc, #456]	; (8008cdc <ff_test_term+0x2b0>)
 8008b12:	4649      	mov	r1, r9
 8008b14:	e019      	b.n	8008b4a <ff_test_term+0x11e>
				sect = p2 + 1;
 8008b16:	990d      	ldr	r1, [sp, #52]	; 0x34
				xprintf("Sector:%lu\n", p2);
 8008b18:	4871      	ldr	r0, [pc, #452]	; (8008ce0 <ff_test_term+0x2b4>)
			switch (*ptr++) {
			case 'd' :	/* dd [<lba>] - Dump sector */
				if (!xatoi(&ptr, &p2)) p2 = sect;
				res = disk_read(0, Buff, p2, 1);
				if (res) { xprintf("rc=%d\n", (WORD)res); break; }
				sect = p2 + 1;
 8008b1a:	1c4f      	adds	r7, r1, #1
				xprintf("Sector:%lu\n", p2);
 8008b1c:	f000 fef4 	bl	8009908 <xprintf>
				for (ptr=(char*)Buff, ofs = 0; ofs < 0x200; ptr+=16, ofs+=16)
 8008b20:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
					put_dump((BYTE*)ptr, ofs, 16);
 8008b24:	4649      	mov	r1, r9
 8008b26:	2210      	movs	r2, #16
 8008b28:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8008b2a:	f000 ff48 	bl	80099be <put_dump>
				if (!xatoi(&ptr, &p2)) p2 = sect;
				res = disk_read(0, Buff, p2, 1);
				if (res) { xprintf("rc=%d\n", (WORD)res); break; }
				sect = p2 + 1;
				xprintf("Sector:%lu\n", p2);
				for (ptr=(char*)Buff, ofs = 0; ofs < 0x200; ptr+=16, ofs+=16)
 8008b2e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008b30:	f109 0910 	add.w	r9, r9, #16
 8008b34:	3310      	adds	r3, #16
 8008b36:	f5b9 7f00 	cmp.w	r9, #512	; 0x200
 8008b3a:	930b      	str	r3, [sp, #44]	; 0x2c
 8008b3c:	d1f2      	bne.n	8008b24 <ff_test_term+0xf8>
 8008b3e:	e782      	b.n	8008a46 <ff_test_term+0x1a>
					put_dump((BYTE*)ptr, ofs, 16);
				break;

			case 'i' :	/* di - Initialize disk */
				xprintf("rc=%d\n", (WORD)disk_initialize(0));
 8008b40:	2000      	movs	r0, #0
 8008b42:	f7fa fa72 	bl	800302a <disk_initialize>
 8008b46:	4601      	mov	r1, r0
 8008b48:	4864      	ldr	r0, [pc, #400]	; (8008cdc <ff_test_term+0x2b0>)
 8008b4a:	f000 fedd 	bl	8009908 <xprintf>
				break;
 8008b4e:	e77a      	b.n	8008a46 <ff_test_term+0x1a>

			case 's' :	/* ds - Show disk status */
				Buff[0]=2;
 8008b50:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 8008d00 <ff_test_term+0x2d4>
 8008b54:	2302      	movs	r3, #2
				if (disk_ioctl(0, CTRL_POWER, Buff) == RES_OK )
 8008b56:	2000      	movs	r0, #0
 8008b58:	2104      	movs	r1, #4
 8008b5a:	464a      	mov	r2, r9
			case 'i' :	/* di - Initialize disk */
				xprintf("rc=%d\n", (WORD)disk_initialize(0));
				break;

			case 's' :	/* ds - Show disk status */
				Buff[0]=2;
 8008b5c:	f889 3000 	strb.w	r3, [r9]
				if (disk_ioctl(0, CTRL_POWER, Buff) == RES_OK )
 8008b60:	f7fa fbb8 	bl	80032d4 <disk_ioctl>
 8008b64:	b950      	cbnz	r0, 8008b7c <ff_test_term+0x150>
					{ xprintf("Power is %s\n", Buff[1] ? "ON" : "OFF"); }
 8008b66:	f899 1001 	ldrb.w	r1, [r9, #1]
 8008b6a:	4b5e      	ldr	r3, [pc, #376]	; (8008ce4 <ff_test_term+0x2b8>)
 8008b6c:	4a5e      	ldr	r2, [pc, #376]	; (8008ce8 <ff_test_term+0x2bc>)
 8008b6e:	485f      	ldr	r0, [pc, #380]	; (8008cec <ff_test_term+0x2c0>)
 8008b70:	2900      	cmp	r1, #0
 8008b72:	bf0c      	ite	eq
 8008b74:	4611      	moveq	r1, r2
 8008b76:	4619      	movne	r1, r3
 8008b78:	f000 fec6 	bl	8009908 <xprintf>
				if (disk_ioctl(0, GET_SECTOR_COUNT, &p2) == RES_OK)
 8008b7c:	2000      	movs	r0, #0
 8008b7e:	2101      	movs	r1, #1
 8008b80:	aa0d      	add	r2, sp, #52	; 0x34
 8008b82:	f7fa fba7 	bl	80032d4 <disk_ioctl>
 8008b86:	b918      	cbnz	r0, 8008b90 <ff_test_term+0x164>
					{ xprintf("Drive size: %lu sectors\n", p2); }
 8008b88:	4859      	ldr	r0, [pc, #356]	; (8008cf0 <ff_test_term+0x2c4>)
 8008b8a:	990d      	ldr	r1, [sp, #52]	; 0x34
 8008b8c:	f000 febc 	bl	8009908 <xprintf>
				if (disk_ioctl(0, GET_SECTOR_SIZE, &w1) == RES_OK)
 8008b90:	2000      	movs	r0, #0
 8008b92:	2102      	movs	r1, #2
 8008b94:	f10d 022a 	add.w	r2, sp, #42	; 0x2a
 8008b98:	f7fa fb9c 	bl	80032d4 <disk_ioctl>
 8008b9c:	b920      	cbnz	r0, 8008ba8 <ff_test_term+0x17c>
					{ xprintf("Sector size: %u\n", w1); }
 8008b9e:	4855      	ldr	r0, [pc, #340]	; (8008cf4 <ff_test_term+0x2c8>)
 8008ba0:	f8bd 102a 	ldrh.w	r1, [sp, #42]	; 0x2a
 8008ba4:	f000 feb0 	bl	8009908 <xprintf>
				if (disk_ioctl(0, GET_BLOCK_SIZE, &p2) == RES_OK)
 8008ba8:	2000      	movs	r0, #0
 8008baa:	2103      	movs	r1, #3
 8008bac:	aa0d      	add	r2, sp, #52	; 0x34
 8008bae:	f7fa fb91 	bl	80032d4 <disk_ioctl>
 8008bb2:	b918      	cbnz	r0, 8008bbc <ff_test_term+0x190>
					{ xprintf("Erase block size: %lu sectors\n", p2); }
 8008bb4:	4850      	ldr	r0, [pc, #320]	; (8008cf8 <ff_test_term+0x2cc>)
 8008bb6:	990d      	ldr	r1, [sp, #52]	; 0x34
 8008bb8:	f000 fea6 	bl	8009908 <xprintf>
				if (disk_ioctl(0, MMC_GET_TYPE, &b1) == RES_OK)
 8008bbc:	2000      	movs	r0, #0
 8008bbe:	210a      	movs	r1, #10
 8008bc0:	f10d 0229 	add.w	r2, sp, #41	; 0x29
 8008bc4:	f7fa fb86 	bl	80032d4 <disk_ioctl>
 8008bc8:	b920      	cbnz	r0, 8008bd4 <ff_test_term+0x1a8>
					{ xprintf("MMC/SDC type: %u\n", b1); }
 8008bca:	484c      	ldr	r0, [pc, #304]	; (8008cfc <ff_test_term+0x2d0>)
 8008bcc:	f89d 1029 	ldrb.w	r1, [sp, #41]	; 0x29
 8008bd0:	f000 fe9a 	bl	8009908 <xprintf>
				if (disk_ioctl(0, MMC_GET_CSD, Buff) == RES_OK)
 8008bd4:	2000      	movs	r0, #0
 8008bd6:	210b      	movs	r1, #11
 8008bd8:	4a49      	ldr	r2, [pc, #292]	; (8008d00 <ff_test_term+0x2d4>)
 8008bda:	f7fa fb7b 	bl	80032d4 <disk_ioctl>
 8008bde:	4681      	mov	r9, r0
 8008be0:	b938      	cbnz	r0, 8008bf2 <ff_test_term+0x1c6>
					{ xputs("CSD:\n"); put_dump(Buff, 0, 16); }
 8008be2:	4848      	ldr	r0, [pc, #288]	; (8008d04 <ff_test_term+0x2d8>)
 8008be4:	f000 fe40 	bl	8009868 <xputs>
 8008be8:	4845      	ldr	r0, [pc, #276]	; (8008d00 <ff_test_term+0x2d4>)
 8008bea:	4649      	mov	r1, r9
 8008bec:	2210      	movs	r2, #16
 8008bee:	f000 fee6 	bl	80099be <put_dump>
				if (disk_ioctl(0, MMC_GET_CID, Buff) == RES_OK)
 8008bf2:	2000      	movs	r0, #0
 8008bf4:	210c      	movs	r1, #12
 8008bf6:	4a42      	ldr	r2, [pc, #264]	; (8008d00 <ff_test_term+0x2d4>)
 8008bf8:	f7fa fb6c 	bl	80032d4 <disk_ioctl>
 8008bfc:	4681      	mov	r9, r0
 8008bfe:	b938      	cbnz	r0, 8008c10 <ff_test_term+0x1e4>
					{ xputs("CID:\n"); put_dump(Buff, 0, 16); }
 8008c00:	4841      	ldr	r0, [pc, #260]	; (8008d08 <ff_test_term+0x2dc>)
 8008c02:	f000 fe31 	bl	8009868 <xputs>
 8008c06:	483e      	ldr	r0, [pc, #248]	; (8008d00 <ff_test_term+0x2d4>)
 8008c08:	4649      	mov	r1, r9
 8008c0a:	2210      	movs	r2, #16
 8008c0c:	f000 fed7 	bl	80099be <put_dump>
				if (disk_ioctl(0, MMC_GET_OCR, Buff) == RES_OK)
 8008c10:	2000      	movs	r0, #0
 8008c12:	210d      	movs	r1, #13
 8008c14:	4a3a      	ldr	r2, [pc, #232]	; (8008d00 <ff_test_term+0x2d4>)
 8008c16:	f7fa fb5d 	bl	80032d4 <disk_ioctl>
 8008c1a:	4681      	mov	r9, r0
 8008c1c:	b938      	cbnz	r0, 8008c2e <ff_test_term+0x202>
					{ xputs("OCR:\n"); put_dump(Buff, 0, 4); }
 8008c1e:	483b      	ldr	r0, [pc, #236]	; (8008d0c <ff_test_term+0x2e0>)
 8008c20:	f000 fe22 	bl	8009868 <xputs>
 8008c24:	4836      	ldr	r0, [pc, #216]	; (8008d00 <ff_test_term+0x2d4>)
 8008c26:	4649      	mov	r1, r9
 8008c28:	2204      	movs	r2, #4
 8008c2a:	f000 fec8 	bl	80099be <put_dump>
				if (disk_ioctl(0, MMC_GET_SDSTAT, Buff) == RES_OK) {
 8008c2e:	2000      	movs	r0, #0
 8008c30:	210e      	movs	r1, #14
 8008c32:	4a33      	ldr	r2, [pc, #204]	; (8008d00 <ff_test_term+0x2d4>)
 8008c34:	f7fa fb4e 	bl	80032d4 <disk_ioctl>
 8008c38:	4681      	mov	r9, r0
 8008c3a:	2800      	cmp	r0, #0
 8008c3c:	f47f af03 	bne.w	8008a46 <ff_test_term+0x1a>
					xputs("SD Status:\n");
 8008c40:	4833      	ldr	r0, [pc, #204]	; (8008d10 <ff_test_term+0x2e4>)
 8008c42:	f000 fe11 	bl	8009868 <xputs>
					for (s1 = 0; s1 < 64; s1 += 16) put_dump(Buff+s1, s1, 16);
 8008c46:	f8cd 903c 	str.w	r9, [sp, #60]	; 0x3c
 8008c4a:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 8008d00 <ff_test_term+0x2d4>
 8008c4e:	e007      	b.n	8008c60 <ff_test_term+0x234>
 8008c50:	eb09 0001 	add.w	r0, r9, r1
 8008c54:	2210      	movs	r2, #16
 8008c56:	f000 feb2 	bl	80099be <put_dump>
 8008c5a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8008c5c:	3310      	adds	r3, #16
 8008c5e:	930f      	str	r3, [sp, #60]	; 0x3c
 8008c60:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8008c62:	293f      	cmp	r1, #63	; 0x3f
 8008c64:	d9f4      	bls.n	8008c50 <ff_test_term+0x224>
 8008c66:	e6ee      	b.n	8008a46 <ff_test_term+0x1a>
				break;
			}
			break;

		case 'b' :
			switch (*ptr++) {
 8008c68:	785a      	ldrb	r2, [r3, #1]
 8008c6a:	3302      	adds	r3, #2
 8008c6c:	2a66      	cmp	r2, #102	; 0x66
 8008c6e:	930b      	str	r3, [sp, #44]	; 0x2c
 8008c70:	f000 80c3 	beq.w	8008dfa <ff_test_term+0x3ce>
 8008c74:	d805      	bhi.n	8008c82 <ff_test_term+0x256>
 8008c76:	2a64      	cmp	r2, #100	; 0x64
 8008c78:	d00a      	beq.n	8008c90 <ff_test_term+0x264>
 8008c7a:	2a65      	cmp	r2, #101	; 0x65
 8008c7c:	f47f aee3 	bne.w	8008a46 <ff_test_term+0x1a>
 8008c80:	e048      	b.n	8008d14 <ff_test_term+0x2e8>
 8008c82:	2a72      	cmp	r2, #114	; 0x72
 8008c84:	f000 808b 	beq.w	8008d9e <ff_test_term+0x372>
 8008c88:	2a77      	cmp	r2, #119	; 0x77
 8008c8a:	f47f aedc 	bne.w	8008a46 <ff_test_term+0x1a>
 8008c8e:	e09c      	b.n	8008dca <ff_test_term+0x39e>
			case 'd' :	/* bd <addr> - Dump R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
 8008c90:	a80b      	add	r0, sp, #44	; 0x2c
 8008c92:	a90c      	add	r1, sp, #48	; 0x30
 8008c94:	f000 fd82 	bl	800979c <xatoi>
 8008c98:	2800      	cmp	r0, #0
 8008c9a:	f43f aed4 	beq.w	8008a46 <ff_test_term+0x1a>
				for (ptr=(char*)&Buff[p1], ofs = p1, cnt = 32; cnt; cnt--, ptr+=16, ofs+=16)
 8008c9e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008ca0:	4a17      	ldr	r2, [pc, #92]	; (8008d00 <ff_test_term+0x2d4>)
 8008ca2:	4699      	mov	r9, r3
 8008ca4:	189a      	adds	r2, r3, r2
 8008ca6:	2320      	movs	r3, #32
 8008ca8:	920b      	str	r2, [sp, #44]	; 0x2c
 8008caa:	9311      	str	r3, [sp, #68]	; 0x44
 8008cac:	e00c      	b.n	8008cc8 <ff_test_term+0x29c>
					put_dump((BYTE*)ptr, ofs, 16);
 8008cae:	4649      	mov	r1, r9
 8008cb0:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8008cb2:	2210      	movs	r2, #16
 8008cb4:	f000 fe83 	bl	80099be <put_dump>

		case 'b' :
			switch (*ptr++) {
			case 'd' :	/* bd <addr> - Dump R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
				for (ptr=(char*)&Buff[p1], ofs = p1, cnt = 32; cnt; cnt--, ptr+=16, ofs+=16)
 8008cb8:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8008cba:	f109 0910 	add.w	r9, r9, #16
 8008cbe:	3b01      	subs	r3, #1
 8008cc0:	9311      	str	r3, [sp, #68]	; 0x44
 8008cc2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008cc4:	3310      	adds	r3, #16
 8008cc6:	930b      	str	r3, [sp, #44]	; 0x2c
 8008cc8:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8008cca:	2b00      	cmp	r3, #0
 8008ccc:	d1ef      	bne.n	8008cae <ff_test_term+0x282>
 8008cce:	e6ba      	b.n	8008a46 <ff_test_term+0x1a>
 8008cd0:	08020012 	.word	0x08020012
 8008cd4:	20002198 	.word	0x20002198
 8008cd8:	20001efc 	.word	0x20001efc
 8008cdc:	0802002f 	.word	0x0802002f
 8008ce0:	08020036 	.word	0x08020036
 8008ce4:	0801fff9 	.word	0x0801fff9
 8008ce8:	0801fffc 	.word	0x0801fffc
 8008cec:	08020365 	.word	0x08020365
 8008cf0:	08020042 	.word	0x08020042
 8008cf4:	0802005b 	.word	0x0802005b
 8008cf8:	0802006c 	.word	0x0802006c
 8008cfc:	0802008b 	.word	0x0802008b
 8008d00:	200021c0 	.word	0x200021c0
 8008d04:	0802009d 	.word	0x0802009d
 8008d08:	080200a3 	.word	0x080200a3
 8008d0c:	080200a9 	.word	0x080200a9
 8008d10:	080200af 	.word	0x080200af
					put_dump((BYTE*)ptr, ofs, 16);
				break;

			case 'e' :	/* be <addr> [<data>] ... - Edit R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
 8008d14:	f10d 092c 	add.w	r9, sp, #44	; 0x2c
 8008d18:	4648      	mov	r0, r9
 8008d1a:	a90c      	add	r1, sp, #48	; 0x30
 8008d1c:	f000 fd3e 	bl	800979c <xatoi>
 8008d20:	2800      	cmp	r0, #0
 8008d22:	f43f ae90 	beq.w	8008a46 <ff_test_term+0x1a>
				if (xatoi(&ptr, &p2)) {
 8008d26:	f10d 0a34 	add.w	sl, sp, #52	; 0x34
 8008d2a:	4648      	mov	r0, r9
 8008d2c:	4651      	mov	r1, sl
 8008d2e:	f000 fd35 	bl	800979c <xatoi>
 8008d32:	b170      	cbz	r0, 8008d52 <ff_test_term+0x326>
					do {
						Buff[p1++] = (BYTE)p2;
 8008d34:	f8df b27c 	ldr.w	fp, [pc, #636]	; 8008fb4 <ff_test_term+0x588>
 8008d38:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008d3a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
					} while (xatoi(&ptr, &p2));
 8008d3c:	4648      	mov	r0, r9

			case 'e' :	/* be <addr> [<data>] ... - Edit R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
				if (xatoi(&ptr, &p2)) {
					do {
						Buff[p1++] = (BYTE)p2;
 8008d3e:	f80b 2003 	strb.w	r2, [fp, r3]
					} while (xatoi(&ptr, &p2));
 8008d42:	4651      	mov	r1, sl

			case 'e' :	/* be <addr> [<data>] ... - Edit R/W buffer */
				if (!xatoi(&ptr, &p1)) break;
				if (xatoi(&ptr, &p2)) {
					do {
						Buff[p1++] = (BYTE)p2;
 8008d44:	3301      	adds	r3, #1
 8008d46:	930c      	str	r3, [sp, #48]	; 0x30
					} while (xatoi(&ptr, &p2));
 8008d48:	f000 fd28 	bl	800979c <xatoi>
 8008d4c:	2800      	cmp	r0, #0
 8008d4e:	d1f3      	bne.n	8008d38 <ff_test_term+0x30c>
 8008d50:	e679      	b.n	8008a46 <ff_test_term+0x1a>
					break;
				}
				for (;;) {
					xprintf("%04X %02X-", (WORD)(p1), (WORD)Buff[p1]);
 8008d52:	f8df a260 	ldr.w	sl, [pc, #608]	; 8008fb4 <ff_test_term+0x588>
 8008d56:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008d58:	4893      	ldr	r0, [pc, #588]	; (8008fa8 <ff_test_term+0x57c>)
 8008d5a:	b299      	uxth	r1, r3
 8008d5c:	f81a 2003 	ldrb.w	r2, [sl, r3]
 8008d60:	f000 fdd2 	bl	8009908 <xprintf>
					get_line(linebuf, sizeof(linebuf));
 8008d64:	2178      	movs	r1, #120	; 0x78
 8008d66:	4891      	ldr	r0, [pc, #580]	; (8008fac <ff_test_term+0x580>)
 8008d68:	f000 fe54 	bl	8009a14 <get_line>
					ptr = linebuf;
					if (*ptr == '.') break;
 8008d6c:	7833      	ldrb	r3, [r6, #0]
					break;
				}
				for (;;) {
					xprintf("%04X %02X-", (WORD)(p1), (WORD)Buff[p1]);
					get_line(linebuf, sizeof(linebuf));
					ptr = linebuf;
 8008d6e:	960b      	str	r6, [sp, #44]	; 0x2c
					if (*ptr == '.') break;
 8008d70:	2b2e      	cmp	r3, #46	; 0x2e
 8008d72:	f43f ae68 	beq.w	8008a46 <ff_test_term+0x1a>
					if (*ptr < ' ') { p1++; continue; }
 8008d76:	2b1f      	cmp	r3, #31
 8008d78:	d801      	bhi.n	8008d7e <ff_test_term+0x352>
 8008d7a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008d7c:	e008      	b.n	8008d90 <ff_test_term+0x364>
					if (xatoi(&ptr, &p2))
 8008d7e:	4648      	mov	r0, r9
 8008d80:	a90d      	add	r1, sp, #52	; 0x34
 8008d82:	f000 fd0b 	bl	800979c <xatoi>
 8008d86:	b130      	cbz	r0, 8008d96 <ff_test_term+0x36a>
						Buff[p1++] = (BYTE)p2;
 8008d88:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008d8a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8008d8c:	f80a 2003 	strb.w	r2, [sl, r3]
 8008d90:	3301      	adds	r3, #1
 8008d92:	930c      	str	r3, [sp, #48]	; 0x30
 8008d94:	e7df      	b.n	8008d56 <ff_test_term+0x32a>
					else
						xputs("???\n");
 8008d96:	4886      	ldr	r0, [pc, #536]	; (8008fb0 <ff_test_term+0x584>)
 8008d98:	f000 fd66 	bl	8009868 <xputs>
 8008d9c:	e7db      	b.n	8008d56 <ff_test_term+0x32a>
				}
				break;

			case 'r' :	/* br <lba> [<num>] - Read disk into R/W buffer */
				if (!xatoi(&ptr, &p2)) break;
 8008d9e:	a80b      	add	r0, sp, #44	; 0x2c
 8008da0:	a90d      	add	r1, sp, #52	; 0x34
 8008da2:	f000 fcfb 	bl	800979c <xatoi>
 8008da6:	2800      	cmp	r0, #0
 8008da8:	f43f ae4d 	beq.w	8008a46 <ff_test_term+0x1a>
				if (!xatoi(&ptr, &p3)) p3 = 1;
 8008dac:	a80b      	add	r0, sp, #44	; 0x2c
 8008dae:	a90e      	add	r1, sp, #56	; 0x38
 8008db0:	f000 fcf4 	bl	800979c <xatoi>
 8008db4:	b908      	cbnz	r0, 8008dba <ff_test_term+0x38e>
 8008db6:	2301      	movs	r3, #1
 8008db8:	930e      	str	r3, [sp, #56]	; 0x38
				xprintf("rc=%u\n", (WORD)disk_read(0, Buff, p2, p3));
 8008dba:	2000      	movs	r0, #0
 8008dbc:	497d      	ldr	r1, [pc, #500]	; (8008fb4 <ff_test_term+0x588>)
 8008dbe:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8008dc0:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
 8008dc4:	f7fa f9de 	bl	8003184 <disk_read>
 8008dc8:	e014      	b.n	8008df4 <ff_test_term+0x3c8>
				break;

			case 'w' :	/* bw <lba> [<num>] - Write R/W buffer into disk */
				if (!xatoi(&ptr, &p2)) break;
 8008dca:	a80b      	add	r0, sp, #44	; 0x2c
 8008dcc:	a90d      	add	r1, sp, #52	; 0x34
 8008dce:	f000 fce5 	bl	800979c <xatoi>
 8008dd2:	2800      	cmp	r0, #0
 8008dd4:	f43f ae37 	beq.w	8008a46 <ff_test_term+0x1a>
				if (!xatoi(&ptr, &p3)) p3 = 1;
 8008dd8:	a80b      	add	r0, sp, #44	; 0x2c
 8008dda:	a90e      	add	r1, sp, #56	; 0x38
 8008ddc:	f000 fcde 	bl	800979c <xatoi>
 8008de0:	b908      	cbnz	r0, 8008de6 <ff_test_term+0x3ba>
 8008de2:	2301      	movs	r3, #1
 8008de4:	930e      	str	r3, [sp, #56]	; 0x38
				xprintf("rc=%u\n", (WORD)disk_write(0, Buff, p2, p3));
 8008de6:	2000      	movs	r0, #0
 8008de8:	4972      	ldr	r1, [pc, #456]	; (8008fb4 <ff_test_term+0x588>)
 8008dea:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8008dec:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
 8008df0:	f7fa fa0c 	bl	800320c <disk_write>
 8008df4:	4601      	mov	r1, r0
 8008df6:	4870      	ldr	r0, [pc, #448]	; (8008fb8 <ff_test_term+0x58c>)
 8008df8:	e6a7      	b.n	8008b4a <ff_test_term+0x11e>
				break;

			case 'f' :	/* bf <val> - Fill working buffer */
				if (!xatoi(&ptr, &p1)) break;
 8008dfa:	a80b      	add	r0, sp, #44	; 0x2c
 8008dfc:	a90c      	add	r1, sp, #48	; 0x30
 8008dfe:	f000 fccd 	bl	800979c <xatoi>
 8008e02:	2800      	cmp	r0, #0
 8008e04:	f43f ae1f 	beq.w	8008a46 <ff_test_term+0x1a>
				memset(Buff, (BYTE)p1, sizeof(Buff));
 8008e08:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
 8008e0c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8008e10:	4868      	ldr	r0, [pc, #416]	; (8008fb4 <ff_test_term+0x588>)
 8008e12:	f009 f89f 	bl	8011f54 <memset>
				break;
 8008e16:	e616      	b.n	8008a46 <ff_test_term+0x1a>

			}
			break;

		case 'f' :
			switch (*ptr++) {
 8008e18:	785a      	ldrb	r2, [r3, #1]
 8008e1a:	3302      	adds	r3, #2
 8008e1c:	930b      	str	r3, [sp, #44]	; 0x2c
 8008e1e:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
 8008e22:	2b19      	cmp	r3, #25
 8008e24:	f63f ae0f 	bhi.w	8008a46 <ff_test_term+0x1a>
 8008e28:	a201      	add	r2, pc, #4	; (adr r2, 8008e30 <ff_test_term+0x404>)
 8008e2a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008e2e:	bf00      	nop
 8008e30:	080092a9 	.word	0x080092a9
 8008e34:	08008a47 	.word	0x08008a47
 8008e38:	080090d9 	.word	0x080090d9
 8008e3c:	08009113 	.word	0x08009113
 8008e40:	080090e1 	.word	0x080090e1
 8008e44:	08008a47 	.word	0x08008a47
 8008e48:	08008a47 	.word	0x08008a47
 8008e4c:	08008a47 	.word	0x08008a47
 8008e50:	08008e99 	.word	0x08008e99
 8008e54:	08008a47 	.word	0x08008a47
 8008e58:	0800929b 	.word	0x0800929b
 8008e5c:	08008f59 	.word	0x08008f59
 8008e60:	08009479 	.word	0x08009479
 8008e64:	08009251 	.word	0x08009251
 8008e68:	080090b1 	.word	0x080090b1
 8008e6c:	08008a47 	.word	0x08008a47
 8008e70:	08008a47 	.word	0x08008a47
 8008e74:	08009171 	.word	0x08009171
 8008e78:	08008ea3 	.word	0x08008ea3
 8008e7c:	0800930d 	.word	0x0800930d
 8008e80:	08009281 	.word	0x08009281
 8008e84:	0800928f 	.word	0x0800928f
 8008e88:	080091d7 	.word	0x080091d7
 8008e8c:	0800939f 	.word	0x0800939f
 8008e90:	08008a47 	.word	0x08008a47
 8008e94:	080094c3 	.word	0x080094c3

			case 'i' :	/* fi - Force initialized the logical drive */
				put_rc(f_mount(0, &Fatfs[0]));
 8008e98:	2000      	movs	r0, #0
 8008e9a:	4948      	ldr	r1, [pc, #288]	; (8008fbc <ff_test_term+0x590>)
 8008e9c:	f7f8 fcc4 	bl	8001828 <f_mount>
 8008ea0:	e30b      	b.n	80094ba <ff_test_term+0xa8e>
				break;

			case 's' :	/* fs - Show logical drive status */
				res = f_getfree("", (DWORD*)&p2, &fs);
 8008ea2:	4847      	ldr	r0, [pc, #284]	; (8008fc0 <ff_test_term+0x594>)
 8008ea4:	a90d      	add	r1, sp, #52	; 0x34
 8008ea6:	aa12      	add	r2, sp, #72	; 0x48
 8008ea8:	f7f9 f8b4 	bl	8002014 <f_getfree>
				if (res) { put_rc(res); break; }
 8008eac:	b100      	cbz	r0, 8008eb0 <ff_test_term+0x484>
 8008eae:	e304      	b.n	80094ba <ff_test_term+0xa8e>
				xprintf("FAT type = %u (%s)\nBytes/Cluster = %lu\nNumber of FATs = %u\n"
						"Root DIR entries = %u\nSectors/FAT = %lu\nNumber of clusters = %lu\n"
						"FAT start (lba) = %lu\nDIR start (lba,clustor) = %lu\nData start (lba) = %lu\n\n",
						(WORD)fs->fs_type,
 8008eb0:	9812      	ldr	r0, [sp, #72]	; 0x48
 8008eb2:	7801      	ldrb	r1, [r0, #0]
				break;

			case 's' :	/* fs - Show logical drive status */
				res = f_getfree("", (DWORD*)&p2, &fs);
				if (res) { put_rc(res); break; }
				xprintf("FAT type = %u (%s)\nBytes/Cluster = %lu\nNumber of FATs = %u\n"
 8008eb4:	2901      	cmp	r1, #1
 8008eb6:	d005      	beq.n	8008ec4 <ff_test_term+0x498>
						"Root DIR entries = %u\nSectors/FAT = %lu\nNumber of clusters = %lu\n"
						"FAT start (lba) = %lu\nDIR start (lba,clustor) = %lu\nData start (lba) = %lu\n\n",
						(WORD)fs->fs_type,
						(fs->fs_type==FS_FAT12) ? "FAT12" : (fs->fs_type==FS_FAT16) ? "FAT16" : "FAT32",
 8008eb8:	4b42      	ldr	r3, [pc, #264]	; (8008fc4 <ff_test_term+0x598>)
 8008eba:	4a43      	ldr	r2, [pc, #268]	; (8008fc8 <ff_test_term+0x59c>)
 8008ebc:	2902      	cmp	r1, #2
 8008ebe:	bf08      	it	eq
 8008ec0:	461a      	moveq	r2, r3
 8008ec2:	e000      	b.n	8008ec6 <ff_test_term+0x49a>
				break;

			case 's' :	/* fs - Show logical drive status */
				res = f_getfree("", (DWORD*)&p2, &fs);
				if (res) { put_rc(res); break; }
				xprintf("FAT type = %u (%s)\nBytes/Cluster = %lu\nNumber of FATs = %u\n"
 8008ec4:	4a41      	ldr	r2, [pc, #260]	; (8008fcc <ff_test_term+0x5a0>)
 8008ec6:	f890 e003 	ldrb.w	lr, [r0, #3]
						"Root DIR entries = %u\nSectors/FAT = %lu\nNumber of clusters = %lu\n"
						"FAT start (lba) = %lu\nDIR start (lba,clustor) = %lu\nData start (lba) = %lu\n\n",
						(WORD)fs->fs_type,
						(fs->fs_type==FS_FAT12) ? "FAT12" : (fs->fs_type==FS_FAT16) ? "FAT16" : "FAT32",
						(DWORD)fs->csize * 512, (WORD)fs->n_fats,
 8008eca:	f890 c002 	ldrb.w	ip, [r0, #2]
				break;

			case 's' :	/* fs - Show logical drive status */
				res = f_getfree("", (DWORD*)&p2, &fs);
				if (res) { put_rc(res); break; }
				xprintf("FAT type = %u (%s)\nBytes/Cluster = %lu\nNumber of FATs = %u\n"
 8008ece:	f8cd e000 	str.w	lr, [sp]
 8008ed2:	f8b0 e008 	ldrh.w	lr, [r0, #8]
						(fs->fs_type==FS_FAT12) ? "FAT12" : (fs->fs_type==FS_FAT16) ? "FAT16" : "FAT32",
						(DWORD)fs->csize * 512, (WORD)fs->n_fats,
						fs->n_rootdir, fs->sects_fat, (DWORD)fs->max_clust - 2,
						fs->fatbase, fs->dirbase, fs->database
				);
				acc_size = acc_files = acc_dirs = 0;
 8008ed6:	f8df a10c 	ldr.w	sl, [pc, #268]	; 8008fe4 <ff_test_term+0x5b8>
				break;

			case 's' :	/* fs - Show logical drive status */
				res = f_getfree("", (DWORD*)&p2, &fs);
				if (res) { put_rc(res); break; }
				xprintf("FAT type = %u (%s)\nBytes/Cluster = %lu\nNumber of FATs = %u\n"
 8008eda:	f8cd e004 	str.w	lr, [sp, #4]
 8008ede:	6983      	ldr	r3, [r0, #24]
						(fs->fs_type==FS_FAT12) ? "FAT12" : (fs->fs_type==FS_FAT16) ? "FAT16" : "FAT32",
						(DWORD)fs->csize * 512, (WORD)fs->n_fats,
						fs->n_rootdir, fs->sects_fat, (DWORD)fs->max_clust - 2,
						fs->fatbase, fs->dirbase, fs->database
				);
				acc_size = acc_files = acc_dirs = 0;
 8008ee0:	f8df b104 	ldr.w	fp, [pc, #260]	; 8008fe8 <ff_test_term+0x5bc>
				break;

			case 's' :	/* fs - Show logical drive status */
				res = f_getfree("", (DWORD*)&p2, &fs);
				if (res) { put_rc(res); break; }
				xprintf("FAT type = %u (%s)\nBytes/Cluster = %lu\nNumber of FATs = %u\n"
 8008ee4:	9302      	str	r3, [sp, #8]
 8008ee6:	69c3      	ldr	r3, [r0, #28]
						(fs->fs_type==FS_FAT12) ? "FAT12" : (fs->fs_type==FS_FAT16) ? "FAT16" : "FAT32",
						(DWORD)fs->csize * 512, (WORD)fs->n_fats,
						fs->n_rootdir, fs->sects_fat, (DWORD)fs->max_clust - 2,
						fs->fatbase, fs->dirbase, fs->database
				);
				acc_size = acc_files = acc_dirs = 0;
 8008ee8:	f8df 9100 	ldr.w	r9, [pc, #256]	; 8008fec <ff_test_term+0x5c0>
				break;

			case 's' :	/* fs - Show logical drive status */
				res = f_getfree("", (DWORD*)&p2, &fs);
				if (res) { put_rc(res); break; }
				xprintf("FAT type = %u (%s)\nBytes/Cluster = %lu\nNumber of FATs = %u\n"
 8008eec:	f1a3 0e02 	sub.w	lr, r3, #2
 8008ef0:	f8cd e00c 	str.w	lr, [sp, #12]
 8008ef4:	6a03      	ldr	r3, [r0, #32]
 8008ef6:	9304      	str	r3, [sp, #16]
 8008ef8:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8008efa:	9305      	str	r3, [sp, #20]
 8008efc:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8008efe:	ea4f 234c 	mov.w	r3, ip, lsl #9
 8008f02:	9006      	str	r0, [sp, #24]
 8008f04:	4832      	ldr	r0, [pc, #200]	; (8008fd0 <ff_test_term+0x5a4>)
 8008f06:	f000 fcff 	bl	8009908 <xprintf>
						(fs->fs_type==FS_FAT12) ? "FAT12" : (fs->fs_type==FS_FAT16) ? "FAT16" : "FAT32",
						(DWORD)fs->csize * 512, (WORD)fs->n_fats,
						fs->n_rootdir, fs->sects_fat, (DWORD)fs->max_clust - 2,
						fs->fatbase, fs->dirbase, fs->database
				);
				acc_size = acc_files = acc_dirs = 0;
 8008f0a:	2300      	movs	r3, #0
 8008f0c:	f8aa 3000 	strh.w	r3, [sl]
 8008f10:	f8ab 3000 	strh.w	r3, [fp]
 8008f14:	f8c9 3000 	str.w	r3, [r9]
#if _USE_LFN
				Finfo.lfname = Lfname;
 8008f18:	4b2e      	ldr	r3, [pc, #184]	; (8008fd4 <ff_test_term+0x5a8>)
				Finfo.lfsize = sizeof(Lfname);
#endif
				res = scan_files(ptr);
 8008f1a:	980b      	ldr	r0, [sp, #44]	; 0x2c
						fs->n_rootdir, fs->sects_fat, (DWORD)fs->max_clust - 2,
						fs->fatbase, fs->dirbase, fs->database
				);
				acc_size = acc_files = acc_dirs = 0;
#if _USE_LFN
				Finfo.lfname = Lfname;
 8008f1c:	61a3      	str	r3, [r4, #24]
				Finfo.lfsize = sizeof(Lfname);
 8008f1e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008f22:	61e3      	str	r3, [r4, #28]
#endif
				res = scan_files(ptr);
 8008f24:	f7ff fd3a 	bl	800899c <scan_files>
				if (res) { put_rc(res); break; }
 8008f28:	b100      	cbz	r0, 8008f2c <ff_test_term+0x500>
 8008f2a:	e2c6      	b.n	80094ba <ff_test_term+0xa8e>
				xprintf("%u files, %lu bytes.\n%u folders.\n"
						"%lu KB total disk space.\n%lu KB available.\n",
						acc_files, acc_size, acc_dirs,
						(fs->max_clust - 2) * (fs->csize / 2), p2 * (fs->csize / 2)
 8008f2c:	9812      	ldr	r0, [sp, #72]	; 0x48
				Finfo.lfname = Lfname;
				Finfo.lfsize = sizeof(Lfname);
#endif
				res = scan_files(ptr);
				if (res) { put_rc(res); break; }
				xprintf("%u files, %lu bytes.\n%u folders.\n"
 8008f2e:	f8bb 1000 	ldrh.w	r1, [fp]
 8008f32:	7882      	ldrb	r2, [r0, #2]
						"%lu KB total disk space.\n%lu KB available.\n",
						acc_files, acc_size, acc_dirs,
						(fs->max_clust - 2) * (fs->csize / 2), p2 * (fs->csize / 2)
 8008f34:	69c0      	ldr	r0, [r0, #28]
				Finfo.lfname = Lfname;
				Finfo.lfsize = sizeof(Lfname);
#endif
				res = scan_files(ptr);
				if (res) { put_rc(res); break; }
				xprintf("%u files, %lu bytes.\n%u folders.\n"
 8008f36:	0852      	lsrs	r2, r2, #1
						"%lu KB total disk space.\n%lu KB available.\n",
						acc_files, acc_size, acc_dirs,
						(fs->max_clust - 2) * (fs->csize / 2), p2 * (fs->csize / 2)
 8008f38:	3802      	subs	r0, #2
				Finfo.lfname = Lfname;
				Finfo.lfsize = sizeof(Lfname);
#endif
				res = scan_files(ptr);
				if (res) { put_rc(res); break; }
				xprintf("%u files, %lu bytes.\n%u folders.\n"
 8008f3a:	4350      	muls	r0, r2
 8008f3c:	f8ba 3000 	ldrh.w	r3, [sl]
 8008f40:	9000      	str	r0, [sp, #0]
 8008f42:	980d      	ldr	r0, [sp, #52]	; 0x34
 8008f44:	4342      	muls	r2, r0
 8008f46:	9201      	str	r2, [sp, #4]
 8008f48:	4823      	ldr	r0, [pc, #140]	; (8008fd8 <ff_test_term+0x5ac>)
 8008f4a:	f8d9 2000 	ldr.w	r2, [r9]
 8008f4e:	f000 fcdb 	bl	8009908 <xprintf>
						"%lu KB total disk space.\n%lu KB available.\n",
						acc_files, acc_size, acc_dirs,
						(fs->max_clust - 2) * (fs->csize / 2), p2 * (fs->csize / 2)
				);
				break;
 8008f52:	e578      	b.n	8008a46 <ff_test_term+0x1a>

			case 'l' :	/* fl [<path>] - Directory listing */
				while (*ptr == ' ') ptr++;
 8008f54:	3101      	adds	r1, #1
 8008f56:	910b      	str	r1, [sp, #44]	; 0x2c
 8008f58:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8008f5a:	780b      	ldrb	r3, [r1, #0]
 8008f5c:	2b20      	cmp	r3, #32
 8008f5e:	d0f9      	beq.n	8008f54 <ff_test_term+0x528>
				res = f_opendir(&Dir, ptr);
 8008f60:	481e      	ldr	r0, [pc, #120]	; (8008fdc <ff_test_term+0x5b0>)
 8008f62:	f7f8 ffcc 	bl	8001efe <f_opendir>
				if (res) { put_rc(res); break; }
 8008f66:	b100      	cbz	r0, 8008f6a <ff_test_term+0x53e>
 8008f68:	e2a7      	b.n	80094ba <ff_test_term+0xa8e>
				p1 = s1 = s2 = 0;
				for(;;) {
#if _USE_LFN
					Finfo.lfname = Lfname;
 8008f6a:	f8df 9068 	ldr.w	r9, [pc, #104]	; 8008fd4 <ff_test_term+0x5a8>

			case 'l' :	/* fl [<path>] - Directory listing */
				while (*ptr == ' ') ptr++;
				res = f_opendir(&Dir, ptr);
				if (res) { put_rc(res); break; }
				p1 = s1 = s2 = 0;
 8008f6e:	9010      	str	r0, [sp, #64]	; 0x40
 8008f70:	900f      	str	r0, [sp, #60]	; 0x3c
 8008f72:	900c      	str	r0, [sp, #48]	; 0x30
				for(;;) {
#if _USE_LFN
					Finfo.lfname = Lfname;
					Finfo.lfsize = sizeof(Lfname);
 8008f74:	f44f 7a00 	mov.w	sl, #512	; 0x200
#endif
					res = f_readdir(&Dir, &Finfo);
 8008f78:	4818      	ldr	r0, [pc, #96]	; (8008fdc <ff_test_term+0x5b0>)
 8008f7a:	4919      	ldr	r1, [pc, #100]	; (8008fe0 <ff_test_term+0x5b4>)
				res = f_opendir(&Dir, ptr);
				if (res) { put_rc(res); break; }
				p1 = s1 = s2 = 0;
				for(;;) {
#if _USE_LFN
					Finfo.lfname = Lfname;
 8008f7c:	f8c4 9018 	str.w	r9, [r4, #24]
					Finfo.lfsize = sizeof(Lfname);
 8008f80:	f8c4 a01c 	str.w	sl, [r4, #28]
#endif
					res = f_readdir(&Dir, &Finfo);
 8008f84:	f7f8 fff4 	bl	8001f70 <f_readdir>
					if ((res != FR_OK) || !Finfo.fname[0]) break;
 8008f88:	2800      	cmp	r0, #0
 8008f8a:	d17b      	bne.n	8009084 <ff_test_term+0x658>
 8008f8c:	7a63      	ldrb	r3, [r4, #9]
 8008f8e:	2b00      	cmp	r3, #0
 8008f90:	d078      	beq.n	8009084 <ff_test_term+0x658>
					if (Finfo.fattrib & AM_DIR) {
 8008f92:	7a20      	ldrb	r0, [r4, #8]
 8008f94:	f000 0310 	and.w	r3, r0, #16
 8008f98:	b2db      	uxtb	r3, r3
 8008f9a:	b34b      	cbz	r3, 8008ff0 <ff_test_term+0x5c4>
						s2++;
 8008f9c:	9b10      	ldr	r3, [sp, #64]	; 0x40
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s",
 8008f9e:	2144      	movs	r1, #68	; 0x44
					Finfo.lfsize = sizeof(Lfname);
#endif
					res = f_readdir(&Dir, &Finfo);
					if ((res != FR_OK) || !Finfo.fname[0]) break;
					if (Finfo.fattrib & AM_DIR) {
						s2++;
 8008fa0:	3301      	adds	r3, #1
 8008fa2:	9310      	str	r3, [sp, #64]	; 0x40
 8008fa4:	e02c      	b.n	8009000 <ff_test_term+0x5d4>
 8008fa6:	bf00      	nop
 8008fa8:	080200bb 	.word	0x080200bb
 8008fac:	20001efc 	.word	0x20001efc
 8008fb0:	080200c6 	.word	0x080200c6
 8008fb4:	200021c0 	.word	0x200021c0
 8008fb8:	080200cb 	.word	0x080200cb
 8008fbc:	20001ccc 	.word	0x20001ccc
 8008fc0:	0802019a 	.word	0x0802019a
 8008fc4:	0802000c 	.word	0x0802000c
 8008fc8:	08020000 	.word	0x08020000
 8008fcc:	08020006 	.word	0x08020006
 8008fd0:	080200d2 	.word	0x080200d2
 8008fd4:	200033e4 	.word	0x200033e4
 8008fd8:	0802019b 	.word	0x0802019b
 8008fdc:	200035e4 	.word	0x200035e4
 8008fe0:	20002198 	.word	0x20002198
 8008fe4:	200021b8 	.word	0x200021b8
 8008fe8:	200021ba 	.word	0x200021ba
 8008fec:	20003608 	.word	0x20003608
					} else {
						s1++; p1 += Finfo.fsize;
 8008ff0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8008ff2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8008ff4:	3301      	adds	r3, #1
 8008ff6:	930f      	str	r3, [sp, #60]	; 0x3c
 8008ff8:	6823      	ldr	r3, [r4, #0]
					}
					xprintf("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s",
 8008ffa:	212d      	movs	r1, #45	; 0x2d
					res = f_readdir(&Dir, &Finfo);
					if ((res != FR_OK) || !Finfo.fname[0]) break;
					if (Finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
 8008ffc:	18d3      	adds	r3, r2, r3
 8008ffe:	930c      	str	r3, [sp, #48]	; 0x30
					}
					xprintf("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s",
 8009000:	f010 0f01 	tst.w	r0, #1
 8009004:	f000 0302 	and.w	r3, r0, #2
 8009008:	f000 0b04 	and.w	fp, r0, #4
 800900c:	f000 0020 	and.w	r0, r0, #32
							(Finfo.fattrib & AM_DIR) ? 'D' : '-',
							(Finfo.fattrib & AM_RDO) ? 'R' : '-',
							(Finfo.fattrib & AM_HID) ? 'H' : '-',
							(Finfo.fattrib & AM_SYS) ? 'S' : '-',
							(Finfo.fattrib & AM_ARC) ? 'A' : '-',
							(Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
 8009010:	f8b4 e004 	ldrh.w	lr, [r4, #4]
					if (Finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s",
 8009014:	b2c0      	uxtb	r0, r0
 8009016:	bf0c      	ite	eq
 8009018:	222d      	moveq	r2, #45	; 0x2d
 800901a:	2252      	movne	r2, #82	; 0x52
 800901c:	2800      	cmp	r0, #0
 800901e:	bf0c      	ite	eq
 8009020:	202d      	moveq	r0, #45	; 0x2d
 8009022:	2041      	movne	r0, #65	; 0x41
 8009024:	9001      	str	r0, [sp, #4]
							(Finfo.fattrib & AM_DIR) ? 'D' : '-',
							(Finfo.fattrib & AM_RDO) ? 'R' : '-',
							(Finfo.fattrib & AM_HID) ? 'H' : '-',
							(Finfo.fattrib & AM_SYS) ? 'S' : '-',
							(Finfo.fattrib & AM_ARC) ? 'A' : '-',
							(Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
 8009026:	ea4f 205e 	mov.w	r0, lr, lsr #9
					if (Finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s",
 800902a:	f200 70bc 	addw	r0, r0, #1980	; 0x7bc
							(Finfo.fattrib & AM_RDO) ? 'R' : '-',
							(Finfo.fattrib & AM_HID) ? 'H' : '-',
							(Finfo.fattrib & AM_SYS) ? 'S' : '-',
							(Finfo.fattrib & AM_ARC) ? 'A' : '-',
							(Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
							(Finfo.ftime >> 11), (Finfo.ftime >> 5) & 63,
 800902e:	f8b4 c006 	ldrh.w	ip, [r4, #6]
					if (Finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += Finfo.fsize;
					}
					xprintf("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s",
 8009032:	9002      	str	r0, [sp, #8]
 8009034:	f3ce 1043 	ubfx	r0, lr, #5, #4
 8009038:	9003      	str	r0, [sp, #12]
 800903a:	f00e 001f 	and.w	r0, lr, #31
 800903e:	9004      	str	r0, [sp, #16]
 8009040:	ea4f 20dc 	mov.w	r0, ip, lsr #11
 8009044:	9005      	str	r0, [sp, #20]
 8009046:	f3cc 1045 	ubfx	r0, ip, #5, #6
 800904a:	9006      	str	r0, [sp, #24]
 800904c:	fa5f fb8b 	uxtb.w	fp, fp
 8009050:	6820      	ldr	r0, [r4, #0]
 8009052:	f1bb 0f00 	cmp.w	fp, #0
 8009056:	bf0c      	ite	eq
 8009058:	f04f 0b2d 	moveq.w	fp, #45	; 0x2d
 800905c:	f04f 0b53 	movne.w	fp, #83	; 0x53
 8009060:	b2db      	uxtb	r3, r3
 8009062:	9007      	str	r0, [sp, #28]
 8009064:	f8cd b000 	str.w	fp, [sp]
 8009068:	f8cd 8020 	str.w	r8, [sp, #32]
 800906c:	489c      	ldr	r0, [pc, #624]	; (80092e0 <ff_test_term+0x8b4>)
 800906e:	2b00      	cmp	r3, #0
 8009070:	bf0c      	ite	eq
 8009072:	232d      	moveq	r3, #45	; 0x2d
 8009074:	2348      	movne	r3, #72	; 0x48
 8009076:	f000 fc47 	bl	8009908 <xprintf>
							(Finfo.fattrib & AM_ARC) ? 'A' : '-',
							(Finfo.fdate >> 9) + 1980, (Finfo.fdate >> 5) & 15, Finfo.fdate & 31,
							(Finfo.ftime >> 11), (Finfo.ftime >> 5) & 63,
							Finfo.fsize, &(Finfo.fname[0]));
#if _USE_LFN
					xprintf("  %s\n", Lfname);
 800907a:	489a      	ldr	r0, [pc, #616]	; (80092e4 <ff_test_term+0x8b8>)
 800907c:	499a      	ldr	r1, [pc, #616]	; (80092e8 <ff_test_term+0x8bc>)
 800907e:	f000 fc43 	bl	8009908 <xprintf>
#else
					xputc('\n');
#endif
				}
 8009082:	e779      	b.n	8008f78 <ff_test_term+0x54c>
				xprintf("%4u File(s),%10lu bytes total\n%4u Dir(s)", s1, p1, s2);
 8009084:	4899      	ldr	r0, [pc, #612]	; (80092ec <ff_test_term+0x8c0>)
 8009086:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8009088:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800908a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800908c:	f000 fc3c 	bl	8009908 <xprintf>
				if (f_getfree(ptr, (DWORD*)&p1, &fs) == FR_OK)
 8009090:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8009092:	a90c      	add	r1, sp, #48	; 0x30
 8009094:	aa12      	add	r2, sp, #72	; 0x48
 8009096:	f7f8 ffbd 	bl	8002014 <f_getfree>
 800909a:	2800      	cmp	r0, #0
 800909c:	f47f acd3 	bne.w	8008a46 <ff_test_term+0x1a>
					xprintf(", %10lu bytes free\n", p1 * fs->csize * 512);
 80090a0:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80090a2:	4893      	ldr	r0, [pc, #588]	; (80092f0 <ff_test_term+0x8c4>)
 80090a4:	789a      	ldrb	r2, [r3, #2]
 80090a6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80090a8:	fb03 f102 	mul.w	r1, r3, r2
 80090ac:	0249      	lsls	r1, r1, #9
 80090ae:	e54c      	b.n	8008b4a <ff_test_term+0x11e>
				break;

			case 'o' :	/* fo <mode> <file> - Open a file */
				if (!xatoi(&ptr, &p1)) break;
 80090b0:	a80b      	add	r0, sp, #44	; 0x2c
 80090b2:	a90c      	add	r1, sp, #48	; 0x30
 80090b4:	f000 fb72 	bl	800979c <xatoi>
 80090b8:	2800      	cmp	r0, #0
 80090ba:	f43f acc4 	beq.w	8008a46 <ff_test_term+0x1a>
 80090be:	e001      	b.n	80090c4 <ff_test_term+0x698>
				while (*ptr == ' ') ptr++;
 80090c0:	3101      	adds	r1, #1
 80090c2:	910b      	str	r1, [sp, #44]	; 0x2c
 80090c4:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80090c6:	780b      	ldrb	r3, [r1, #0]
 80090c8:	2b20      	cmp	r3, #32
 80090ca:	d0f9      	beq.n	80090c0 <ff_test_term+0x694>
				put_rc(f_open(&File1, ptr, (BYTE)p1));
 80090cc:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
 80090d0:	4888      	ldr	r0, [pc, #544]	; (80092f4 <ff_test_term+0x8c8>)
 80090d2:	f7f8 fbb9 	bl	8001848 <f_open>
 80090d6:	e1f0      	b.n	80094ba <ff_test_term+0xa8e>
				break;

			case 'c' :	/* fc - Close a file */
				put_rc(f_close(&File1));
 80090d8:	4886      	ldr	r0, [pc, #536]	; (80092f4 <ff_test_term+0x8c8>)
 80090da:	f7f8 fe58 	bl	8001d8e <f_close>
 80090de:	e1ec      	b.n	80094ba <ff_test_term+0xa8e>
				break;

			case 'e' :	/* fe - Seek file pointer */
				if (!xatoi(&ptr, &p1)) break;
 80090e0:	a80b      	add	r0, sp, #44	; 0x2c
 80090e2:	a90c      	add	r1, sp, #48	; 0x30
 80090e4:	f000 fb5a 	bl	800979c <xatoi>
 80090e8:	2800      	cmp	r0, #0
 80090ea:	f43f acac 	beq.w	8008a46 <ff_test_term+0x1a>
				res = f_lseek(&File1, p1);
 80090ee:	f8df 9204 	ldr.w	r9, [pc, #516]	; 80092f4 <ff_test_term+0x8c8>
 80090f2:	990c      	ldr	r1, [sp, #48]	; 0x30
 80090f4:	4648      	mov	r0, r9
 80090f6:	f7f8 fe51 	bl	8001d9c <f_lseek>
 80090fa:	4682      	mov	sl, r0
				put_rc(res);
 80090fc:	f7ff fc36 	bl	800896c <put_rc>
				if (res == FR_OK)
 8009100:	f1ba 0f00 	cmp.w	sl, #0
 8009104:	f47f ac9f 	bne.w	8008a46 <ff_test_term+0x1a>
					xprintf("fptr=%lu(0x%lX)\n", File1.fptr, File1.fptr);
 8009108:	f8d9 1008 	ldr.w	r1, [r9, #8]
 800910c:	487a      	ldr	r0, [pc, #488]	; (80092f8 <ff_test_term+0x8cc>)
 800910e:	460a      	mov	r2, r1
 8009110:	e05e      	b.n	80091d0 <ff_test_term+0x7a4>
				break;

			case 'd' :	/* fd <len> - read and dump file from current fp */
				if (!xatoi(&ptr, &p1)) break;
 8009112:	a80b      	add	r0, sp, #44	; 0x2c
 8009114:	a90c      	add	r1, sp, #48	; 0x30
 8009116:	f000 fb41 	bl	800979c <xatoi>
 800911a:	2800      	cmp	r0, #0
 800911c:	f43f ac93 	beq.w	8008a46 <ff_test_term+0x1a>
				ofs = File1.fptr;
 8009120:	4b74      	ldr	r3, [pc, #464]	; (80092f4 <ff_test_term+0x8c8>)
				while (p1) {
					if ((UINT)p1 >= 16) { cnt = 16; p1 -= 16; }
					else 				{ cnt = p1; p1 = 0; }
 8009122:	f04f 0a00 	mov.w	sl, #0
					xprintf("fptr=%lu(0x%lX)\n", File1.fptr, File1.fptr);
				break;

			case 'd' :	/* fd <len> - read and dump file from current fp */
				if (!xatoi(&ptr, &p1)) break;
				ofs = File1.fptr;
 8009126:	f8d3 9008 	ldr.w	r9, [r3, #8]
				while (p1) {
					if ((UINT)p1 >= 16) { cnt = 16; p1 -= 16; }
 800912a:	f04f 0b10 	mov.w	fp, #16
				break;

			case 'd' :	/* fd <len> - read and dump file from current fp */
				if (!xatoi(&ptr, &p1)) break;
				ofs = File1.fptr;
				while (p1) {
 800912e:	e01b      	b.n	8009168 <ff_test_term+0x73c>
					if ((UINT)p1 >= 16) { cnt = 16; p1 -= 16; }
 8009130:	2b0f      	cmp	r3, #15
 8009132:	d904      	bls.n	800913e <ff_test_term+0x712>
 8009134:	3b10      	subs	r3, #16
 8009136:	f8cd b044 	str.w	fp, [sp, #68]	; 0x44
 800913a:	930c      	str	r3, [sp, #48]	; 0x30
 800913c:	e002      	b.n	8009144 <ff_test_term+0x718>
					else 				{ cnt = p1; p1 = 0; }
 800913e:	9311      	str	r3, [sp, #68]	; 0x44
 8009140:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
					res = f_read(&File1, Buff, cnt, &cnt);
 8009144:	486b      	ldr	r0, [pc, #428]	; (80092f4 <ff_test_term+0x8c8>)
 8009146:	496d      	ldr	r1, [pc, #436]	; (80092fc <ff_test_term+0x8d0>)
 8009148:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800914a:	ab11      	add	r3, sp, #68	; 0x44
 800914c:	f7f8 fc36 	bl	80019bc <f_read>
					if (res != FR_OK) { put_rc(res); break; }
 8009150:	b100      	cbz	r0, 8009154 <ff_test_term+0x728>
 8009152:	e1b2      	b.n	80094ba <ff_test_term+0xa8e>
					if (!cnt) break;
 8009154:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8009156:	2a00      	cmp	r2, #0
 8009158:	f43f ac75 	beq.w	8008a46 <ff_test_term+0x1a>
					put_dump(Buff, ofs, cnt);
 800915c:	4649      	mov	r1, r9
 800915e:	4867      	ldr	r0, [pc, #412]	; (80092fc <ff_test_term+0x8d0>)
 8009160:	f000 fc2d 	bl	80099be <put_dump>
					ofs += 16;
 8009164:	f109 0910 	add.w	r9, r9, #16
				break;

			case 'd' :	/* fd <len> - read and dump file from current fp */
				if (!xatoi(&ptr, &p1)) break;
				ofs = File1.fptr;
				while (p1) {
 8009168:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800916a:	2b00      	cmp	r3, #0
 800916c:	d1e0      	bne.n	8009130 <ff_test_term+0x704>
 800916e:	e46a      	b.n	8008a46 <ff_test_term+0x1a>
					ofs += 16;
				}
				break;

			case 'r' :	/* fr <len> - read file */
				if (!xatoi(&ptr, &p1)) break;
 8009170:	a80b      	add	r0, sp, #44	; 0x2c
 8009172:	a90c      	add	r1, sp, #48	; 0x30
 8009174:	f000 fb12 	bl	800979c <xatoi>
 8009178:	2800      	cmp	r0, #0
 800917a:	f43f ac64 	beq.w	8008a46 <ff_test_term+0x1a>
				p2 = 0;
				Timer = 0;
 800917e:	4a60      	ldr	r2, [pc, #384]	; (8009300 <ff_test_term+0x8d4>)
				}
				break;

			case 'r' :	/* fr <len> - read file */
				if (!xatoi(&ptr, &p1)) break;
				p2 = 0;
 8009180:	2300      	movs	r3, #0
 8009182:	930d      	str	r3, [sp, #52]	; 0x34
				Timer = 0;
 8009184:	6013      	str	r3, [r2, #0]
				while (p1) {
					if ((UINT)p1 >= blen) {
						cnt = blen; p1 -= blen;
					} else {
						cnt = p1; p1 = 0;
 8009186:	4699      	mov	r9, r3

			case 'r' :	/* fr <len> - read file */
				if (!xatoi(&ptr, &p1)) break;
				p2 = 0;
				Timer = 0;
				while (p1) {
 8009188:	e019      	b.n	80091be <ff_test_term+0x792>
					if ((UINT)p1 >= blen) {
 800918a:	42ab      	cmp	r3, r5
 800918c:	d303      	bcc.n	8009196 <ff_test_term+0x76a>
						cnt = blen; p1 -= blen;
 800918e:	1b5b      	subs	r3, r3, r5
 8009190:	9511      	str	r5, [sp, #68]	; 0x44
 8009192:	930c      	str	r3, [sp, #48]	; 0x30
 8009194:	e002      	b.n	800919c <ff_test_term+0x770>
					} else {
						cnt = p1; p1 = 0;
 8009196:	9311      	str	r3, [sp, #68]	; 0x44
 8009198:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
					}
					res = f_read(&File1, Buff, cnt, &s2);
 800919c:	4855      	ldr	r0, [pc, #340]	; (80092f4 <ff_test_term+0x8c8>)
 800919e:	4957      	ldr	r1, [pc, #348]	; (80092fc <ff_test_term+0x8d0>)
 80091a0:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80091a2:	ab10      	add	r3, sp, #64	; 0x40
 80091a4:	f7f8 fc0a 	bl	80019bc <f_read>
					if (res != FR_OK) { put_rc(res); break; }
 80091a8:	b110      	cbz	r0, 80091b0 <ff_test_term+0x784>
 80091aa:	f7ff fbdf 	bl	800896c <put_rc>
 80091ae:	e009      	b.n	80091c4 <ff_test_term+0x798>
					p2 += s2;
 80091b0:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80091b2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80091b4:	189b      	adds	r3, r3, r2
 80091b6:	930d      	str	r3, [sp, #52]	; 0x34
					if (cnt != s2) break;
 80091b8:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80091ba:	4293      	cmp	r3, r2
 80091bc:	d102      	bne.n	80091c4 <ff_test_term+0x798>

			case 'r' :	/* fr <len> - read file */
				if (!xatoi(&ptr, &p1)) break;
				p2 = 0;
				Timer = 0;
				while (p1) {
 80091be:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80091c0:	2b00      	cmp	r3, #0
 80091c2:	d1e2      	bne.n	800918a <ff_test_term+0x75e>
					res = f_read(&File1, Buff, cnt, &s2);
					if (res != FR_OK) { put_rc(res); break; }
					p2 += s2;
					if (cnt != s2) break;
				}
				xprintf("%lu bytes read with %lu kB/sec.\n", p2, p2 / Timer);
 80091c4:	4b4e      	ldr	r3, [pc, #312]	; (8009300 <ff_test_term+0x8d4>)
 80091c6:	484f      	ldr	r0, [pc, #316]	; (8009304 <ff_test_term+0x8d8>)
 80091c8:	681a      	ldr	r2, [r3, #0]
 80091ca:	990d      	ldr	r1, [sp, #52]	; 0x34
 80091cc:	fbb1 f2f2 	udiv	r2, r1, r2
 80091d0:	f000 fb9a 	bl	8009908 <xprintf>
				break;
 80091d4:	e437      	b.n	8008a46 <ff_test_term+0x1a>

			case 'w' :	/* fw <len> <val> - write file */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
 80091d6:	a80b      	add	r0, sp, #44	; 0x2c
 80091d8:	a90c      	add	r1, sp, #48	; 0x30
 80091da:	f000 fadf 	bl	800979c <xatoi>
 80091de:	2800      	cmp	r0, #0
 80091e0:	f43f ac31 	beq.w	8008a46 <ff_test_term+0x1a>
 80091e4:	a80b      	add	r0, sp, #44	; 0x2c
 80091e6:	a90d      	add	r1, sp, #52	; 0x34
 80091e8:	f000 fad8 	bl	800979c <xatoi>
 80091ec:	2800      	cmp	r0, #0
 80091ee:	f43f ac2a 	beq.w	8008a46 <ff_test_term+0x1a>
				memset(Buff, (BYTE)p2, blen);
 80091f2:	462a      	mov	r2, r5
 80091f4:	4841      	ldr	r0, [pc, #260]	; (80092fc <ff_test_term+0x8d0>)
 80091f6:	f89d 1034 	ldrb.w	r1, [sp, #52]	; 0x34
 80091fa:	f008 feab 	bl	8011f54 <memset>
				p2 = 0;
				Timer = 0;
 80091fe:	4a40      	ldr	r2, [pc, #256]	; (8009300 <ff_test_term+0x8d4>)
				break;

			case 'w' :	/* fw <len> <val> - write file */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
				memset(Buff, (BYTE)p2, blen);
				p2 = 0;
 8009200:	2300      	movs	r3, #0
 8009202:	930d      	str	r3, [sp, #52]	; 0x34
				Timer = 0;
 8009204:	6013      	str	r3, [r2, #0]
				while (p1) {
					if ((UINT)p1 >= blen) {
						cnt = blen; p1 -= blen;
					} else {
						cnt = p1; p1 = 0;
 8009206:	4699      	mov	r9, r3
			case 'w' :	/* fw <len> <val> - write file */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
				memset(Buff, (BYTE)p2, blen);
				p2 = 0;
				Timer = 0;
				while (p1) {
 8009208:	e019      	b.n	800923e <ff_test_term+0x812>
					if ((UINT)p1 >= blen) {
 800920a:	42ab      	cmp	r3, r5
 800920c:	d303      	bcc.n	8009216 <ff_test_term+0x7ea>
						cnt = blen; p1 -= blen;
 800920e:	1b5b      	subs	r3, r3, r5
 8009210:	9511      	str	r5, [sp, #68]	; 0x44
 8009212:	930c      	str	r3, [sp, #48]	; 0x30
 8009214:	e002      	b.n	800921c <ff_test_term+0x7f0>
					} else {
						cnt = p1; p1 = 0;
 8009216:	9311      	str	r3, [sp, #68]	; 0x44
 8009218:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
					}
					res = f_write(&File1, Buff, cnt, &s2);
 800921c:	4835      	ldr	r0, [pc, #212]	; (80092f4 <ff_test_term+0x8c8>)
 800921e:	4937      	ldr	r1, [pc, #220]	; (80092fc <ff_test_term+0x8d0>)
 8009220:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8009222:	ab10      	add	r3, sp, #64	; 0x40
 8009224:	f7f8 fc86 	bl	8001b34 <f_write>
					if (res != FR_OK) { put_rc(res); break; }
 8009228:	b110      	cbz	r0, 8009230 <ff_test_term+0x804>
 800922a:	f7ff fb9f 	bl	800896c <put_rc>
 800922e:	e009      	b.n	8009244 <ff_test_term+0x818>
					p2 += s2;
 8009230:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8009232:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8009234:	189b      	adds	r3, r3, r2
 8009236:	930d      	str	r3, [sp, #52]	; 0x34
					if (cnt != s2) break;
 8009238:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800923a:	4293      	cmp	r3, r2
 800923c:	d102      	bne.n	8009244 <ff_test_term+0x818>
			case 'w' :	/* fw <len> <val> - write file */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
				memset(Buff, (BYTE)p2, blen);
				p2 = 0;
				Timer = 0;
				while (p1) {
 800923e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009240:	2b00      	cmp	r3, #0
 8009242:	d1e2      	bne.n	800920a <ff_test_term+0x7de>
					res = f_write(&File1, Buff, cnt, &s2);
					if (res != FR_OK) { put_rc(res); break; }
					p2 += s2;
					if (cnt != s2) break;
				}
				xprintf("%lu bytes written with %lu kB/sec.\n", p2, p2 / Timer);
 8009244:	4b2e      	ldr	r3, [pc, #184]	; (8009300 <ff_test_term+0x8d4>)
 8009246:	4830      	ldr	r0, [pc, #192]	; (8009308 <ff_test_term+0x8dc>)
 8009248:	681a      	ldr	r2, [r3, #0]
 800924a:	e7be      	b.n	80091ca <ff_test_term+0x79e>
				break;

			case 'n' :	/* fn <old_name> <new_name> - Change file/dir name */
				while (*ptr == ' ') ptr++;
 800924c:	3001      	adds	r0, #1
 800924e:	900b      	str	r0, [sp, #44]	; 0x2c
 8009250:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8009252:	7803      	ldrb	r3, [r0, #0]
 8009254:	2b20      	cmp	r3, #32
 8009256:	d0f9      	beq.n	800924c <ff_test_term+0x820>
				ptr2 = strchr(ptr, ' ');
 8009258:	2120      	movs	r1, #32
 800925a:	f009 fac1 	bl	80127e0 <strchr>
				if (!ptr2) break;
 800925e:	2800      	cmp	r0, #0
 8009260:	f43f abf1 	beq.w	8008a46 <ff_test_term+0x1a>
				*ptr2++ = 0;
 8009264:	2300      	movs	r3, #0
 8009266:	f800 3b01 	strb.w	r3, [r0], #1
 800926a:	4601      	mov	r1, r0
				while (*ptr2 == ' ') ptr2++;
 800926c:	780b      	ldrb	r3, [r1, #0]
 800926e:	3001      	adds	r0, #1
 8009270:	2b20      	cmp	r3, #32
 8009272:	d0fa      	beq.n	800926a <ff_test_term+0x83e>
				put_rc(f_rename(ptr, ptr2));
 8009274:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8009276:	f7f9 f91d 	bl	80024b4 <f_rename>
 800927a:	e11e      	b.n	80094ba <ff_test_term+0xa8e>
				break;

			case 'u' :	/* fu <name> - Unlink a file or dir */
				while (*ptr == ' ') ptr++;
 800927c:	3001      	adds	r0, #1
 800927e:	900b      	str	r0, [sp, #44]	; 0x2c
 8009280:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8009282:	7803      	ldrb	r3, [r0, #0]
 8009284:	2b20      	cmp	r3, #32
 8009286:	d0f9      	beq.n	800927c <ff_test_term+0x850>
				put_rc(f_unlink(ptr));
 8009288:	f7f8 ff81 	bl	800218e <f_unlink>
 800928c:	e115      	b.n	80094ba <ff_test_term+0xa8e>
				break;

			case 'v' :	/* fv - Truncate file */
				put_rc(f_truncate(&File1));
 800928e:	4819      	ldr	r0, [pc, #100]	; (80092f4 <ff_test_term+0x8c8>)
 8009290:	f7f8 ff34 	bl	80020fc <f_truncate>
 8009294:	e111      	b.n	80094ba <ff_test_term+0xa8e>
				break;

			case 'k' :	/* fk <name> - Create a directory */
				while (*ptr == ' ') ptr++;
 8009296:	3001      	adds	r0, #1
 8009298:	900b      	str	r0, [sp, #44]	; 0x2c
 800929a:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800929c:	7803      	ldrb	r3, [r0, #0]
 800929e:	2b20      	cmp	r3, #32
 80092a0:	d0f9      	beq.n	8009296 <ff_test_term+0x86a>
				put_rc(f_mkdir(ptr));
 80092a2:	f7f8 ffcd 	bl	8002240 <f_mkdir>
 80092a6:	e108      	b.n	80094ba <ff_test_term+0xa8e>
				break;

			case 'a' :	/* fa <atrr> <mask> <name> - Change file/dir attribute */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
 80092a8:	a80b      	add	r0, sp, #44	; 0x2c
 80092aa:	a90c      	add	r1, sp, #48	; 0x30
 80092ac:	f000 fa76 	bl	800979c <xatoi>
 80092b0:	2800      	cmp	r0, #0
 80092b2:	f43f abc8 	beq.w	8008a46 <ff_test_term+0x1a>
 80092b6:	a80b      	add	r0, sp, #44	; 0x2c
 80092b8:	a90d      	add	r1, sp, #52	; 0x34
 80092ba:	f000 fa6f 	bl	800979c <xatoi>
 80092be:	2800      	cmp	r0, #0
 80092c0:	f43f abc1 	beq.w	8008a46 <ff_test_term+0x1a>
 80092c4:	e001      	b.n	80092ca <ff_test_term+0x89e>
				while (*ptr == ' ') ptr++;
 80092c6:	3001      	adds	r0, #1
 80092c8:	900b      	str	r0, [sp, #44]	; 0x2c
 80092ca:	980b      	ldr	r0, [sp, #44]	; 0x2c
 80092cc:	7803      	ldrb	r3, [r0, #0]
 80092ce:	2b20      	cmp	r3, #32
 80092d0:	d0f9      	beq.n	80092c6 <ff_test_term+0x89a>
				put_rc(f_chmod(ptr, p1, p2));
 80092d2:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
 80092d6:	f89d 2034 	ldrb.w	r2, [sp, #52]	; 0x34
 80092da:	f7f9 f893 	bl	8002404 <f_chmod>
 80092de:	e0ec      	b.n	80094ba <ff_test_term+0xa8e>
 80092e0:	080201e8 	.word	0x080201e8
 80092e4:	08020213 	.word	0x08020213
 80092e8:	200033e4 	.word	0x200033e4
 80092ec:	08020219 	.word	0x08020219
 80092f0:	08020242 	.word	0x08020242
 80092f4:	20001f74 	.word	0x20001f74
 80092f8:	08020256 	.word	0x08020256
 80092fc:	200021c0 	.word	0x200021c0
 8009300:	200021bc 	.word	0x200021bc
 8009304:	08020267 	.word	0x08020267
 8009308:	08020288 	.word	0x08020288
				break;

			case 't' :	/* ft <year> <month> <day> <hour> <min> <sec> <name> - Change timestamp */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
 800930c:	a80b      	add	r0, sp, #44	; 0x2c
 800930e:	a90c      	add	r1, sp, #48	; 0x30
 8009310:	f000 fa44 	bl	800979c <xatoi>
 8009314:	2800      	cmp	r0, #0
 8009316:	f43f ab96 	beq.w	8008a46 <ff_test_term+0x1a>
 800931a:	a80b      	add	r0, sp, #44	; 0x2c
 800931c:	a90d      	add	r1, sp, #52	; 0x34
 800931e:	f000 fa3d 	bl	800979c <xatoi>
 8009322:	2800      	cmp	r0, #0
 8009324:	f43f ab8f 	beq.w	8008a46 <ff_test_term+0x1a>
 8009328:	a80b      	add	r0, sp, #44	; 0x2c
 800932a:	a90e      	add	r1, sp, #56	; 0x38
 800932c:	f000 fa36 	bl	800979c <xatoi>
 8009330:	2800      	cmp	r0, #0
 8009332:	f43f ab88 	beq.w	8008a46 <ff_test_term+0x1a>
				Finfo.fdate = ((p1 - 1980) << 9) | ((p2 & 15) << 5) | (p3 & 31);
 8009336:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8009338:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800933a:	f002 020f 	and.w	r2, r2, #15
 800933e:	f2a3 73bc 	subw	r3, r3, #1980	; 0x7bc
 8009342:	0152      	lsls	r2, r2, #5
 8009344:	ea42 2243 	orr.w	r2, r2, r3, lsl #9
 8009348:	9b0e      	ldr	r3, [sp, #56]	; 0x38
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
 800934a:	a80b      	add	r0, sp, #44	; 0x2c
				put_rc(f_chmod(ptr, p1, p2));
				break;

			case 't' :	/* ft <year> <month> <day> <hour> <min> <sec> <name> - Change timestamp */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
				Finfo.fdate = ((p1 - 1980) << 9) | ((p2 & 15) << 5) | (p3 & 31);
 800934c:	f003 031f 	and.w	r3, r3, #31
 8009350:	4313      	orrs	r3, r2
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
 8009352:	a90c      	add	r1, sp, #48	; 0x30
				put_rc(f_chmod(ptr, p1, p2));
				break;

			case 't' :	/* ft <year> <month> <day> <hour> <min> <sec> <name> - Change timestamp */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
				Finfo.fdate = ((p1 - 1980) << 9) | ((p2 & 15) << 5) | (p3 & 31);
 8009354:	80a3      	strh	r3, [r4, #4]
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
 8009356:	f000 fa21 	bl	800979c <xatoi>
 800935a:	2800      	cmp	r0, #0
 800935c:	f43f ab73 	beq.w	8008a46 <ff_test_term+0x1a>
 8009360:	a80b      	add	r0, sp, #44	; 0x2c
 8009362:	a90d      	add	r1, sp, #52	; 0x34
 8009364:	f000 fa1a 	bl	800979c <xatoi>
 8009368:	2800      	cmp	r0, #0
 800936a:	f43f ab6c 	beq.w	8008a46 <ff_test_term+0x1a>
 800936e:	a80b      	add	r0, sp, #44	; 0x2c
 8009370:	a90e      	add	r1, sp, #56	; 0x38
 8009372:	f000 fa13 	bl	800979c <xatoi>
 8009376:	2800      	cmp	r0, #0
 8009378:	f43f ab65 	beq.w	8008a46 <ff_test_term+0x1a>
				Finfo.ftime = ((p1 & 31) << 11) | ((p1 & 63) << 5) | ((p1 >> 1) & 31);
 800937c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
				put_rc(f_utime(ptr, &Finfo));
 800937e:	980b      	ldr	r0, [sp, #44]	; 0x2c

			case 't' :	/* ft <year> <month> <day> <hour> <min> <sec> <name> - Change timestamp */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
				Finfo.fdate = ((p1 - 1980) << 9) | ((p2 & 15) << 5) | (p3 & 31);
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
				Finfo.ftime = ((p1 & 31) << 11) | ((p1 & 63) << 5) | ((p1 >> 1) & 31);
 8009380:	f003 013f 	and.w	r1, r3, #63	; 0x3f
 8009384:	f3c3 0244 	ubfx	r2, r3, #1, #5
 8009388:	ea42 1241 	orr.w	r2, r2, r1, lsl #5
 800938c:	ea42 23c3 	orr.w	r3, r2, r3, lsl #11
				put_rc(f_utime(ptr, &Finfo));
 8009390:	498e      	ldr	r1, [pc, #568]	; (80095cc <ff_test_term+0xba0>)

			case 't' :	/* ft <year> <month> <day> <hour> <min> <sec> <name> - Change timestamp */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
				Finfo.fdate = ((p1 - 1980) << 9) | ((p2 & 15) << 5) | (p3 & 31);
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
				Finfo.ftime = ((p1 & 31) << 11) | ((p1 & 63) << 5) | ((p1 >> 1) & 31);
 8009392:	80e3      	strh	r3, [r4, #6]
				put_rc(f_utime(ptr, &Finfo));
 8009394:	f7f9 f862 	bl	800245c <f_utime>
 8009398:	e08f      	b.n	80094ba <ff_test_term+0xa8e>
				break;

			case 'x' : /* fx <src_name> <dst_name> - Copy file */
				while (*ptr == ' ') ptr++;
 800939a:	3001      	adds	r0, #1
 800939c:	900b      	str	r0, [sp, #44]	; 0x2c
 800939e:	980b      	ldr	r0, [sp, #44]	; 0x2c
 80093a0:	7803      	ldrb	r3, [r0, #0]
 80093a2:	2b20      	cmp	r3, #32
 80093a4:	d0f9      	beq.n	800939a <ff_test_term+0x96e>
				ptr2 = strchr(ptr, ' ');
 80093a6:	2120      	movs	r1, #32
 80093a8:	f009 fa1a 	bl	80127e0 <strchr>
				if (!ptr2) break;
 80093ac:	2800      	cmp	r0, #0
 80093ae:	f43f ab4a 	beq.w	8008a46 <ff_test_term+0x1a>
				*ptr2++ = 0;
 80093b2:	2300      	movs	r3, #0
 80093b4:	f800 3b01 	strb.w	r3, [r0], #1
 80093b8:	4681      	mov	r9, r0
				while (*ptr2 == ' ') ptr2++;
 80093ba:	f899 3000 	ldrb.w	r3, [r9]
 80093be:	3001      	adds	r0, #1
 80093c0:	2b20      	cmp	r3, #32
 80093c2:	d0f9      	beq.n	80093b8 <ff_test_term+0x98c>
				xprintf("Opening \"%s\"", ptr);
 80093c4:	4882      	ldr	r0, [pc, #520]	; (80095d0 <ff_test_term+0xba4>)
 80093c6:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80093c8:	f000 fa9e 	bl	8009908 <xprintf>
				res = f_open(&File1, ptr, FA_OPEN_EXISTING | FA_READ);
 80093cc:	4881      	ldr	r0, [pc, #516]	; (80095d4 <ff_test_term+0xba8>)
 80093ce:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80093d0:	2201      	movs	r2, #1
 80093d2:	f7f8 fa39 	bl	8001848 <f_open>
 80093d6:	4682      	mov	sl, r0
				xputc('\n');
 80093d8:	200a      	movs	r0, #10
 80093da:	f000 fa33 	bl	8009844 <xputc>
				if (res) {
 80093de:	f1ba 0f00 	cmp.w	sl, #0
 80093e2:	d001      	beq.n	80093e8 <ff_test_term+0x9bc>
					put_rc(res);
 80093e4:	4650      	mov	r0, sl
 80093e6:	e068      	b.n	80094ba <ff_test_term+0xa8e>
					break;
				}
				xprintf("Creating \"%s\"", ptr2);
 80093e8:	4649      	mov	r1, r9
 80093ea:	487b      	ldr	r0, [pc, #492]	; (80095d8 <ff_test_term+0xbac>)
 80093ec:	f000 fa8c 	bl	8009908 <xprintf>
				res = f_open(&File2, ptr2, FA_CREATE_ALWAYS | FA_WRITE);
 80093f0:	4649      	mov	r1, r9
 80093f2:	487a      	ldr	r0, [pc, #488]	; (80095dc <ff_test_term+0xbb0>)
 80093f4:	220a      	movs	r2, #10
 80093f6:	f7f8 fa27 	bl	8001848 <f_open>
 80093fa:	4681      	mov	r9, r0
				xputc('\n');
 80093fc:	200a      	movs	r0, #10
 80093fe:	f000 fa21 	bl	8009844 <xputc>
				if (res) {
 8009402:	f1b9 0f00 	cmp.w	r9, #0
 8009406:	d004      	beq.n	8009412 <ff_test_term+0x9e6>
					put_rc(res);
 8009408:	4648      	mov	r0, r9
 800940a:	f7ff faaf 	bl	800896c <put_rc>
					f_close(&File1);
 800940e:	4871      	ldr	r0, [pc, #452]	; (80095d4 <ff_test_term+0xba8>)
 8009410:	e02e      	b.n	8009470 <ff_test_term+0xa44>
					break;
				}
				xprintf("Copying file...");
 8009412:	4873      	ldr	r0, [pc, #460]	; (80095e0 <ff_test_term+0xbb4>)
 8009414:	f000 fa78 	bl	8009908 <xprintf>
				Timer = 0;
 8009418:	4b72      	ldr	r3, [pc, #456]	; (80095e4 <ff_test_term+0xbb8>)
				p1 = 0;
 800941a:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
					put_rc(res);
					f_close(&File1);
					break;
				}
				xprintf("Copying file...");
				Timer = 0;
 800941e:	f8c3 9000 	str.w	r9, [r3]
				p1 = 0;
				for (;;) {
					res = f_read(&File1, Buff, blen, &s1);
 8009422:	486c      	ldr	r0, [pc, #432]	; (80095d4 <ff_test_term+0xba8>)
 8009424:	4970      	ldr	r1, [pc, #448]	; (80095e8 <ff_test_term+0xbbc>)
 8009426:	462a      	mov	r2, r5
 8009428:	ab0f      	add	r3, sp, #60	; 0x3c
 800942a:	f7f8 fac7 	bl	80019bc <f_read>
					if (res || s1 == 0) {
 800942e:	b908      	cbnz	r0, 8009434 <ff_test_term+0xa08>
 8009430:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8009432:	b90a      	cbnz	r2, 8009438 <ff_test_term+0xa0c>
						xprintf("EOF\n");
 8009434:	486d      	ldr	r0, [pc, #436]	; (80095ec <ff_test_term+0xbc0>)
 8009436:	e00d      	b.n	8009454 <ff_test_term+0xa28>
						break;   /* error or eof */
					}
					res = f_write(&File2, Buff, s1, &s2);
 8009438:	ab10      	add	r3, sp, #64	; 0x40
 800943a:	4868      	ldr	r0, [pc, #416]	; (80095dc <ff_test_term+0xbb0>)
 800943c:	496a      	ldr	r1, [pc, #424]	; (80095e8 <ff_test_term+0xbbc>)
 800943e:	f7f8 fb79 	bl	8001b34 <f_write>
					p1 += s2;
 8009442:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8009444:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8009446:	18d2      	adds	r2, r2, r3
 8009448:	920c      	str	r2, [sp, #48]	; 0x30
					if (res || s2 < s1) {
 800944a:	b910      	cbnz	r0, 8009452 <ff_test_term+0xa26>
 800944c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800944e:	4293      	cmp	r3, r2
 8009450:	d2e7      	bcs.n	8009422 <ff_test_term+0x9f6>
						xprintf("disk full\n");
 8009452:	4867      	ldr	r0, [pc, #412]	; (80095f0 <ff_test_term+0xbc4>)
 8009454:	f000 fa58 	bl	8009908 <xprintf>
						break;   /* error or disk full */
					}
				}
				xprintf("%lu bytes copied with %lu kB/sec.\n", p1, p1 / Timer);
 8009458:	4b62      	ldr	r3, [pc, #392]	; (80095e4 <ff_test_term+0xbb8>)
 800945a:	990c      	ldr	r1, [sp, #48]	; 0x30
 800945c:	681a      	ldr	r2, [r3, #0]
 800945e:	4865      	ldr	r0, [pc, #404]	; (80095f4 <ff_test_term+0xbc8>)
 8009460:	fbb1 f2f2 	udiv	r2, r1, r2
 8009464:	f000 fa50 	bl	8009908 <xprintf>
				f_close(&File1);
 8009468:	485a      	ldr	r0, [pc, #360]	; (80095d4 <ff_test_term+0xba8>)
 800946a:	f7f8 fc90 	bl	8001d8e <f_close>
				f_close(&File2);
 800946e:	485b      	ldr	r0, [pc, #364]	; (80095dc <ff_test_term+0xbb0>)
 8009470:	f7f8 fc8d 	bl	8001d8e <f_close>
				break;
 8009474:	f7ff bae7 	b.w	8008a46 <ff_test_term+0x1a>
#if _USE_MKFS
			case 'm' :	/* fm <partition rule> <cluster size> - Create file system */
				if (!xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
 8009478:	a80b      	add	r0, sp, #44	; 0x2c
 800947a:	a90d      	add	r1, sp, #52	; 0x34
 800947c:	f000 f98e 	bl	800979c <xatoi>
 8009480:	2800      	cmp	r0, #0
 8009482:	f43f aae0 	beq.w	8008a46 <ff_test_term+0x1a>
 8009486:	a80b      	add	r0, sp, #44	; 0x2c
 8009488:	a90e      	add	r1, sp, #56	; 0x38
 800948a:	f000 f987 	bl	800979c <xatoi>
 800948e:	2800      	cmp	r0, #0
 8009490:	f43f aad9 	beq.w	8008a46 <ff_test_term+0x1a>
				xprintf("The drive 0 will be formatted. Are you sure? (Y/n)=");
 8009494:	4858      	ldr	r0, [pc, #352]	; (80095f8 <ff_test_term+0xbcc>)
 8009496:	f000 fa37 	bl	8009908 <xprintf>
				get_line(ptr, sizeof(linebuf));
 800949a:	2178      	movs	r1, #120	; 0x78
 800949c:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800949e:	f000 fab9 	bl	8009a14 <get_line>
				if (*ptr == 'Y')
 80094a2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80094a4:	781b      	ldrb	r3, [r3, #0]
 80094a6:	2b59      	cmp	r3, #89	; 0x59
 80094a8:	f47f aacd 	bne.w	8008a46 <ff_test_term+0x1a>
					put_rc(f_mkfs(0, (BYTE)p2, (WORD)p3));
 80094ac:	2000      	movs	r0, #0
 80094ae:	f89d 1034 	ldrb.w	r1, [sp, #52]	; 0x34
 80094b2:	f8bd 2038 	ldrh.w	r2, [sp, #56]	; 0x38
 80094b6:	f7f9 f887 	bl	80025c8 <f_mkfs>
 80094ba:	f7ff fa57 	bl	800896c <put_rc>
 80094be:	f7ff bac2 	b.w	8008a46 <ff_test_term+0x1a>
				break;
#endif
			case 'z' :	/* fz [<rw size>] - Change R/W length for fr/fw/fx command */
				if (xatoi(&ptr, &p1) && p1 >= 1 && (size_t)p1 <= sizeof(Buff))
 80094c2:	a80b      	add	r0, sp, #44	; 0x2c
 80094c4:	a90c      	add	r1, sp, #48	; 0x30
 80094c6:	f000 f969 	bl	800979c <xatoi>
 80094ca:	b130      	cbz	r0, 80094da <ff_test_term+0xaae>
 80094cc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80094ce:	2b00      	cmp	r3, #0
 80094d0:	dd03      	ble.n	80094da <ff_test_term+0xaae>
 80094d2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80094d6:	bf98      	it	ls
 80094d8:	461d      	movls	r5, r3
					blen = p1;
				xprintf("blen=%u\n", blen);
 80094da:	4848      	ldr	r0, [pc, #288]	; (80095fc <ff_test_term+0xbd0>)
 80094dc:	4629      	mov	r1, r5
 80094de:	f7ff bb34 	b.w	8008b4a <ff_test_term+0x11e>
				break;
			}
			break;

		case 't' :	/* t [<year> <mon> <mday> <hour> <min> <sec>] */
			if (xatoi(&ptr, &p1)) {
 80094e2:	a80b      	add	r0, sp, #44	; 0x2c
 80094e4:	a90c      	add	r1, sp, #48	; 0x30
 80094e6:	f000 f959 	bl	800979c <xatoi>
 80094ea:	b358      	cbz	r0, 8009544 <ff_test_term+0xb18>
				rtc.year = (WORD)p1;
 80094ec:	9b0c      	ldr	r3, [sp, #48]	; 0x30
				xatoi(&ptr, &p1); rtc.month = (BYTE)p1;
 80094ee:	a90c      	add	r1, sp, #48	; 0x30
 80094f0:	a80b      	add	r0, sp, #44	; 0x2c
			}
			break;

		case 't' :	/* t [<year> <mon> <mday> <hour> <min> <sec>] */
			if (xatoi(&ptr, &p1)) {
				rtc.year = (WORD)p1;
 80094f2:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
				xatoi(&ptr, &p1); rtc.month = (BYTE)p1;
 80094f6:	f000 f951 	bl	800979c <xatoi>
 80094fa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
				xatoi(&ptr, &p1); rtc.mday = (BYTE)p1;
 80094fc:	a90c      	add	r1, sp, #48	; 0x30
 80094fe:	a80b      	add	r0, sp, #44	; 0x2c
			break;

		case 't' :	/* t [<year> <mon> <mday> <hour> <min> <sec>] */
			if (xatoi(&ptr, &p1)) {
				rtc.year = (WORD)p1;
				xatoi(&ptr, &p1); rtc.month = (BYTE)p1;
 8009500:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
				xatoi(&ptr, &p1); rtc.mday = (BYTE)p1;
 8009504:	f000 f94a 	bl	800979c <xatoi>
 8009508:	9b0c      	ldr	r3, [sp, #48]	; 0x30
				xatoi(&ptr, &p1); rtc.hour = (BYTE)p1;
 800950a:	a90c      	add	r1, sp, #48	; 0x30
 800950c:	a80b      	add	r0, sp, #44	; 0x2c

		case 't' :	/* t [<year> <mon> <mday> <hour> <min> <sec>] */
			if (xatoi(&ptr, &p1)) {
				rtc.year = (WORD)p1;
				xatoi(&ptr, &p1); rtc.month = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.mday = (BYTE)p1;
 800950e:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
				xatoi(&ptr, &p1); rtc.hour = (BYTE)p1;
 8009512:	f000 f943 	bl	800979c <xatoi>
 8009516:	9b0c      	ldr	r3, [sp, #48]	; 0x30
				xatoi(&ptr, &p1); rtc.min = (BYTE)p1;
 8009518:	a90c      	add	r1, sp, #48	; 0x30
 800951a:	a80b      	add	r0, sp, #44	; 0x2c
		case 't' :	/* t [<year> <mon> <mday> <hour> <min> <sec>] */
			if (xatoi(&ptr, &p1)) {
				rtc.year = (WORD)p1;
				xatoi(&ptr, &p1); rtc.month = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.mday = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.hour = (BYTE)p1;
 800951c:	f88d 3051 	strb.w	r3, [sp, #81]	; 0x51
				xatoi(&ptr, &p1); rtc.min = (BYTE)p1;
 8009520:	f000 f93c 	bl	800979c <xatoi>
 8009524:	9b0c      	ldr	r3, [sp, #48]	; 0x30
				if (!xatoi(&ptr, &p1)) break;
 8009526:	a80b      	add	r0, sp, #44	; 0x2c
 8009528:	a90c      	add	r1, sp, #48	; 0x30
			if (xatoi(&ptr, &p1)) {
				rtc.year = (WORD)p1;
				xatoi(&ptr, &p1); rtc.month = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.mday = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.hour = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.min = (BYTE)p1;
 800952a:	f88d 3052 	strb.w	r3, [sp, #82]	; 0x52
				if (!xatoi(&ptr, &p1)) break;
 800952e:	f000 f935 	bl	800979c <xatoi>
 8009532:	2800      	cmp	r0, #0
 8009534:	f43f aa87 	beq.w	8008a46 <ff_test_term+0x1a>
				rtc.sec = (BYTE)p1;
 8009538:	9b0c      	ldr	r3, [sp, #48]	; 0x30
				rtc_settime(&rtc);
 800953a:	a813      	add	r0, sp, #76	; 0x4c
				xatoi(&ptr, &p1); rtc.month = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.mday = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.hour = (BYTE)p1;
				xatoi(&ptr, &p1); rtc.min = (BYTE)p1;
				if (!xatoi(&ptr, &p1)) break;
				rtc.sec = (BYTE)p1;
 800953c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
				rtc_settime(&rtc);
 8009540:	f7fe ffa2 	bl	8008488 <rtc_settime>
			}
			rtc_gettime(&rtc);
 8009544:	a813      	add	r0, sp, #76	; 0x4c
 8009546:	f7fe ff67 	bl	8008418 <rtc_gettime>
			xprintf("%u/%u/%u %02u:%02u:%02u\n", rtc.year, rtc.month, rtc.mday, rtc.hour, rtc.min, rtc.sec);
 800954a:	f89d 0051 	ldrb.w	r0, [sp, #81]	; 0x51
 800954e:	f8bd 104c 	ldrh.w	r1, [sp, #76]	; 0x4c
 8009552:	9000      	str	r0, [sp, #0]
 8009554:	f89d 0052 	ldrb.w	r0, [sp, #82]	; 0x52
 8009558:	f89d 204e 	ldrb.w	r2, [sp, #78]	; 0x4e
 800955c:	9001      	str	r0, [sp, #4]
 800955e:	f89d 0053 	ldrb.w	r0, [sp, #83]	; 0x53
 8009562:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 8009566:	9002      	str	r0, [sp, #8]
 8009568:	4825      	ldr	r0, [pc, #148]	; (8009600 <ff_test_term+0xbd4>)
 800956a:	f000 f9cd 	bl	8009908 <xprintf>
			break;
 800956e:	f7ff ba6a 	b.w	8008a46 <ff_test_term+0x1a>

		case 'p' : /* p [<0|1>] - Card Power state, Card Power Control off/on */
			if (xatoi(&ptr, &p1)) {
 8009572:	a80b      	add	r0, sp, #44	; 0x2c
 8009574:	a90c      	add	r1, sp, #48	; 0x30
 8009576:	f000 f911 	bl	800979c <xatoi>
 800957a:	b158      	cbz	r0, 8009594 <ff_test_term+0xb68>
				if (!p1) {
 800957c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800957e:	b913      	cbnz	r3, 8009586 <ff_test_term+0xb5a>
					f_sync(&File1);
 8009580:	4814      	ldr	r0, [pc, #80]	; (80095d4 <ff_test_term+0xba8>)
 8009582:	f7f8 fbae 	bl	8001ce2 <f_sync>
				}
				Buff[0] = p1;
 8009586:	4a18      	ldr	r2, [pc, #96]	; (80095e8 <ff_test_term+0xbbc>)
 8009588:	9b0c      	ldr	r3, [sp, #48]	; 0x30
				disk_ioctl(0, CTRL_POWER, Buff);
 800958a:	2000      	movs	r0, #0
 800958c:	2104      	movs	r1, #4
		case 'p' : /* p [<0|1>] - Card Power state, Card Power Control off/on */
			if (xatoi(&ptr, &p1)) {
				if (!p1) {
					f_sync(&File1);
				}
				Buff[0] = p1;
 800958e:	7013      	strb	r3, [r2, #0]
				disk_ioctl(0, CTRL_POWER, Buff);
 8009590:	f7f9 fea0 	bl	80032d4 <disk_ioctl>
			}
			Buff[0] = 2;
 8009594:	f8df 9050 	ldr.w	r9, [pc, #80]	; 80095e8 <ff_test_term+0xbbc>
 8009598:	2302      	movs	r3, #2
			if (disk_ioctl(0, CTRL_POWER, Buff) == RES_OK ) {
 800959a:	2000      	movs	r0, #0
 800959c:	2104      	movs	r1, #4
 800959e:	464a      	mov	r2, r9
					f_sync(&File1);
				}
				Buff[0] = p1;
				disk_ioctl(0, CTRL_POWER, Buff);
			}
			Buff[0] = 2;
 80095a0:	f889 3000 	strb.w	r3, [r9]
			if (disk_ioctl(0, CTRL_POWER, Buff) == RES_OK ) {
 80095a4:	f7f9 fe96 	bl	80032d4 <disk_ioctl>
 80095a8:	2800      	cmp	r0, #0
 80095aa:	f47f aa4c 	bne.w	8008a46 <ff_test_term+0x1a>
				xprintf("Card Power is %s\n", Buff[1] ? "ON" : "OFF");
 80095ae:	f899 1001 	ldrb.w	r1, [r9, #1]
 80095b2:	4b14      	ldr	r3, [pc, #80]	; (8009604 <ff_test_term+0xbd8>)
 80095b4:	4a14      	ldr	r2, [pc, #80]	; (8009608 <ff_test_term+0xbdc>)
 80095b6:	4815      	ldr	r0, [pc, #84]	; (800960c <ff_test_term+0xbe0>)
 80095b8:	2900      	cmp	r1, #0
 80095ba:	bf0c      	ite	eq
 80095bc:	4611      	moveq	r1, r2
 80095be:	4619      	movne	r1, r3
 80095c0:	f7ff bac3 	b.w	8008b4a <ff_test_term+0x11e>
			break;
		}
	}

	return 1;
}
 80095c4:	2000      	movs	r0, #0
 80095c6:	b017      	add	sp, #92	; 0x5c
 80095c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80095cc:	20002198 	.word	0x20002198
 80095d0:	080202ac 	.word	0x080202ac
 80095d4:	20001f74 	.word	0x20001f74
 80095d8:	080202b9 	.word	0x080202b9
 80095dc:	200031c0 	.word	0x200031c0
 80095e0:	080202c7 	.word	0x080202c7
 80095e4:	200021bc 	.word	0x200021bc
 80095e8:	200021c0 	.word	0x200021c0
 80095ec:	080202d7 	.word	0x080202d7
 80095f0:	080202dc 	.word	0x080202dc
 80095f4:	080202e7 	.word	0x080202e7
 80095f8:	0802030a 	.word	0x0802030a
 80095fc:	0802033e 	.word	0x0802033e
 8009600:	08020347 	.word	0x08020347
 8009604:	0801fff9 	.word	0x0801fff9
 8009608:	0801fffc 	.word	0x0801fffc
 800960c:	08020360 	.word	0x08020360

08009610 <setup>:
//#include <library/usb/libuhs20.h>

int uhs_init(void);
#endif

void setup(void) {
 8009610:	b508      	push	{r3, lr}
	BSP_init();
 8009612:	f7fe fcca 	bl	8007faa <BSP_init>
	printf("\n\rWelcome to USB-Host-Dock project!\n\r");
 8009616:	4806      	ldr	r0, [pc, #24]	; (8009630 <setup+0x20>)
 8009618:	f7ff f984 	bl	8008924 <printf>
	return 1;
}

int uhs_init(void)
{
	register_libuhs_callback();
 800961c:	f7f6 fffe 	bl	800061c <register_libuhs_callback>

	/* --- Hub class --- */
	libuhs_class_hub_init();
 8009620:	f00a fb5e 	bl	8013ce0 <libuhs_class_hub_init>
	BSP_init();
	printf("\n\rWelcome to USB-Host-Dock project!\n\r");

#ifdef USE_UHS20
	if (uhs_init() != -1)
		xprintf("\nUsb is initialized.\n");
 8009624:	4803      	ldr	r0, [pc, #12]	; (8009634 <setup+0x24>)
			&USB_Host,
			&HID_cb,
			&USR_Callbacks);

#endif
}
 8009626:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	BSP_init();
	printf("\n\rWelcome to USB-Host-Dock project!\n\r");

#ifdef USE_UHS20
	if (uhs_init() != -1)
		xprintf("\nUsb is initialized.\n");
 800962a:	f000 b96d 	b.w	8009908 <xprintf>
 800962e:	bf00      	nop
 8009630:	08020372 	.word	0x08020372
 8009634:	08020398 	.word	0x08020398

08009638 <uhs_init>:

	return 1;
}

int uhs_init(void)
{
 8009638:	b508      	push	{r3, lr}
	register_libuhs_callback();
 800963a:	f7f6 ffef 	bl	800061c <register_libuhs_callback>
	/* --- CDC FTDI class --- */

	/* --- kernel init --- */
	//return libuhs_kernel_init();

}
 800963e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
int uhs_init(void)
{
	register_libuhs_callback();

	/* --- Hub class --- */
	libuhs_class_hub_init();
 8009642:	f00a bb4d 	b.w	8013ce0 <libuhs_class_hub_init>
 8009646:	bf00      	nop

08009648 <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 8009648:	4770      	bx	lr

0800964a <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 800964a:	e7fe      	b.n	800964a <HardFault_Handler>

0800964c <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 800964c:	e7fe      	b.n	800964c <MemManage_Handler>

0800964e <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 800964e:	e7fe      	b.n	800964e <BusFault_Handler>

08009650 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8009650:	e7fe      	b.n	8009650 <UsageFault_Handler>

08009652 <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
 8009652:	4770      	bx	lr

08009654 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 8009654:	4770      	bx	lr

08009656 <PendSV_Handler>:
  * @brief  This function handles PendSV_Handler exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 8009656:	4770      	bx	lr

08009658 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 8009658:	b510      	push	{r4, lr}
	delay_tick_calc();

	static uint16_t cnt=0;
	static uint8_t cntdiskio=0;

	if( cnt++ >= 500 ) {
 800965a:	4c0e      	ldr	r4, [pc, #56]	; (8009694 <SysTick_Handler+0x3c>)
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
	delay_tick_calc();
 800965c:	f7fe fd96 	bl	800818c <delay_tick_calc>

	static uint16_t cnt=0;
	static uint8_t cntdiskio=0;

	if( cnt++ >= 500 ) {
 8009660:	8823      	ldrh	r3, [r4, #0]
 8009662:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8009666:	d202      	bcs.n	800966e <SysTick_Handler+0x16>
 8009668:	3301      	adds	r3, #1
 800966a:	8023      	strh	r3, [r4, #0]
 800966c:	e003      	b.n	8009676 <SysTick_Handler+0x1e>
		cnt = 0;
 800966e:	2000      	movs	r0, #0
 8009670:	8020      	strh	r0, [r4, #0]
		STM_EVAL_LEDToggle(LED1);
 8009672:	f7fe fdd1 	bl	8008218 <STM_EVAL_LEDToggle>
	}

	if ( cntdiskio++ >= 10 ) {
 8009676:	78a2      	ldrb	r2, [r4, #2]
 8009678:	4b06      	ldr	r3, [pc, #24]	; (8009694 <SysTick_Handler+0x3c>)
 800967a:	2a09      	cmp	r2, #9
 800967c:	d802      	bhi.n	8009684 <SysTick_Handler+0x2c>
 800967e:	3201      	adds	r2, #1
 8009680:	709a      	strb	r2, [r3, #2]
 8009682:	e003      	b.n	800968c <SysTick_Handler+0x34>
		cntdiskio = 0;
 8009684:	2200      	movs	r2, #0
 8009686:	709a      	strb	r2, [r3, #2]
		disk_timerproc(); /* to be called every 10ms */
 8009688:	f7f9 ff3a 	bl	8003500 <disk_timerproc>
	}

	ff_test_term_timerproc();
}
 800968c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	if ( cntdiskio++ >= 10 ) {
		cntdiskio = 0;
		disk_timerproc(); /* to be called every 10ms */
	}

	ff_test_term_timerproc();
 8009690:	f014 bcfa 	b.w	801e088 <_etext>
 8009694:	20000b4c 	.word	0x20000b4c

08009698 <Default_Handler_c>:
}

void Default_Handler_c(unsigned int * hardfault_args) {
 8009698:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	unsigned int stacked_r12;
	unsigned int stacked_lr;
	unsigned int stacked_pc;
	unsigned int stacked_psr;

	stacked_r0 = ((unsigned long) hardfault_args[0]);
 800969c:	f8d0 b000 	ldr.w	fp, [r0]
	stacked_r1 = ((unsigned long) hardfault_args[1]);
 80096a0:	f8d0 a004 	ldr.w	sl, [r0, #4]
	stacked_r2 = ((unsigned long) hardfault_args[2]);
 80096a4:	f8d0 9008 	ldr.w	r9, [r0, #8]
	stacked_r3 = ((unsigned long) hardfault_args[3]);
 80096a8:	f8d0 800c 	ldr.w	r8, [r0, #12]

	stacked_r12 = ((unsigned long) hardfault_args[4]);
 80096ac:	6907      	ldr	r7, [r0, #16]
	stacked_lr = ((unsigned long) hardfault_args[5]);
 80096ae:	6946      	ldr	r6, [r0, #20]
	stacked_pc = ((unsigned long) hardfault_args[6]);
 80096b0:	6985      	ldr	r5, [r0, #24]
	stacked_psr = ((unsigned long) hardfault_args[7]);
 80096b2:	69c4      	ldr	r4, [r0, #28]

	printf ("\n\n[Hard fault handler - all numbers in hex]\n");
 80096b4:	4820      	ldr	r0, [pc, #128]	; (8009738 <Default_Handler_c+0xa0>)
 80096b6:	f008 fd33 	bl	8012120 <puts>
	printf ("R0 = %x\n", stacked_r0);
 80096ba:	4659      	mov	r1, fp
 80096bc:	481f      	ldr	r0, [pc, #124]	; (800973c <Default_Handler_c+0xa4>)
 80096be:	f7ff f931 	bl	8008924 <printf>
	printf ("R1 = %x\n", stacked_r1);
 80096c2:	4651      	mov	r1, sl
 80096c4:	481e      	ldr	r0, [pc, #120]	; (8009740 <Default_Handler_c+0xa8>)
 80096c6:	f7ff f92d 	bl	8008924 <printf>
	printf ("R2 = %x\n", stacked_r2);
 80096ca:	4649      	mov	r1, r9
 80096cc:	481d      	ldr	r0, [pc, #116]	; (8009744 <Default_Handler_c+0xac>)
 80096ce:	f7ff f929 	bl	8008924 <printf>
	printf ("R3 = %x\n", stacked_r3);
 80096d2:	4641      	mov	r1, r8
 80096d4:	481c      	ldr	r0, [pc, #112]	; (8009748 <Default_Handler_c+0xb0>)
 80096d6:	f7ff f925 	bl	8008924 <printf>
	printf ("R12 = %x\n", stacked_r12);
 80096da:	4639      	mov	r1, r7
 80096dc:	481b      	ldr	r0, [pc, #108]	; (800974c <Default_Handler_c+0xb4>)
 80096de:	f7ff f921 	bl	8008924 <printf>
	printf ("LR [R14] = %x  subroutine call return address\n", stacked_lr);
 80096e2:	4631      	mov	r1, r6
 80096e4:	481a      	ldr	r0, [pc, #104]	; (8009750 <Default_Handler_c+0xb8>)
 80096e6:	f7ff f91d 	bl	8008924 <printf>
	printf ("PC [R15] = %x  program counter\n", stacked_pc);
 80096ea:	4629      	mov	r1, r5
 80096ec:	4819      	ldr	r0, [pc, #100]	; (8009754 <Default_Handler_c+0xbc>)
 80096ee:	f7ff f919 	bl	8008924 <printf>
	printf ("PSR = %x\n", stacked_psr);
 80096f2:	4621      	mov	r1, r4
 80096f4:	4818      	ldr	r0, [pc, #96]	; (8009758 <Default_Handler_c+0xc0>)
 80096f6:	f7ff f915 	bl	8008924 <printf>
	printf ("BFAR = %x\n", (*((volatile unsigned long *)(0xE000ED38))));
 80096fa:	4b18      	ldr	r3, [pc, #96]	; (800975c <Default_Handler_c+0xc4>)
 80096fc:	4818      	ldr	r0, [pc, #96]	; (8009760 <Default_Handler_c+0xc8>)
 80096fe:	6819      	ldr	r1, [r3, #0]
 8009700:	f7ff f910 	bl	8008924 <printf>
	printf ("CFSR = %x\n", (*((volatile unsigned long *)(0xE000ED28))));
 8009704:	4b17      	ldr	r3, [pc, #92]	; (8009764 <Default_Handler_c+0xcc>)
 8009706:	4818      	ldr	r0, [pc, #96]	; (8009768 <Default_Handler_c+0xd0>)
 8009708:	6819      	ldr	r1, [r3, #0]
 800970a:	f7ff f90b 	bl	8008924 <printf>
	printf ("HFSR = %x\n", (*((volatile unsigned long *)(0xE000ED2C))));
 800970e:	4b17      	ldr	r3, [pc, #92]	; (800976c <Default_Handler_c+0xd4>)
 8009710:	4817      	ldr	r0, [pc, #92]	; (8009770 <Default_Handler_c+0xd8>)
 8009712:	6819      	ldr	r1, [r3, #0]
 8009714:	f7ff f906 	bl	8008924 <printf>
	printf ("DFSR = %x\n", (*((volatile unsigned long *)(0xE000ED30))));
 8009718:	4b16      	ldr	r3, [pc, #88]	; (8009774 <Default_Handler_c+0xdc>)
 800971a:	4817      	ldr	r0, [pc, #92]	; (8009778 <Default_Handler_c+0xe0>)
 800971c:	6819      	ldr	r1, [r3, #0]
 800971e:	f7ff f901 	bl	8008924 <printf>
	printf ("AFSR = %x\n", (*((volatile unsigned long *)(0xE000ED3C))));
 8009722:	4b16      	ldr	r3, [pc, #88]	; (800977c <Default_Handler_c+0xe4>)
 8009724:	4816      	ldr	r0, [pc, #88]	; (8009780 <Default_Handler_c+0xe8>)
 8009726:	6819      	ldr	r1, [r3, #0]
 8009728:	f7ff f8fc 	bl	8008924 <printf>
	printf ("SCB_SHCSR = %x\n", SCB->SHCSR);
 800972c:	4b15      	ldr	r3, [pc, #84]	; (8009784 <Default_Handler_c+0xec>)
 800972e:	4816      	ldr	r0, [pc, #88]	; (8009788 <Default_Handler_c+0xf0>)
 8009730:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8009732:	f7ff f8f7 	bl	8008924 <printf>
 8009736:	e7fe      	b.n	8009736 <Default_Handler_c+0x9e>
 8009738:	080203ae 	.word	0x080203ae
 800973c:	080203da 	.word	0x080203da
 8009740:	080203e3 	.word	0x080203e3
 8009744:	080203ec 	.word	0x080203ec
 8009748:	080203f5 	.word	0x080203f5
 800974c:	080203fe 	.word	0x080203fe
 8009750:	08020408 	.word	0x08020408
 8009754:	08020437 	.word	0x08020437
 8009758:	08020457 	.word	0x08020457
 800975c:	e000ed38 	.word	0xe000ed38
 8009760:	08020461 	.word	0x08020461
 8009764:	e000ed28 	.word	0xe000ed28
 8009768:	0802046c 	.word	0x0802046c
 800976c:	e000ed2c 	.word	0xe000ed2c
 8009770:	08020477 	.word	0x08020477
 8009774:	e000ed30 	.word	0xe000ed30
 8009778:	08020482 	.word	0x08020482
 800977c:	e000ed3c 	.word	0xe000ed3c
 8009780:	0802048d 	.word	0x0802048d
 8009784:	e000ed00 	.word	0xe000ed00
 8009788:	08020498 	.word	0x08020498

0800978c <TIM2_IRQHandler>:
//  }
//}

void TIM2_IRQHandler(void)
{
  USB_OTG_BSP_TimerIRQ();
 800978c:	f7fc bb6e 	b.w	8005e6c <USB_OTG_BSP_TimerIRQ>

08009790 <OTG_FS_IRQHandler>:
void OTG_FS_IRQHandler(void)
#else
void OTG_HS_IRQHandler(void)
#endif
{
  USBH_OTG_ISR_Handler(&USB_OTG_Core_dev);
 8009790:	4801      	ldr	r0, [pc, #4]	; (8009798 <OTG_FS_IRQHandler+0x8>)
 8009792:	f7fe b9f3 	b.w	8007b7c <USBH_OTG_ISR_Handler>
 8009796:	bf00      	nop
 8009798:	20001674 	.word	0x20001674

0800979c <xatoi>:

#include <bsp/bsp.h>
#include "term_io.h"

int xatoi (char **str, long *res)
{
 800979c:	b570      	push	{r4, r5, r6, lr}
	DWORD val;
	BYTE c, radix, s = 0;


	while ((c = **str) == ' ') (*str)++;
 800979e:	e001      	b.n	80097a4 <xatoi+0x8>
 80097a0:	3201      	adds	r2, #1
 80097a2:	6002      	str	r2, [r0, #0]
 80097a4:	6802      	ldr	r2, [r0, #0]
 80097a6:	7813      	ldrb	r3, [r2, #0]
 80097a8:	2b20      	cmp	r3, #32
 80097aa:	d0f9      	beq.n	80097a0 <xatoi+0x4>
	if (c == '-') {
 80097ac:	2b2d      	cmp	r3, #45	; 0x2d
 80097ae:	d104      	bne.n	80097ba <xatoi+0x1e>
		s = 1;
		c = *(++(*str));
 80097b0:	1c53      	adds	r3, r2, #1
 80097b2:	6003      	str	r3, [r0, #0]
 80097b4:	7853      	ldrb	r3, [r2, #1]
	BYTE c, radix, s = 0;


	while ((c = **str) == ' ') (*str)++;
	if (c == '-') {
		s = 1;
 80097b6:	2601      	movs	r6, #1
 80097b8:	e000      	b.n	80097bc <xatoi+0x20>
#include "term_io.h"

int xatoi (char **str, long *res)
{
	DWORD val;
	BYTE c, radix, s = 0;
 80097ba:	2600      	movs	r6, #0
	while ((c = **str) == ' ') (*str)++;
	if (c == '-') {
		s = 1;
		c = *(++(*str));
	}
	if (c == '0') {
 80097bc:	2b30      	cmp	r3, #48	; 0x30
 80097be:	d11c      	bne.n	80097fa <xatoi+0x5e>
		c = *(++(*str));
 80097c0:	6802      	ldr	r2, [r0, #0]
 80097c2:	1c53      	adds	r3, r2, #1
 80097c4:	6003      	str	r3, [r0, #0]
 80097c6:	7853      	ldrb	r3, [r2, #1]
		if (c <= ' ') {
 80097c8:	2b20      	cmp	r3, #32
 80097ca:	d802      	bhi.n	80097d2 <xatoi+0x36>
			*res = 0; return 1;
 80097cc:	2300      	movs	r3, #0
 80097ce:	600b      	str	r3, [r1, #0]
 80097d0:	e036      	b.n	8009840 <xatoi+0xa4>
		}
		if (c == 'x') {
 80097d2:	2b78      	cmp	r3, #120	; 0x78
 80097d4:	d104      	bne.n	80097e0 <xatoi+0x44>
			radix = 16;
			c = *(++(*str));
 80097d6:	1c93      	adds	r3, r2, #2
 80097d8:	6003      	str	r3, [r0, #0]
 80097da:	7893      	ldrb	r3, [r2, #2]
		c = *(++(*str));
		if (c <= ' ') {
			*res = 0; return 1;
		}
		if (c == 'x') {
			radix = 16;
 80097dc:	2410      	movs	r4, #16
 80097de:	e013      	b.n	8009808 <xatoi+0x6c>
			c = *(++(*str));
		} else {
			if (c == 'b') {
 80097e0:	2b62      	cmp	r3, #98	; 0x62
 80097e2:	d104      	bne.n	80097ee <xatoi+0x52>
				radix = 2;
				c = *(++(*str));
 80097e4:	1c93      	adds	r3, r2, #2
 80097e6:	6003      	str	r3, [r0, #0]
 80097e8:	7893      	ldrb	r3, [r2, #2]
		if (c == 'x') {
			radix = 16;
			c = *(++(*str));
		} else {
			if (c == 'b') {
				radix = 2;
 80097ea:	2402      	movs	r4, #2
 80097ec:	e00c      	b.n	8009808 <xatoi+0x6c>
				c = *(++(*str));
			} else {
				if ((c >= '0')&&(c <= '9'))
 80097ee:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 80097f2:	2a09      	cmp	r2, #9
 80097f4:	d907      	bls.n	8009806 <xatoi+0x6a>
					radix = 8;
				else
					return 0;
 80097f6:	2000      	movs	r0, #0
 80097f8:	bd70      	pop	{r4, r5, r6, pc}
			}
		}
	} else {
		if ((c < '1')||(c > '9'))
 80097fa:	f1a3 0231 	sub.w	r2, r3, #49	; 0x31
 80097fe:	2a08      	cmp	r2, #8
 8009800:	d8f9      	bhi.n	80097f6 <xatoi+0x5a>
			return 0;
		radix = 10;
 8009802:	240a      	movs	r4, #10
 8009804:	e000      	b.n	8009808 <xatoi+0x6c>
			if (c == 'b') {
				radix = 2;
				c = *(++(*str));
			} else {
				if ((c >= '0')&&(c <= '9'))
					radix = 8;
 8009806:	2408      	movs	r4, #8
	} else {
		if ((c < '1')||(c > '9'))
			return 0;
		radix = 10;
	}
	val = 0;
 8009808:	2200      	movs	r2, #0
	while (c > ' ') {
 800980a:	e014      	b.n	8009836 <xatoi+0x9a>
		if (c >= 'a') c -= 0x20;
 800980c:	2b60      	cmp	r3, #96	; 0x60
 800980e:	d901      	bls.n	8009814 <xatoi+0x78>
 8009810:	3b20      	subs	r3, #32
 8009812:	b2db      	uxtb	r3, r3
		c -= '0';
 8009814:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
 8009818:	b2ed      	uxtb	r5, r5
		if (c >= 17) {
 800981a:	2d10      	cmp	r5, #16
 800981c:	d903      	bls.n	8009826 <xatoi+0x8a>
			c -= 7;
 800981e:	3b37      	subs	r3, #55	; 0x37
 8009820:	b2dd      	uxtb	r5, r3
			if (c <= 9) return 0;
 8009822:	2d09      	cmp	r5, #9
 8009824:	d9e7      	bls.n	80097f6 <xatoi+0x5a>
		}
		if (c >= radix) return 0;
 8009826:	42a5      	cmp	r5, r4
 8009828:	d2e5      	bcs.n	80097f6 <xatoi+0x5a>
		val = val * radix + c;
		c = *(++(*str));
 800982a:	6803      	ldr	r3, [r0, #0]
		if (c >= 17) {
			c -= 7;
			if (c <= 9) return 0;
		}
		if (c >= radix) return 0;
		val = val * radix + c;
 800982c:	fb04 5202 	mla	r2, r4, r2, r5
		c = *(++(*str));
 8009830:	1c5d      	adds	r5, r3, #1
 8009832:	6005      	str	r5, [r0, #0]
 8009834:	785b      	ldrb	r3, [r3, #1]
		if ((c < '1')||(c > '9'))
			return 0;
		radix = 10;
	}
	val = 0;
	while (c > ' ') {
 8009836:	2b20      	cmp	r3, #32
 8009838:	d8e8      	bhi.n	800980c <xatoi+0x70>
		}
		if (c >= radix) return 0;
		val = val * radix + c;
		c = *(++(*str));
	}
	if (s) val = -val;
 800983a:	b106      	cbz	r6, 800983e <xatoi+0xa2>
 800983c:	4252      	negs	r2, r2
	*res = val;
 800983e:	600a      	str	r2, [r1, #0]
	return 1;
 8009840:	2001      	movs	r0, #1
}
 8009842:	bd70      	pop	{r4, r5, r6, pc}

08009844 <xputc>:



void xputc (char c)
{
	if (c == '\n') {
 8009844:	280a      	cmp	r0, #10




void xputc (char c)
{
 8009846:	b510      	push	{r4, lr}
 8009848:	4604      	mov	r4, r0
	if (c == '\n') {
 800984a:	d105      	bne.n	8009858 <xputc+0x14>
		__uart_putchar('\r');
 800984c:	200d      	movs	r0, #13
 800984e:	f7fe fc57 	bl	8008100 <__uart_putchar>
		SWO_PrintChar('\r');
 8009852:	200d      	movs	r0, #13
 8009854:	f7fe fed2 	bl	80085fc <SWO_PrintChar>
	}
	__uart_putchar(c);
 8009858:	4620      	mov	r0, r4
 800985a:	f7fe fc51 	bl	8008100 <__uart_putchar>
	SWO_PrintChar(c);
 800985e:	4620      	mov	r0, r4

}
 8009860:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	if (c == '\n') {
		__uart_putchar('\r');
		SWO_PrintChar('\r');
	}
	__uart_putchar(c);
	SWO_PrintChar(c);
 8009864:	f7fe beca 	b.w	80085fc <SWO_PrintChar>

08009868 <xputs>:




void xputs (const char* str)
{
 8009868:	b510      	push	{r4, lr}
}




void xputs (const char* str)
 800986a:	1e44      	subs	r4, r0, #1
{
	while (*str)
 800986c:	e001      	b.n	8009872 <xputs+0xa>
		xputc(*str++);
 800986e:	f7ff ffe9 	bl	8009844 <xputc>



void xputs (const char* str)
{
	while (*str)
 8009872:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 8009876:	2800      	cmp	r0, #0
 8009878:	d1f9      	bne.n	800986e <xputs+0x6>
		xputc(*str++);
}
 800987a:	bd10      	pop	{r4, pc}

0800987c <xitoa>:




void xitoa (long val, int radix, int len)
{
 800987c:	b5f0      	push	{r4, r5, r6, r7, lr}
	BYTE c, r, sgn = 0, pad = ' ';
	BYTE s[20], i = 0;
	DWORD v;


	if (radix < 0) {
 800987e:	2900      	cmp	r1, #0




void xitoa (long val, int radix, int len)
{
 8009880:	b087      	sub	sp, #28
	BYTE c, r, sgn = 0, pad = ' ';
	BYTE s[20], i = 0;
	DWORD v;


	if (radix < 0) {
 8009882:	da05      	bge.n	8009890 <xitoa+0x14>
		radix = -radix;
 8009884:	4249      	negs	r1, r1
		if (val < 0) {
 8009886:	2800      	cmp	r0, #0
 8009888:	da02      	bge.n	8009890 <xitoa+0x14>
			val = -val;
 800988a:	4240      	negs	r0, r0
			sgn = '-';
 800988c:	232d      	movs	r3, #45	; 0x2d
 800988e:	e000      	b.n	8009892 <xitoa+0x16>



void xitoa (long val, int radix, int len)
{
	BYTE c, r, sgn = 0, pad = ' ';
 8009890:	2300      	movs	r3, #0
			sgn = '-';
		}
	}
	v = val;
	r = radix;
	if (len < 0) {
 8009892:	2a00      	cmp	r2, #0
 8009894:	da02      	bge.n	800989c <xitoa+0x20>
		len = -len;
 8009896:	4252      	negs	r2, r2
		pad = '0';
 8009898:	2630      	movs	r6, #48	; 0x30
 800989a:	e000      	b.n	800989e <xitoa+0x22>



void xitoa (long val, int radix, int len)
{
	BYTE c, r, sgn = 0, pad = ' ';
 800989c:	2620      	movs	r6, #32
	r = radix;
	if (len < 0) {
		len = -len;
		pad = '0';
	}
	if (len > 20) return;
 800989e:	2a14      	cmp	r2, #20
 80098a0:	dc30      	bgt.n	8009904 <xitoa+0x88>
		if (val < 0) {
			val = -val;
			sgn = '-';
		}
	}
	v = val;
 80098a2:	2500      	movs	r5, #0
				buff[idx++] = c; xputc(c);
		}
	}
	buff[idx] = 0;
	xputc('\n');
}
 80098a4:	b2c9      	uxtb	r1, r1
 80098a6:	e000      	b.n	80098aa <xitoa+0x2e>
	if (len > 20) return;
	do {
		c = (BYTE)(v % r);
		if (c >= 10) c += 7;
		c += '0';
		s[i++] = c;
 80098a8:	4625      	mov	r5, r4
		len = -len;
		pad = '0';
	}
	if (len > 20) return;
	do {
		c = (BYTE)(v % r);
 80098aa:	fbb0 f7f1 	udiv	r7, r0, r1
 80098ae:	fb01 0017 	mls	r0, r1, r7, r0
 80098b2:	b2c0      	uxtb	r0, r0
		if (c >= 10) c += 7;
 80098b4:	2809      	cmp	r0, #9
 80098b6:	d901      	bls.n	80098bc <xitoa+0x40>
 80098b8:	3007      	adds	r0, #7
 80098ba:	b2c0      	uxtb	r0, r0
		c += '0';
		s[i++] = c;
 80098bc:	f10d 0e18 	add.w	lr, sp, #24
 80098c0:	eb0e 0405 	add.w	r4, lr, r5
	}
	if (len > 20) return;
	do {
		c = (BYTE)(v % r);
		if (c >= 10) c += 7;
		c += '0';
 80098c4:	3030      	adds	r0, #48	; 0x30
		s[i++] = c;
 80098c6:	f804 0c14 	strb.w	r0, [r4, #-20]
 80098ca:	1c6c      	adds	r4, r5, #1
 80098cc:	b2e4      	uxtb	r4, r4
		v /= r;
 80098ce:	4638      	mov	r0, r7
	} while (v);
 80098d0:	2f00      	cmp	r7, #0
 80098d2:	d1e9      	bne.n	80098a8 <xitoa+0x2c>
	if (sgn) s[i++] = sgn;
 80098d4:	b153      	cbz	r3, 80098ec <xitoa+0x70>
 80098d6:	4474      	add	r4, lr
 80098d8:	f804 3c14 	strb.w	r3, [r4, #-20]
 80098dc:	1cac      	adds	r4, r5, #2
 80098de:	e004      	b.n	80098ea <xitoa+0x6e>
	while (i < len)
		s[i++] = pad;
 80098e0:	a906      	add	r1, sp, #24
 80098e2:	190b      	adds	r3, r1, r4
 80098e4:	f803 6c14 	strb.w	r6, [r3, #-20]
 80098e8:	3401      	adds	r4, #1
 80098ea:	b2e4      	uxtb	r4, r4
		c += '0';
		s[i++] = c;
		v /= r;
	} while (v);
	if (sgn) s[i++] = sgn;
	while (i < len)
 80098ec:	4294      	cmp	r4, r2
 80098ee:	dbf7      	blt.n	80098e0 <xitoa+0x64>
		s[i++] = pad;
	do
		xputc(s[--i]);
 80098f0:	3c01      	subs	r4, #1
 80098f2:	b2e4      	uxtb	r4, r4
 80098f4:	aa06      	add	r2, sp, #24
 80098f6:	1913      	adds	r3, r2, r4
 80098f8:	f813 0c14 	ldrb.w	r0, [r3, #-20]
 80098fc:	f7ff ffa2 	bl	8009844 <xputc>
	while (i);
 8009900:	2c00      	cmp	r4, #0
 8009902:	d1f5      	bne.n	80098f0 <xitoa+0x74>
}
 8009904:	b007      	add	sp, #28
 8009906:	bdf0      	pop	{r4, r5, r6, r7, pc}

08009908 <xprintf>:

void xprintf (const char* str, ...)
{
 8009908:	b40f      	push	{r0, r1, r2, r3}
 800990a:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800990c:	ab06      	add	r3, sp, #24
 800990e:	f853 4b04 	ldr.w	r4, [r3], #4
		d = *str++; w = r = s = l = 0;
		if (d == '0') {
			d = *str++; s = 1;
		}
		while ((d >= '0')&&(d <= '9')) {
			w += w * 10 + (d - '0');
 8009912:	250a      	movs	r5, #10
{
	va_list arp;
	int d, r, w, s, l;


	va_start(arp, str);
 8009914:	9301      	str	r3, [sp, #4]

	while ((d = *str++) != 0) {
 8009916:	e041      	b.n	800999c <xprintf+0x94>
		if (d != '%') {
 8009918:	2825      	cmp	r0, #37	; 0x25
 800991a:	d001      	beq.n	8009920 <xprintf+0x18>
	int d, r, w, s, l;


	va_start(arp, str);

	while ((d = *str++) != 0) {
 800991c:	3401      	adds	r4, #1
 800991e:	e029      	b.n	8009974 <xprintf+0x6c>
		if (d != '%') {
			xputc(d); continue;
		}
		d = *str++; w = r = s = l = 0;
 8009920:	7863      	ldrb	r3, [r4, #1]
		if (d == '0') {
 8009922:	2b30      	cmp	r3, #48	; 0x30
 8009924:	d002      	beq.n	800992c <xprintf+0x24>

	while ((d = *str++) != 0) {
		if (d != '%') {
			xputc(d); continue;
		}
		d = *str++; w = r = s = l = 0;
 8009926:	3402      	adds	r4, #2
 8009928:	2100      	movs	r1, #0
 800992a:	e002      	b.n	8009932 <xprintf+0x2a>
		if (d == '0') {
			d = *str++; s = 1;
 800992c:	78a3      	ldrb	r3, [r4, #2]
 800992e:	2101      	movs	r1, #1
 8009930:	3403      	adds	r4, #3

	while ((d = *str++) != 0) {
		if (d != '%') {
			xputc(d); continue;
		}
		d = *str++; w = r = s = l = 0;
 8009932:	2200      	movs	r2, #0
 8009934:	e004      	b.n	8009940 <xprintf+0x38>
		if (d == '0') {
			d = *str++; s = 1;
		}
		while ((d >= '0')&&(d <= '9')) {
			w += w * 10 + (d - '0');
 8009936:	fb05 0002 	mla	r0, r5, r2, r0
			d = *str++;
 800993a:	f814 3b01 	ldrb.w	r3, [r4], #1
		d = *str++; w = r = s = l = 0;
		if (d == '0') {
			d = *str++; s = 1;
		}
		while ((d >= '0')&&(d <= '9')) {
			w += w * 10 + (d - '0');
 800993e:	1812      	adds	r2, r2, r0
		}
		d = *str++; w = r = s = l = 0;
		if (d == '0') {
			d = *str++; s = 1;
		}
		while ((d >= '0')&&(d <= '9')) {
 8009940:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 8009944:	2809      	cmp	r0, #9
 8009946:	d9f6      	bls.n	8009936 <xprintf+0x2e>
			w += w * 10 + (d - '0');
			d = *str++;
		}
		if (s) w = -w;
 8009948:	b101      	cbz	r1, 800994c <xprintf+0x44>
 800994a:	4252      	negs	r2, r2
		if (d == 'l') {
 800994c:	2b6c      	cmp	r3, #108	; 0x6c
			l = 1;
			d = *str++;
 800994e:	bf08      	it	eq
 8009950:	f814 3b01 	ldrbeq.w	r3, [r4], #1
		}
		if (!d) break;
 8009954:	b37b      	cbz	r3, 80099b6 <xprintf+0xae>
		if (d == 's') {
 8009956:	2b73      	cmp	r3, #115	; 0x73
 8009958:	d106      	bne.n	8009968 <xprintf+0x60>
			xputs(va_arg(arp, char*));
 800995a:	9b01      	ldr	r3, [sp, #4]
 800995c:	1d1a      	adds	r2, r3, #4
 800995e:	6818      	ldr	r0, [r3, #0]
 8009960:	9201      	str	r2, [sp, #4]
 8009962:	f7ff ff81 	bl	8009868 <xputs>
			continue;
 8009966:	e019      	b.n	800999c <xprintf+0x94>
		}
		if (d == 'c') {
 8009968:	2b63      	cmp	r3, #99	; 0x63
 800996a:	d106      	bne.n	800997a <xprintf+0x72>
			xputc((char)va_arg(arp, int));
 800996c:	9b01      	ldr	r3, [sp, #4]
 800996e:	1d1a      	adds	r2, r3, #4
 8009970:	7818      	ldrb	r0, [r3, #0]
 8009972:	9201      	str	r2, [sp, #4]
 8009974:	f7ff ff66 	bl	8009844 <xputc>
			continue;
 8009978:	e010      	b.n	800999c <xprintf+0x94>
		}
		if (d == 'u') r = 10;
 800997a:	2b75      	cmp	r3, #117	; 0x75
 800997c:	d014      	beq.n	80099a8 <xprintf+0xa0>
		if (d == 'd') r = -10;
 800997e:	2b64      	cmp	r3, #100	; 0x64
 8009980:	d014      	beq.n	80099ac <xprintf+0xa4>
		if (d == 'X' || d == 'x') r = 16; // 'x' added by mthomas in increase compatibility
 8009982:	2b58      	cmp	r3, #88	; 0x58
 8009984:	d015      	beq.n	80099b2 <xprintf+0xaa>
 8009986:	2b78      	cmp	r3, #120	; 0x78
 8009988:	d013      	beq.n	80099b2 <xprintf+0xaa>
		if (d == 'b') r = 2;
 800998a:	2b62      	cmp	r3, #98	; 0x62
 800998c:	d00a      	beq.n	80099a4 <xprintf+0x9c>
 800998e:	e012      	b.n	80099b6 <xprintf+0xae>
			xitoa((long)va_arg(arp, long), r, w);
		} else {
			if (r > 0)
				xitoa((unsigned long)va_arg(arp, int), r, w);
			else
				xitoa((long)va_arg(arp, int), r, w);
 8009990:	9b01      	ldr	r3, [sp, #4]
 8009992:	1d18      	adds	r0, r3, #4
 8009994:	9001      	str	r0, [sp, #4]
 8009996:	6818      	ldr	r0, [r3, #0]
 8009998:	f7ff ff70 	bl	800987c <xitoa>
	int d, r, w, s, l;


	va_start(arp, str);

	while ((d = *str++) != 0) {
 800999c:	7820      	ldrb	r0, [r4, #0]
 800999e:	2800      	cmp	r0, #0
 80099a0:	d1ba      	bne.n	8009918 <xprintf+0x10>
 80099a2:	e008      	b.n	80099b6 <xprintf+0xae>
			continue;
		}
		if (d == 'u') r = 10;
		if (d == 'd') r = -10;
		if (d == 'X' || d == 'x') r = 16; // 'x' added by mthomas in increase compatibility
		if (d == 'b') r = 2;
 80099a4:	2102      	movs	r1, #2
 80099a6:	e7f3      	b.n	8009990 <xprintf+0x88>
		}
		if (d == 'c') {
			xputc((char)va_arg(arp, int));
			continue;
		}
		if (d == 'u') r = 10;
 80099a8:	210a      	movs	r1, #10
 80099aa:	e7f1      	b.n	8009990 <xprintf+0x88>
		if (d == 'd') r = -10;
 80099ac:	f06f 0109 	mvn.w	r1, #9
 80099b0:	e7ee      	b.n	8009990 <xprintf+0x88>
		if (d == 'X' || d == 'x') r = 16; // 'x' added by mthomas in increase compatibility
		if (d == 'b') r = 2;
		if (!r) break;
		if (l) {
 80099b2:	2110      	movs	r1, #16
 80099b4:	e7ec      	b.n	8009990 <xprintf+0x88>
				xitoa((long)va_arg(arp, int), r, w);
		}
	}

	va_end(arp);
}
 80099b6:	e8bd 403e 	ldmia.w	sp!, {r1, r2, r3, r4, r5, lr}
 80099ba:	b004      	add	sp, #16
 80099bc:	4770      	bx	lr

080099be <put_dump>:




void put_dump (const BYTE *buff, DWORD ofs, int cnt)
{
 80099be:	b570      	push	{r4, r5, r6, lr}
 80099c0:	4606      	mov	r6, r0
	BYTE n;


	xprintf("%08lX ", ofs);
 80099c2:	4812      	ldr	r0, [pc, #72]	; (8009a0c <put_dump+0x4e>)




void put_dump (const BYTE *buff, DWORD ofs, int cnt)
{
 80099c4:	4615      	mov	r5, r2
	BYTE n;


	xprintf("%08lX ", ofs);
	for(n = 0; n < cnt; n++)
 80099c6:	2400      	movs	r4, #0
void put_dump (const BYTE *buff, DWORD ofs, int cnt)
{
	BYTE n;


	xprintf("%08lX ", ofs);
 80099c8:	f7ff ff9e 	bl	8009908 <xprintf>
	for(n = 0; n < cnt; n++)
 80099cc:	e005      	b.n	80099da <put_dump+0x1c>
		xprintf(" %02X", buff[n]);
 80099ce:	5d31      	ldrb	r1, [r6, r4]
 80099d0:	480f      	ldr	r0, [pc, #60]	; (8009a10 <put_dump+0x52>)
 80099d2:	f7ff ff99 	bl	8009908 <xprintf>
{
	BYTE n;


	xprintf("%08lX ", ofs);
	for(n = 0; n < cnt; n++)
 80099d6:	3401      	adds	r4, #1
 80099d8:	b2e4      	uxtb	r4, r4
 80099da:	42ac      	cmp	r4, r5
 80099dc:	dbf7      	blt.n	80099ce <put_dump+0x10>
		xprintf(" %02X", buff[n]);
	xputc(' ');
 80099de:	2020      	movs	r0, #32
 80099e0:	f7ff ff30 	bl	8009844 <xputc>
	for(n = 0; n < cnt; n++) {
 80099e4:	2400      	movs	r4, #0
 80099e6:	e009      	b.n	80099fc <put_dump+0x3e>
		if ((buff[n] < 0x20)||(buff[n] >= 0x7F))
 80099e8:	5d30      	ldrb	r0, [r6, r4]
 80099ea:	f1a0 0320 	sub.w	r3, r0, #32
 80099ee:	2b5e      	cmp	r3, #94	; 0x5e
			xputc('.');
 80099f0:	bf88      	it	hi
 80099f2:	202e      	movhi	r0, #46	; 0x2e
		else
			xputc(buff[n]);
 80099f4:	f7ff ff26 	bl	8009844 <xputc>

	xprintf("%08lX ", ofs);
	for(n = 0; n < cnt; n++)
		xprintf(" %02X", buff[n]);
	xputc(' ');
	for(n = 0; n < cnt; n++) {
 80099f8:	3401      	adds	r4, #1
 80099fa:	b2e4      	uxtb	r4, r4
 80099fc:	42ac      	cmp	r4, r5
 80099fe:	dbf3      	blt.n	80099e8 <put_dump+0x2a>
		if ((buff[n] < 0x20)||(buff[n] >= 0x7F))
			xputc('.');
		else
			xputc(buff[n]);
	}
	xputc('\n');
 8009a00:	200a      	movs	r0, #10
}
 8009a02:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if ((buff[n] < 0x20)||(buff[n] >= 0x7F))
			xputc('.');
		else
			xputc(buff[n]);
	}
	xputc('\n');
 8009a06:	f7ff bf1d 	b.w	8009844 <xputc>
 8009a0a:	bf00      	nop
 8009a0c:	080204a8 	.word	0x080204a8
 8009a10:	080204af 	.word	0x080204af

08009a14 <get_line>:
}

void get_line (char *buff, int len)
{
 8009a14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009a16:	4606      	mov	r6, r0
	char c;
	int idx = 0;
 8009a18:	2400      	movs	r4, #0
		if (c == '\n') break;
		if ((c == '\b') && idx) {
			idx--; xputc(c);
			xputc(' '); xputc(c); // added by mthomas for Eclipse Terminal plug-in
		}
		if (((BYTE)c >= ' ') && (idx < len - 1)) {
 8009a1a:	1e4f      	subs	r7, r1, #1
{
	char c;
	int idx = 0;

	for (;;) {
		c = xgetc();
 8009a1c:	f7fe faea 	bl	8007ff4 <comm_getc>
		if (c == '\r') break;
 8009a20:	280d      	cmp	r0, #13
{
	char c;
	int idx = 0;

	for (;;) {
		c = xgetc();
 8009a22:	4605      	mov	r5, r0
		if (c == '\r') break;
 8009a24:	d016      	beq.n	8009a54 <get_line+0x40>
		if (c == '\n') break;
 8009a26:	280a      	cmp	r0, #10
 8009a28:	d014      	beq.n	8009a54 <get_line+0x40>
		if ((c == '\b') && idx) {
 8009a2a:	2808      	cmp	r0, #8
 8009a2c:	d109      	bne.n	8009a42 <get_line+0x2e>
 8009a2e:	2c00      	cmp	r4, #0
 8009a30:	d0f4      	beq.n	8009a1c <get_line+0x8>
			idx--; xputc(c);
 8009a32:	f7ff ff07 	bl	8009844 <xputc>
			xputc(' '); xputc(c); // added by mthomas for Eclipse Terminal plug-in
 8009a36:	2020      	movs	r0, #32
 8009a38:	f7ff ff04 	bl	8009844 <xputc>
	for (;;) {
		c = xgetc();
		if (c == '\r') break;
		if (c == '\n') break;
		if ((c == '\b') && idx) {
			idx--; xputc(c);
 8009a3c:	3c01      	subs	r4, #1
			xputc(' '); xputc(c); // added by mthomas for Eclipse Terminal plug-in
 8009a3e:	4628      	mov	r0, r5
 8009a40:	e005      	b.n	8009a4e <get_line+0x3a>
		}
		if (((BYTE)c >= ' ') && (idx < len - 1)) {
 8009a42:	281f      	cmp	r0, #31
 8009a44:	d9ea      	bls.n	8009a1c <get_line+0x8>
 8009a46:	42bc      	cmp	r4, r7
 8009a48:	dae8      	bge.n	8009a1c <get_line+0x8>
				buff[idx++] = c; xputc(c);
 8009a4a:	5530      	strb	r0, [r6, r4]
 8009a4c:	3401      	adds	r4, #1
 8009a4e:	f7ff fef9 	bl	8009844 <xputc>
 8009a52:	e7e3      	b.n	8009a1c <get_line+0x8>
		}
	}
	buff[idx] = 0;
 8009a54:	2300      	movs	r3, #0
	xputc('\n');
 8009a56:	200a      	movs	r0, #10
		}
		if (((BYTE)c >= ' ') && (idx < len - 1)) {
				buff[idx++] = c; xputc(c);
		}
	}
	buff[idx] = 0;
 8009a58:	5533      	strb	r3, [r6, r4]
	xputc('\n');
}
 8009a5a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		if (((BYTE)c >= ' ') && (idx < len - 1)) {
				buff[idx++] = c; xputc(c);
		}
	}
	buff[idx] = 0;
	xputc('\n');
 8009a5e:	f7ff bef1 	b.w	8009844 <xputc>
 8009a62:	bf00      	nop

08009a64 <d_fill_name>:
 8009a64:	b480      	push	{r7}
 8009a66:	b085      	sub	sp, #20
 8009a68:	af00      	add	r7, sp, #0
 8009a6a:	60f8      	str	r0, [r7, #12]
 8009a6c:	60b9      	str	r1, [r7, #8]
 8009a6e:	607a      	str	r2, [r7, #4]
 8009a70:	68fb      	ldr	r3, [r7, #12]
 8009a72:	2b00      	cmp	r3, #0
 8009a74:	d005      	beq.n	8009a82 <d_fill_name+0x1e>
 8009a76:	68bb      	ldr	r3, [r7, #8]
 8009a78:	2b00      	cmp	r3, #0
 8009a7a:	d002      	beq.n	8009a82 <d_fill_name+0x1e>
 8009a7c:	687b      	ldr	r3, [r7, #4]
 8009a7e:	2b00      	cmp	r3, #0
 8009a80:	d102      	bne.n	8009a88 <d_fill_name+0x24>
 8009a82:	f04f 0300 	mov.w	r3, #0
 8009a86:	e00b      	b.n	8009aa0 <d_fill_name+0x3c>
 8009a88:	68fb      	ldr	r3, [r7, #12]
 8009a8a:	f04f 0200 	mov.w	r2, #0
 8009a8e:	701a      	strb	r2, [r3, #0]
 8009a90:	68fb      	ldr	r3, [r7, #12]
 8009a92:	68ba      	ldr	r2, [r7, #8]
 8009a94:	605a      	str	r2, [r3, #4]
 8009a96:	68fb      	ldr	r3, [r7, #12]
 8009a98:	687a      	ldr	r2, [r7, #4]
 8009a9a:	609a      	str	r2, [r3, #8]
 8009a9c:	f04f 0301 	mov.w	r3, #1
 8009aa0:	4618      	mov	r0, r3
 8009aa2:	f107 0714 	add.w	r7, r7, #20
 8009aa6:	46bd      	mov	sp, r7
 8009aa8:	bc80      	pop	{r7}
 8009aaa:	4770      	bx	lr

08009aac <d_fill_extended_operator>:
 8009aac:	b480      	push	{r7}
 8009aae:	b085      	sub	sp, #20
 8009ab0:	af00      	add	r7, sp, #0
 8009ab2:	60f8      	str	r0, [r7, #12]
 8009ab4:	60b9      	str	r1, [r7, #8]
 8009ab6:	607a      	str	r2, [r7, #4]
 8009ab8:	68fb      	ldr	r3, [r7, #12]
 8009aba:	2b00      	cmp	r3, #0
 8009abc:	d005      	beq.n	8009aca <d_fill_extended_operator+0x1e>
 8009abe:	68bb      	ldr	r3, [r7, #8]
 8009ac0:	2b00      	cmp	r3, #0
 8009ac2:	db02      	blt.n	8009aca <d_fill_extended_operator+0x1e>
 8009ac4:	687b      	ldr	r3, [r7, #4]
 8009ac6:	2b00      	cmp	r3, #0
 8009ac8:	d102      	bne.n	8009ad0 <d_fill_extended_operator+0x24>
 8009aca:	f04f 0300 	mov.w	r3, #0
 8009ace:	e00b      	b.n	8009ae8 <d_fill_extended_operator+0x3c>
 8009ad0:	68fb      	ldr	r3, [r7, #12]
 8009ad2:	f04f 022e 	mov.w	r2, #46	; 0x2e
 8009ad6:	701a      	strb	r2, [r3, #0]
 8009ad8:	68fb      	ldr	r3, [r7, #12]
 8009ada:	68ba      	ldr	r2, [r7, #8]
 8009adc:	605a      	str	r2, [r3, #4]
 8009ade:	68fb      	ldr	r3, [r7, #12]
 8009ae0:	687a      	ldr	r2, [r7, #4]
 8009ae2:	609a      	str	r2, [r3, #8]
 8009ae4:	f04f 0301 	mov.w	r3, #1
 8009ae8:	4618      	mov	r0, r3
 8009aea:	f107 0714 	add.w	r7, r7, #20
 8009aee:	46bd      	mov	sp, r7
 8009af0:	bc80      	pop	{r7}
 8009af2:	4770      	bx	lr

08009af4 <d_fill_ctor>:
 8009af4:	b480      	push	{r7}
 8009af6:	b085      	sub	sp, #20
 8009af8:	af00      	add	r7, sp, #0
 8009afa:	60f8      	str	r0, [r7, #12]
 8009afc:	460b      	mov	r3, r1
 8009afe:	607a      	str	r2, [r7, #4]
 8009b00:	72fb      	strb	r3, [r7, #11]
 8009b02:	68fb      	ldr	r3, [r7, #12]
 8009b04:	2b00      	cmp	r3, #0
 8009b06:	d008      	beq.n	8009b1a <d_fill_ctor+0x26>
 8009b08:	687b      	ldr	r3, [r7, #4]
 8009b0a:	2b00      	cmp	r3, #0
 8009b0c:	d005      	beq.n	8009b1a <d_fill_ctor+0x26>
 8009b0e:	7afb      	ldrb	r3, [r7, #11]
 8009b10:	2b00      	cmp	r3, #0
 8009b12:	d002      	beq.n	8009b1a <d_fill_ctor+0x26>
 8009b14:	7afb      	ldrb	r3, [r7, #11]
 8009b16:	2b04      	cmp	r3, #4
 8009b18:	d902      	bls.n	8009b20 <d_fill_ctor+0x2c>
 8009b1a:	f04f 0300 	mov.w	r3, #0
 8009b1e:	e00b      	b.n	8009b38 <d_fill_ctor+0x44>
 8009b20:	68fb      	ldr	r3, [r7, #12]
 8009b22:	f04f 0207 	mov.w	r2, #7
 8009b26:	701a      	strb	r2, [r3, #0]
 8009b28:	68fb      	ldr	r3, [r7, #12]
 8009b2a:	7afa      	ldrb	r2, [r7, #11]
 8009b2c:	711a      	strb	r2, [r3, #4]
 8009b2e:	68fb      	ldr	r3, [r7, #12]
 8009b30:	687a      	ldr	r2, [r7, #4]
 8009b32:	609a      	str	r2, [r3, #8]
 8009b34:	f04f 0301 	mov.w	r3, #1
 8009b38:	4618      	mov	r0, r3
 8009b3a:	f107 0714 	add.w	r7, r7, #20
 8009b3e:	46bd      	mov	sp, r7
 8009b40:	bc80      	pop	{r7}
 8009b42:	4770      	bx	lr

08009b44 <d_fill_dtor>:
 8009b44:	b480      	push	{r7}
 8009b46:	b085      	sub	sp, #20
 8009b48:	af00      	add	r7, sp, #0
 8009b4a:	60f8      	str	r0, [r7, #12]
 8009b4c:	460b      	mov	r3, r1
 8009b4e:	607a      	str	r2, [r7, #4]
 8009b50:	72fb      	strb	r3, [r7, #11]
 8009b52:	68fb      	ldr	r3, [r7, #12]
 8009b54:	2b00      	cmp	r3, #0
 8009b56:	d008      	beq.n	8009b6a <d_fill_dtor+0x26>
 8009b58:	687b      	ldr	r3, [r7, #4]
 8009b5a:	2b00      	cmp	r3, #0
 8009b5c:	d005      	beq.n	8009b6a <d_fill_dtor+0x26>
 8009b5e:	7afb      	ldrb	r3, [r7, #11]
 8009b60:	2b00      	cmp	r3, #0
 8009b62:	d002      	beq.n	8009b6a <d_fill_dtor+0x26>
 8009b64:	7afb      	ldrb	r3, [r7, #11]
 8009b66:	2b04      	cmp	r3, #4
 8009b68:	d902      	bls.n	8009b70 <d_fill_dtor+0x2c>
 8009b6a:	f04f 0300 	mov.w	r3, #0
 8009b6e:	e00b      	b.n	8009b88 <d_fill_dtor+0x44>
 8009b70:	68fb      	ldr	r3, [r7, #12]
 8009b72:	f04f 0208 	mov.w	r2, #8
 8009b76:	701a      	strb	r2, [r3, #0]
 8009b78:	68fb      	ldr	r3, [r7, #12]
 8009b7a:	7afa      	ldrb	r2, [r7, #11]
 8009b7c:	711a      	strb	r2, [r3, #4]
 8009b7e:	68fb      	ldr	r3, [r7, #12]
 8009b80:	687a      	ldr	r2, [r7, #4]
 8009b82:	609a      	str	r2, [r3, #8]
 8009b84:	f04f 0301 	mov.w	r3, #1
 8009b88:	4618      	mov	r0, r3
 8009b8a:	f107 0714 	add.w	r7, r7, #20
 8009b8e:	46bd      	mov	sp, r7
 8009b90:	bc80      	pop	{r7}
 8009b92:	4770      	bx	lr

08009b94 <d_make_empty>:
 8009b94:	b480      	push	{r7}
 8009b96:	b085      	sub	sp, #20
 8009b98:	af00      	add	r7, sp, #0
 8009b9a:	6078      	str	r0, [r7, #4]
 8009b9c:	687b      	ldr	r3, [r7, #4]
 8009b9e:	695a      	ldr	r2, [r3, #20]
 8009ba0:	687b      	ldr	r3, [r7, #4]
 8009ba2:	699b      	ldr	r3, [r3, #24]
 8009ba4:	429a      	cmp	r2, r3
 8009ba6:	db02      	blt.n	8009bae <d_make_empty+0x1a>
 8009ba8:	f04f 0300 	mov.w	r3, #0
 8009bac:	e013      	b.n	8009bd6 <d_make_empty+0x42>
 8009bae:	687b      	ldr	r3, [r7, #4]
 8009bb0:	6919      	ldr	r1, [r3, #16]
 8009bb2:	687b      	ldr	r3, [r7, #4]
 8009bb4:	695b      	ldr	r3, [r3, #20]
 8009bb6:	461a      	mov	r2, r3
 8009bb8:	4613      	mov	r3, r2
 8009bba:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8009bbe:	189b      	adds	r3, r3, r2
 8009bc0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8009bc4:	18cb      	adds	r3, r1, r3
 8009bc6:	60fb      	str	r3, [r7, #12]
 8009bc8:	687b      	ldr	r3, [r7, #4]
 8009bca:	695b      	ldr	r3, [r3, #20]
 8009bcc:	f103 0201 	add.w	r2, r3, #1
 8009bd0:	687b      	ldr	r3, [r7, #4]
 8009bd2:	615a      	str	r2, [r3, #20]
 8009bd4:	68fb      	ldr	r3, [r7, #12]
 8009bd6:	4618      	mov	r0, r3
 8009bd8:	f107 0714 	add.w	r7, r7, #20
 8009bdc:	46bd      	mov	sp, r7
 8009bde:	bc80      	pop	{r7}
 8009be0:	4770      	bx	lr
 8009be2:	bf00      	nop

08009be4 <d_make_comp>:
 8009be4:	b580      	push	{r7, lr}
 8009be6:	b086      	sub	sp, #24
 8009be8:	af00      	add	r7, sp, #0
 8009bea:	60f8      	str	r0, [r7, #12]
 8009bec:	607a      	str	r2, [r7, #4]
 8009bee:	603b      	str	r3, [r7, #0]
 8009bf0:	460b      	mov	r3, r1
 8009bf2:	72fb      	strb	r3, [r7, #11]
 8009bf4:	7afb      	ldrb	r3, [r7, #11]
 8009bf6:	f103 33ff 	add.w	r3, r3, #4294967295
 8009bfa:	2b45      	cmp	r3, #69	; 0x45
 8009bfc:	f200 80a5 	bhi.w	8009d4a <d_make_comp+0x166>
 8009c00:	a201      	add	r2, pc, #4	; (adr r2, 8009c08 <d_make_comp+0x24>)
 8009c02:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009c06:	bf00      	nop
 8009c08:	08009d21 	.word	0x08009d21
 8009c0c:	08009d21 	.word	0x08009d21
 8009c10:	08009d21 	.word	0x08009d21
 8009c14:	08009d21 	.word	0x08009d21
 8009c18:	08009d4b 	.word	0x08009d4b
 8009c1c:	08009d4b 	.word	0x08009d4b
 8009c20:	08009d4b 	.word	0x08009d4b
 8009c24:	08009d4b 	.word	0x08009d4b
 8009c28:	08009d33 	.word	0x08009d33
 8009c2c:	08009d33 	.word	0x08009d33
 8009c30:	08009d21 	.word	0x08009d21
 8009c34:	08009d33 	.word	0x08009d33
 8009c38:	08009d33 	.word	0x08009d33
 8009c3c:	08009d33 	.word	0x08009d33
 8009c40:	08009d33 	.word	0x08009d33
 8009c44:	08009d33 	.word	0x08009d33
 8009c48:	08009d33 	.word	0x08009d33
 8009c4c:	08009d33 	.word	0x08009d33
 8009c50:	08009d33 	.word	0x08009d33
 8009c54:	08009d33 	.word	0x08009d33
 8009c58:	08009d33 	.word	0x08009d33
 8009c5c:	08009d4b 	.word	0x08009d4b
 8009c60:	08009d51 	.word	0x08009d51
 8009c64:	08009d51 	.word	0x08009d51
 8009c68:	08009d51 	.word	0x08009d51
 8009c6c:	08009d51 	.word	0x08009d51
 8009c70:	08009d51 	.word	0x08009d51
 8009c74:	08009d51 	.word	0x08009d51
 8009c78:	08009d21 	.word	0x08009d21
 8009c7c:	08009d33 	.word	0x08009d33
 8009c80:	08009d33 	.word	0x08009d33
 8009c84:	08009d33 	.word	0x08009d33
 8009c88:	08009d33 	.word	0x08009d33
 8009c8c:	08009d33 	.word	0x08009d33
 8009c90:	08009d4b 	.word	0x08009d4b
 8009c94:	08009d33 	.word	0x08009d33
 8009c98:	08009d51 	.word	0x08009d51
 8009c9c:	08009d3f 	.word	0x08009d3f
 8009ca0:	08009d21 	.word	0x08009d21
 8009ca4:	08009d4b 	.word	0x08009d4b
 8009ca8:	08009d21 	.word	0x08009d21
 8009cac:	08009d51 	.word	0x08009d51
 8009cb0:	08009d51 	.word	0x08009d51
 8009cb4:	08009d3f 	.word	0x08009d3f
 8009cb8:	08009d4b 	.word	0x08009d4b
 8009cbc:	08009d4b 	.word	0x08009d4b
 8009cc0:	08009d33 	.word	0x08009d33
 8009cc4:	08009d33 	.word	0x08009d33
 8009cc8:	08009d21 	.word	0x08009d21
 8009ccc:	08009d21 	.word	0x08009d21
 8009cd0:	08009d21 	.word	0x08009d21
 8009cd4:	08009d21 	.word	0x08009d21
 8009cd8:	08009d21 	.word	0x08009d21
 8009cdc:	08009d33 	.word	0x08009d33
 8009ce0:	08009d21 	.word	0x08009d21
 8009ce4:	08009d21 	.word	0x08009d21
 8009ce8:	08009d33 	.word	0x08009d33
 8009cec:	08009d21 	.word	0x08009d21
 8009cf0:	08009d4b 	.word	0x08009d4b
 8009cf4:	08009d4b 	.word	0x08009d4b
 8009cf8:	08009d33 	.word	0x08009d33
 8009cfc:	08009d33 	.word	0x08009d33
 8009d00:	08009d33 	.word	0x08009d33
 8009d04:	08009d4b 	.word	0x08009d4b
 8009d08:	08009d4b 	.word	0x08009d4b
 8009d0c:	08009d4b 	.word	0x08009d4b
 8009d10:	08009d33 	.word	0x08009d33
 8009d14:	08009d33 	.word	0x08009d33
 8009d18:	08009d33 	.word	0x08009d33
 8009d1c:	08009d21 	.word	0x08009d21
 8009d20:	687b      	ldr	r3, [r7, #4]
 8009d22:	2b00      	cmp	r3, #0
 8009d24:	d002      	beq.n	8009d2c <d_make_comp+0x148>
 8009d26:	683b      	ldr	r3, [r7, #0]
 8009d28:	2b00      	cmp	r3, #0
 8009d2a:	d113      	bne.n	8009d54 <d_make_comp+0x170>
 8009d2c:	f04f 0300 	mov.w	r3, #0
 8009d30:	e026      	b.n	8009d80 <d_make_comp+0x19c>
 8009d32:	687b      	ldr	r3, [r7, #4]
 8009d34:	2b00      	cmp	r3, #0
 8009d36:	d10f      	bne.n	8009d58 <d_make_comp+0x174>
 8009d38:	f04f 0300 	mov.w	r3, #0
 8009d3c:	e020      	b.n	8009d80 <d_make_comp+0x19c>
 8009d3e:	683b      	ldr	r3, [r7, #0]
 8009d40:	2b00      	cmp	r3, #0
 8009d42:	d10b      	bne.n	8009d5c <d_make_comp+0x178>
 8009d44:	f04f 0300 	mov.w	r3, #0
 8009d48:	e01a      	b.n	8009d80 <d_make_comp+0x19c>
 8009d4a:	f04f 0300 	mov.w	r3, #0
 8009d4e:	e017      	b.n	8009d80 <d_make_comp+0x19c>
 8009d50:	bf00      	nop
 8009d52:	e004      	b.n	8009d5e <d_make_comp+0x17a>
 8009d54:	bf00      	nop
 8009d56:	e002      	b.n	8009d5e <d_make_comp+0x17a>
 8009d58:	bf00      	nop
 8009d5a:	e000      	b.n	8009d5e <d_make_comp+0x17a>
 8009d5c:	bf00      	nop
 8009d5e:	68f8      	ldr	r0, [r7, #12]
 8009d60:	f7ff ff18 	bl	8009b94 <d_make_empty>
 8009d64:	6178      	str	r0, [r7, #20]
 8009d66:	697b      	ldr	r3, [r7, #20]
 8009d68:	2b00      	cmp	r3, #0
 8009d6a:	d008      	beq.n	8009d7e <d_make_comp+0x19a>
 8009d6c:	697b      	ldr	r3, [r7, #20]
 8009d6e:	7afa      	ldrb	r2, [r7, #11]
 8009d70:	701a      	strb	r2, [r3, #0]
 8009d72:	697b      	ldr	r3, [r7, #20]
 8009d74:	687a      	ldr	r2, [r7, #4]
 8009d76:	605a      	str	r2, [r3, #4]
 8009d78:	697b      	ldr	r3, [r7, #20]
 8009d7a:	683a      	ldr	r2, [r7, #0]
 8009d7c:	609a      	str	r2, [r3, #8]
 8009d7e:	697b      	ldr	r3, [r7, #20]
 8009d80:	4618      	mov	r0, r3
 8009d82:	f107 0718 	add.w	r7, r7, #24
 8009d86:	46bd      	mov	sp, r7
 8009d88:	bd80      	pop	{r7, pc}
 8009d8a:	bf00      	nop

08009d8c <d_make_demangle_mangled_name>:
 8009d8c:	b580      	push	{r7, lr}
 8009d8e:	b082      	sub	sp, #8
 8009d90:	af00      	add	r7, sp, #0
 8009d92:	6078      	str	r0, [r7, #4]
 8009d94:	6039      	str	r1, [r7, #0]
 8009d96:	687b      	ldr	r3, [r7, #4]
 8009d98:	68db      	ldr	r3, [r3, #12]
 8009d9a:	781b      	ldrb	r3, [r3, #0]
 8009d9c:	2b5f      	cmp	r3, #95	; 0x5f
 8009d9e:	d106      	bne.n	8009dae <d_make_demangle_mangled_name+0x22>
 8009da0:	687b      	ldr	r3, [r7, #4]
 8009da2:	68db      	ldr	r3, [r3, #12]
 8009da4:	f103 0301 	add.w	r3, r3, #1
 8009da8:	781b      	ldrb	r3, [r3, #0]
 8009daa:	2b5a      	cmp	r3, #90	; 0x5a
 8009dac:	d00a      	beq.n	8009dc4 <d_make_demangle_mangled_name+0x38>
 8009dae:	6838      	ldr	r0, [r7, #0]
 8009db0:	f008 fee2 	bl	8012b78 <strlen>
 8009db4:	4603      	mov	r3, r0
 8009db6:	6878      	ldr	r0, [r7, #4]
 8009db8:	6839      	ldr	r1, [r7, #0]
 8009dba:	461a      	mov	r2, r3
 8009dbc:	f000 f814 	bl	8009de8 <d_make_name>
 8009dc0:	4603      	mov	r3, r0
 8009dc2:	e00b      	b.n	8009ddc <d_make_demangle_mangled_name+0x50>
 8009dc4:	687b      	ldr	r3, [r7, #4]
 8009dc6:	68db      	ldr	r3, [r3, #12]
 8009dc8:	f103 0202 	add.w	r2, r3, #2
 8009dcc:	687b      	ldr	r3, [r7, #4]
 8009dce:	60da      	str	r2, [r3, #12]
 8009dd0:	6878      	ldr	r0, [r7, #4]
 8009dd2:	f04f 0100 	mov.w	r1, #0
 8009dd6:	f000 fa4b 	bl	800a270 <d_encoding>
 8009dda:	4603      	mov	r3, r0
 8009ddc:	4618      	mov	r0, r3
 8009dde:	f107 0708 	add.w	r7, r7, #8
 8009de2:	46bd      	mov	sp, r7
 8009de4:	bd80      	pop	{r7, pc}
 8009de6:	bf00      	nop

08009de8 <d_make_name>:
 8009de8:	b580      	push	{r7, lr}
 8009dea:	b086      	sub	sp, #24
 8009dec:	af00      	add	r7, sp, #0
 8009dee:	60f8      	str	r0, [r7, #12]
 8009df0:	60b9      	str	r1, [r7, #8]
 8009df2:	607a      	str	r2, [r7, #4]
 8009df4:	68f8      	ldr	r0, [r7, #12]
 8009df6:	f7ff fecd 	bl	8009b94 <d_make_empty>
 8009dfa:	6178      	str	r0, [r7, #20]
 8009dfc:	6978      	ldr	r0, [r7, #20]
 8009dfe:	68b9      	ldr	r1, [r7, #8]
 8009e00:	687a      	ldr	r2, [r7, #4]
 8009e02:	f7ff fe2f 	bl	8009a64 <d_fill_name>
 8009e06:	4603      	mov	r3, r0
 8009e08:	2b00      	cmp	r3, #0
 8009e0a:	d102      	bne.n	8009e12 <d_make_name+0x2a>
 8009e0c:	f04f 0300 	mov.w	r3, #0
 8009e10:	e000      	b.n	8009e14 <d_make_name+0x2c>
 8009e12:	697b      	ldr	r3, [r7, #20]
 8009e14:	4618      	mov	r0, r3
 8009e16:	f107 0718 	add.w	r7, r7, #24
 8009e1a:	46bd      	mov	sp, r7
 8009e1c:	bd80      	pop	{r7, pc}
 8009e1e:	bf00      	nop

08009e20 <d_make_builtin_type>:
 8009e20:	b580      	push	{r7, lr}
 8009e22:	b084      	sub	sp, #16
 8009e24:	af00      	add	r7, sp, #0
 8009e26:	6078      	str	r0, [r7, #4]
 8009e28:	6039      	str	r1, [r7, #0]
 8009e2a:	683b      	ldr	r3, [r7, #0]
 8009e2c:	2b00      	cmp	r3, #0
 8009e2e:	d102      	bne.n	8009e36 <d_make_builtin_type+0x16>
 8009e30:	f04f 0300 	mov.w	r3, #0
 8009e34:	e00e      	b.n	8009e54 <d_make_builtin_type+0x34>
 8009e36:	6878      	ldr	r0, [r7, #4]
 8009e38:	f7ff feac 	bl	8009b94 <d_make_empty>
 8009e3c:	60f8      	str	r0, [r7, #12]
 8009e3e:	68fb      	ldr	r3, [r7, #12]
 8009e40:	2b00      	cmp	r3, #0
 8009e42:	d006      	beq.n	8009e52 <d_make_builtin_type+0x32>
 8009e44:	68fb      	ldr	r3, [r7, #12]
 8009e46:	f04f 0223 	mov.w	r2, #35	; 0x23
 8009e4a:	701a      	strb	r2, [r3, #0]
 8009e4c:	68fb      	ldr	r3, [r7, #12]
 8009e4e:	683a      	ldr	r2, [r7, #0]
 8009e50:	605a      	str	r2, [r3, #4]
 8009e52:	68fb      	ldr	r3, [r7, #12]
 8009e54:	4618      	mov	r0, r3
 8009e56:	f107 0710 	add.w	r7, r7, #16
 8009e5a:	46bd      	mov	sp, r7
 8009e5c:	bd80      	pop	{r7, pc}
 8009e5e:	bf00      	nop

08009e60 <d_make_operator>:
 8009e60:	b580      	push	{r7, lr}
 8009e62:	b084      	sub	sp, #16
 8009e64:	af00      	add	r7, sp, #0
 8009e66:	6078      	str	r0, [r7, #4]
 8009e68:	6039      	str	r1, [r7, #0]
 8009e6a:	6878      	ldr	r0, [r7, #4]
 8009e6c:	f7ff fe92 	bl	8009b94 <d_make_empty>
 8009e70:	60f8      	str	r0, [r7, #12]
 8009e72:	68fb      	ldr	r3, [r7, #12]
 8009e74:	2b00      	cmp	r3, #0
 8009e76:	d006      	beq.n	8009e86 <d_make_operator+0x26>
 8009e78:	68fb      	ldr	r3, [r7, #12]
 8009e7a:	f04f 022d 	mov.w	r2, #45	; 0x2d
 8009e7e:	701a      	strb	r2, [r3, #0]
 8009e80:	68fb      	ldr	r3, [r7, #12]
 8009e82:	683a      	ldr	r2, [r7, #0]
 8009e84:	605a      	str	r2, [r3, #4]
 8009e86:	68fb      	ldr	r3, [r7, #12]
 8009e88:	4618      	mov	r0, r3
 8009e8a:	f107 0710 	add.w	r7, r7, #16
 8009e8e:	46bd      	mov	sp, r7
 8009e90:	bd80      	pop	{r7, pc}
 8009e92:	bf00      	nop

08009e94 <d_make_extended_operator>:
 8009e94:	b580      	push	{r7, lr}
 8009e96:	b086      	sub	sp, #24
 8009e98:	af00      	add	r7, sp, #0
 8009e9a:	60f8      	str	r0, [r7, #12]
 8009e9c:	60b9      	str	r1, [r7, #8]
 8009e9e:	607a      	str	r2, [r7, #4]
 8009ea0:	68f8      	ldr	r0, [r7, #12]
 8009ea2:	f7ff fe77 	bl	8009b94 <d_make_empty>
 8009ea6:	6178      	str	r0, [r7, #20]
 8009ea8:	6978      	ldr	r0, [r7, #20]
 8009eaa:	68b9      	ldr	r1, [r7, #8]
 8009eac:	687a      	ldr	r2, [r7, #4]
 8009eae:	f7ff fdfd 	bl	8009aac <d_fill_extended_operator>
 8009eb2:	4603      	mov	r3, r0
 8009eb4:	2b00      	cmp	r3, #0
 8009eb6:	d102      	bne.n	8009ebe <d_make_extended_operator+0x2a>
 8009eb8:	f04f 0300 	mov.w	r3, #0
 8009ebc:	e000      	b.n	8009ec0 <d_make_extended_operator+0x2c>
 8009ebe:	697b      	ldr	r3, [r7, #20]
 8009ec0:	4618      	mov	r0, r3
 8009ec2:	f107 0718 	add.w	r7, r7, #24
 8009ec6:	46bd      	mov	sp, r7
 8009ec8:	bd80      	pop	{r7, pc}
 8009eca:	bf00      	nop

08009ecc <d_make_default_arg>:
 8009ecc:	b580      	push	{r7, lr}
 8009ece:	b086      	sub	sp, #24
 8009ed0:	af00      	add	r7, sp, #0
 8009ed2:	60f8      	str	r0, [r7, #12]
 8009ed4:	60b9      	str	r1, [r7, #8]
 8009ed6:	607a      	str	r2, [r7, #4]
 8009ed8:	68f8      	ldr	r0, [r7, #12]
 8009eda:	f7ff fe5b 	bl	8009b94 <d_make_empty>
 8009ede:	6178      	str	r0, [r7, #20]
 8009ee0:	697b      	ldr	r3, [r7, #20]
 8009ee2:	2b00      	cmp	r3, #0
 8009ee4:	d009      	beq.n	8009efa <d_make_default_arg+0x2e>
 8009ee6:	697b      	ldr	r3, [r7, #20]
 8009ee8:	f04f 0241 	mov.w	r2, #65	; 0x41
 8009eec:	701a      	strb	r2, [r3, #0]
 8009eee:	697b      	ldr	r3, [r7, #20]
 8009ef0:	68ba      	ldr	r2, [r7, #8]
 8009ef2:	609a      	str	r2, [r3, #8]
 8009ef4:	697b      	ldr	r3, [r7, #20]
 8009ef6:	687a      	ldr	r2, [r7, #4]
 8009ef8:	605a      	str	r2, [r3, #4]
 8009efa:	697b      	ldr	r3, [r7, #20]
 8009efc:	4618      	mov	r0, r3
 8009efe:	f107 0718 	add.w	r7, r7, #24
 8009f02:	46bd      	mov	sp, r7
 8009f04:	bd80      	pop	{r7, pc}
 8009f06:	bf00      	nop

08009f08 <d_make_ctor>:
 8009f08:	b580      	push	{r7, lr}
 8009f0a:	b086      	sub	sp, #24
 8009f0c:	af00      	add	r7, sp, #0
 8009f0e:	60f8      	str	r0, [r7, #12]
 8009f10:	460b      	mov	r3, r1
 8009f12:	607a      	str	r2, [r7, #4]
 8009f14:	72fb      	strb	r3, [r7, #11]
 8009f16:	68f8      	ldr	r0, [r7, #12]
 8009f18:	f7ff fe3c 	bl	8009b94 <d_make_empty>
 8009f1c:	6178      	str	r0, [r7, #20]
 8009f1e:	7afb      	ldrb	r3, [r7, #11]
 8009f20:	6978      	ldr	r0, [r7, #20]
 8009f22:	4619      	mov	r1, r3
 8009f24:	687a      	ldr	r2, [r7, #4]
 8009f26:	f7ff fde5 	bl	8009af4 <d_fill_ctor>
 8009f2a:	4603      	mov	r3, r0
 8009f2c:	2b00      	cmp	r3, #0
 8009f2e:	d102      	bne.n	8009f36 <d_make_ctor+0x2e>
 8009f30:	f04f 0300 	mov.w	r3, #0
 8009f34:	e000      	b.n	8009f38 <d_make_ctor+0x30>
 8009f36:	697b      	ldr	r3, [r7, #20]
 8009f38:	4618      	mov	r0, r3
 8009f3a:	f107 0718 	add.w	r7, r7, #24
 8009f3e:	46bd      	mov	sp, r7
 8009f40:	bd80      	pop	{r7, pc}
 8009f42:	bf00      	nop

08009f44 <d_make_dtor>:
 8009f44:	b580      	push	{r7, lr}
 8009f46:	b086      	sub	sp, #24
 8009f48:	af00      	add	r7, sp, #0
 8009f4a:	60f8      	str	r0, [r7, #12]
 8009f4c:	460b      	mov	r3, r1
 8009f4e:	607a      	str	r2, [r7, #4]
 8009f50:	72fb      	strb	r3, [r7, #11]
 8009f52:	68f8      	ldr	r0, [r7, #12]
 8009f54:	f7ff fe1e 	bl	8009b94 <d_make_empty>
 8009f58:	6178      	str	r0, [r7, #20]
 8009f5a:	7afb      	ldrb	r3, [r7, #11]
 8009f5c:	6978      	ldr	r0, [r7, #20]
 8009f5e:	4619      	mov	r1, r3
 8009f60:	687a      	ldr	r2, [r7, #4]
 8009f62:	f7ff fdef 	bl	8009b44 <d_fill_dtor>
 8009f66:	4603      	mov	r3, r0
 8009f68:	2b00      	cmp	r3, #0
 8009f6a:	d102      	bne.n	8009f72 <d_make_dtor+0x2e>
 8009f6c:	f04f 0300 	mov.w	r3, #0
 8009f70:	e000      	b.n	8009f74 <d_make_dtor+0x30>
 8009f72:	697b      	ldr	r3, [r7, #20]
 8009f74:	4618      	mov	r0, r3
 8009f76:	f107 0718 	add.w	r7, r7, #24
 8009f7a:	46bd      	mov	sp, r7
 8009f7c:	bd80      	pop	{r7, pc}
 8009f7e:	bf00      	nop

08009f80 <d_make_template_param>:
 8009f80:	b580      	push	{r7, lr}
 8009f82:	b084      	sub	sp, #16
 8009f84:	af00      	add	r7, sp, #0
 8009f86:	6078      	str	r0, [r7, #4]
 8009f88:	6039      	str	r1, [r7, #0]
 8009f8a:	6878      	ldr	r0, [r7, #4]
 8009f8c:	f7ff fe02 	bl	8009b94 <d_make_empty>
 8009f90:	60f8      	str	r0, [r7, #12]
 8009f92:	68fb      	ldr	r3, [r7, #12]
 8009f94:	2b00      	cmp	r3, #0
 8009f96:	d006      	beq.n	8009fa6 <d_make_template_param+0x26>
 8009f98:	68fb      	ldr	r3, [r7, #12]
 8009f9a:	f04f 0205 	mov.w	r2, #5
 8009f9e:	701a      	strb	r2, [r3, #0]
 8009fa0:	68fb      	ldr	r3, [r7, #12]
 8009fa2:	683a      	ldr	r2, [r7, #0]
 8009fa4:	605a      	str	r2, [r3, #4]
 8009fa6:	68fb      	ldr	r3, [r7, #12]
 8009fa8:	4618      	mov	r0, r3
 8009faa:	f107 0710 	add.w	r7, r7, #16
 8009fae:	46bd      	mov	sp, r7
 8009fb0:	bd80      	pop	{r7, pc}
 8009fb2:	bf00      	nop

08009fb4 <d_make_function_param>:
 8009fb4:	b580      	push	{r7, lr}
 8009fb6:	b084      	sub	sp, #16
 8009fb8:	af00      	add	r7, sp, #0
 8009fba:	6078      	str	r0, [r7, #4]
 8009fbc:	6039      	str	r1, [r7, #0]
 8009fbe:	6878      	ldr	r0, [r7, #4]
 8009fc0:	f7ff fde8 	bl	8009b94 <d_make_empty>
 8009fc4:	60f8      	str	r0, [r7, #12]
 8009fc6:	68fb      	ldr	r3, [r7, #12]
 8009fc8:	2b00      	cmp	r3, #0
 8009fca:	d006      	beq.n	8009fda <d_make_function_param+0x26>
 8009fcc:	68fb      	ldr	r3, [r7, #12]
 8009fce:	f04f 0206 	mov.w	r2, #6
 8009fd2:	701a      	strb	r2, [r3, #0]
 8009fd4:	68fb      	ldr	r3, [r7, #12]
 8009fd6:	683a      	ldr	r2, [r7, #0]
 8009fd8:	605a      	str	r2, [r3, #4]
 8009fda:	68fb      	ldr	r3, [r7, #12]
 8009fdc:	4618      	mov	r0, r3
 8009fde:	f107 0710 	add.w	r7, r7, #16
 8009fe2:	46bd      	mov	sp, r7
 8009fe4:	bd80      	pop	{r7, pc}
 8009fe6:	bf00      	nop

08009fe8 <d_make_sub>:
 8009fe8:	b580      	push	{r7, lr}
 8009fea:	b086      	sub	sp, #24
 8009fec:	af00      	add	r7, sp, #0
 8009fee:	60f8      	str	r0, [r7, #12]
 8009ff0:	60b9      	str	r1, [r7, #8]
 8009ff2:	607a      	str	r2, [r7, #4]
 8009ff4:	68f8      	ldr	r0, [r7, #12]
 8009ff6:	f7ff fdcd 	bl	8009b94 <d_make_empty>
 8009ffa:	6178      	str	r0, [r7, #20]
 8009ffc:	697b      	ldr	r3, [r7, #20]
 8009ffe:	2b00      	cmp	r3, #0
 800a000:	d009      	beq.n	800a016 <d_make_sub+0x2e>
 800a002:	697b      	ldr	r3, [r7, #20]
 800a004:	f04f 0216 	mov.w	r2, #22
 800a008:	701a      	strb	r2, [r3, #0]
 800a00a:	697b      	ldr	r3, [r7, #20]
 800a00c:	68ba      	ldr	r2, [r7, #8]
 800a00e:	605a      	str	r2, [r3, #4]
 800a010:	697b      	ldr	r3, [r7, #20]
 800a012:	687a      	ldr	r2, [r7, #4]
 800a014:	609a      	str	r2, [r3, #8]
 800a016:	697b      	ldr	r3, [r7, #20]
 800a018:	4618      	mov	r0, r3
 800a01a:	f107 0718 	add.w	r7, r7, #24
 800a01e:	46bd      	mov	sp, r7
 800a020:	bd80      	pop	{r7, pc}
 800a022:	bf00      	nop

0800a024 <d_mangled_name>:
 800a024:	b580      	push	{r7, lr}
 800a026:	b084      	sub	sp, #16
 800a028:	af00      	add	r7, sp, #0
 800a02a:	6078      	str	r0, [r7, #4]
 800a02c:	6039      	str	r1, [r7, #0]
 800a02e:	687b      	ldr	r3, [r7, #4]
 800a030:	68db      	ldr	r3, [r3, #12]
 800a032:	781b      	ldrb	r3, [r3, #0]
 800a034:	2b5f      	cmp	r3, #95	; 0x5f
 800a036:	d108      	bne.n	800a04a <d_mangled_name+0x26>
 800a038:	687b      	ldr	r3, [r7, #4]
 800a03a:	68db      	ldr	r3, [r3, #12]
 800a03c:	f103 0201 	add.w	r2, r3, #1
 800a040:	687b      	ldr	r3, [r7, #4]
 800a042:	60da      	str	r2, [r3, #12]
 800a044:	f04f 0300 	mov.w	r3, #0
 800a048:	e001      	b.n	800a04e <d_mangled_name+0x2a>
 800a04a:	f04f 0301 	mov.w	r3, #1
 800a04e:	2b00      	cmp	r3, #0
 800a050:	d005      	beq.n	800a05e <d_mangled_name+0x3a>
 800a052:	683b      	ldr	r3, [r7, #0]
 800a054:	2b00      	cmp	r3, #0
 800a056:	d002      	beq.n	800a05e <d_mangled_name+0x3a>
 800a058:	f04f 0300 	mov.w	r3, #0
 800a05c:	e051      	b.n	800a102 <d_mangled_name+0xde>
 800a05e:	687b      	ldr	r3, [r7, #4]
 800a060:	68db      	ldr	r3, [r3, #12]
 800a062:	781b      	ldrb	r3, [r3, #0]
 800a064:	2b5a      	cmp	r3, #90	; 0x5a
 800a066:	d108      	bne.n	800a07a <d_mangled_name+0x56>
 800a068:	687b      	ldr	r3, [r7, #4]
 800a06a:	68db      	ldr	r3, [r3, #12]
 800a06c:	f103 0201 	add.w	r2, r3, #1
 800a070:	687b      	ldr	r3, [r7, #4]
 800a072:	60da      	str	r2, [r3, #12]
 800a074:	f04f 0300 	mov.w	r3, #0
 800a078:	e001      	b.n	800a07e <d_mangled_name+0x5a>
 800a07a:	f04f 0301 	mov.w	r3, #1
 800a07e:	2b00      	cmp	r3, #0
 800a080:	d002      	beq.n	800a088 <d_mangled_name+0x64>
 800a082:	f04f 0300 	mov.w	r3, #0
 800a086:	e03c      	b.n	800a102 <d_mangled_name+0xde>
 800a088:	6878      	ldr	r0, [r7, #4]
 800a08a:	6839      	ldr	r1, [r7, #0]
 800a08c:	f000 f8f0 	bl	800a270 <d_encoding>
 800a090:	60f8      	str	r0, [r7, #12]
 800a092:	683b      	ldr	r3, [r7, #0]
 800a094:	2b00      	cmp	r3, #0
 800a096:	d033      	beq.n	800a100 <d_mangled_name+0xdc>
 800a098:	687b      	ldr	r3, [r7, #4]
 800a09a:	689b      	ldr	r3, [r3, #8]
 800a09c:	f003 0301 	and.w	r3, r3, #1
 800a0a0:	2b00      	cmp	r3, #0
 800a0a2:	d02d      	beq.n	800a100 <d_mangled_name+0xdc>
 800a0a4:	e004      	b.n	800a0b0 <d_mangled_name+0x8c>
 800a0a6:	6878      	ldr	r0, [r7, #4]
 800a0a8:	68f9      	ldr	r1, [r7, #12]
 800a0aa:	f002 fea3 	bl	800cdf4 <d_clone_suffix>
 800a0ae:	60f8      	str	r0, [r7, #12]
 800a0b0:	687b      	ldr	r3, [r7, #4]
 800a0b2:	68db      	ldr	r3, [r3, #12]
 800a0b4:	781b      	ldrb	r3, [r3, #0]
 800a0b6:	2b2e      	cmp	r3, #46	; 0x2e
 800a0b8:	d122      	bne.n	800a100 <d_mangled_name+0xdc>
 800a0ba:	687b      	ldr	r3, [r7, #4]
 800a0bc:	68db      	ldr	r3, [r3, #12]
 800a0be:	f103 0301 	add.w	r3, r3, #1
 800a0c2:	781b      	ldrb	r3, [r3, #0]
 800a0c4:	2b60      	cmp	r3, #96	; 0x60
 800a0c6:	d906      	bls.n	800a0d6 <d_mangled_name+0xb2>
 800a0c8:	687b      	ldr	r3, [r7, #4]
 800a0ca:	68db      	ldr	r3, [r3, #12]
 800a0cc:	f103 0301 	add.w	r3, r3, #1
 800a0d0:	781b      	ldrb	r3, [r3, #0]
 800a0d2:	2b7a      	cmp	r3, #122	; 0x7a
 800a0d4:	d9e7      	bls.n	800a0a6 <d_mangled_name+0x82>
 800a0d6:	687b      	ldr	r3, [r7, #4]
 800a0d8:	68db      	ldr	r3, [r3, #12]
 800a0da:	f103 0301 	add.w	r3, r3, #1
 800a0de:	781b      	ldrb	r3, [r3, #0]
 800a0e0:	2b5f      	cmp	r3, #95	; 0x5f
 800a0e2:	d0e0      	beq.n	800a0a6 <d_mangled_name+0x82>
 800a0e4:	687b      	ldr	r3, [r7, #4]
 800a0e6:	68db      	ldr	r3, [r3, #12]
 800a0e8:	f103 0301 	add.w	r3, r3, #1
 800a0ec:	781b      	ldrb	r3, [r3, #0]
 800a0ee:	2b2f      	cmp	r3, #47	; 0x2f
 800a0f0:	d906      	bls.n	800a100 <d_mangled_name+0xdc>
 800a0f2:	687b      	ldr	r3, [r7, #4]
 800a0f4:	68db      	ldr	r3, [r3, #12]
 800a0f6:	f103 0301 	add.w	r3, r3, #1
 800a0fa:	781b      	ldrb	r3, [r3, #0]
 800a0fc:	2b39      	cmp	r3, #57	; 0x39
 800a0fe:	d9d2      	bls.n	800a0a6 <d_mangled_name+0x82>
 800a100:	68fb      	ldr	r3, [r7, #12]
 800a102:	4618      	mov	r0, r3
 800a104:	f107 0710 	add.w	r7, r7, #16
 800a108:	46bd      	mov	sp, r7
 800a10a:	bd80      	pop	{r7, pc}

0800a10c <has_return_type>:
 800a10c:	b580      	push	{r7, lr}
 800a10e:	b082      	sub	sp, #8
 800a110:	af00      	add	r7, sp, #0
 800a112:	6078      	str	r0, [r7, #4]
 800a114:	687b      	ldr	r3, [r7, #4]
 800a116:	2b00      	cmp	r3, #0
 800a118:	d102      	bne.n	800a120 <has_return_type+0x14>
 800a11a:	f04f 0300 	mov.w	r3, #0
 800a11e:	e01e      	b.n	800a15e <has_return_type+0x52>
 800a120:	687b      	ldr	r3, [r7, #4]
 800a122:	781b      	ldrb	r3, [r3, #0]
 800a124:	2b04      	cmp	r3, #4
 800a126:	d008      	beq.n	800a13a <has_return_type+0x2e>
 800a128:	2b04      	cmp	r3, #4
 800a12a:	db03      	blt.n	800a134 <has_return_type+0x28>
 800a12c:	f1a3 031a 	sub.w	r3, r3, #26
 800a130:	2b02      	cmp	r3, #2
 800a132:	d90e      	bls.n	800a152 <has_return_type+0x46>
 800a134:	f04f 0300 	mov.w	r3, #0
 800a138:	e011      	b.n	800a15e <has_return_type+0x52>
 800a13a:	687b      	ldr	r3, [r7, #4]
 800a13c:	685b      	ldr	r3, [r3, #4]
 800a13e:	4618      	mov	r0, r3
 800a140:	f000 f812 	bl	800a168 <is_ctor_dtor_or_conversion>
 800a144:	4603      	mov	r3, r0
 800a146:	2b00      	cmp	r3, #0
 800a148:	bf14      	ite	ne
 800a14a:	2300      	movne	r3, #0
 800a14c:	2301      	moveq	r3, #1
 800a14e:	b2db      	uxtb	r3, r3
 800a150:	e005      	b.n	800a15e <has_return_type+0x52>
 800a152:	687b      	ldr	r3, [r7, #4]
 800a154:	685b      	ldr	r3, [r3, #4]
 800a156:	4618      	mov	r0, r3
 800a158:	f7ff ffd8 	bl	800a10c <has_return_type>
 800a15c:	4603      	mov	r3, r0
 800a15e:	4618      	mov	r0, r3
 800a160:	f107 0708 	add.w	r7, r7, #8
 800a164:	46bd      	mov	sp, r7
 800a166:	bd80      	pop	{r7, pc}

0800a168 <is_ctor_dtor_or_conversion>:
 800a168:	b580      	push	{r7, lr}
 800a16a:	b082      	sub	sp, #8
 800a16c:	af00      	add	r7, sp, #0
 800a16e:	6078      	str	r0, [r7, #4]
 800a170:	687b      	ldr	r3, [r7, #4]
 800a172:	2b00      	cmp	r3, #0
 800a174:	d102      	bne.n	800a17c <is_ctor_dtor_or_conversion+0x14>
 800a176:	f04f 0300 	mov.w	r3, #0
 800a17a:	e073      	b.n	800a264 <is_ctor_dtor_or_conversion+0xfc>
 800a17c:	687b      	ldr	r3, [r7, #4]
 800a17e:	781b      	ldrb	r3, [r3, #0]
 800a180:	f103 33ff 	add.w	r3, r3, #4294967295
 800a184:	2b2e      	cmp	r3, #46	; 0x2e
 800a186:	d861      	bhi.n	800a24c <is_ctor_dtor_or_conversion+0xe4>
 800a188:	a201      	add	r2, pc, #4	; (adr r2, 800a190 <is_ctor_dtor_or_conversion+0x28>)
 800a18a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a18e:	bf00      	nop
 800a190:	0800a253 	.word	0x0800a253
 800a194:	0800a253 	.word	0x0800a253
 800a198:	0800a24d 	.word	0x0800a24d
 800a19c:	0800a24d 	.word	0x0800a24d
 800a1a0:	0800a24d 	.word	0x0800a24d
 800a1a4:	0800a24d 	.word	0x0800a24d
 800a1a8:	0800a261 	.word	0x0800a261
 800a1ac:	0800a261 	.word	0x0800a261
 800a1b0:	0800a24d 	.word	0x0800a24d
 800a1b4:	0800a24d 	.word	0x0800a24d
 800a1b8:	0800a24d 	.word	0x0800a24d
 800a1bc:	0800a24d 	.word	0x0800a24d
 800a1c0:	0800a24d 	.word	0x0800a24d
 800a1c4:	0800a24d 	.word	0x0800a24d
 800a1c8:	0800a24d 	.word	0x0800a24d
 800a1cc:	0800a24d 	.word	0x0800a24d
 800a1d0:	0800a24d 	.word	0x0800a24d
 800a1d4:	0800a24d 	.word	0x0800a24d
 800a1d8:	0800a24d 	.word	0x0800a24d
 800a1dc:	0800a24d 	.word	0x0800a24d
 800a1e0:	0800a24d 	.word	0x0800a24d
 800a1e4:	0800a24d 	.word	0x0800a24d
 800a1e8:	0800a24d 	.word	0x0800a24d
 800a1ec:	0800a24d 	.word	0x0800a24d
 800a1f0:	0800a24d 	.word	0x0800a24d
 800a1f4:	0800a24d 	.word	0x0800a24d
 800a1f8:	0800a24d 	.word	0x0800a24d
 800a1fc:	0800a24d 	.word	0x0800a24d
 800a200:	0800a24d 	.word	0x0800a24d
 800a204:	0800a24d 	.word	0x0800a24d
 800a208:	0800a24d 	.word	0x0800a24d
 800a20c:	0800a24d 	.word	0x0800a24d
 800a210:	0800a24d 	.word	0x0800a24d
 800a214:	0800a24d 	.word	0x0800a24d
 800a218:	0800a24d 	.word	0x0800a24d
 800a21c:	0800a24d 	.word	0x0800a24d
 800a220:	0800a24d 	.word	0x0800a24d
 800a224:	0800a24d 	.word	0x0800a24d
 800a228:	0800a24d 	.word	0x0800a24d
 800a22c:	0800a24d 	.word	0x0800a24d
 800a230:	0800a24d 	.word	0x0800a24d
 800a234:	0800a24d 	.word	0x0800a24d
 800a238:	0800a24d 	.word	0x0800a24d
 800a23c:	0800a24d 	.word	0x0800a24d
 800a240:	0800a24d 	.word	0x0800a24d
 800a244:	0800a24d 	.word	0x0800a24d
 800a248:	0800a261 	.word	0x0800a261
 800a24c:	f04f 0300 	mov.w	r3, #0
 800a250:	e008      	b.n	800a264 <is_ctor_dtor_or_conversion+0xfc>
 800a252:	687b      	ldr	r3, [r7, #4]
 800a254:	689b      	ldr	r3, [r3, #8]
 800a256:	4618      	mov	r0, r3
 800a258:	f7ff ff86 	bl	800a168 <is_ctor_dtor_or_conversion>
 800a25c:	4603      	mov	r3, r0
 800a25e:	e001      	b.n	800a264 <is_ctor_dtor_or_conversion+0xfc>
 800a260:	f04f 0301 	mov.w	r3, #1
 800a264:	4618      	mov	r0, r3
 800a266:	f107 0708 	add.w	r7, r7, #8
 800a26a:	46bd      	mov	sp, r7
 800a26c:	bd80      	pop	{r7, pc}
 800a26e:	bf00      	nop

0800a270 <d_encoding>:
 800a270:	b580      	push	{r7, lr}
 800a272:	b086      	sub	sp, #24
 800a274:	af00      	add	r7, sp, #0
 800a276:	6078      	str	r0, [r7, #4]
 800a278:	6039      	str	r1, [r7, #0]
 800a27a:	687b      	ldr	r3, [r7, #4]
 800a27c:	68db      	ldr	r3, [r3, #12]
 800a27e:	781b      	ldrb	r3, [r3, #0]
 800a280:	73fb      	strb	r3, [r7, #15]
 800a282:	7bfb      	ldrb	r3, [r7, #15]
 800a284:	2b47      	cmp	r3, #71	; 0x47
 800a286:	d002      	beq.n	800a28e <d_encoding+0x1e>
 800a288:	7bfb      	ldrb	r3, [r7, #15]
 800a28a:	2b54      	cmp	r3, #84	; 0x54
 800a28c:	d104      	bne.n	800a298 <d_encoding+0x28>
 800a28e:	6878      	ldr	r0, [r7, #4]
 800a290:	f000 fd34 	bl	800acfc <d_special_name>
 800a294:	4603      	mov	r3, r0
 800a296:	e05a      	b.n	800a34e <d_encoding+0xde>
 800a298:	6878      	ldr	r0, [r7, #4]
 800a29a:	f000 f85d 	bl	800a358 <d_name>
 800a29e:	6178      	str	r0, [r7, #20]
 800a2a0:	697b      	ldr	r3, [r7, #20]
 800a2a2:	2b00      	cmp	r3, #0
 800a2a4:	d034      	beq.n	800a310 <d_encoding+0xa0>
 800a2a6:	683b      	ldr	r3, [r7, #0]
 800a2a8:	2b00      	cmp	r3, #0
 800a2aa:	d031      	beq.n	800a310 <d_encoding+0xa0>
 800a2ac:	687b      	ldr	r3, [r7, #4]
 800a2ae:	689b      	ldr	r3, [r3, #8]
 800a2b0:	f003 0301 	and.w	r3, r3, #1
 800a2b4:	2b00      	cmp	r3, #0
 800a2b6:	d12b      	bne.n	800a310 <d_encoding+0xa0>
 800a2b8:	e002      	b.n	800a2c0 <d_encoding+0x50>
 800a2ba:	697b      	ldr	r3, [r7, #20]
 800a2bc:	685b      	ldr	r3, [r3, #4]
 800a2be:	617b      	str	r3, [r7, #20]
 800a2c0:	697b      	ldr	r3, [r7, #20]
 800a2c2:	781b      	ldrb	r3, [r3, #0]
 800a2c4:	2b1a      	cmp	r3, #26
 800a2c6:	d0f8      	beq.n	800a2ba <d_encoding+0x4a>
 800a2c8:	697b      	ldr	r3, [r7, #20]
 800a2ca:	781b      	ldrb	r3, [r3, #0]
 800a2cc:	2b1b      	cmp	r3, #27
 800a2ce:	d0f4      	beq.n	800a2ba <d_encoding+0x4a>
 800a2d0:	697b      	ldr	r3, [r7, #20]
 800a2d2:	781b      	ldrb	r3, [r3, #0]
 800a2d4:	2b1c      	cmp	r3, #28
 800a2d6:	d0f0      	beq.n	800a2ba <d_encoding+0x4a>
 800a2d8:	697b      	ldr	r3, [r7, #20]
 800a2da:	781b      	ldrb	r3, [r3, #0]
 800a2dc:	2b02      	cmp	r3, #2
 800a2de:	d115      	bne.n	800a30c <d_encoding+0x9c>
 800a2e0:	697b      	ldr	r3, [r7, #20]
 800a2e2:	689b      	ldr	r3, [r3, #8]
 800a2e4:	613b      	str	r3, [r7, #16]
 800a2e6:	e002      	b.n	800a2ee <d_encoding+0x7e>
 800a2e8:	693b      	ldr	r3, [r7, #16]
 800a2ea:	685b      	ldr	r3, [r3, #4]
 800a2ec:	613b      	str	r3, [r7, #16]
 800a2ee:	693b      	ldr	r3, [r7, #16]
 800a2f0:	781b      	ldrb	r3, [r3, #0]
 800a2f2:	2b1a      	cmp	r3, #26
 800a2f4:	d0f8      	beq.n	800a2e8 <d_encoding+0x78>
 800a2f6:	693b      	ldr	r3, [r7, #16]
 800a2f8:	781b      	ldrb	r3, [r3, #0]
 800a2fa:	2b1b      	cmp	r3, #27
 800a2fc:	d0f4      	beq.n	800a2e8 <d_encoding+0x78>
 800a2fe:	693b      	ldr	r3, [r7, #16]
 800a300:	781b      	ldrb	r3, [r3, #0]
 800a302:	2b1c      	cmp	r3, #28
 800a304:	d0f0      	beq.n	800a2e8 <d_encoding+0x78>
 800a306:	697b      	ldr	r3, [r7, #20]
 800a308:	693a      	ldr	r2, [r7, #16]
 800a30a:	609a      	str	r2, [r3, #8]
 800a30c:	697b      	ldr	r3, [r7, #20]
 800a30e:	e01e      	b.n	800a34e <d_encoding+0xde>
 800a310:	687b      	ldr	r3, [r7, #4]
 800a312:	68db      	ldr	r3, [r3, #12]
 800a314:	781b      	ldrb	r3, [r3, #0]
 800a316:	73fb      	strb	r3, [r7, #15]
 800a318:	697b      	ldr	r3, [r7, #20]
 800a31a:	2b00      	cmp	r3, #0
 800a31c:	d005      	beq.n	800a32a <d_encoding+0xba>
 800a31e:	7bfb      	ldrb	r3, [r7, #15]
 800a320:	2b00      	cmp	r3, #0
 800a322:	d002      	beq.n	800a32a <d_encoding+0xba>
 800a324:	7bfb      	ldrb	r3, [r7, #15]
 800a326:	2b45      	cmp	r3, #69	; 0x45
 800a328:	d101      	bne.n	800a32e <d_encoding+0xbe>
 800a32a:	697b      	ldr	r3, [r7, #20]
 800a32c:	e00f      	b.n	800a34e <d_encoding+0xde>
 800a32e:	6978      	ldr	r0, [r7, #20]
 800a330:	f7ff feec 	bl	800a10c <has_return_type>
 800a334:	4603      	mov	r3, r0
 800a336:	6878      	ldr	r0, [r7, #4]
 800a338:	4619      	mov	r1, r3
 800a33a:	f001 fd89 	bl	800be50 <d_bare_function_type>
 800a33e:	4603      	mov	r3, r0
 800a340:	6878      	ldr	r0, [r7, #4]
 800a342:	f04f 0103 	mov.w	r1, #3
 800a346:	697a      	ldr	r2, [r7, #20]
 800a348:	f7ff fc4c 	bl	8009be4 <d_make_comp>
 800a34c:	4603      	mov	r3, r0
 800a34e:	4618      	mov	r0, r3
 800a350:	f107 0718 	add.w	r7, r7, #24
 800a354:	46bd      	mov	sp, r7
 800a356:	bd80      	pop	{r7, pc}

0800a358 <d_name>:
 800a358:	b590      	push	{r4, r7, lr}
 800a35a:	b087      	sub	sp, #28
 800a35c:	af00      	add	r7, sp, #0
 800a35e:	6078      	str	r0, [r7, #4]
 800a360:	687b      	ldr	r3, [r7, #4]
 800a362:	68db      	ldr	r3, [r3, #12]
 800a364:	781b      	ldrb	r3, [r3, #0]
 800a366:	73fb      	strb	r3, [r7, #15]
 800a368:	7bfb      	ldrb	r3, [r7, #15]
 800a36a:	f1a3 034c 	sub.w	r3, r3, #76	; 0x4c
 800a36e:	2b0e      	cmp	r3, #14
 800a370:	f200 8085 	bhi.w	800a47e <d_name+0x126>
 800a374:	a201      	add	r2, pc, #4	; (adr r2, 800a37c <d_name+0x24>)
 800a376:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a37a:	bf00      	nop
 800a37c:	0800a3cd 	.word	0x0800a3cd
 800a380:	0800a47f 	.word	0x0800a47f
 800a384:	0800a3b9 	.word	0x0800a3b9
 800a388:	0800a47f 	.word	0x0800a47f
 800a38c:	0800a47f 	.word	0x0800a47f
 800a390:	0800a47f 	.word	0x0800a47f
 800a394:	0800a47f 	.word	0x0800a47f
 800a398:	0800a3d7 	.word	0x0800a3d7
 800a39c:	0800a47f 	.word	0x0800a47f
 800a3a0:	0800a3cd 	.word	0x0800a3cd
 800a3a4:	0800a47f 	.word	0x0800a47f
 800a3a8:	0800a47f 	.word	0x0800a47f
 800a3ac:	0800a47f 	.word	0x0800a47f
 800a3b0:	0800a47f 	.word	0x0800a47f
 800a3b4:	0800a3c3 	.word	0x0800a3c3
 800a3b8:	6878      	ldr	r0, [r7, #4]
 800a3ba:	f000 f885 	bl	800a4c8 <d_nested_name>
 800a3be:	4603      	mov	r3, r0
 800a3c0:	e07c      	b.n	800a4bc <d_name+0x164>
 800a3c2:	6878      	ldr	r0, [r7, #4]
 800a3c4:	f002 fb84 	bl	800cad0 <d_local_name>
 800a3c8:	4603      	mov	r3, r0
 800a3ca:	e077      	b.n	800a4bc <d_name+0x164>
 800a3cc:	6878      	ldr	r0, [r7, #4]
 800a3ce:	f000 f975 	bl	800a6bc <d_unqualified_name>
 800a3d2:	4603      	mov	r3, r0
 800a3d4:	e072      	b.n	800a4bc <d_name+0x164>
 800a3d6:	687b      	ldr	r3, [r7, #4]
 800a3d8:	68db      	ldr	r3, [r3, #12]
 800a3da:	f103 0301 	add.w	r3, r3, #1
 800a3de:	781b      	ldrb	r3, [r3, #0]
 800a3e0:	2b74      	cmp	r3, #116	; 0x74
 800a3e2:	d009      	beq.n	800a3f8 <d_name+0xa0>
 800a3e4:	6878      	ldr	r0, [r7, #4]
 800a3e6:	f04f 0100 	mov.w	r1, #0
 800a3ea:	f002 fda7 	bl	800cf3c <d_substitution>
 800a3ee:	6178      	str	r0, [r7, #20]
 800a3f0:	f04f 0301 	mov.w	r3, #1
 800a3f4:	613b      	str	r3, [r7, #16]
 800a3f6:	e023      	b.n	800a440 <d_name+0xe8>
 800a3f8:	687b      	ldr	r3, [r7, #4]
 800a3fa:	68db      	ldr	r3, [r3, #12]
 800a3fc:	f103 0202 	add.w	r2, r3, #2
 800a400:	687b      	ldr	r3, [r7, #4]
 800a402:	60da      	str	r2, [r3, #12]
 800a404:	6878      	ldr	r0, [r7, #4]
 800a406:	f24f 41f8 	movw	r1, #62712	; 0xf4f8
 800a40a:	f6c0 0101 	movt	r1, #2049	; 0x801
 800a40e:	f04f 0203 	mov.w	r2, #3
 800a412:	f7ff fce9 	bl	8009de8 <d_make_name>
 800a416:	4604      	mov	r4, r0
 800a418:	6878      	ldr	r0, [r7, #4]
 800a41a:	f000 f94f 	bl	800a6bc <d_unqualified_name>
 800a41e:	4603      	mov	r3, r0
 800a420:	6878      	ldr	r0, [r7, #4]
 800a422:	f04f 0101 	mov.w	r1, #1
 800a426:	4622      	mov	r2, r4
 800a428:	f7ff fbdc 	bl	8009be4 <d_make_comp>
 800a42c:	6178      	str	r0, [r7, #20]
 800a42e:	687b      	ldr	r3, [r7, #4]
 800a430:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a432:	f103 0203 	add.w	r2, r3, #3
 800a436:	687b      	ldr	r3, [r7, #4]
 800a438:	631a      	str	r2, [r3, #48]	; 0x30
 800a43a:	f04f 0300 	mov.w	r3, #0
 800a43e:	613b      	str	r3, [r7, #16]
 800a440:	687b      	ldr	r3, [r7, #4]
 800a442:	68db      	ldr	r3, [r3, #12]
 800a444:	781b      	ldrb	r3, [r3, #0]
 800a446:	2b49      	cmp	r3, #73	; 0x49
 800a448:	d117      	bne.n	800a47a <d_name+0x122>
 800a44a:	693b      	ldr	r3, [r7, #16]
 800a44c:	2b00      	cmp	r3, #0
 800a44e:	d109      	bne.n	800a464 <d_name+0x10c>
 800a450:	6878      	ldr	r0, [r7, #4]
 800a452:	6979      	ldr	r1, [r7, #20]
 800a454:	f002 fd46 	bl	800cee4 <d_add_substitution>
 800a458:	4603      	mov	r3, r0
 800a45a:	2b00      	cmp	r3, #0
 800a45c:	d102      	bne.n	800a464 <d_name+0x10c>
 800a45e:	f04f 0300 	mov.w	r3, #0
 800a462:	e02b      	b.n	800a4bc <d_name+0x164>
 800a464:	6878      	ldr	r0, [r7, #4]
 800a466:	f001 fec9 	bl	800c1fc <d_template_args>
 800a46a:	4603      	mov	r3, r0
 800a46c:	6878      	ldr	r0, [r7, #4]
 800a46e:	f04f 0104 	mov.w	r1, #4
 800a472:	697a      	ldr	r2, [r7, #20]
 800a474:	f7ff fbb6 	bl	8009be4 <d_make_comp>
 800a478:	6178      	str	r0, [r7, #20]
 800a47a:	697b      	ldr	r3, [r7, #20]
 800a47c:	e01e      	b.n	800a4bc <d_name+0x164>
 800a47e:	6878      	ldr	r0, [r7, #4]
 800a480:	f000 f91c 	bl	800a6bc <d_unqualified_name>
 800a484:	6178      	str	r0, [r7, #20]
 800a486:	687b      	ldr	r3, [r7, #4]
 800a488:	68db      	ldr	r3, [r3, #12]
 800a48a:	781b      	ldrb	r3, [r3, #0]
 800a48c:	2b49      	cmp	r3, #73	; 0x49
 800a48e:	d114      	bne.n	800a4ba <d_name+0x162>
 800a490:	6878      	ldr	r0, [r7, #4]
 800a492:	6979      	ldr	r1, [r7, #20]
 800a494:	f002 fd26 	bl	800cee4 <d_add_substitution>
 800a498:	4603      	mov	r3, r0
 800a49a:	2b00      	cmp	r3, #0
 800a49c:	d102      	bne.n	800a4a4 <d_name+0x14c>
 800a49e:	f04f 0300 	mov.w	r3, #0
 800a4a2:	e00b      	b.n	800a4bc <d_name+0x164>
 800a4a4:	6878      	ldr	r0, [r7, #4]
 800a4a6:	f001 fea9 	bl	800c1fc <d_template_args>
 800a4aa:	4603      	mov	r3, r0
 800a4ac:	6878      	ldr	r0, [r7, #4]
 800a4ae:	f04f 0104 	mov.w	r1, #4
 800a4b2:	697a      	ldr	r2, [r7, #20]
 800a4b4:	f7ff fb96 	bl	8009be4 <d_make_comp>
 800a4b8:	6178      	str	r0, [r7, #20]
 800a4ba:	697b      	ldr	r3, [r7, #20]
 800a4bc:	4618      	mov	r0, r3
 800a4be:	f107 071c 	add.w	r7, r7, #28
 800a4c2:	46bd      	mov	sp, r7
 800a4c4:	bd90      	pop	{r4, r7, pc}
 800a4c6:	bf00      	nop

0800a4c8 <d_nested_name>:
 800a4c8:	b580      	push	{r7, lr}
 800a4ca:	b084      	sub	sp, #16
 800a4cc:	af00      	add	r7, sp, #0
 800a4ce:	6078      	str	r0, [r7, #4]
 800a4d0:	687b      	ldr	r3, [r7, #4]
 800a4d2:	68db      	ldr	r3, [r3, #12]
 800a4d4:	781b      	ldrb	r3, [r3, #0]
 800a4d6:	2b4e      	cmp	r3, #78	; 0x4e
 800a4d8:	d108      	bne.n	800a4ec <d_nested_name+0x24>
 800a4da:	687b      	ldr	r3, [r7, #4]
 800a4dc:	68db      	ldr	r3, [r3, #12]
 800a4de:	f103 0201 	add.w	r2, r3, #1
 800a4e2:	687b      	ldr	r3, [r7, #4]
 800a4e4:	60da      	str	r2, [r3, #12]
 800a4e6:	f04f 0300 	mov.w	r3, #0
 800a4ea:	e001      	b.n	800a4f0 <d_nested_name+0x28>
 800a4ec:	f04f 0301 	mov.w	r3, #1
 800a4f0:	2b00      	cmp	r3, #0
 800a4f2:	d002      	beq.n	800a4fa <d_nested_name+0x32>
 800a4f4:	f04f 0300 	mov.w	r3, #0
 800a4f8:	e031      	b.n	800a55e <d_nested_name+0x96>
 800a4fa:	f107 0308 	add.w	r3, r7, #8
 800a4fe:	6878      	ldr	r0, [r7, #4]
 800a500:	4619      	mov	r1, r3
 800a502:	f04f 0201 	mov.w	r2, #1
 800a506:	f001 fb59 	bl	800bbbc <d_cv_qualifiers>
 800a50a:	60f8      	str	r0, [r7, #12]
 800a50c:	68fb      	ldr	r3, [r7, #12]
 800a50e:	2b00      	cmp	r3, #0
 800a510:	d102      	bne.n	800a518 <d_nested_name+0x50>
 800a512:	f04f 0300 	mov.w	r3, #0
 800a516:	e022      	b.n	800a55e <d_nested_name+0x96>
 800a518:	6878      	ldr	r0, [r7, #4]
 800a51a:	f000 f825 	bl	800a568 <d_prefix>
 800a51e:	4602      	mov	r2, r0
 800a520:	68fb      	ldr	r3, [r7, #12]
 800a522:	601a      	str	r2, [r3, #0]
 800a524:	68fb      	ldr	r3, [r7, #12]
 800a526:	681b      	ldr	r3, [r3, #0]
 800a528:	2b00      	cmp	r3, #0
 800a52a:	d102      	bne.n	800a532 <d_nested_name+0x6a>
 800a52c:	f04f 0300 	mov.w	r3, #0
 800a530:	e015      	b.n	800a55e <d_nested_name+0x96>
 800a532:	687b      	ldr	r3, [r7, #4]
 800a534:	68db      	ldr	r3, [r3, #12]
 800a536:	781b      	ldrb	r3, [r3, #0]
 800a538:	2b45      	cmp	r3, #69	; 0x45
 800a53a:	d108      	bne.n	800a54e <d_nested_name+0x86>
 800a53c:	687b      	ldr	r3, [r7, #4]
 800a53e:	68db      	ldr	r3, [r3, #12]
 800a540:	f103 0201 	add.w	r2, r3, #1
 800a544:	687b      	ldr	r3, [r7, #4]
 800a546:	60da      	str	r2, [r3, #12]
 800a548:	f04f 0300 	mov.w	r3, #0
 800a54c:	e001      	b.n	800a552 <d_nested_name+0x8a>
 800a54e:	f04f 0301 	mov.w	r3, #1
 800a552:	2b00      	cmp	r3, #0
 800a554:	d002      	beq.n	800a55c <d_nested_name+0x94>
 800a556:	f04f 0300 	mov.w	r3, #0
 800a55a:	e000      	b.n	800a55e <d_nested_name+0x96>
 800a55c:	68bb      	ldr	r3, [r7, #8]
 800a55e:	4618      	mov	r0, r3
 800a560:	f107 0710 	add.w	r7, r7, #16
 800a564:	46bd      	mov	sp, r7
 800a566:	bd80      	pop	{r7, pc}

0800a568 <d_prefix>:
 800a568:	b580      	push	{r7, lr}
 800a56a:	b086      	sub	sp, #24
 800a56c:	af00      	add	r7, sp, #0
 800a56e:	6078      	str	r0, [r7, #4]
 800a570:	f04f 0300 	mov.w	r3, #0
 800a574:	617b      	str	r3, [r7, #20]
 800a576:	e000      	b.n	800a57a <d_prefix+0x12>
 800a578:	bf00      	nop
 800a57a:	687b      	ldr	r3, [r7, #4]
 800a57c:	68db      	ldr	r3, [r3, #12]
 800a57e:	781b      	ldrb	r3, [r3, #0]
 800a580:	72fb      	strb	r3, [r7, #11]
 800a582:	7afb      	ldrb	r3, [r7, #11]
 800a584:	2b00      	cmp	r3, #0
 800a586:	d102      	bne.n	800a58e <d_prefix+0x26>
 800a588:	f04f 0300 	mov.w	r3, #0
 800a58c:	e091      	b.n	800a6b2 <d_prefix+0x14a>
 800a58e:	f04f 0301 	mov.w	r3, #1
 800a592:	74fb      	strb	r3, [r7, #19]
 800a594:	7afb      	ldrb	r3, [r7, #11]
 800a596:	2b44      	cmp	r3, #68	; 0x44
 800a598:	d113      	bne.n	800a5c2 <d_prefix+0x5a>
 800a59a:	687b      	ldr	r3, [r7, #4]
 800a59c:	68db      	ldr	r3, [r3, #12]
 800a59e:	785b      	ldrb	r3, [r3, #1]
 800a5a0:	72bb      	strb	r3, [r7, #10]
 800a5a2:	7abb      	ldrb	r3, [r7, #10]
 800a5a4:	2b54      	cmp	r3, #84	; 0x54
 800a5a6:	d002      	beq.n	800a5ae <d_prefix+0x46>
 800a5a8:	7abb      	ldrb	r3, [r7, #10]
 800a5aa:	2b74      	cmp	r3, #116	; 0x74
 800a5ac:	d104      	bne.n	800a5b8 <d_prefix+0x50>
 800a5ae:	6878      	ldr	r0, [r7, #4]
 800a5b0:	f000 ff38 	bl	800b424 <d_type>
 800a5b4:	60f8      	str	r0, [r7, #12]
 800a5b6:	e05a      	b.n	800a66e <d_prefix+0x106>
 800a5b8:	6878      	ldr	r0, [r7, #4]
 800a5ba:	f000 f87f 	bl	800a6bc <d_unqualified_name>
 800a5be:	60f8      	str	r0, [r7, #12]
 800a5c0:	e055      	b.n	800a66e <d_prefix+0x106>
 800a5c2:	7afb      	ldrb	r3, [r7, #11]
 800a5c4:	2b2f      	cmp	r3, #47	; 0x2f
 800a5c6:	d902      	bls.n	800a5ce <d_prefix+0x66>
 800a5c8:	7afb      	ldrb	r3, [r7, #11]
 800a5ca:	2b39      	cmp	r3, #57	; 0x39
 800a5cc:	d90e      	bls.n	800a5ec <d_prefix+0x84>
 800a5ce:	7afb      	ldrb	r3, [r7, #11]
 800a5d0:	2b60      	cmp	r3, #96	; 0x60
 800a5d2:	d902      	bls.n	800a5da <d_prefix+0x72>
 800a5d4:	7afb      	ldrb	r3, [r7, #11]
 800a5d6:	2b7a      	cmp	r3, #122	; 0x7a
 800a5d8:	d908      	bls.n	800a5ec <d_prefix+0x84>
 800a5da:	7afb      	ldrb	r3, [r7, #11]
 800a5dc:	2b43      	cmp	r3, #67	; 0x43
 800a5de:	d005      	beq.n	800a5ec <d_prefix+0x84>
 800a5e0:	7afb      	ldrb	r3, [r7, #11]
 800a5e2:	2b55      	cmp	r3, #85	; 0x55
 800a5e4:	d002      	beq.n	800a5ec <d_prefix+0x84>
 800a5e6:	7afb      	ldrb	r3, [r7, #11]
 800a5e8:	2b4c      	cmp	r3, #76	; 0x4c
 800a5ea:	d104      	bne.n	800a5f6 <d_prefix+0x8e>
 800a5ec:	6878      	ldr	r0, [r7, #4]
 800a5ee:	f000 f865 	bl	800a6bc <d_unqualified_name>
 800a5f2:	60f8      	str	r0, [r7, #12]
 800a5f4:	e03b      	b.n	800a66e <d_prefix+0x106>
 800a5f6:	7afb      	ldrb	r3, [r7, #11]
 800a5f8:	2b53      	cmp	r3, #83	; 0x53
 800a5fa:	d106      	bne.n	800a60a <d_prefix+0xa2>
 800a5fc:	6878      	ldr	r0, [r7, #4]
 800a5fe:	f04f 0101 	mov.w	r1, #1
 800a602:	f002 fc9b 	bl	800cf3c <d_substitution>
 800a606:	60f8      	str	r0, [r7, #12]
 800a608:	e031      	b.n	800a66e <d_prefix+0x106>
 800a60a:	7afb      	ldrb	r3, [r7, #11]
 800a60c:	2b49      	cmp	r3, #73	; 0x49
 800a60e:	d10d      	bne.n	800a62c <d_prefix+0xc4>
 800a610:	697b      	ldr	r3, [r7, #20]
 800a612:	2b00      	cmp	r3, #0
 800a614:	d102      	bne.n	800a61c <d_prefix+0xb4>
 800a616:	f04f 0300 	mov.w	r3, #0
 800a61a:	e04a      	b.n	800a6b2 <d_prefix+0x14a>
 800a61c:	f04f 0304 	mov.w	r3, #4
 800a620:	74fb      	strb	r3, [r7, #19]
 800a622:	6878      	ldr	r0, [r7, #4]
 800a624:	f001 fdea 	bl	800c1fc <d_template_args>
 800a628:	60f8      	str	r0, [r7, #12]
 800a62a:	e020      	b.n	800a66e <d_prefix+0x106>
 800a62c:	7afb      	ldrb	r3, [r7, #11]
 800a62e:	2b54      	cmp	r3, #84	; 0x54
 800a630:	d104      	bne.n	800a63c <d_prefix+0xd4>
 800a632:	6878      	ldr	r0, [r7, #4]
 800a634:	f001 fdae 	bl	800c194 <d_template_param>
 800a638:	60f8      	str	r0, [r7, #12]
 800a63a:	e018      	b.n	800a66e <d_prefix+0x106>
 800a63c:	7afb      	ldrb	r3, [r7, #11]
 800a63e:	2b45      	cmp	r3, #69	; 0x45
 800a640:	d101      	bne.n	800a646 <d_prefix+0xde>
 800a642:	697b      	ldr	r3, [r7, #20]
 800a644:	e035      	b.n	800a6b2 <d_prefix+0x14a>
 800a646:	7afb      	ldrb	r3, [r7, #11]
 800a648:	2b4d      	cmp	r3, #77	; 0x4d
 800a64a:	d10d      	bne.n	800a668 <d_prefix+0x100>
 800a64c:	697b      	ldr	r3, [r7, #20]
 800a64e:	2b00      	cmp	r3, #0
 800a650:	d102      	bne.n	800a658 <d_prefix+0xf0>
 800a652:	f04f 0300 	mov.w	r3, #0
 800a656:	e02c      	b.n	800a6b2 <d_prefix+0x14a>
 800a658:	687b      	ldr	r3, [r7, #4]
 800a65a:	68db      	ldr	r3, [r3, #12]
 800a65c:	f103 0201 	add.w	r2, r3, #1
 800a660:	687b      	ldr	r3, [r7, #4]
 800a662:	60da      	str	r2, [r3, #12]
 800a664:	bf00      	nop
 800a666:	e787      	b.n	800a578 <d_prefix+0x10>
 800a668:	f04f 0300 	mov.w	r3, #0
 800a66c:	e021      	b.n	800a6b2 <d_prefix+0x14a>
 800a66e:	697b      	ldr	r3, [r7, #20]
 800a670:	2b00      	cmp	r3, #0
 800a672:	d102      	bne.n	800a67a <d_prefix+0x112>
 800a674:	68fb      	ldr	r3, [r7, #12]
 800a676:	617b      	str	r3, [r7, #20]
 800a678:	e007      	b.n	800a68a <d_prefix+0x122>
 800a67a:	7cfb      	ldrb	r3, [r7, #19]
 800a67c:	6878      	ldr	r0, [r7, #4]
 800a67e:	4619      	mov	r1, r3
 800a680:	697a      	ldr	r2, [r7, #20]
 800a682:	68fb      	ldr	r3, [r7, #12]
 800a684:	f7ff faae 	bl	8009be4 <d_make_comp>
 800a688:	6178      	str	r0, [r7, #20]
 800a68a:	7afb      	ldrb	r3, [r7, #11]
 800a68c:	2b53      	cmp	r3, #83	; 0x53
 800a68e:	f43f af73 	beq.w	800a578 <d_prefix+0x10>
 800a692:	687b      	ldr	r3, [r7, #4]
 800a694:	68db      	ldr	r3, [r3, #12]
 800a696:	781b      	ldrb	r3, [r3, #0]
 800a698:	2b45      	cmp	r3, #69	; 0x45
 800a69a:	f43f af6d 	beq.w	800a578 <d_prefix+0x10>
 800a69e:	6878      	ldr	r0, [r7, #4]
 800a6a0:	6979      	ldr	r1, [r7, #20]
 800a6a2:	f002 fc1f 	bl	800cee4 <d_add_substitution>
 800a6a6:	4603      	mov	r3, r0
 800a6a8:	2b00      	cmp	r3, #0
 800a6aa:	f47f af65 	bne.w	800a578 <d_prefix+0x10>
 800a6ae:	f04f 0300 	mov.w	r3, #0
 800a6b2:	4618      	mov	r0, r3
 800a6b4:	f107 0718 	add.w	r7, r7, #24
 800a6b8:	46bd      	mov	sp, r7
 800a6ba:	bd80      	pop	{r7, pc}

0800a6bc <d_unqualified_name>:
 800a6bc:	b580      	push	{r7, lr}
 800a6be:	b086      	sub	sp, #24
 800a6c0:	af00      	add	r7, sp, #0
 800a6c2:	6078      	str	r0, [r7, #4]
 800a6c4:	687b      	ldr	r3, [r7, #4]
 800a6c6:	68db      	ldr	r3, [r3, #12]
 800a6c8:	781b      	ldrb	r3, [r3, #0]
 800a6ca:	74fb      	strb	r3, [r7, #19]
 800a6cc:	7cfb      	ldrb	r3, [r7, #19]
 800a6ce:	2b2f      	cmp	r3, #47	; 0x2f
 800a6d0:	d907      	bls.n	800a6e2 <d_unqualified_name+0x26>
 800a6d2:	7cfb      	ldrb	r3, [r7, #19]
 800a6d4:	2b39      	cmp	r3, #57	; 0x39
 800a6d6:	d804      	bhi.n	800a6e2 <d_unqualified_name+0x26>
 800a6d8:	6878      	ldr	r0, [r7, #4]
 800a6da:	f000 f883 	bl	800a7e4 <d_source_name>
 800a6de:	4603      	mov	r3, r0
 800a6e0:	e07b      	b.n	800a7da <d_unqualified_name+0x11e>
 800a6e2:	7cfb      	ldrb	r3, [r7, #19]
 800a6e4:	2b60      	cmp	r3, #96	; 0x60
 800a6e6:	d933      	bls.n	800a750 <d_unqualified_name+0x94>
 800a6e8:	7cfb      	ldrb	r3, [r7, #19]
 800a6ea:	2b7a      	cmp	r3, #122	; 0x7a
 800a6ec:	d830      	bhi.n	800a750 <d_unqualified_name+0x94>
 800a6ee:	6878      	ldr	r0, [r7, #4]
 800a6f0:	f000 f96c 	bl	800a9cc <d_operator_name>
 800a6f4:	6178      	str	r0, [r7, #20]
 800a6f6:	697b      	ldr	r3, [r7, #20]
 800a6f8:	2b00      	cmp	r3, #0
 800a6fa:	d027      	beq.n	800a74c <d_unqualified_name+0x90>
 800a6fc:	697b      	ldr	r3, [r7, #20]
 800a6fe:	781b      	ldrb	r3, [r3, #0]
 800a700:	2b2d      	cmp	r3, #45	; 0x2d
 800a702:	d123      	bne.n	800a74c <d_unqualified_name+0x90>
 800a704:	687b      	ldr	r3, [r7, #4]
 800a706:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a708:	461a      	mov	r2, r3
 800a70a:	697b      	ldr	r3, [r7, #20]
 800a70c:	685b      	ldr	r3, [r3, #4]
 800a70e:	689b      	ldr	r3, [r3, #8]
 800a710:	18d3      	adds	r3, r2, r3
 800a712:	f103 0307 	add.w	r3, r3, #7
 800a716:	461a      	mov	r2, r3
 800a718:	687b      	ldr	r3, [r7, #4]
 800a71a:	631a      	str	r2, [r3, #48]	; 0x30
 800a71c:	697b      	ldr	r3, [r7, #20]
 800a71e:	685b      	ldr	r3, [r3, #4]
 800a720:	681b      	ldr	r3, [r3, #0]
 800a722:	4618      	mov	r0, r3
 800a724:	f24f 41fc 	movw	r1, #62716	; 0xf4fc
 800a728:	f6c0 0101 	movt	r1, #2049	; 0x801
 800a72c:	f008 f8d8 	bl	80128e0 <strcmp>
 800a730:	4603      	mov	r3, r0
 800a732:	2b00      	cmp	r3, #0
 800a734:	d10a      	bne.n	800a74c <d_unqualified_name+0x90>
 800a736:	6878      	ldr	r0, [r7, #4]
 800a738:	f000 f854 	bl	800a7e4 <d_source_name>
 800a73c:	4603      	mov	r3, r0
 800a73e:	6878      	ldr	r0, [r7, #4]
 800a740:	f04f 0131 	mov.w	r1, #49	; 0x31
 800a744:	697a      	ldr	r2, [r7, #20]
 800a746:	f7ff fa4d 	bl	8009be4 <d_make_comp>
 800a74a:	6178      	str	r0, [r7, #20]
 800a74c:	697b      	ldr	r3, [r7, #20]
 800a74e:	e044      	b.n	800a7da <d_unqualified_name+0x11e>
 800a750:	7cfb      	ldrb	r3, [r7, #19]
 800a752:	2b43      	cmp	r3, #67	; 0x43
 800a754:	d002      	beq.n	800a75c <d_unqualified_name+0xa0>
 800a756:	7cfb      	ldrb	r3, [r7, #19]
 800a758:	2b44      	cmp	r3, #68	; 0x44
 800a75a:	d104      	bne.n	800a766 <d_unqualified_name+0xaa>
 800a75c:	6878      	ldr	r0, [r7, #4]
 800a75e:	f000 fdb9 	bl	800b2d4 <d_ctor_dtor_name>
 800a762:	4603      	mov	r3, r0
 800a764:	e039      	b.n	800a7da <d_unqualified_name+0x11e>
 800a766:	7cfb      	ldrb	r3, [r7, #19]
 800a768:	2b4c      	cmp	r3, #76	; 0x4c
 800a76a:	d11a      	bne.n	800a7a2 <d_unqualified_name+0xe6>
 800a76c:	687b      	ldr	r3, [r7, #4]
 800a76e:	68db      	ldr	r3, [r3, #12]
 800a770:	f103 0201 	add.w	r2, r3, #1
 800a774:	687b      	ldr	r3, [r7, #4]
 800a776:	60da      	str	r2, [r3, #12]
 800a778:	6878      	ldr	r0, [r7, #4]
 800a77a:	f000 f833 	bl	800a7e4 <d_source_name>
 800a77e:	60f8      	str	r0, [r7, #12]
 800a780:	68fb      	ldr	r3, [r7, #12]
 800a782:	2b00      	cmp	r3, #0
 800a784:	d102      	bne.n	800a78c <d_unqualified_name+0xd0>
 800a786:	f04f 0300 	mov.w	r3, #0
 800a78a:	e026      	b.n	800a7da <d_unqualified_name+0x11e>
 800a78c:	6878      	ldr	r0, [r7, #4]
 800a78e:	f002 fa3f 	bl	800cc10 <d_discriminator>
 800a792:	4603      	mov	r3, r0
 800a794:	2b00      	cmp	r3, #0
 800a796:	d102      	bne.n	800a79e <d_unqualified_name+0xe2>
 800a798:	f04f 0300 	mov.w	r3, #0
 800a79c:	e01d      	b.n	800a7da <d_unqualified_name+0x11e>
 800a79e:	68fb      	ldr	r3, [r7, #12]
 800a7a0:	e01b      	b.n	800a7da <d_unqualified_name+0x11e>
 800a7a2:	7cfb      	ldrb	r3, [r7, #19]
 800a7a4:	2b55      	cmp	r3, #85	; 0x55
 800a7a6:	d116      	bne.n	800a7d6 <d_unqualified_name+0x11a>
 800a7a8:	687b      	ldr	r3, [r7, #4]
 800a7aa:	68db      	ldr	r3, [r3, #12]
 800a7ac:	f103 0301 	add.w	r3, r3, #1
 800a7b0:	781b      	ldrb	r3, [r3, #0]
 800a7b2:	2b6c      	cmp	r3, #108	; 0x6c
 800a7b4:	d002      	beq.n	800a7bc <d_unqualified_name+0x100>
 800a7b6:	2b74      	cmp	r3, #116	; 0x74
 800a7b8:	d005      	beq.n	800a7c6 <d_unqualified_name+0x10a>
 800a7ba:	e009      	b.n	800a7d0 <d_unqualified_name+0x114>
 800a7bc:	6878      	ldr	r0, [r7, #4]
 800a7be:	f002 fa4b 	bl	800cc58 <d_lambda>
 800a7c2:	4603      	mov	r3, r0
 800a7c4:	e009      	b.n	800a7da <d_unqualified_name+0x11e>
 800a7c6:	6878      	ldr	r0, [r7, #4]
 800a7c8:	f002 fabe 	bl	800cd48 <d_unnamed_type>
 800a7cc:	4603      	mov	r3, r0
 800a7ce:	e004      	b.n	800a7da <d_unqualified_name+0x11e>
 800a7d0:	f04f 0300 	mov.w	r3, #0
 800a7d4:	e001      	b.n	800a7da <d_unqualified_name+0x11e>
 800a7d6:	f04f 0300 	mov.w	r3, #0
 800a7da:	4618      	mov	r0, r3
 800a7dc:	f107 0718 	add.w	r7, r7, #24
 800a7e0:	46bd      	mov	sp, r7
 800a7e2:	bd80      	pop	{r7, pc}

0800a7e4 <d_source_name>:
 800a7e4:	b580      	push	{r7, lr}
 800a7e6:	b084      	sub	sp, #16
 800a7e8:	af00      	add	r7, sp, #0
 800a7ea:	6078      	str	r0, [r7, #4]
 800a7ec:	6878      	ldr	r0, [r7, #4]
 800a7ee:	f000 f815 	bl	800a81c <d_number>
 800a7f2:	60f8      	str	r0, [r7, #12]
 800a7f4:	68fb      	ldr	r3, [r7, #12]
 800a7f6:	2b00      	cmp	r3, #0
 800a7f8:	dc02      	bgt.n	800a800 <d_source_name+0x1c>
 800a7fa:	f04f 0300 	mov.w	r3, #0
 800a7fe:	e008      	b.n	800a812 <d_source_name+0x2e>
 800a800:	6878      	ldr	r0, [r7, #4]
 800a802:	68f9      	ldr	r1, [r7, #12]
 800a804:	f000 f872 	bl	800a8ec <d_identifier>
 800a808:	60b8      	str	r0, [r7, #8]
 800a80a:	687b      	ldr	r3, [r7, #4]
 800a80c:	68ba      	ldr	r2, [r7, #8]
 800a80e:	62da      	str	r2, [r3, #44]	; 0x2c
 800a810:	68bb      	ldr	r3, [r7, #8]
 800a812:	4618      	mov	r0, r3
 800a814:	f107 0710 	add.w	r7, r7, #16
 800a818:	46bd      	mov	sp, r7
 800a81a:	bd80      	pop	{r7, pc}

0800a81c <d_number>:
 800a81c:	b480      	push	{r7}
 800a81e:	b087      	sub	sp, #28
 800a820:	af00      	add	r7, sp, #0
 800a822:	6078      	str	r0, [r7, #4]
 800a824:	f04f 0300 	mov.w	r3, #0
 800a828:	617b      	str	r3, [r7, #20]
 800a82a:	687b      	ldr	r3, [r7, #4]
 800a82c:	68db      	ldr	r3, [r3, #12]
 800a82e:	781b      	ldrb	r3, [r3, #0]
 800a830:	74fb      	strb	r3, [r7, #19]
 800a832:	7cfb      	ldrb	r3, [r7, #19]
 800a834:	2b6e      	cmp	r3, #110	; 0x6e
 800a836:	d10c      	bne.n	800a852 <d_number+0x36>
 800a838:	f04f 0301 	mov.w	r3, #1
 800a83c:	617b      	str	r3, [r7, #20]
 800a83e:	687b      	ldr	r3, [r7, #4]
 800a840:	68db      	ldr	r3, [r3, #12]
 800a842:	f103 0201 	add.w	r2, r3, #1
 800a846:	687b      	ldr	r3, [r7, #4]
 800a848:	60da      	str	r2, [r3, #12]
 800a84a:	687b      	ldr	r3, [r7, #4]
 800a84c:	68db      	ldr	r3, [r3, #12]
 800a84e:	781b      	ldrb	r3, [r3, #0]
 800a850:	74fb      	strb	r3, [r7, #19]
 800a852:	f04f 0300 	mov.w	r3, #0
 800a856:	60fb      	str	r3, [r7, #12]
 800a858:	7cfb      	ldrb	r3, [r7, #19]
 800a85a:	2b2f      	cmp	r3, #47	; 0x2f
 800a85c:	d902      	bls.n	800a864 <d_number+0x48>
 800a85e:	7cfb      	ldrb	r3, [r7, #19]
 800a860:	2b39      	cmp	r3, #57	; 0x39
 800a862:	d908      	bls.n	800a876 <d_number+0x5a>
 800a864:	697b      	ldr	r3, [r7, #20]
 800a866:	2b00      	cmp	r3, #0
 800a868:	d003      	beq.n	800a872 <d_number+0x56>
 800a86a:	68fb      	ldr	r3, [r7, #12]
 800a86c:	f1c3 0300 	rsb	r3, r3, #0
 800a870:	60fb      	str	r3, [r7, #12]
 800a872:	68fb      	ldr	r3, [r7, #12]
 800a874:	e017      	b.n	800a8a6 <d_number+0x8a>
 800a876:	68fa      	ldr	r2, [r7, #12]
 800a878:	4613      	mov	r3, r2
 800a87a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800a87e:	189b      	adds	r3, r3, r2
 800a880:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800a884:	461a      	mov	r2, r3
 800a886:	7cfb      	ldrb	r3, [r7, #19]
 800a888:	18d3      	adds	r3, r2, r3
 800a88a:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 800a88e:	60fb      	str	r3, [r7, #12]
 800a890:	687b      	ldr	r3, [r7, #4]
 800a892:	68db      	ldr	r3, [r3, #12]
 800a894:	f103 0201 	add.w	r2, r3, #1
 800a898:	687b      	ldr	r3, [r7, #4]
 800a89a:	60da      	str	r2, [r3, #12]
 800a89c:	687b      	ldr	r3, [r7, #4]
 800a89e:	68db      	ldr	r3, [r3, #12]
 800a8a0:	781b      	ldrb	r3, [r3, #0]
 800a8a2:	74fb      	strb	r3, [r7, #19]
 800a8a4:	e7d8      	b.n	800a858 <d_number+0x3c>
 800a8a6:	4618      	mov	r0, r3
 800a8a8:	f107 071c 	add.w	r7, r7, #28
 800a8ac:	46bd      	mov	sp, r7
 800a8ae:	bc80      	pop	{r7}
 800a8b0:	4770      	bx	lr
 800a8b2:	bf00      	nop

0800a8b4 <d_number_component>:
 800a8b4:	b580      	push	{r7, lr}
 800a8b6:	b084      	sub	sp, #16
 800a8b8:	af00      	add	r7, sp, #0
 800a8ba:	6078      	str	r0, [r7, #4]
 800a8bc:	6878      	ldr	r0, [r7, #4]
 800a8be:	f7ff f969 	bl	8009b94 <d_make_empty>
 800a8c2:	60f8      	str	r0, [r7, #12]
 800a8c4:	68fb      	ldr	r3, [r7, #12]
 800a8c6:	2b00      	cmp	r3, #0
 800a8c8:	d009      	beq.n	800a8de <d_number_component+0x2a>
 800a8ca:	68fb      	ldr	r3, [r7, #12]
 800a8cc:	f04f 023c 	mov.w	r2, #60	; 0x3c
 800a8d0:	701a      	strb	r2, [r3, #0]
 800a8d2:	6878      	ldr	r0, [r7, #4]
 800a8d4:	f7ff ffa2 	bl	800a81c <d_number>
 800a8d8:	4602      	mov	r2, r0
 800a8da:	68fb      	ldr	r3, [r7, #12]
 800a8dc:	605a      	str	r2, [r3, #4]
 800a8de:	68fb      	ldr	r3, [r7, #12]
 800a8e0:	4618      	mov	r0, r3
 800a8e2:	f107 0710 	add.w	r7, r7, #16
 800a8e6:	46bd      	mov	sp, r7
 800a8e8:	bd80      	pop	{r7, pc}
 800a8ea:	bf00      	nop

0800a8ec <d_identifier>:
 800a8ec:	b580      	push	{r7, lr}
 800a8ee:	b084      	sub	sp, #16
 800a8f0:	af00      	add	r7, sp, #0
 800a8f2:	6078      	str	r0, [r7, #4]
 800a8f4:	6039      	str	r1, [r7, #0]
 800a8f6:	687b      	ldr	r3, [r7, #4]
 800a8f8:	68db      	ldr	r3, [r3, #12]
 800a8fa:	60fb      	str	r3, [r7, #12]
 800a8fc:	687b      	ldr	r3, [r7, #4]
 800a8fe:	685b      	ldr	r3, [r3, #4]
 800a900:	461a      	mov	r2, r3
 800a902:	68fb      	ldr	r3, [r7, #12]
 800a904:	1ad2      	subs	r2, r2, r3
 800a906:	683b      	ldr	r3, [r7, #0]
 800a908:	429a      	cmp	r2, r3
 800a90a:	da02      	bge.n	800a912 <d_identifier+0x26>
 800a90c:	f04f 0300 	mov.w	r3, #0
 800a910:	e056      	b.n	800a9c0 <d_identifier+0xd4>
 800a912:	687b      	ldr	r3, [r7, #4]
 800a914:	68da      	ldr	r2, [r3, #12]
 800a916:	683b      	ldr	r3, [r7, #0]
 800a918:	18d2      	adds	r2, r2, r3
 800a91a:	687b      	ldr	r3, [r7, #4]
 800a91c:	60da      	str	r2, [r3, #12]
 800a91e:	687b      	ldr	r3, [r7, #4]
 800a920:	689b      	ldr	r3, [r3, #8]
 800a922:	f003 0304 	and.w	r3, r3, #4
 800a926:	2b00      	cmp	r3, #0
 800a928:	d00a      	beq.n	800a940 <d_identifier+0x54>
 800a92a:	687b      	ldr	r3, [r7, #4]
 800a92c:	68db      	ldr	r3, [r3, #12]
 800a92e:	781b      	ldrb	r3, [r3, #0]
 800a930:	2b24      	cmp	r3, #36	; 0x24
 800a932:	d105      	bne.n	800a940 <d_identifier+0x54>
 800a934:	687b      	ldr	r3, [r7, #4]
 800a936:	68db      	ldr	r3, [r3, #12]
 800a938:	f103 0201 	add.w	r2, r3, #1
 800a93c:	687b      	ldr	r3, [r7, #4]
 800a93e:	60da      	str	r2, [r3, #12]
 800a940:	683b      	ldr	r3, [r7, #0]
 800a942:	2b09      	cmp	r3, #9
 800a944:	dd36      	ble.n	800a9b4 <d_identifier+0xc8>
 800a946:	68f8      	ldr	r0, [r7, #12]
 800a948:	f24f 5100 	movw	r1, #62720	; 0xf500
 800a94c:	f6c0 0101 	movt	r1, #2049	; 0x801
 800a950:	f04f 0208 	mov.w	r2, #8
 800a954:	f007 fa24 	bl	8011da0 <memcmp>
 800a958:	4603      	mov	r3, r0
 800a95a:	2b00      	cmp	r3, #0
 800a95c:	d12a      	bne.n	800a9b4 <d_identifier+0xc8>
 800a95e:	68fb      	ldr	r3, [r7, #12]
 800a960:	f103 0308 	add.w	r3, r3, #8
 800a964:	60bb      	str	r3, [r7, #8]
 800a966:	68bb      	ldr	r3, [r7, #8]
 800a968:	781b      	ldrb	r3, [r3, #0]
 800a96a:	2b2e      	cmp	r3, #46	; 0x2e
 800a96c:	d007      	beq.n	800a97e <d_identifier+0x92>
 800a96e:	68bb      	ldr	r3, [r7, #8]
 800a970:	781b      	ldrb	r3, [r3, #0]
 800a972:	2b5f      	cmp	r3, #95	; 0x5f
 800a974:	d003      	beq.n	800a97e <d_identifier+0x92>
 800a976:	68bb      	ldr	r3, [r7, #8]
 800a978:	781b      	ldrb	r3, [r3, #0]
 800a97a:	2b24      	cmp	r3, #36	; 0x24
 800a97c:	d11a      	bne.n	800a9b4 <d_identifier+0xc8>
 800a97e:	68bb      	ldr	r3, [r7, #8]
 800a980:	f103 0301 	add.w	r3, r3, #1
 800a984:	781b      	ldrb	r3, [r3, #0]
 800a986:	2b4e      	cmp	r3, #78	; 0x4e
 800a988:	d114      	bne.n	800a9b4 <d_identifier+0xc8>
 800a98a:	687b      	ldr	r3, [r7, #4]
 800a98c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a98e:	461a      	mov	r2, r3
 800a990:	683b      	ldr	r3, [r7, #0]
 800a992:	1ad3      	subs	r3, r2, r3
 800a994:	f103 0316 	add.w	r3, r3, #22
 800a998:	461a      	mov	r2, r3
 800a99a:	687b      	ldr	r3, [r7, #4]
 800a99c:	631a      	str	r2, [r3, #48]	; 0x30
 800a99e:	6878      	ldr	r0, [r7, #4]
 800a9a0:	f24f 510c 	movw	r1, #62732	; 0xf50c
 800a9a4:	f6c0 0101 	movt	r1, #2049	; 0x801
 800a9a8:	f04f 0215 	mov.w	r2, #21
 800a9ac:	f7ff fa1c 	bl	8009de8 <d_make_name>
 800a9b0:	4603      	mov	r3, r0
 800a9b2:	e005      	b.n	800a9c0 <d_identifier+0xd4>
 800a9b4:	6878      	ldr	r0, [r7, #4]
 800a9b6:	68f9      	ldr	r1, [r7, #12]
 800a9b8:	683a      	ldr	r2, [r7, #0]
 800a9ba:	f7ff fa15 	bl	8009de8 <d_make_name>
 800a9be:	4603      	mov	r3, r0
 800a9c0:	4618      	mov	r0, r3
 800a9c2:	f107 0710 	add.w	r7, r7, #16
 800a9c6:	46bd      	mov	sp, r7
 800a9c8:	bd80      	pop	{r7, pc}
 800a9ca:	bf00      	nop

0800a9cc <d_operator_name>:
 800a9cc:	b590      	push	{r4, r7, lr}
 800a9ce:	b089      	sub	sp, #36	; 0x24
 800a9d0:	af00      	add	r7, sp, #0
 800a9d2:	6078      	str	r0, [r7, #4]
 800a9d4:	687b      	ldr	r3, [r7, #4]
 800a9d6:	68db      	ldr	r3, [r3, #12]
 800a9d8:	781b      	ldrb	r3, [r3, #0]
 800a9da:	2b00      	cmp	r3, #0
 800a9dc:	d007      	beq.n	800a9ee <d_operator_name+0x22>
 800a9de:	687b      	ldr	r3, [r7, #4]
 800a9e0:	68da      	ldr	r2, [r3, #12]
 800a9e2:	7813      	ldrb	r3, [r2, #0]
 800a9e4:	f102 0101 	add.w	r1, r2, #1
 800a9e8:	687a      	ldr	r2, [r7, #4]
 800a9ea:	60d1      	str	r1, [r2, #12]
 800a9ec:	e001      	b.n	800a9f2 <d_operator_name+0x26>
 800a9ee:	f04f 0300 	mov.w	r3, #0
 800a9f2:	75fb      	strb	r3, [r7, #23]
 800a9f4:	687b      	ldr	r3, [r7, #4]
 800a9f6:	68db      	ldr	r3, [r3, #12]
 800a9f8:	781b      	ldrb	r3, [r3, #0]
 800a9fa:	2b00      	cmp	r3, #0
 800a9fc:	d007      	beq.n	800aa0e <d_operator_name+0x42>
 800a9fe:	687b      	ldr	r3, [r7, #4]
 800aa00:	68da      	ldr	r2, [r3, #12]
 800aa02:	7813      	ldrb	r3, [r2, #0]
 800aa04:	f102 0101 	add.w	r1, r2, #1
 800aa08:	687a      	ldr	r2, [r7, #4]
 800aa0a:	60d1      	str	r1, [r2, #12]
 800aa0c:	e001      	b.n	800aa12 <d_operator_name+0x46>
 800aa0e:	f04f 0300 	mov.w	r3, #0
 800aa12:	75bb      	strb	r3, [r7, #22]
 800aa14:	7dfb      	ldrb	r3, [r7, #23]
 800aa16:	2b76      	cmp	r3, #118	; 0x76
 800aa18:	d113      	bne.n	800aa42 <d_operator_name+0x76>
 800aa1a:	7dbb      	ldrb	r3, [r7, #22]
 800aa1c:	2b2f      	cmp	r3, #47	; 0x2f
 800aa1e:	d910      	bls.n	800aa42 <d_operator_name+0x76>
 800aa20:	7dbb      	ldrb	r3, [r7, #22]
 800aa22:	2b39      	cmp	r3, #57	; 0x39
 800aa24:	d80d      	bhi.n	800aa42 <d_operator_name+0x76>
 800aa26:	7dbb      	ldrb	r3, [r7, #22]
 800aa28:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
 800aa2c:	6878      	ldr	r0, [r7, #4]
 800aa2e:	f7ff fed9 	bl	800a7e4 <d_source_name>
 800aa32:	4603      	mov	r3, r0
 800aa34:	6878      	ldr	r0, [r7, #4]
 800aa36:	4621      	mov	r1, r4
 800aa38:	461a      	mov	r2, r3
 800aa3a:	f7ff fa2b 	bl	8009e94 <d_make_extended_operator>
 800aa3e:	4603      	mov	r3, r0
 800aa40:	e065      	b.n	800ab0e <d_operator_name+0x142>
 800aa42:	7dfb      	ldrb	r3, [r7, #23]
 800aa44:	2b63      	cmp	r3, #99	; 0x63
 800aa46:	d110      	bne.n	800aa6a <d_operator_name+0x9e>
 800aa48:	7dbb      	ldrb	r3, [r7, #22]
 800aa4a:	2b76      	cmp	r3, #118	; 0x76
 800aa4c:	d10d      	bne.n	800aa6a <d_operator_name+0x9e>
 800aa4e:	6878      	ldr	r0, [r7, #4]
 800aa50:	f000 fce8 	bl	800b424 <d_type>
 800aa54:	4603      	mov	r3, r0
 800aa56:	6878      	ldr	r0, [r7, #4]
 800aa58:	f04f 012f 	mov.w	r1, #47	; 0x2f
 800aa5c:	461a      	mov	r2, r3
 800aa5e:	f04f 0300 	mov.w	r3, #0
 800aa62:	f7ff f8bf 	bl	8009be4 <d_make_comp>
 800aa66:	4603      	mov	r3, r0
 800aa68:	e051      	b.n	800ab0e <d_operator_name+0x142>
 800aa6a:	f04f 0300 	mov.w	r3, #0
 800aa6e:	61fb      	str	r3, [r7, #28]
 800aa70:	f04f 0339 	mov.w	r3, #57	; 0x39
 800aa74:	61bb      	str	r3, [r7, #24]
 800aa76:	e000      	b.n	800aa7a <d_operator_name+0xae>
 800aa78:	bf00      	nop
 800aa7a:	69ba      	ldr	r2, [r7, #24]
 800aa7c:	69fb      	ldr	r3, [r7, #28]
 800aa7e:	1ad3      	subs	r3, r2, r3
 800aa80:	ea4f 72d3 	mov.w	r2, r3, lsr #31
 800aa84:	18d3      	adds	r3, r2, r3
 800aa86:	ea4f 0363 	mov.w	r3, r3, asr #1
 800aa8a:	461a      	mov	r2, r3
 800aa8c:	69fb      	ldr	r3, [r7, #28]
 800aa8e:	18d3      	adds	r3, r2, r3
 800aa90:	613b      	str	r3, [r7, #16]
 800aa92:	693b      	ldr	r3, [r7, #16]
 800aa94:	ea4f 1203 	mov.w	r2, r3, lsl #4
 800aa98:	f24f 63fc 	movw	r3, #63228	; 0xf6fc
 800aa9c:	f6c0 0301 	movt	r3, #2049	; 0x801
 800aaa0:	18d3      	adds	r3, r2, r3
 800aaa2:	60fb      	str	r3, [r7, #12]
 800aaa4:	68fb      	ldr	r3, [r7, #12]
 800aaa6:	681b      	ldr	r3, [r3, #0]
 800aaa8:	781b      	ldrb	r3, [r3, #0]
 800aaaa:	7dfa      	ldrb	r2, [r7, #23]
 800aaac:	429a      	cmp	r2, r3
 800aaae:	d10d      	bne.n	800aacc <d_operator_name+0x100>
 800aab0:	68fb      	ldr	r3, [r7, #12]
 800aab2:	681b      	ldr	r3, [r3, #0]
 800aab4:	f103 0301 	add.w	r3, r3, #1
 800aab8:	781b      	ldrb	r3, [r3, #0]
 800aaba:	7dba      	ldrb	r2, [r7, #22]
 800aabc:	429a      	cmp	r2, r3
 800aabe:	d105      	bne.n	800aacc <d_operator_name+0x100>
 800aac0:	6878      	ldr	r0, [r7, #4]
 800aac2:	68f9      	ldr	r1, [r7, #12]
 800aac4:	f7ff f9cc 	bl	8009e60 <d_make_operator>
 800aac8:	4603      	mov	r3, r0
 800aaca:	e020      	b.n	800ab0e <d_operator_name+0x142>
 800aacc:	68fb      	ldr	r3, [r7, #12]
 800aace:	681b      	ldr	r3, [r3, #0]
 800aad0:	781b      	ldrb	r3, [r3, #0]
 800aad2:	7dfa      	ldrb	r2, [r7, #23]
 800aad4:	429a      	cmp	r2, r3
 800aad6:	d30d      	bcc.n	800aaf4 <d_operator_name+0x128>
 800aad8:	68fb      	ldr	r3, [r7, #12]
 800aada:	681b      	ldr	r3, [r3, #0]
 800aadc:	781b      	ldrb	r3, [r3, #0]
 800aade:	7dfa      	ldrb	r2, [r7, #23]
 800aae0:	429a      	cmp	r2, r3
 800aae2:	d10a      	bne.n	800aafa <d_operator_name+0x12e>
 800aae4:	68fb      	ldr	r3, [r7, #12]
 800aae6:	681b      	ldr	r3, [r3, #0]
 800aae8:	f103 0301 	add.w	r3, r3, #1
 800aaec:	781b      	ldrb	r3, [r3, #0]
 800aaee:	7dba      	ldrb	r2, [r7, #22]
 800aaf0:	429a      	cmp	r2, r3
 800aaf2:	d202      	bcs.n	800aafa <d_operator_name+0x12e>
 800aaf4:	693b      	ldr	r3, [r7, #16]
 800aaf6:	61bb      	str	r3, [r7, #24]
 800aaf8:	e003      	b.n	800ab02 <d_operator_name+0x136>
 800aafa:	693b      	ldr	r3, [r7, #16]
 800aafc:	f103 0301 	add.w	r3, r3, #1
 800ab00:	61fb      	str	r3, [r7, #28]
 800ab02:	69fa      	ldr	r2, [r7, #28]
 800ab04:	69bb      	ldr	r3, [r7, #24]
 800ab06:	429a      	cmp	r2, r3
 800ab08:	d1b6      	bne.n	800aa78 <d_operator_name+0xac>
 800ab0a:	f04f 0300 	mov.w	r3, #0
 800ab0e:	4618      	mov	r0, r3
 800ab10:	f107 0724 	add.w	r7, r7, #36	; 0x24
 800ab14:	46bd      	mov	sp, r7
 800ab16:	bd90      	pop	{r4, r7, pc}

0800ab18 <d_make_character>:
 800ab18:	b580      	push	{r7, lr}
 800ab1a:	b084      	sub	sp, #16
 800ab1c:	af00      	add	r7, sp, #0
 800ab1e:	6078      	str	r0, [r7, #4]
 800ab20:	6039      	str	r1, [r7, #0]
 800ab22:	6878      	ldr	r0, [r7, #4]
 800ab24:	f7ff f836 	bl	8009b94 <d_make_empty>
 800ab28:	60f8      	str	r0, [r7, #12]
 800ab2a:	68fb      	ldr	r3, [r7, #12]
 800ab2c:	2b00      	cmp	r3, #0
 800ab2e:	d006      	beq.n	800ab3e <d_make_character+0x26>
 800ab30:	68fb      	ldr	r3, [r7, #12]
 800ab32:	f04f 023b 	mov.w	r2, #59	; 0x3b
 800ab36:	701a      	strb	r2, [r3, #0]
 800ab38:	68fb      	ldr	r3, [r7, #12]
 800ab3a:	683a      	ldr	r2, [r7, #0]
 800ab3c:	605a      	str	r2, [r3, #4]
 800ab3e:	68fb      	ldr	r3, [r7, #12]
 800ab40:	4618      	mov	r0, r3
 800ab42:	f107 0710 	add.w	r7, r7, #16
 800ab46:	46bd      	mov	sp, r7
 800ab48:	bd80      	pop	{r7, pc}
 800ab4a:	bf00      	nop

0800ab4c <d_java_resource>:
 800ab4c:	b580      	push	{r7, lr}
 800ab4e:	b088      	sub	sp, #32
 800ab50:	af00      	add	r7, sp, #0
 800ab52:	6078      	str	r0, [r7, #4]
 800ab54:	f04f 0300 	mov.w	r3, #0
 800ab58:	61fb      	str	r3, [r7, #28]
 800ab5a:	f04f 0300 	mov.w	r3, #0
 800ab5e:	61bb      	str	r3, [r7, #24]
 800ab60:	6878      	ldr	r0, [r7, #4]
 800ab62:	f7ff fe5b 	bl	800a81c <d_number>
 800ab66:	6178      	str	r0, [r7, #20]
 800ab68:	697b      	ldr	r3, [r7, #20]
 800ab6a:	2b01      	cmp	r3, #1
 800ab6c:	dc02      	bgt.n	800ab74 <d_java_resource+0x28>
 800ab6e:	f04f 0300 	mov.w	r3, #0
 800ab72:	e0be      	b.n	800acf2 <d_java_resource+0x1a6>
 800ab74:	687b      	ldr	r3, [r7, #4]
 800ab76:	68db      	ldr	r3, [r3, #12]
 800ab78:	781b      	ldrb	r3, [r3, #0]
 800ab7a:	2b00      	cmp	r3, #0
 800ab7c:	d00d      	beq.n	800ab9a <d_java_resource+0x4e>
 800ab7e:	687b      	ldr	r3, [r7, #4]
 800ab80:	68db      	ldr	r3, [r3, #12]
 800ab82:	781a      	ldrb	r2, [r3, #0]
 800ab84:	2a5f      	cmp	r2, #95	; 0x5f
 800ab86:	bf0c      	ite	eq
 800ab88:	2200      	moveq	r2, #0
 800ab8a:	2201      	movne	r2, #1
 800ab8c:	b2d2      	uxtb	r2, r2
 800ab8e:	f103 0101 	add.w	r1, r3, #1
 800ab92:	687b      	ldr	r3, [r7, #4]
 800ab94:	60d9      	str	r1, [r3, #12]
 800ab96:	2a00      	cmp	r2, #0
 800ab98:	d002      	beq.n	800aba0 <d_java_resource+0x54>
 800ab9a:	f04f 0300 	mov.w	r3, #0
 800ab9e:	e0a8      	b.n	800acf2 <d_java_resource+0x1a6>
 800aba0:	697b      	ldr	r3, [r7, #20]
 800aba2:	f103 33ff 	add.w	r3, r3, #4294967295
 800aba6:	617b      	str	r3, [r7, #20]
 800aba8:	687b      	ldr	r3, [r7, #4]
 800abaa:	68db      	ldr	r3, [r3, #12]
 800abac:	60bb      	str	r3, [r7, #8]
 800abae:	f04f 0300 	mov.w	r3, #0
 800abb2:	613b      	str	r3, [r7, #16]
 800abb4:	e08f      	b.n	800acd6 <d_java_resource+0x18a>
 800abb6:	693b      	ldr	r3, [r7, #16]
 800abb8:	68ba      	ldr	r2, [r7, #8]
 800abba:	18d3      	adds	r3, r2, r3
 800abbc:	781b      	ldrb	r3, [r3, #0]
 800abbe:	73fb      	strb	r3, [r7, #15]
 800abc0:	7bfb      	ldrb	r3, [r7, #15]
 800abc2:	2b00      	cmp	r3, #0
 800abc4:	d102      	bne.n	800abcc <d_java_resource+0x80>
 800abc6:	f04f 0300 	mov.w	r3, #0
 800abca:	e092      	b.n	800acf2 <d_java_resource+0x1a6>
 800abcc:	7bfb      	ldrb	r3, [r7, #15]
 800abce:	2b24      	cmp	r3, #36	; 0x24
 800abd0:	d141      	bne.n	800ac56 <d_java_resource+0x10a>
 800abd2:	693b      	ldr	r3, [r7, #16]
 800abd4:	f103 0301 	add.w	r3, r3, #1
 800abd8:	613b      	str	r3, [r7, #16]
 800abda:	693b      	ldr	r3, [r7, #16]
 800abdc:	68ba      	ldr	r2, [r7, #8]
 800abde:	18d3      	adds	r3, r2, r3
 800abe0:	781b      	ldrb	r3, [r3, #0]
 800abe2:	693a      	ldr	r2, [r7, #16]
 800abe4:	f102 0201 	add.w	r2, r2, #1
 800abe8:	613a      	str	r2, [r7, #16]
 800abea:	2b53      	cmp	r3, #83	; 0x53
 800abec:	d004      	beq.n	800abf8 <d_java_resource+0xac>
 800abee:	2b5f      	cmp	r3, #95	; 0x5f
 800abf0:	d006      	beq.n	800ac00 <d_java_resource+0xb4>
 800abf2:	2b24      	cmp	r3, #36	; 0x24
 800abf4:	d008      	beq.n	800ac08 <d_java_resource+0xbc>
 800abf6:	e00b      	b.n	800ac10 <d_java_resource+0xc4>
 800abf8:	f04f 032f 	mov.w	r3, #47	; 0x2f
 800abfc:	73fb      	strb	r3, [r7, #15]
 800abfe:	e00a      	b.n	800ac16 <d_java_resource+0xca>
 800ac00:	f04f 032e 	mov.w	r3, #46	; 0x2e
 800ac04:	73fb      	strb	r3, [r7, #15]
 800ac06:	e006      	b.n	800ac16 <d_java_resource+0xca>
 800ac08:	f04f 0324 	mov.w	r3, #36	; 0x24
 800ac0c:	73fb      	strb	r3, [r7, #15]
 800ac0e:	e002      	b.n	800ac16 <d_java_resource+0xca>
 800ac10:	f04f 0300 	mov.w	r3, #0
 800ac14:	e06d      	b.n	800acf2 <d_java_resource+0x1a6>
 800ac16:	7bfb      	ldrb	r3, [r7, #15]
 800ac18:	6878      	ldr	r0, [r7, #4]
 800ac1a:	4619      	mov	r1, r3
 800ac1c:	f7ff ff7c 	bl	800ab18 <d_make_character>
 800ac20:	61b8      	str	r0, [r7, #24]
 800ac22:	687b      	ldr	r3, [r7, #4]
 800ac24:	68da      	ldr	r2, [r3, #12]
 800ac26:	693b      	ldr	r3, [r7, #16]
 800ac28:	18d2      	adds	r2, r2, r3
 800ac2a:	687b      	ldr	r3, [r7, #4]
 800ac2c:	60da      	str	r2, [r3, #12]
 800ac2e:	687b      	ldr	r3, [r7, #4]
 800ac30:	68db      	ldr	r3, [r3, #12]
 800ac32:	60bb      	str	r3, [r7, #8]
 800ac34:	697a      	ldr	r2, [r7, #20]
 800ac36:	693b      	ldr	r3, [r7, #16]
 800ac38:	1ad3      	subs	r3, r2, r3
 800ac3a:	617b      	str	r3, [r7, #20]
 800ac3c:	f04f 0300 	mov.w	r3, #0
 800ac40:	613b      	str	r3, [r7, #16]
 800ac42:	69bb      	ldr	r3, [r7, #24]
 800ac44:	2b00      	cmp	r3, #0
 800ac46:	d132      	bne.n	800acae <d_java_resource+0x162>
 800ac48:	f04f 0300 	mov.w	r3, #0
 800ac4c:	e051      	b.n	800acf2 <d_java_resource+0x1a6>
 800ac4e:	693b      	ldr	r3, [r7, #16]
 800ac50:	f103 0301 	add.w	r3, r3, #1
 800ac54:	613b      	str	r3, [r7, #16]
 800ac56:	693a      	ldr	r2, [r7, #16]
 800ac58:	697b      	ldr	r3, [r7, #20]
 800ac5a:	429a      	cmp	r2, r3
 800ac5c:	da0b      	bge.n	800ac76 <d_java_resource+0x12a>
 800ac5e:	693b      	ldr	r3, [r7, #16]
 800ac60:	68ba      	ldr	r2, [r7, #8]
 800ac62:	18d3      	adds	r3, r2, r3
 800ac64:	781b      	ldrb	r3, [r3, #0]
 800ac66:	2b00      	cmp	r3, #0
 800ac68:	d005      	beq.n	800ac76 <d_java_resource+0x12a>
 800ac6a:	693b      	ldr	r3, [r7, #16]
 800ac6c:	68ba      	ldr	r2, [r7, #8]
 800ac6e:	18d3      	adds	r3, r2, r3
 800ac70:	781b      	ldrb	r3, [r3, #0]
 800ac72:	2b24      	cmp	r3, #36	; 0x24
 800ac74:	d1eb      	bne.n	800ac4e <d_java_resource+0x102>
 800ac76:	6878      	ldr	r0, [r7, #4]
 800ac78:	68b9      	ldr	r1, [r7, #8]
 800ac7a:	693a      	ldr	r2, [r7, #16]
 800ac7c:	f7ff f8b4 	bl	8009de8 <d_make_name>
 800ac80:	61b8      	str	r0, [r7, #24]
 800ac82:	687b      	ldr	r3, [r7, #4]
 800ac84:	68da      	ldr	r2, [r3, #12]
 800ac86:	693b      	ldr	r3, [r7, #16]
 800ac88:	18d2      	adds	r2, r2, r3
 800ac8a:	687b      	ldr	r3, [r7, #4]
 800ac8c:	60da      	str	r2, [r3, #12]
 800ac8e:	687b      	ldr	r3, [r7, #4]
 800ac90:	68db      	ldr	r3, [r3, #12]
 800ac92:	60bb      	str	r3, [r7, #8]
 800ac94:	697a      	ldr	r2, [r7, #20]
 800ac96:	693b      	ldr	r3, [r7, #16]
 800ac98:	1ad3      	subs	r3, r2, r3
 800ac9a:	617b      	str	r3, [r7, #20]
 800ac9c:	f04f 0300 	mov.w	r3, #0
 800aca0:	613b      	str	r3, [r7, #16]
 800aca2:	69bb      	ldr	r3, [r7, #24]
 800aca4:	2b00      	cmp	r3, #0
 800aca6:	d102      	bne.n	800acae <d_java_resource+0x162>
 800aca8:	f04f 0300 	mov.w	r3, #0
 800acac:	e021      	b.n	800acf2 <d_java_resource+0x1a6>
 800acae:	69fb      	ldr	r3, [r7, #28]
 800acb0:	2b00      	cmp	r3, #0
 800acb2:	d102      	bne.n	800acba <d_java_resource+0x16e>
 800acb4:	69bb      	ldr	r3, [r7, #24]
 800acb6:	61fb      	str	r3, [r7, #28]
 800acb8:	e00d      	b.n	800acd6 <d_java_resource+0x18a>
 800acba:	6878      	ldr	r0, [r7, #4]
 800acbc:	f04f 013a 	mov.w	r1, #58	; 0x3a
 800acc0:	69fa      	ldr	r2, [r7, #28]
 800acc2:	69bb      	ldr	r3, [r7, #24]
 800acc4:	f7fe ff8e 	bl	8009be4 <d_make_comp>
 800acc8:	61f8      	str	r0, [r7, #28]
 800acca:	69fb      	ldr	r3, [r7, #28]
 800accc:	2b00      	cmp	r3, #0
 800acce:	d102      	bne.n	800acd6 <d_java_resource+0x18a>
 800acd0:	f04f 0300 	mov.w	r3, #0
 800acd4:	e00d      	b.n	800acf2 <d_java_resource+0x1a6>
 800acd6:	697b      	ldr	r3, [r7, #20]
 800acd8:	2b00      	cmp	r3, #0
 800acda:	f73f af6c 	bgt.w	800abb6 <d_java_resource+0x6a>
 800acde:	6878      	ldr	r0, [r7, #4]
 800ace0:	f04f 0139 	mov.w	r1, #57	; 0x39
 800ace4:	69fa      	ldr	r2, [r7, #28]
 800ace6:	f04f 0300 	mov.w	r3, #0
 800acea:	f7fe ff7b 	bl	8009be4 <d_make_comp>
 800acee:	61f8      	str	r0, [r7, #28]
 800acf0:	69fb      	ldr	r3, [r7, #28]
 800acf2:	4618      	mov	r0, r3
 800acf4:	f107 0720 	add.w	r7, r7, #32
 800acf8:	46bd      	mov	sp, r7
 800acfa:	bd80      	pop	{r7, pc}

0800acfc <d_special_name>:
 800acfc:	b580      	push	{r7, lr}
 800acfe:	b086      	sub	sp, #24
 800ad00:	af00      	add	r7, sp, #0
 800ad02:	6078      	str	r0, [r7, #4]
 800ad04:	687b      	ldr	r3, [r7, #4]
 800ad06:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ad08:	f103 0214 	add.w	r2, r3, #20
 800ad0c:	687b      	ldr	r3, [r7, #4]
 800ad0e:	631a      	str	r2, [r3, #48]	; 0x30
 800ad10:	687b      	ldr	r3, [r7, #4]
 800ad12:	68db      	ldr	r3, [r3, #12]
 800ad14:	781b      	ldrb	r3, [r3, #0]
 800ad16:	2b54      	cmp	r3, #84	; 0x54
 800ad18:	d108      	bne.n	800ad2c <d_special_name+0x30>
 800ad1a:	687b      	ldr	r3, [r7, #4]
 800ad1c:	68db      	ldr	r3, [r3, #12]
 800ad1e:	f103 0201 	add.w	r2, r3, #1
 800ad22:	687b      	ldr	r3, [r7, #4]
 800ad24:	60da      	str	r2, [r3, #12]
 800ad26:	f04f 0301 	mov.w	r3, #1
 800ad2a:	e001      	b.n	800ad30 <d_special_name+0x34>
 800ad2c:	f04f 0300 	mov.w	r3, #0
 800ad30:	2b00      	cmp	r3, #0
 800ad32:	f000 8174 	beq.w	800b01e <d_special_name+0x322>
 800ad36:	687b      	ldr	r3, [r7, #4]
 800ad38:	68db      	ldr	r3, [r3, #12]
 800ad3a:	781b      	ldrb	r3, [r3, #0]
 800ad3c:	2b00      	cmp	r3, #0
 800ad3e:	d007      	beq.n	800ad50 <d_special_name+0x54>
 800ad40:	687b      	ldr	r3, [r7, #4]
 800ad42:	68da      	ldr	r2, [r3, #12]
 800ad44:	7813      	ldrb	r3, [r2, #0]
 800ad46:	f102 0101 	add.w	r1, r2, #1
 800ad4a:	687a      	ldr	r2, [r7, #4]
 800ad4c:	60d1      	str	r1, [r2, #12]
 800ad4e:	e001      	b.n	800ad54 <d_special_name+0x58>
 800ad50:	f04f 0300 	mov.w	r3, #0
 800ad54:	f1a3 0343 	sub.w	r3, r3, #67	; 0x43
 800ad58:	2b33      	cmp	r3, #51	; 0x33
 800ad5a:	f200 815d 	bhi.w	800b018 <d_special_name+0x31c>
 800ad5e:	a201      	add	r2, pc, #4	; (adr r2, 800ad64 <d_special_name+0x68>)
 800ad60:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ad64:	0800af75 	.word	0x0800af75
 800ad68:	0800b019 	.word	0x0800b019
 800ad6c:	0800b019 	.word	0x0800b019
 800ad70:	0800afe1 	.word	0x0800afe1
 800ad74:	0800b019 	.word	0x0800b019
 800ad78:	0800b019 	.word	0x0800b019
 800ad7c:	0800ae85 	.word	0x0800ae85
 800ad80:	0800affd 	.word	0x0800affd
 800ad84:	0800b019 	.word	0x0800b019
 800ad88:	0800b019 	.word	0x0800b019
 800ad8c:	0800b019 	.word	0x0800b019
 800ad90:	0800b019 	.word	0x0800b019
 800ad94:	0800b019 	.word	0x0800b019
 800ad98:	0800b019 	.word	0x0800b019
 800ad9c:	0800b019 	.word	0x0800b019
 800ada0:	0800b019 	.word	0x0800b019
 800ada4:	0800aea1 	.word	0x0800aea1
 800ada8:	0800ae5d 	.word	0x0800ae5d
 800adac:	0800b019 	.word	0x0800b019
 800adb0:	0800ae35 	.word	0x0800ae35
 800adb4:	0800b019 	.word	0x0800b019
 800adb8:	0800b019 	.word	0x0800b019
 800adbc:	0800b019 	.word	0x0800b019
 800adc0:	0800b019 	.word	0x0800b019
 800adc4:	0800b019 	.word	0x0800b019
 800adc8:	0800b019 	.word	0x0800b019
 800adcc:	0800b019 	.word	0x0800b019
 800add0:	0800b019 	.word	0x0800b019
 800add4:	0800b019 	.word	0x0800b019
 800add8:	0800b019 	.word	0x0800b019
 800addc:	0800b019 	.word	0x0800b019
 800ade0:	0800b019 	.word	0x0800b019
 800ade4:	0800af29 	.word	0x0800af29
 800ade8:	0800b019 	.word	0x0800b019
 800adec:	0800b019 	.word	0x0800b019
 800adf0:	0800b019 	.word	0x0800b019
 800adf4:	0800b019 	.word	0x0800b019
 800adf8:	0800aebd 	.word	0x0800aebd
 800adfc:	0800b019 	.word	0x0800b019
 800ae00:	0800b019 	.word	0x0800b019
 800ae04:	0800b019 	.word	0x0800b019
 800ae08:	0800b019 	.word	0x0800b019
 800ae0c:	0800b019 	.word	0x0800b019
 800ae10:	0800b019 	.word	0x0800b019
 800ae14:	0800b019 	.word	0x0800b019
 800ae18:	0800b019 	.word	0x0800b019
 800ae1c:	0800b019 	.word	0x0800b019
 800ae20:	0800b019 	.word	0x0800b019
 800ae24:	0800b019 	.word	0x0800b019
 800ae28:	0800b019 	.word	0x0800b019
 800ae2c:	0800b019 	.word	0x0800b019
 800ae30:	0800aef3 	.word	0x0800aef3
 800ae34:	687b      	ldr	r3, [r7, #4]
 800ae36:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ae38:	f1a3 0205 	sub.w	r2, r3, #5
 800ae3c:	687b      	ldr	r3, [r7, #4]
 800ae3e:	631a      	str	r2, [r3, #48]	; 0x30
 800ae40:	6878      	ldr	r0, [r7, #4]
 800ae42:	f000 faef 	bl	800b424 <d_type>
 800ae46:	4603      	mov	r3, r0
 800ae48:	6878      	ldr	r0, [r7, #4]
 800ae4a:	f04f 0109 	mov.w	r1, #9
 800ae4e:	461a      	mov	r2, r3
 800ae50:	f04f 0300 	mov.w	r3, #0
 800ae54:	f7fe fec6 	bl	8009be4 <d_make_comp>
 800ae58:	4603      	mov	r3, r0
 800ae5a:	e1d8      	b.n	800b20e <d_special_name+0x512>
 800ae5c:	687b      	ldr	r3, [r7, #4]
 800ae5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ae60:	f1a3 020a 	sub.w	r2, r3, #10
 800ae64:	687b      	ldr	r3, [r7, #4]
 800ae66:	631a      	str	r2, [r3, #48]	; 0x30
 800ae68:	6878      	ldr	r0, [r7, #4]
 800ae6a:	f000 fadb 	bl	800b424 <d_type>
 800ae6e:	4603      	mov	r3, r0
 800ae70:	6878      	ldr	r0, [r7, #4]
 800ae72:	f04f 010a 	mov.w	r1, #10
 800ae76:	461a      	mov	r2, r3
 800ae78:	f04f 0300 	mov.w	r3, #0
 800ae7c:	f7fe feb2 	bl	8009be4 <d_make_comp>
 800ae80:	4603      	mov	r3, r0
 800ae82:	e1c4      	b.n	800b20e <d_special_name+0x512>
 800ae84:	6878      	ldr	r0, [r7, #4]
 800ae86:	f000 facd 	bl	800b424 <d_type>
 800ae8a:	4603      	mov	r3, r0
 800ae8c:	6878      	ldr	r0, [r7, #4]
 800ae8e:	f04f 010c 	mov.w	r1, #12
 800ae92:	461a      	mov	r2, r3
 800ae94:	f04f 0300 	mov.w	r3, #0
 800ae98:	f7fe fea4 	bl	8009be4 <d_make_comp>
 800ae9c:	4603      	mov	r3, r0
 800ae9e:	e1b6      	b.n	800b20e <d_special_name+0x512>
 800aea0:	6878      	ldr	r0, [r7, #4]
 800aea2:	f000 fabf 	bl	800b424 <d_type>
 800aea6:	4603      	mov	r3, r0
 800aea8:	6878      	ldr	r0, [r7, #4]
 800aeaa:	f04f 010d 	mov.w	r1, #13
 800aeae:	461a      	mov	r2, r3
 800aeb0:	f04f 0300 	mov.w	r3, #0
 800aeb4:	f7fe fe96 	bl	8009be4 <d_make_comp>
 800aeb8:	4603      	mov	r3, r0
 800aeba:	e1a8      	b.n	800b20e <d_special_name+0x512>
 800aebc:	6878      	ldr	r0, [r7, #4]
 800aebe:	f04f 0168 	mov.w	r1, #104	; 0x68
 800aec2:	f000 f9a9 	bl	800b218 <d_call_offset>
 800aec6:	4603      	mov	r3, r0
 800aec8:	2b00      	cmp	r3, #0
 800aeca:	d102      	bne.n	800aed2 <d_special_name+0x1d6>
 800aecc:	f04f 0300 	mov.w	r3, #0
 800aed0:	e19d      	b.n	800b20e <d_special_name+0x512>
 800aed2:	6878      	ldr	r0, [r7, #4]
 800aed4:	f04f 0100 	mov.w	r1, #0
 800aed8:	f7ff f9ca 	bl	800a270 <d_encoding>
 800aedc:	4603      	mov	r3, r0
 800aede:	6878      	ldr	r0, [r7, #4]
 800aee0:	f04f 010f 	mov.w	r1, #15
 800aee4:	461a      	mov	r2, r3
 800aee6:	f04f 0300 	mov.w	r3, #0
 800aeea:	f7fe fe7b 	bl	8009be4 <d_make_comp>
 800aeee:	4603      	mov	r3, r0
 800aef0:	e18d      	b.n	800b20e <d_special_name+0x512>
 800aef2:	6878      	ldr	r0, [r7, #4]
 800aef4:	f04f 0176 	mov.w	r1, #118	; 0x76
 800aef8:	f000 f98e 	bl	800b218 <d_call_offset>
 800aefc:	4603      	mov	r3, r0
 800aefe:	2b00      	cmp	r3, #0
 800af00:	d102      	bne.n	800af08 <d_special_name+0x20c>
 800af02:	f04f 0300 	mov.w	r3, #0
 800af06:	e182      	b.n	800b20e <d_special_name+0x512>
 800af08:	6878      	ldr	r0, [r7, #4]
 800af0a:	f04f 0100 	mov.w	r1, #0
 800af0e:	f7ff f9af 	bl	800a270 <d_encoding>
 800af12:	4603      	mov	r3, r0
 800af14:	6878      	ldr	r0, [r7, #4]
 800af16:	f04f 0110 	mov.w	r1, #16
 800af1a:	461a      	mov	r2, r3
 800af1c:	f04f 0300 	mov.w	r3, #0
 800af20:	f7fe fe60 	bl	8009be4 <d_make_comp>
 800af24:	4603      	mov	r3, r0
 800af26:	e172      	b.n	800b20e <d_special_name+0x512>
 800af28:	6878      	ldr	r0, [r7, #4]
 800af2a:	f04f 0100 	mov.w	r1, #0
 800af2e:	f000 f973 	bl	800b218 <d_call_offset>
 800af32:	4603      	mov	r3, r0
 800af34:	2b00      	cmp	r3, #0
 800af36:	d102      	bne.n	800af3e <d_special_name+0x242>
 800af38:	f04f 0300 	mov.w	r3, #0
 800af3c:	e167      	b.n	800b20e <d_special_name+0x512>
 800af3e:	6878      	ldr	r0, [r7, #4]
 800af40:	f04f 0100 	mov.w	r1, #0
 800af44:	f000 f968 	bl	800b218 <d_call_offset>
 800af48:	4603      	mov	r3, r0
 800af4a:	2b00      	cmp	r3, #0
 800af4c:	d102      	bne.n	800af54 <d_special_name+0x258>
 800af4e:	f04f 0300 	mov.w	r3, #0
 800af52:	e15c      	b.n	800b20e <d_special_name+0x512>
 800af54:	6878      	ldr	r0, [r7, #4]
 800af56:	f04f 0100 	mov.w	r1, #0
 800af5a:	f7ff f989 	bl	800a270 <d_encoding>
 800af5e:	4603      	mov	r3, r0
 800af60:	6878      	ldr	r0, [r7, #4]
 800af62:	f04f 0111 	mov.w	r1, #17
 800af66:	461a      	mov	r2, r3
 800af68:	f04f 0300 	mov.w	r3, #0
 800af6c:	f7fe fe3a 	bl	8009be4 <d_make_comp>
 800af70:	4603      	mov	r3, r0
 800af72:	e14c      	b.n	800b20e <d_special_name+0x512>
 800af74:	6878      	ldr	r0, [r7, #4]
 800af76:	f000 fa55 	bl	800b424 <d_type>
 800af7a:	6178      	str	r0, [r7, #20]
 800af7c:	6878      	ldr	r0, [r7, #4]
 800af7e:	f7ff fc4d 	bl	800a81c <d_number>
 800af82:	6138      	str	r0, [r7, #16]
 800af84:	693b      	ldr	r3, [r7, #16]
 800af86:	2b00      	cmp	r3, #0
 800af88:	da02      	bge.n	800af90 <d_special_name+0x294>
 800af8a:	f04f 0300 	mov.w	r3, #0
 800af8e:	e13e      	b.n	800b20e <d_special_name+0x512>
 800af90:	687b      	ldr	r3, [r7, #4]
 800af92:	68db      	ldr	r3, [r3, #12]
 800af94:	781b      	ldrb	r3, [r3, #0]
 800af96:	2b5f      	cmp	r3, #95	; 0x5f
 800af98:	d108      	bne.n	800afac <d_special_name+0x2b0>
 800af9a:	687b      	ldr	r3, [r7, #4]
 800af9c:	68db      	ldr	r3, [r3, #12]
 800af9e:	f103 0201 	add.w	r2, r3, #1
 800afa2:	687b      	ldr	r3, [r7, #4]
 800afa4:	60da      	str	r2, [r3, #12]
 800afa6:	f04f 0300 	mov.w	r3, #0
 800afaa:	e001      	b.n	800afb0 <d_special_name+0x2b4>
 800afac:	f04f 0301 	mov.w	r3, #1
 800afb0:	2b00      	cmp	r3, #0
 800afb2:	d002      	beq.n	800afba <d_special_name+0x2be>
 800afb4:	f04f 0300 	mov.w	r3, #0
 800afb8:	e129      	b.n	800b20e <d_special_name+0x512>
 800afba:	6878      	ldr	r0, [r7, #4]
 800afbc:	f000 fa32 	bl	800b424 <d_type>
 800afc0:	60f8      	str	r0, [r7, #12]
 800afc2:	687b      	ldr	r3, [r7, #4]
 800afc4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800afc6:	f103 0205 	add.w	r2, r3, #5
 800afca:	687b      	ldr	r3, [r7, #4]
 800afcc:	631a      	str	r2, [r3, #48]	; 0x30
 800afce:	6878      	ldr	r0, [r7, #4]
 800afd0:	f04f 010b 	mov.w	r1, #11
 800afd4:	68fa      	ldr	r2, [r7, #12]
 800afd6:	697b      	ldr	r3, [r7, #20]
 800afd8:	f7fe fe04 	bl	8009be4 <d_make_comp>
 800afdc:	4603      	mov	r3, r0
 800afde:	e116      	b.n	800b20e <d_special_name+0x512>
 800afe0:	6878      	ldr	r0, [r7, #4]
 800afe2:	f000 fa1f 	bl	800b424 <d_type>
 800afe6:	4603      	mov	r3, r0
 800afe8:	6878      	ldr	r0, [r7, #4]
 800afea:	f04f 010e 	mov.w	r1, #14
 800afee:	461a      	mov	r2, r3
 800aff0:	f04f 0300 	mov.w	r3, #0
 800aff4:	f7fe fdf6 	bl	8009be4 <d_make_comp>
 800aff8:	4603      	mov	r3, r0
 800affa:	e108      	b.n	800b20e <d_special_name+0x512>
 800affc:	6878      	ldr	r0, [r7, #4]
 800affe:	f000 fa11 	bl	800b424 <d_type>
 800b002:	4603      	mov	r3, r0
 800b004:	6878      	ldr	r0, [r7, #4]
 800b006:	f04f 0112 	mov.w	r1, #18
 800b00a:	461a      	mov	r2, r3
 800b00c:	f04f 0300 	mov.w	r3, #0
 800b010:	f7fe fde8 	bl	8009be4 <d_make_comp>
 800b014:	4603      	mov	r3, r0
 800b016:	e0fa      	b.n	800b20e <d_special_name+0x512>
 800b018:	f04f 0300 	mov.w	r3, #0
 800b01c:	e0f7      	b.n	800b20e <d_special_name+0x512>
 800b01e:	687b      	ldr	r3, [r7, #4]
 800b020:	68db      	ldr	r3, [r3, #12]
 800b022:	781b      	ldrb	r3, [r3, #0]
 800b024:	2b47      	cmp	r3, #71	; 0x47
 800b026:	d108      	bne.n	800b03a <d_special_name+0x33e>
 800b028:	687b      	ldr	r3, [r7, #4]
 800b02a:	68db      	ldr	r3, [r3, #12]
 800b02c:	f103 0201 	add.w	r2, r3, #1
 800b030:	687b      	ldr	r3, [r7, #4]
 800b032:	60da      	str	r2, [r3, #12]
 800b034:	f04f 0301 	mov.w	r3, #1
 800b038:	e001      	b.n	800b03e <d_special_name+0x342>
 800b03a:	f04f 0300 	mov.w	r3, #0
 800b03e:	2b00      	cmp	r3, #0
 800b040:	f000 80e3 	beq.w	800b20a <d_special_name+0x50e>
 800b044:	687b      	ldr	r3, [r7, #4]
 800b046:	68db      	ldr	r3, [r3, #12]
 800b048:	781b      	ldrb	r3, [r3, #0]
 800b04a:	2b00      	cmp	r3, #0
 800b04c:	d007      	beq.n	800b05e <d_special_name+0x362>
 800b04e:	687b      	ldr	r3, [r7, #4]
 800b050:	68da      	ldr	r2, [r3, #12]
 800b052:	7813      	ldrb	r3, [r2, #0]
 800b054:	f102 0101 	add.w	r1, r2, #1
 800b058:	687a      	ldr	r2, [r7, #4]
 800b05a:	60d1      	str	r1, [r2, #12]
 800b05c:	e001      	b.n	800b062 <d_special_name+0x366>
 800b05e:	f04f 0300 	mov.w	r3, #0
 800b062:	f1a3 0341 	sub.w	r3, r3, #65	; 0x41
 800b066:	2b31      	cmp	r3, #49	; 0x31
 800b068:	f200 80cc 	bhi.w	800b204 <d_special_name+0x508>
 800b06c:	a201      	add	r2, pc, #4	; (adr r2, 800b074 <d_special_name+0x378>)
 800b06e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b072:	bf00      	nop
 800b074:	0800b179 	.word	0x0800b179
 800b078:	0800b205 	.word	0x0800b205
 800b07c:	0800b205 	.word	0x0800b205
 800b080:	0800b205 	.word	0x0800b205
 800b084:	0800b205 	.word	0x0800b205
 800b088:	0800b205 	.word	0x0800b205
 800b08c:	0800b205 	.word	0x0800b205
 800b090:	0800b205 	.word	0x0800b205
 800b094:	0800b205 	.word	0x0800b205
 800b098:	0800b205 	.word	0x0800b205
 800b09c:	0800b205 	.word	0x0800b205
 800b0a0:	0800b205 	.word	0x0800b205
 800b0a4:	0800b205 	.word	0x0800b205
 800b0a8:	0800b205 	.word	0x0800b205
 800b0ac:	0800b205 	.word	0x0800b205
 800b0b0:	0800b205 	.word	0x0800b205
 800b0b4:	0800b205 	.word	0x0800b205
 800b0b8:	0800b159 	.word	0x0800b159
 800b0bc:	0800b205 	.word	0x0800b205
 800b0c0:	0800b199 	.word	0x0800b199
 800b0c4:	0800b205 	.word	0x0800b205
 800b0c8:	0800b13d 	.word	0x0800b13d
 800b0cc:	0800b205 	.word	0x0800b205
 800b0d0:	0800b205 	.word	0x0800b205
 800b0d4:	0800b205 	.word	0x0800b205
 800b0d8:	0800b205 	.word	0x0800b205
 800b0dc:	0800b205 	.word	0x0800b205
 800b0e0:	0800b205 	.word	0x0800b205
 800b0e4:	0800b205 	.word	0x0800b205
 800b0e8:	0800b205 	.word	0x0800b205
 800b0ec:	0800b205 	.word	0x0800b205
 800b0f0:	0800b205 	.word	0x0800b205
 800b0f4:	0800b205 	.word	0x0800b205
 800b0f8:	0800b205 	.word	0x0800b205
 800b0fc:	0800b205 	.word	0x0800b205
 800b100:	0800b205 	.word	0x0800b205
 800b104:	0800b205 	.word	0x0800b205
 800b108:	0800b205 	.word	0x0800b205
 800b10c:	0800b205 	.word	0x0800b205
 800b110:	0800b205 	.word	0x0800b205
 800b114:	0800b205 	.word	0x0800b205
 800b118:	0800b205 	.word	0x0800b205
 800b11c:	0800b205 	.word	0x0800b205
 800b120:	0800b205 	.word	0x0800b205
 800b124:	0800b205 	.word	0x0800b205
 800b128:	0800b205 	.word	0x0800b205
 800b12c:	0800b205 	.word	0x0800b205
 800b130:	0800b205 	.word	0x0800b205
 800b134:	0800b205 	.word	0x0800b205
 800b138:	0800b1fb 	.word	0x0800b1fb
 800b13c:	6878      	ldr	r0, [r7, #4]
 800b13e:	f7ff f90b 	bl	800a358 <d_name>
 800b142:	4603      	mov	r3, r0
 800b144:	6878      	ldr	r0, [r7, #4]
 800b146:	f04f 0113 	mov.w	r1, #19
 800b14a:	461a      	mov	r2, r3
 800b14c:	f04f 0300 	mov.w	r3, #0
 800b150:	f7fe fd48 	bl	8009be4 <d_make_comp>
 800b154:	4603      	mov	r3, r0
 800b156:	e05a      	b.n	800b20e <d_special_name+0x512>
 800b158:	6878      	ldr	r0, [r7, #4]
 800b15a:	f7ff f8fd 	bl	800a358 <d_name>
 800b15e:	60b8      	str	r0, [r7, #8]
 800b160:	6878      	ldr	r0, [r7, #4]
 800b162:	f7ff fba7 	bl	800a8b4 <d_number_component>
 800b166:	4603      	mov	r3, r0
 800b168:	6878      	ldr	r0, [r7, #4]
 800b16a:	f04f 0114 	mov.w	r1, #20
 800b16e:	68ba      	ldr	r2, [r7, #8]
 800b170:	f7fe fd38 	bl	8009be4 <d_make_comp>
 800b174:	4603      	mov	r3, r0
 800b176:	e04a      	b.n	800b20e <d_special_name+0x512>
 800b178:	6878      	ldr	r0, [r7, #4]
 800b17a:	f04f 0100 	mov.w	r1, #0
 800b17e:	f7ff f877 	bl	800a270 <d_encoding>
 800b182:	4603      	mov	r3, r0
 800b184:	6878      	ldr	r0, [r7, #4]
 800b186:	f04f 0115 	mov.w	r1, #21
 800b18a:	461a      	mov	r2, r3
 800b18c:	f04f 0300 	mov.w	r3, #0
 800b190:	f7fe fd28 	bl	8009be4 <d_make_comp>
 800b194:	4603      	mov	r3, r0
 800b196:	e03a      	b.n	800b20e <d_special_name+0x512>
 800b198:	687b      	ldr	r3, [r7, #4]
 800b19a:	68db      	ldr	r3, [r3, #12]
 800b19c:	781b      	ldrb	r3, [r3, #0]
 800b19e:	2b00      	cmp	r3, #0
 800b1a0:	d007      	beq.n	800b1b2 <d_special_name+0x4b6>
 800b1a2:	687b      	ldr	r3, [r7, #4]
 800b1a4:	68da      	ldr	r2, [r3, #12]
 800b1a6:	7813      	ldrb	r3, [r2, #0]
 800b1a8:	f102 0101 	add.w	r1, r2, #1
 800b1ac:	687a      	ldr	r2, [r7, #4]
 800b1ae:	60d1      	str	r1, [r2, #12]
 800b1b0:	e001      	b.n	800b1b6 <d_special_name+0x4ba>
 800b1b2:	f04f 0300 	mov.w	r3, #0
 800b1b6:	2b6e      	cmp	r3, #110	; 0x6e
 800b1b8:	d10f      	bne.n	800b1da <d_special_name+0x4de>
 800b1ba:	6878      	ldr	r0, [r7, #4]
 800b1bc:	f04f 0100 	mov.w	r1, #0
 800b1c0:	f7ff f856 	bl	800a270 <d_encoding>
 800b1c4:	4603      	mov	r3, r0
 800b1c6:	6878      	ldr	r0, [r7, #4]
 800b1c8:	f04f 0144 	mov.w	r1, #68	; 0x44
 800b1cc:	461a      	mov	r2, r3
 800b1ce:	f04f 0300 	mov.w	r3, #0
 800b1d2:	f7fe fd07 	bl	8009be4 <d_make_comp>
 800b1d6:	4603      	mov	r3, r0
 800b1d8:	e019      	b.n	800b20e <d_special_name+0x512>
 800b1da:	6878      	ldr	r0, [r7, #4]
 800b1dc:	f04f 0100 	mov.w	r1, #0
 800b1e0:	f7ff f846 	bl	800a270 <d_encoding>
 800b1e4:	4603      	mov	r3, r0
 800b1e6:	6878      	ldr	r0, [r7, #4]
 800b1e8:	f04f 0143 	mov.w	r1, #67	; 0x43
 800b1ec:	461a      	mov	r2, r3
 800b1ee:	f04f 0300 	mov.w	r3, #0
 800b1f2:	f7fe fcf7 	bl	8009be4 <d_make_comp>
 800b1f6:	4603      	mov	r3, r0
 800b1f8:	e009      	b.n	800b20e <d_special_name+0x512>
 800b1fa:	6878      	ldr	r0, [r7, #4]
 800b1fc:	f7ff fca6 	bl	800ab4c <d_java_resource>
 800b200:	4603      	mov	r3, r0
 800b202:	e004      	b.n	800b20e <d_special_name+0x512>
 800b204:	f04f 0300 	mov.w	r3, #0
 800b208:	e001      	b.n	800b20e <d_special_name+0x512>
 800b20a:	f04f 0300 	mov.w	r3, #0
 800b20e:	4618      	mov	r0, r3
 800b210:	f107 0718 	add.w	r7, r7, #24
 800b214:	46bd      	mov	sp, r7
 800b216:	bd80      	pop	{r7, pc}

0800b218 <d_call_offset>:
 800b218:	b580      	push	{r7, lr}
 800b21a:	b082      	sub	sp, #8
 800b21c:	af00      	add	r7, sp, #0
 800b21e:	6078      	str	r0, [r7, #4]
 800b220:	6039      	str	r1, [r7, #0]
 800b222:	683b      	ldr	r3, [r7, #0]
 800b224:	2b00      	cmp	r3, #0
 800b226:	d10f      	bne.n	800b248 <d_call_offset+0x30>
 800b228:	687b      	ldr	r3, [r7, #4]
 800b22a:	68db      	ldr	r3, [r3, #12]
 800b22c:	781b      	ldrb	r3, [r3, #0]
 800b22e:	2b00      	cmp	r3, #0
 800b230:	d007      	beq.n	800b242 <d_call_offset+0x2a>
 800b232:	687b      	ldr	r3, [r7, #4]
 800b234:	68da      	ldr	r2, [r3, #12]
 800b236:	7813      	ldrb	r3, [r2, #0]
 800b238:	f102 0101 	add.w	r1, r2, #1
 800b23c:	687a      	ldr	r2, [r7, #4]
 800b23e:	60d1      	str	r1, [r2, #12]
 800b240:	e001      	b.n	800b246 <d_call_offset+0x2e>
 800b242:	f04f 0300 	mov.w	r3, #0
 800b246:	603b      	str	r3, [r7, #0]
 800b248:	683b      	ldr	r3, [r7, #0]
 800b24a:	2b68      	cmp	r3, #104	; 0x68
 800b24c:	d103      	bne.n	800b256 <d_call_offset+0x3e>
 800b24e:	6878      	ldr	r0, [r7, #4]
 800b250:	f7ff fae4 	bl	800a81c <d_number>
 800b254:	e021      	b.n	800b29a <d_call_offset+0x82>
 800b256:	683b      	ldr	r3, [r7, #0]
 800b258:	2b76      	cmp	r3, #118	; 0x76
 800b25a:	d11b      	bne.n	800b294 <d_call_offset+0x7c>
 800b25c:	6878      	ldr	r0, [r7, #4]
 800b25e:	f7ff fadd 	bl	800a81c <d_number>
 800b262:	687b      	ldr	r3, [r7, #4]
 800b264:	68db      	ldr	r3, [r3, #12]
 800b266:	781b      	ldrb	r3, [r3, #0]
 800b268:	2b5f      	cmp	r3, #95	; 0x5f
 800b26a:	d108      	bne.n	800b27e <d_call_offset+0x66>
 800b26c:	687b      	ldr	r3, [r7, #4]
 800b26e:	68db      	ldr	r3, [r3, #12]
 800b270:	f103 0201 	add.w	r2, r3, #1
 800b274:	687b      	ldr	r3, [r7, #4]
 800b276:	60da      	str	r2, [r3, #12]
 800b278:	f04f 0300 	mov.w	r3, #0
 800b27c:	e001      	b.n	800b282 <d_call_offset+0x6a>
 800b27e:	f04f 0301 	mov.w	r3, #1
 800b282:	2b00      	cmp	r3, #0
 800b284:	d002      	beq.n	800b28c <d_call_offset+0x74>
 800b286:	f04f 0300 	mov.w	r3, #0
 800b28a:	e01d      	b.n	800b2c8 <d_call_offset+0xb0>
 800b28c:	6878      	ldr	r0, [r7, #4]
 800b28e:	f7ff fac5 	bl	800a81c <d_number>
 800b292:	e002      	b.n	800b29a <d_call_offset+0x82>
 800b294:	f04f 0300 	mov.w	r3, #0
 800b298:	e016      	b.n	800b2c8 <d_call_offset+0xb0>
 800b29a:	687b      	ldr	r3, [r7, #4]
 800b29c:	68db      	ldr	r3, [r3, #12]
 800b29e:	781b      	ldrb	r3, [r3, #0]
 800b2a0:	2b5f      	cmp	r3, #95	; 0x5f
 800b2a2:	d108      	bne.n	800b2b6 <d_call_offset+0x9e>
 800b2a4:	687b      	ldr	r3, [r7, #4]
 800b2a6:	68db      	ldr	r3, [r3, #12]
 800b2a8:	f103 0201 	add.w	r2, r3, #1
 800b2ac:	687b      	ldr	r3, [r7, #4]
 800b2ae:	60da      	str	r2, [r3, #12]
 800b2b0:	f04f 0300 	mov.w	r3, #0
 800b2b4:	e001      	b.n	800b2ba <d_call_offset+0xa2>
 800b2b6:	f04f 0301 	mov.w	r3, #1
 800b2ba:	2b00      	cmp	r3, #0
 800b2bc:	d002      	beq.n	800b2c4 <d_call_offset+0xac>
 800b2be:	f04f 0300 	mov.w	r3, #0
 800b2c2:	e001      	b.n	800b2c8 <d_call_offset+0xb0>
 800b2c4:	f04f 0301 	mov.w	r3, #1
 800b2c8:	4618      	mov	r0, r3
 800b2ca:	f107 0708 	add.w	r7, r7, #8
 800b2ce:	46bd      	mov	sp, r7
 800b2d0:	bd80      	pop	{r7, pc}
 800b2d2:	bf00      	nop

0800b2d4 <d_ctor_dtor_name>:
 800b2d4:	b580      	push	{r7, lr}
 800b2d6:	b084      	sub	sp, #16
 800b2d8:	af00      	add	r7, sp, #0
 800b2da:	6078      	str	r0, [r7, #4]
 800b2dc:	687b      	ldr	r3, [r7, #4]
 800b2de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b2e0:	2b00      	cmp	r3, #0
 800b2e2:	d01a      	beq.n	800b31a <d_ctor_dtor_name+0x46>
 800b2e4:	687b      	ldr	r3, [r7, #4]
 800b2e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b2e8:	781b      	ldrb	r3, [r3, #0]
 800b2ea:	2b00      	cmp	r3, #0
 800b2ec:	d108      	bne.n	800b300 <d_ctor_dtor_name+0x2c>
 800b2ee:	687b      	ldr	r3, [r7, #4]
 800b2f0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800b2f2:	687b      	ldr	r3, [r7, #4]
 800b2f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b2f6:	689b      	ldr	r3, [r3, #8]
 800b2f8:	18d2      	adds	r2, r2, r3
 800b2fa:	687b      	ldr	r3, [r7, #4]
 800b2fc:	631a      	str	r2, [r3, #48]	; 0x30
 800b2fe:	e00c      	b.n	800b31a <d_ctor_dtor_name+0x46>
 800b300:	687b      	ldr	r3, [r7, #4]
 800b302:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b304:	781b      	ldrb	r3, [r3, #0]
 800b306:	2b16      	cmp	r3, #22
 800b308:	d107      	bne.n	800b31a <d_ctor_dtor_name+0x46>
 800b30a:	687b      	ldr	r3, [r7, #4]
 800b30c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800b30e:	687b      	ldr	r3, [r7, #4]
 800b310:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b312:	689b      	ldr	r3, [r3, #8]
 800b314:	18d2      	adds	r2, r2, r3
 800b316:	687b      	ldr	r3, [r7, #4]
 800b318:	631a      	str	r2, [r3, #48]	; 0x30
 800b31a:	687b      	ldr	r3, [r7, #4]
 800b31c:	68db      	ldr	r3, [r3, #12]
 800b31e:	781b      	ldrb	r3, [r3, #0]
 800b320:	2b43      	cmp	r3, #67	; 0x43
 800b322:	d002      	beq.n	800b32a <d_ctor_dtor_name+0x56>
 800b324:	2b44      	cmp	r3, #68	; 0x44
 800b326:	d03a      	beq.n	800b39e <d_ctor_dtor_name+0xca>
 800b328:	e075      	b.n	800b416 <d_ctor_dtor_name+0x142>
 800b32a:	687b      	ldr	r3, [r7, #4]
 800b32c:	68db      	ldr	r3, [r3, #12]
 800b32e:	f103 0301 	add.w	r3, r3, #1
 800b332:	781b      	ldrb	r3, [r3, #0]
 800b334:	f1a3 0331 	sub.w	r3, r3, #49	; 0x31
 800b338:	2b04      	cmp	r3, #4
 800b33a:	d81d      	bhi.n	800b378 <d_ctor_dtor_name+0xa4>
 800b33c:	a201      	add	r2, pc, #4	; (adr r2, 800b344 <d_ctor_dtor_name+0x70>)
 800b33e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b342:	bf00      	nop
 800b344:	0800b359 	.word	0x0800b359
 800b348:	0800b361 	.word	0x0800b361
 800b34c:	0800b369 	.word	0x0800b369
 800b350:	0800b379 	.word	0x0800b379
 800b354:	0800b371 	.word	0x0800b371
 800b358:	f04f 0301 	mov.w	r3, #1
 800b35c:	73fb      	strb	r3, [r7, #15]
 800b35e:	e00e      	b.n	800b37e <d_ctor_dtor_name+0xaa>
 800b360:	f04f 0302 	mov.w	r3, #2
 800b364:	73fb      	strb	r3, [r7, #15]
 800b366:	e00a      	b.n	800b37e <d_ctor_dtor_name+0xaa>
 800b368:	f04f 0303 	mov.w	r3, #3
 800b36c:	73fb      	strb	r3, [r7, #15]
 800b36e:	e006      	b.n	800b37e <d_ctor_dtor_name+0xaa>
 800b370:	f04f 0304 	mov.w	r3, #4
 800b374:	73fb      	strb	r3, [r7, #15]
 800b376:	e002      	b.n	800b37e <d_ctor_dtor_name+0xaa>
 800b378:	f04f 0300 	mov.w	r3, #0
 800b37c:	e04d      	b.n	800b41a <d_ctor_dtor_name+0x146>
 800b37e:	687b      	ldr	r3, [r7, #4]
 800b380:	68db      	ldr	r3, [r3, #12]
 800b382:	f103 0202 	add.w	r2, r3, #2
 800b386:	687b      	ldr	r3, [r7, #4]
 800b388:	60da      	str	r2, [r3, #12]
 800b38a:	687b      	ldr	r3, [r7, #4]
 800b38c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b38e:	7bfa      	ldrb	r2, [r7, #15]
 800b390:	6878      	ldr	r0, [r7, #4]
 800b392:	4611      	mov	r1, r2
 800b394:	461a      	mov	r2, r3
 800b396:	f7fe fdb7 	bl	8009f08 <d_make_ctor>
 800b39a:	4603      	mov	r3, r0
 800b39c:	e03d      	b.n	800b41a <d_ctor_dtor_name+0x146>
 800b39e:	687b      	ldr	r3, [r7, #4]
 800b3a0:	68db      	ldr	r3, [r3, #12]
 800b3a2:	f103 0301 	add.w	r3, r3, #1
 800b3a6:	781b      	ldrb	r3, [r3, #0]
 800b3a8:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 800b3ac:	2b05      	cmp	r3, #5
 800b3ae:	d81f      	bhi.n	800b3f0 <d_ctor_dtor_name+0x11c>
 800b3b0:	a201      	add	r2, pc, #4	; (adr r2, 800b3b8 <d_ctor_dtor_name+0xe4>)
 800b3b2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b3b6:	bf00      	nop
 800b3b8:	0800b3d1 	.word	0x0800b3d1
 800b3bc:	0800b3d9 	.word	0x0800b3d9
 800b3c0:	0800b3e1 	.word	0x0800b3e1
 800b3c4:	0800b3f1 	.word	0x0800b3f1
 800b3c8:	0800b3f1 	.word	0x0800b3f1
 800b3cc:	0800b3e9 	.word	0x0800b3e9
 800b3d0:	f04f 0301 	mov.w	r3, #1
 800b3d4:	73bb      	strb	r3, [r7, #14]
 800b3d6:	e00e      	b.n	800b3f6 <d_ctor_dtor_name+0x122>
 800b3d8:	f04f 0302 	mov.w	r3, #2
 800b3dc:	73bb      	strb	r3, [r7, #14]
 800b3de:	e00a      	b.n	800b3f6 <d_ctor_dtor_name+0x122>
 800b3e0:	f04f 0303 	mov.w	r3, #3
 800b3e4:	73bb      	strb	r3, [r7, #14]
 800b3e6:	e006      	b.n	800b3f6 <d_ctor_dtor_name+0x122>
 800b3e8:	f04f 0304 	mov.w	r3, #4
 800b3ec:	73bb      	strb	r3, [r7, #14]
 800b3ee:	e002      	b.n	800b3f6 <d_ctor_dtor_name+0x122>
 800b3f0:	f04f 0300 	mov.w	r3, #0
 800b3f4:	e011      	b.n	800b41a <d_ctor_dtor_name+0x146>
 800b3f6:	687b      	ldr	r3, [r7, #4]
 800b3f8:	68db      	ldr	r3, [r3, #12]
 800b3fa:	f103 0202 	add.w	r2, r3, #2
 800b3fe:	687b      	ldr	r3, [r7, #4]
 800b400:	60da      	str	r2, [r3, #12]
 800b402:	687b      	ldr	r3, [r7, #4]
 800b404:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b406:	7bba      	ldrb	r2, [r7, #14]
 800b408:	6878      	ldr	r0, [r7, #4]
 800b40a:	4611      	mov	r1, r2
 800b40c:	461a      	mov	r2, r3
 800b40e:	f7fe fd99 	bl	8009f44 <d_make_dtor>
 800b412:	4603      	mov	r3, r0
 800b414:	e001      	b.n	800b41a <d_ctor_dtor_name+0x146>
 800b416:	f04f 0300 	mov.w	r3, #0
 800b41a:	4618      	mov	r0, r3
 800b41c:	f107 0710 	add.w	r7, r7, #16
 800b420:	46bd      	mov	sp, r7
 800b422:	bd80      	pop	{r7, pc}

0800b424 <d_type>:
 800b424:	b590      	push	{r4, r7, lr}
 800b426:	b087      	sub	sp, #28
 800b428:	af00      	add	r7, sp, #0
 800b42a:	6078      	str	r0, [r7, #4]
 800b42c:	687b      	ldr	r3, [r7, #4]
 800b42e:	68db      	ldr	r3, [r3, #12]
 800b430:	781b      	ldrb	r3, [r3, #0]
 800b432:	74fb      	strb	r3, [r7, #19]
 800b434:	7cfb      	ldrb	r3, [r7, #19]
 800b436:	2b72      	cmp	r3, #114	; 0x72
 800b438:	d005      	beq.n	800b446 <d_type+0x22>
 800b43a:	7cfb      	ldrb	r3, [r7, #19]
 800b43c:	2b56      	cmp	r3, #86	; 0x56
 800b43e:	d002      	beq.n	800b446 <d_type+0x22>
 800b440:	7cfb      	ldrb	r3, [r7, #19]
 800b442:	2b4b      	cmp	r3, #75	; 0x4b
 800b444:	d125      	bne.n	800b492 <d_type+0x6e>
 800b446:	f107 0308 	add.w	r3, r7, #8
 800b44a:	6878      	ldr	r0, [r7, #4]
 800b44c:	4619      	mov	r1, r3
 800b44e:	f04f 0200 	mov.w	r2, #0
 800b452:	f000 fbb3 	bl	800bbbc <d_cv_qualifiers>
 800b456:	60f8      	str	r0, [r7, #12]
 800b458:	68fb      	ldr	r3, [r7, #12]
 800b45a:	2b00      	cmp	r3, #0
 800b45c:	d102      	bne.n	800b464 <d_type+0x40>
 800b45e:	f04f 0300 	mov.w	r3, #0
 800b462:	e397      	b.n	800bb94 <d_type+0x770>
 800b464:	6878      	ldr	r0, [r7, #4]
 800b466:	f7ff ffdd 	bl	800b424 <d_type>
 800b46a:	4602      	mov	r2, r0
 800b46c:	68fb      	ldr	r3, [r7, #12]
 800b46e:	601a      	str	r2, [r3, #0]
 800b470:	68fb      	ldr	r3, [r7, #12]
 800b472:	681b      	ldr	r3, [r3, #0]
 800b474:	2b00      	cmp	r3, #0
 800b476:	d007      	beq.n	800b488 <d_type+0x64>
 800b478:	68bb      	ldr	r3, [r7, #8]
 800b47a:	6878      	ldr	r0, [r7, #4]
 800b47c:	4619      	mov	r1, r3
 800b47e:	f001 fd31 	bl	800cee4 <d_add_substitution>
 800b482:	4603      	mov	r3, r0
 800b484:	2b00      	cmp	r3, #0
 800b486:	d102      	bne.n	800b48e <d_type+0x6a>
 800b488:	f04f 0300 	mov.w	r3, #0
 800b48c:	e382      	b.n	800bb94 <d_type+0x770>
 800b48e:	68bb      	ldr	r3, [r7, #8]
 800b490:	e380      	b.n	800bb94 <d_type+0x770>
 800b492:	f04f 0301 	mov.w	r3, #1
 800b496:	617b      	str	r3, [r7, #20]
 800b498:	7cfb      	ldrb	r3, [r7, #19]
 800b49a:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 800b49e:	2b4a      	cmp	r3, #74	; 0x4a
 800b4a0:	f200 8363 	bhi.w	800bb6a <d_type+0x746>
 800b4a4:	a201      	add	r2, pc, #4	; (adr r2, 800b4ac <d_type+0x88>)
 800b4a6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b4aa:	bf00      	nop
 800b4ac:	0800b65b 	.word	0x0800b65b
 800b4b0:	0800b65b 	.word	0x0800b65b
 800b4b4:	0800b65b 	.word	0x0800b65b
 800b4b8:	0800b65b 	.word	0x0800b65b
 800b4bc:	0800b65b 	.word	0x0800b65b
 800b4c0:	0800b65b 	.word	0x0800b65b
 800b4c4:	0800b65b 	.word	0x0800b65b
 800b4c8:	0800b65b 	.word	0x0800b65b
 800b4cc:	0800b65b 	.word	0x0800b65b
 800b4d0:	0800b65b 	.word	0x0800b65b
 800b4d4:	0800bb6b 	.word	0x0800bb6b
 800b4d8:	0800bb6b 	.word	0x0800bb6b
 800b4dc:	0800bb6b 	.word	0x0800bb6b
 800b4e0:	0800bb6b 	.word	0x0800bb6b
 800b4e4:	0800bb6b 	.word	0x0800bb6b
 800b4e8:	0800bb6b 	.word	0x0800bb6b
 800b4ec:	0800bb6b 	.word	0x0800bb6b
 800b4f0:	0800b667 	.word	0x0800b667
 800b4f4:	0800bb6b 	.word	0x0800bb6b
 800b4f8:	0800b7cd 	.word	0x0800b7cd
 800b4fc:	0800b851 	.word	0x0800b851
 800b500:	0800bb6b 	.word	0x0800bb6b
 800b504:	0800b64f 	.word	0x0800b64f
 800b508:	0800b7f7 	.word	0x0800b7f7
 800b50c:	0800bb6b 	.word	0x0800bb6b
 800b510:	0800bb6b 	.word	0x0800bb6b
 800b514:	0800bb6b 	.word	0x0800bb6b
 800b518:	0800bb6b 	.word	0x0800bb6b
 800b51c:	0800bb6b 	.word	0x0800bb6b
 800b520:	0800b673 	.word	0x0800b673
 800b524:	0800b65b 	.word	0x0800b65b
 800b528:	0800b74f 	.word	0x0800b74f
 800b52c:	0800b779 	.word	0x0800b779
 800b530:	0800bb6b 	.word	0x0800bb6b
 800b534:	0800b7a3 	.word	0x0800b7a3
 800b538:	0800b6c7 	.word	0x0800b6c7
 800b53c:	0800b67f 	.word	0x0800b67f
 800b540:	0800b821 	.word	0x0800b821
 800b544:	0800bb6b 	.word	0x0800bb6b
 800b548:	0800bb6b 	.word	0x0800bb6b
 800b54c:	0800bb6b 	.word	0x0800bb6b
 800b550:	0800bb6b 	.word	0x0800bb6b
 800b554:	0800b65b 	.word	0x0800b65b
 800b558:	0800bb6b 	.word	0x0800bb6b
 800b55c:	0800bb6b 	.word	0x0800bb6b
 800b560:	0800bb6b 	.word	0x0800bb6b
 800b564:	0800bb6b 	.word	0x0800bb6b
 800b568:	0800bb6b 	.word	0x0800bb6b
 800b56c:	0800bb6b 	.word	0x0800bb6b
 800b570:	0800b5d9 	.word	0x0800b5d9
 800b574:	0800b5d9 	.word	0x0800b5d9
 800b578:	0800b5d9 	.word	0x0800b5d9
 800b57c:	0800b5d9 	.word	0x0800b5d9
 800b580:	0800b5d9 	.word	0x0800b5d9
 800b584:	0800b5d9 	.word	0x0800b5d9
 800b588:	0800b5d9 	.word	0x0800b5d9
 800b58c:	0800b5d9 	.word	0x0800b5d9
 800b590:	0800b5d9 	.word	0x0800b5d9
 800b594:	0800b5d9 	.word	0x0800b5d9
 800b598:	0800bb6b 	.word	0x0800bb6b
 800b59c:	0800b5d9 	.word	0x0800b5d9
 800b5a0:	0800b5d9 	.word	0x0800b5d9
 800b5a4:	0800b5d9 	.word	0x0800b5d9
 800b5a8:	0800b5d9 	.word	0x0800b5d9
 800b5ac:	0800bb6b 	.word	0x0800bb6b
 800b5b0:	0800bb6b 	.word	0x0800bb6b
 800b5b4:	0800bb6b 	.word	0x0800bb6b
 800b5b8:	0800b5d9 	.word	0x0800b5d9
 800b5bc:	0800b5d9 	.word	0x0800b5d9
 800b5c0:	0800b625 	.word	0x0800b625
 800b5c4:	0800b5d9 	.word	0x0800b5d9
 800b5c8:	0800b5d9 	.word	0x0800b5d9
 800b5cc:	0800b5d9 	.word	0x0800b5d9
 800b5d0:	0800b5d9 	.word	0x0800b5d9
 800b5d4:	0800b5d9 	.word	0x0800b5d9
 800b5d8:	7cfb      	ldrb	r3, [r7, #19]
 800b5da:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
 800b5de:	4613      	mov	r3, r2
 800b5e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b5e4:	189b      	adds	r3, r3, r2
 800b5e6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b5ea:	f24f 2264 	movw	r2, #62052	; 0xf264
 800b5ee:	f6c0 0201 	movt	r2, #2049	; 0x801
 800b5f2:	189b      	adds	r3, r3, r2
 800b5f4:	6878      	ldr	r0, [r7, #4]
 800b5f6:	4619      	mov	r1, r3
 800b5f8:	f7fe fc12 	bl	8009e20 <d_make_builtin_type>
 800b5fc:	4603      	mov	r3, r0
 800b5fe:	60bb      	str	r3, [r7, #8]
 800b600:	687b      	ldr	r3, [r7, #4]
 800b602:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800b604:	68bb      	ldr	r3, [r7, #8]
 800b606:	685b      	ldr	r3, [r3, #4]
 800b608:	685b      	ldr	r3, [r3, #4]
 800b60a:	18d2      	adds	r2, r2, r3
 800b60c:	687b      	ldr	r3, [r7, #4]
 800b60e:	631a      	str	r2, [r3, #48]	; 0x30
 800b610:	f04f 0300 	mov.w	r3, #0
 800b614:	617b      	str	r3, [r7, #20]
 800b616:	687b      	ldr	r3, [r7, #4]
 800b618:	68db      	ldr	r3, [r3, #12]
 800b61a:	f103 0201 	add.w	r2, r3, #1
 800b61e:	687b      	ldr	r3, [r7, #4]
 800b620:	60da      	str	r2, [r3, #12]
 800b622:	e2a8      	b.n	800bb76 <d_type+0x752>
 800b624:	687b      	ldr	r3, [r7, #4]
 800b626:	68db      	ldr	r3, [r3, #12]
 800b628:	f103 0201 	add.w	r2, r3, #1
 800b62c:	687b      	ldr	r3, [r7, #4]
 800b62e:	60da      	str	r2, [r3, #12]
 800b630:	6878      	ldr	r0, [r7, #4]
 800b632:	f7ff f8d7 	bl	800a7e4 <d_source_name>
 800b636:	4603      	mov	r3, r0
 800b638:	6878      	ldr	r0, [r7, #4]
 800b63a:	f04f 0124 	mov.w	r1, #36	; 0x24
 800b63e:	461a      	mov	r2, r3
 800b640:	f04f 0300 	mov.w	r3, #0
 800b644:	f7fe face 	bl	8009be4 <d_make_comp>
 800b648:	4603      	mov	r3, r0
 800b64a:	60bb      	str	r3, [r7, #8]
 800b64c:	e293      	b.n	800bb76 <d_type+0x752>
 800b64e:	6878      	ldr	r0, [r7, #4]
 800b650:	f000 fb56 	bl	800bd00 <d_function_type>
 800b654:	4603      	mov	r3, r0
 800b656:	60bb      	str	r3, [r7, #8]
 800b658:	e28d      	b.n	800bb76 <d_type+0x752>
 800b65a:	6878      	ldr	r0, [r7, #4]
 800b65c:	f000 fc34 	bl	800bec8 <d_class_enum_type>
 800b660:	4603      	mov	r3, r0
 800b662:	60bb      	str	r3, [r7, #8]
 800b664:	e287      	b.n	800bb76 <d_type+0x752>
 800b666:	6878      	ldr	r0, [r7, #4]
 800b668:	f000 fc3c 	bl	800bee4 <d_array_type>
 800b66c:	4603      	mov	r3, r0
 800b66e:	60bb      	str	r3, [r7, #8]
 800b670:	e281      	b.n	800bb76 <d_type+0x752>
 800b672:	6878      	ldr	r0, [r7, #4]
 800b674:	f000 fcfa 	bl	800c06c <d_pointer_to_member_type>
 800b678:	4603      	mov	r3, r0
 800b67a:	60bb      	str	r3, [r7, #8]
 800b67c:	e27b      	b.n	800bb76 <d_type+0x752>
 800b67e:	6878      	ldr	r0, [r7, #4]
 800b680:	f000 fd88 	bl	800c194 <d_template_param>
 800b684:	4603      	mov	r3, r0
 800b686:	60bb      	str	r3, [r7, #8]
 800b688:	687b      	ldr	r3, [r7, #4]
 800b68a:	68db      	ldr	r3, [r3, #12]
 800b68c:	781b      	ldrb	r3, [r3, #0]
 800b68e:	2b49      	cmp	r3, #73	; 0x49
 800b690:	f040 826e 	bne.w	800bb70 <d_type+0x74c>
 800b694:	68bb      	ldr	r3, [r7, #8]
 800b696:	6878      	ldr	r0, [r7, #4]
 800b698:	4619      	mov	r1, r3
 800b69a:	f001 fc23 	bl	800cee4 <d_add_substitution>
 800b69e:	4603      	mov	r3, r0
 800b6a0:	2b00      	cmp	r3, #0
 800b6a2:	d102      	bne.n	800b6aa <d_type+0x286>
 800b6a4:	f04f 0300 	mov.w	r3, #0
 800b6a8:	e274      	b.n	800bb94 <d_type+0x770>
 800b6aa:	68bc      	ldr	r4, [r7, #8]
 800b6ac:	6878      	ldr	r0, [r7, #4]
 800b6ae:	f000 fda5 	bl	800c1fc <d_template_args>
 800b6b2:	4603      	mov	r3, r0
 800b6b4:	6878      	ldr	r0, [r7, #4]
 800b6b6:	f04f 0104 	mov.w	r1, #4
 800b6ba:	4622      	mov	r2, r4
 800b6bc:	f7fe fa92 	bl	8009be4 <d_make_comp>
 800b6c0:	4603      	mov	r3, r0
 800b6c2:	60bb      	str	r3, [r7, #8]
 800b6c4:	e254      	b.n	800bb70 <d_type+0x74c>
 800b6c6:	687b      	ldr	r3, [r7, #4]
 800b6c8:	68db      	ldr	r3, [r3, #12]
 800b6ca:	785b      	ldrb	r3, [r3, #1]
 800b6cc:	74bb      	strb	r3, [r7, #18]
 800b6ce:	7cbb      	ldrb	r3, [r7, #18]
 800b6d0:	2b2f      	cmp	r3, #47	; 0x2f
 800b6d2:	d902      	bls.n	800b6da <d_type+0x2b6>
 800b6d4:	7cbb      	ldrb	r3, [r7, #18]
 800b6d6:	2b39      	cmp	r3, #57	; 0x39
 800b6d8:	d908      	bls.n	800b6ec <d_type+0x2c8>
 800b6da:	7cbb      	ldrb	r3, [r7, #18]
 800b6dc:	2b5f      	cmp	r3, #95	; 0x5f
 800b6de:	d005      	beq.n	800b6ec <d_type+0x2c8>
 800b6e0:	7cbb      	ldrb	r3, [r7, #18]
 800b6e2:	2b40      	cmp	r3, #64	; 0x40
 800b6e4:	d920      	bls.n	800b728 <d_type+0x304>
 800b6e6:	7cbb      	ldrb	r3, [r7, #18]
 800b6e8:	2b5a      	cmp	r3, #90	; 0x5a
 800b6ea:	d81d      	bhi.n	800b728 <d_type+0x304>
 800b6ec:	6878      	ldr	r0, [r7, #4]
 800b6ee:	f04f 0100 	mov.w	r1, #0
 800b6f2:	f001 fc23 	bl	800cf3c <d_substitution>
 800b6f6:	4603      	mov	r3, r0
 800b6f8:	60bb      	str	r3, [r7, #8]
 800b6fa:	687b      	ldr	r3, [r7, #4]
 800b6fc:	68db      	ldr	r3, [r3, #12]
 800b6fe:	781b      	ldrb	r3, [r3, #0]
 800b700:	2b49      	cmp	r3, #73	; 0x49
 800b702:	d10d      	bne.n	800b720 <d_type+0x2fc>
 800b704:	68bc      	ldr	r4, [r7, #8]
 800b706:	6878      	ldr	r0, [r7, #4]
 800b708:	f000 fd78 	bl	800c1fc <d_template_args>
 800b70c:	4603      	mov	r3, r0
 800b70e:	6878      	ldr	r0, [r7, #4]
 800b710:	f04f 0104 	mov.w	r1, #4
 800b714:	4622      	mov	r2, r4
 800b716:	f7fe fa65 	bl	8009be4 <d_make_comp>
 800b71a:	4603      	mov	r3, r0
 800b71c:	60bb      	str	r3, [r7, #8]
 800b71e:	e015      	b.n	800b74c <d_type+0x328>
 800b720:	f04f 0300 	mov.w	r3, #0
 800b724:	617b      	str	r3, [r7, #20]
 800b726:	e011      	b.n	800b74c <d_type+0x328>
 800b728:	6878      	ldr	r0, [r7, #4]
 800b72a:	f000 fbcd 	bl	800bec8 <d_class_enum_type>
 800b72e:	4603      	mov	r3, r0
 800b730:	60bb      	str	r3, [r7, #8]
 800b732:	68bb      	ldr	r3, [r7, #8]
 800b734:	2b00      	cmp	r3, #0
 800b736:	f000 821d 	beq.w	800bb74 <d_type+0x750>
 800b73a:	68bb      	ldr	r3, [r7, #8]
 800b73c:	781b      	ldrb	r3, [r3, #0]
 800b73e:	2b16      	cmp	r3, #22
 800b740:	f040 8218 	bne.w	800bb74 <d_type+0x750>
 800b744:	f04f 0300 	mov.w	r3, #0
 800b748:	617b      	str	r3, [r7, #20]
 800b74a:	e213      	b.n	800bb74 <d_type+0x750>
 800b74c:	e212      	b.n	800bb74 <d_type+0x750>
 800b74e:	687b      	ldr	r3, [r7, #4]
 800b750:	68db      	ldr	r3, [r3, #12]
 800b752:	f103 0201 	add.w	r2, r3, #1
 800b756:	687b      	ldr	r3, [r7, #4]
 800b758:	60da      	str	r2, [r3, #12]
 800b75a:	6878      	ldr	r0, [r7, #4]
 800b75c:	f7ff fe62 	bl	800b424 <d_type>
 800b760:	4603      	mov	r3, r0
 800b762:	6878      	ldr	r0, [r7, #4]
 800b764:	f04f 0120 	mov.w	r1, #32
 800b768:	461a      	mov	r2, r3
 800b76a:	f04f 0300 	mov.w	r3, #0
 800b76e:	f7fe fa39 	bl	8009be4 <d_make_comp>
 800b772:	4603      	mov	r3, r0
 800b774:	60bb      	str	r3, [r7, #8]
 800b776:	e1fe      	b.n	800bb76 <d_type+0x752>
 800b778:	687b      	ldr	r3, [r7, #4]
 800b77a:	68db      	ldr	r3, [r3, #12]
 800b77c:	f103 0201 	add.w	r2, r3, #1
 800b780:	687b      	ldr	r3, [r7, #4]
 800b782:	60da      	str	r2, [r3, #12]
 800b784:	6878      	ldr	r0, [r7, #4]
 800b786:	f7ff fe4d 	bl	800b424 <d_type>
 800b78a:	4603      	mov	r3, r0
 800b78c:	6878      	ldr	r0, [r7, #4]
 800b78e:	f04f 011e 	mov.w	r1, #30
 800b792:	461a      	mov	r2, r3
 800b794:	f04f 0300 	mov.w	r3, #0
 800b798:	f7fe fa24 	bl	8009be4 <d_make_comp>
 800b79c:	4603      	mov	r3, r0
 800b79e:	60bb      	str	r3, [r7, #8]
 800b7a0:	e1e9      	b.n	800bb76 <d_type+0x752>
 800b7a2:	687b      	ldr	r3, [r7, #4]
 800b7a4:	68db      	ldr	r3, [r3, #12]
 800b7a6:	f103 0201 	add.w	r2, r3, #1
 800b7aa:	687b      	ldr	r3, [r7, #4]
 800b7ac:	60da      	str	r2, [r3, #12]
 800b7ae:	6878      	ldr	r0, [r7, #4]
 800b7b0:	f7ff fe38 	bl	800b424 <d_type>
 800b7b4:	4603      	mov	r3, r0
 800b7b6:	6878      	ldr	r0, [r7, #4]
 800b7b8:	f04f 011f 	mov.w	r1, #31
 800b7bc:	461a      	mov	r2, r3
 800b7be:	f04f 0300 	mov.w	r3, #0
 800b7c2:	f7fe fa0f 	bl	8009be4 <d_make_comp>
 800b7c6:	4603      	mov	r3, r0
 800b7c8:	60bb      	str	r3, [r7, #8]
 800b7ca:	e1d4      	b.n	800bb76 <d_type+0x752>
 800b7cc:	687b      	ldr	r3, [r7, #4]
 800b7ce:	68db      	ldr	r3, [r3, #12]
 800b7d0:	f103 0201 	add.w	r2, r3, #1
 800b7d4:	687b      	ldr	r3, [r7, #4]
 800b7d6:	60da      	str	r2, [r3, #12]
 800b7d8:	6878      	ldr	r0, [r7, #4]
 800b7da:	f7ff fe23 	bl	800b424 <d_type>
 800b7de:	4603      	mov	r3, r0
 800b7e0:	6878      	ldr	r0, [r7, #4]
 800b7e2:	f04f 0121 	mov.w	r1, #33	; 0x21
 800b7e6:	461a      	mov	r2, r3
 800b7e8:	f04f 0300 	mov.w	r3, #0
 800b7ec:	f7fe f9fa 	bl	8009be4 <d_make_comp>
 800b7f0:	4603      	mov	r3, r0
 800b7f2:	60bb      	str	r3, [r7, #8]
 800b7f4:	e1bf      	b.n	800bb76 <d_type+0x752>
 800b7f6:	687b      	ldr	r3, [r7, #4]
 800b7f8:	68db      	ldr	r3, [r3, #12]
 800b7fa:	f103 0201 	add.w	r2, r3, #1
 800b7fe:	687b      	ldr	r3, [r7, #4]
 800b800:	60da      	str	r2, [r3, #12]
 800b802:	6878      	ldr	r0, [r7, #4]
 800b804:	f7ff fe0e 	bl	800b424 <d_type>
 800b808:	4603      	mov	r3, r0
 800b80a:	6878      	ldr	r0, [r7, #4]
 800b80c:	f04f 0122 	mov.w	r1, #34	; 0x22
 800b810:	461a      	mov	r2, r3
 800b812:	f04f 0300 	mov.w	r3, #0
 800b816:	f7fe f9e5 	bl	8009be4 <d_make_comp>
 800b81a:	4603      	mov	r3, r0
 800b81c:	60bb      	str	r3, [r7, #8]
 800b81e:	e1aa      	b.n	800bb76 <d_type+0x752>
 800b820:	687b      	ldr	r3, [r7, #4]
 800b822:	68db      	ldr	r3, [r3, #12]
 800b824:	f103 0201 	add.w	r2, r3, #1
 800b828:	687b      	ldr	r3, [r7, #4]
 800b82a:	60da      	str	r2, [r3, #12]
 800b82c:	6878      	ldr	r0, [r7, #4]
 800b82e:	f7fe ffd9 	bl	800a7e4 <d_source_name>
 800b832:	4603      	mov	r3, r0
 800b834:	60bb      	str	r3, [r7, #8]
 800b836:	6878      	ldr	r0, [r7, #4]
 800b838:	f7ff fdf4 	bl	800b424 <d_type>
 800b83c:	4602      	mov	r2, r0
 800b83e:	68bb      	ldr	r3, [r7, #8]
 800b840:	6878      	ldr	r0, [r7, #4]
 800b842:	f04f 011d 	mov.w	r1, #29
 800b846:	f7fe f9cd 	bl	8009be4 <d_make_comp>
 800b84a:	4603      	mov	r3, r0
 800b84c:	60bb      	str	r3, [r7, #8]
 800b84e:	e192      	b.n	800bb76 <d_type+0x752>
 800b850:	f04f 0300 	mov.w	r3, #0
 800b854:	617b      	str	r3, [r7, #20]
 800b856:	687b      	ldr	r3, [r7, #4]
 800b858:	68db      	ldr	r3, [r3, #12]
 800b85a:	f103 0201 	add.w	r2, r3, #1
 800b85e:	687b      	ldr	r3, [r7, #4]
 800b860:	60da      	str	r2, [r3, #12]
 800b862:	687b      	ldr	r3, [r7, #4]
 800b864:	68db      	ldr	r3, [r3, #12]
 800b866:	781b      	ldrb	r3, [r3, #0]
 800b868:	2b00      	cmp	r3, #0
 800b86a:	d007      	beq.n	800b87c <d_type+0x458>
 800b86c:	687b      	ldr	r3, [r7, #4]
 800b86e:	68da      	ldr	r2, [r3, #12]
 800b870:	7813      	ldrb	r3, [r2, #0]
 800b872:	f102 0101 	add.w	r1, r2, #1
 800b876:	687a      	ldr	r2, [r7, #4]
 800b878:	60d1      	str	r1, [r2, #12]
 800b87a:	e001      	b.n	800b880 <d_type+0x45c>
 800b87c:	f04f 0300 	mov.w	r3, #0
 800b880:	74fb      	strb	r3, [r7, #19]
 800b882:	7cfb      	ldrb	r3, [r7, #19]
 800b884:	f1a3 0346 	sub.w	r3, r3, #70	; 0x46
 800b888:	2b30      	cmp	r3, #48	; 0x30
 800b88a:	f200 816a 	bhi.w	800bb62 <d_type+0x73e>
 800b88e:	a201      	add	r2, pc, #4	; (adr r2, 800b894 <d_type+0x470>)
 800b890:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b894:	0800ba9f 	.word	0x0800ba9f
 800b898:	0800bb63 	.word	0x0800bb63
 800b89c:	0800bb63 	.word	0x0800bb63
 800b8a0:	0800bb63 	.word	0x0800bb63
 800b8a4:	0800bb63 	.word	0x0800bb63
 800b8a8:	0800bb63 	.word	0x0800bb63
 800b8ac:	0800bb63 	.word	0x0800bb63
 800b8b0:	0800bb63 	.word	0x0800bb63
 800b8b4:	0800bb63 	.word	0x0800bb63
 800b8b8:	0800bb63 	.word	0x0800bb63
 800b8bc:	0800bb63 	.word	0x0800bb63
 800b8c0:	0800bb63 	.word	0x0800bb63
 800b8c4:	0800bb63 	.word	0x0800bb63
 800b8c8:	0800bb63 	.word	0x0800bb63
 800b8cc:	0800b959 	.word	0x0800b959
 800b8d0:	0800bb63 	.word	0x0800bb63
 800b8d4:	0800bb63 	.word	0x0800bb63
 800b8d8:	0800bb63 	.word	0x0800bb63
 800b8dc:	0800bb63 	.word	0x0800bb63
 800b8e0:	0800bb63 	.word	0x0800bb63
 800b8e4:	0800bb63 	.word	0x0800bb63
 800b8e8:	0800bb63 	.word	0x0800bb63
 800b8ec:	0800bb63 	.word	0x0800bb63
 800b8f0:	0800bb63 	.word	0x0800bb63
 800b8f4:	0800bb63 	.word	0x0800bb63
 800b8f8:	0800bb63 	.word	0x0800bb63
 800b8fc:	0800bb63 	.word	0x0800bb63
 800b900:	0800b9d3 	.word	0x0800b9d3
 800b904:	0800bb63 	.word	0x0800bb63
 800b908:	0800bb63 	.word	0x0800bb63
 800b90c:	0800ba09 	.word	0x0800ba09
 800b910:	0800ba27 	.word	0x0800ba27
 800b914:	0800b9eb 	.word	0x0800b9eb
 800b918:	0800bb63 	.word	0x0800bb63
 800b91c:	0800ba45 	.word	0x0800ba45
 800b920:	0800ba81 	.word	0x0800ba81
 800b924:	0800bb63 	.word	0x0800bb63
 800b928:	0800bb63 	.word	0x0800bb63
 800b92c:	0800bb63 	.word	0x0800bb63
 800b930:	0800bb63 	.word	0x0800bb63
 800b934:	0800bb45 	.word	0x0800bb45
 800b938:	0800bb63 	.word	0x0800bb63
 800b93c:	0800b9af 	.word	0x0800b9af
 800b940:	0800bb63 	.word	0x0800bb63
 800b944:	0800bb63 	.word	0x0800bb63
 800b948:	0800ba63 	.word	0x0800ba63
 800b94c:	0800b959 	.word	0x0800b959
 800b950:	0800bb63 	.word	0x0800bb63
 800b954:	0800bb33 	.word	0x0800bb33
 800b958:	6878      	ldr	r0, [r7, #4]
 800b95a:	f000 fd77 	bl	800c44c <d_expression>
 800b95e:	4603      	mov	r3, r0
 800b960:	6878      	ldr	r0, [r7, #4]
 800b962:	f04f 013d 	mov.w	r1, #61	; 0x3d
 800b966:	461a      	mov	r2, r3
 800b968:	f04f 0300 	mov.w	r3, #0
 800b96c:	f7fe f93a 	bl	8009be4 <d_make_comp>
 800b970:	4603      	mov	r3, r0
 800b972:	60bb      	str	r3, [r7, #8]
 800b974:	68bb      	ldr	r3, [r7, #8]
 800b976:	2b00      	cmp	r3, #0
 800b978:	d015      	beq.n	800b9a6 <d_type+0x582>
 800b97a:	687b      	ldr	r3, [r7, #4]
 800b97c:	68db      	ldr	r3, [r3, #12]
 800b97e:	781b      	ldrb	r3, [r3, #0]
 800b980:	2b00      	cmp	r3, #0
 800b982:	d00d      	beq.n	800b9a0 <d_type+0x57c>
 800b984:	687b      	ldr	r3, [r7, #4]
 800b986:	68db      	ldr	r3, [r3, #12]
 800b988:	781a      	ldrb	r2, [r3, #0]
 800b98a:	2a45      	cmp	r2, #69	; 0x45
 800b98c:	bf0c      	ite	eq
 800b98e:	2200      	moveq	r2, #0
 800b990:	2201      	movne	r2, #1
 800b992:	b2d2      	uxtb	r2, r2
 800b994:	f103 0101 	add.w	r1, r3, #1
 800b998:	687b      	ldr	r3, [r7, #4]
 800b99a:	60d9      	str	r1, [r3, #12]
 800b99c:	2a00      	cmp	r2, #0
 800b99e:	d002      	beq.n	800b9a6 <d_type+0x582>
 800b9a0:	f04f 0300 	mov.w	r3, #0
 800b9a4:	60bb      	str	r3, [r7, #8]
 800b9a6:	f04f 0301 	mov.w	r3, #1
 800b9aa:	617b      	str	r3, [r7, #20]
 800b9ac:	e0dc      	b.n	800bb68 <d_type+0x744>
 800b9ae:	6878      	ldr	r0, [r7, #4]
 800b9b0:	f7ff fd38 	bl	800b424 <d_type>
 800b9b4:	4603      	mov	r3, r0
 800b9b6:	6878      	ldr	r0, [r7, #4]
 800b9b8:	f04f 0145 	mov.w	r1, #69	; 0x45
 800b9bc:	461a      	mov	r2, r3
 800b9be:	f04f 0300 	mov.w	r3, #0
 800b9c2:	f7fe f90f 	bl	8009be4 <d_make_comp>
 800b9c6:	4603      	mov	r3, r0
 800b9c8:	60bb      	str	r3, [r7, #8]
 800b9ca:	f04f 0301 	mov.w	r3, #1
 800b9ce:	617b      	str	r3, [r7, #20]
 800b9d0:	e0ca      	b.n	800bb68 <d_type+0x744>
 800b9d2:	6878      	ldr	r0, [r7, #4]
 800b9d4:	f64f 219c 	movw	r1, #64156	; 0xfa9c
 800b9d8:	f6c0 0101 	movt	r1, #2049	; 0x801
 800b9dc:	f04f 0204 	mov.w	r2, #4
 800b9e0:	f7fe fa02 	bl	8009de8 <d_make_name>
 800b9e4:	4603      	mov	r3, r0
 800b9e6:	60bb      	str	r3, [r7, #8]
 800b9e8:	e0be      	b.n	800bb68 <d_type+0x744>
 800b9ea:	6878      	ldr	r0, [r7, #4]
 800b9ec:	496c      	ldr	r1, [pc, #432]	; (800bba0 <d_type+0x77c>)
 800b9ee:	f7fe fa17 	bl	8009e20 <d_make_builtin_type>
 800b9f2:	4603      	mov	r3, r0
 800b9f4:	60bb      	str	r3, [r7, #8]
 800b9f6:	687b      	ldr	r3, [r7, #4]
 800b9f8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800b9fa:	68bb      	ldr	r3, [r7, #8]
 800b9fc:	685b      	ldr	r3, [r3, #4]
 800b9fe:	685b      	ldr	r3, [r3, #4]
 800ba00:	18d2      	adds	r2, r2, r3
 800ba02:	687b      	ldr	r3, [r7, #4]
 800ba04:	631a      	str	r2, [r3, #48]	; 0x30
 800ba06:	e0af      	b.n	800bb68 <d_type+0x744>
 800ba08:	6878      	ldr	r0, [r7, #4]
 800ba0a:	4966      	ldr	r1, [pc, #408]	; (800bba4 <d_type+0x780>)
 800ba0c:	f7fe fa08 	bl	8009e20 <d_make_builtin_type>
 800ba10:	4603      	mov	r3, r0
 800ba12:	60bb      	str	r3, [r7, #8]
 800ba14:	687b      	ldr	r3, [r7, #4]
 800ba16:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ba18:	68bb      	ldr	r3, [r7, #8]
 800ba1a:	685b      	ldr	r3, [r3, #4]
 800ba1c:	685b      	ldr	r3, [r3, #4]
 800ba1e:	18d2      	adds	r2, r2, r3
 800ba20:	687b      	ldr	r3, [r7, #4]
 800ba22:	631a      	str	r2, [r3, #48]	; 0x30
 800ba24:	e0a0      	b.n	800bb68 <d_type+0x744>
 800ba26:	6878      	ldr	r0, [r7, #4]
 800ba28:	495f      	ldr	r1, [pc, #380]	; (800bba8 <d_type+0x784>)
 800ba2a:	f7fe f9f9 	bl	8009e20 <d_make_builtin_type>
 800ba2e:	4603      	mov	r3, r0
 800ba30:	60bb      	str	r3, [r7, #8]
 800ba32:	687b      	ldr	r3, [r7, #4]
 800ba34:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ba36:	68bb      	ldr	r3, [r7, #8]
 800ba38:	685b      	ldr	r3, [r3, #4]
 800ba3a:	685b      	ldr	r3, [r3, #4]
 800ba3c:	18d2      	adds	r2, r2, r3
 800ba3e:	687b      	ldr	r3, [r7, #4]
 800ba40:	631a      	str	r2, [r3, #48]	; 0x30
 800ba42:	e091      	b.n	800bb68 <d_type+0x744>
 800ba44:	6878      	ldr	r0, [r7, #4]
 800ba46:	4959      	ldr	r1, [pc, #356]	; (800bbac <d_type+0x788>)
 800ba48:	f7fe f9ea 	bl	8009e20 <d_make_builtin_type>
 800ba4c:	4603      	mov	r3, r0
 800ba4e:	60bb      	str	r3, [r7, #8]
 800ba50:	687b      	ldr	r3, [r7, #4]
 800ba52:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ba54:	68bb      	ldr	r3, [r7, #8]
 800ba56:	685b      	ldr	r3, [r3, #4]
 800ba58:	685b      	ldr	r3, [r3, #4]
 800ba5a:	18d2      	adds	r2, r2, r3
 800ba5c:	687b      	ldr	r3, [r7, #4]
 800ba5e:	631a      	str	r2, [r3, #48]	; 0x30
 800ba60:	e082      	b.n	800bb68 <d_type+0x744>
 800ba62:	6878      	ldr	r0, [r7, #4]
 800ba64:	4952      	ldr	r1, [pc, #328]	; (800bbb0 <d_type+0x78c>)
 800ba66:	f7fe f9db 	bl	8009e20 <d_make_builtin_type>
 800ba6a:	4603      	mov	r3, r0
 800ba6c:	60bb      	str	r3, [r7, #8]
 800ba6e:	687b      	ldr	r3, [r7, #4]
 800ba70:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ba72:	68bb      	ldr	r3, [r7, #8]
 800ba74:	685b      	ldr	r3, [r3, #4]
 800ba76:	685b      	ldr	r3, [r3, #4]
 800ba78:	18d2      	adds	r2, r2, r3
 800ba7a:	687b      	ldr	r3, [r7, #4]
 800ba7c:	631a      	str	r2, [r3, #48]	; 0x30
 800ba7e:	e073      	b.n	800bb68 <d_type+0x744>
 800ba80:	6878      	ldr	r0, [r7, #4]
 800ba82:	494c      	ldr	r1, [pc, #304]	; (800bbb4 <d_type+0x790>)
 800ba84:	f7fe f9cc 	bl	8009e20 <d_make_builtin_type>
 800ba88:	4603      	mov	r3, r0
 800ba8a:	60bb      	str	r3, [r7, #8]
 800ba8c:	687b      	ldr	r3, [r7, #4]
 800ba8e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ba90:	68bb      	ldr	r3, [r7, #8]
 800ba92:	685b      	ldr	r3, [r3, #4]
 800ba94:	685b      	ldr	r3, [r3, #4]
 800ba96:	18d2      	adds	r2, r2, r3
 800ba98:	687b      	ldr	r3, [r7, #4]
 800ba9a:	631a      	str	r2, [r3, #48]	; 0x30
 800ba9c:	e064      	b.n	800bb68 <d_type+0x744>
 800ba9e:	6878      	ldr	r0, [r7, #4]
 800baa0:	f7fe f878 	bl	8009b94 <d_make_empty>
 800baa4:	4603      	mov	r3, r0
 800baa6:	60bb      	str	r3, [r7, #8]
 800baa8:	68bb      	ldr	r3, [r7, #8]
 800baaa:	f04f 0228 	mov.w	r2, #40	; 0x28
 800baae:	701a      	strb	r2, [r3, #0]
 800bab0:	68bb      	ldr	r3, [r7, #8]
 800bab2:	687a      	ldr	r2, [r7, #4]
 800bab4:	68d2      	ldr	r2, [r2, #12]
 800bab6:	7812      	ldrb	r2, [r2, #0]
 800bab8:	2a2f      	cmp	r2, #47	; 0x2f
 800baba:	d907      	bls.n	800bacc <d_type+0x6a8>
 800babc:	687a      	ldr	r2, [r7, #4]
 800babe:	68d2      	ldr	r2, [r2, #12]
 800bac0:	7812      	ldrb	r2, [r2, #0]
 800bac2:	2a39      	cmp	r2, #57	; 0x39
 800bac4:	d802      	bhi.n	800bacc <d_type+0x6a8>
 800bac6:	f04f 0201 	mov.w	r2, #1
 800baca:	e001      	b.n	800bad0 <d_type+0x6ac>
 800bacc:	f04f 0200 	mov.w	r2, #0
 800bad0:	b292      	uxth	r2, r2
 800bad2:	811a      	strh	r2, [r3, #8]
 800bad4:	891b      	ldrh	r3, [r3, #8]
 800bad6:	2b00      	cmp	r3, #0
 800bad8:	d002      	beq.n	800bae0 <d_type+0x6bc>
 800bada:	6878      	ldr	r0, [r7, #4]
 800badc:	f7fe fe9e 	bl	800a81c <d_number>
 800bae0:	68bc      	ldr	r4, [r7, #8]
 800bae2:	6878      	ldr	r0, [r7, #4]
 800bae4:	f7ff fc9e 	bl	800b424 <d_type>
 800bae8:	4603      	mov	r3, r0
 800baea:	6063      	str	r3, [r4, #4]
 800baec:	68bb      	ldr	r3, [r7, #8]
 800baee:	685b      	ldr	r3, [r3, #4]
 800baf0:	2b00      	cmp	r3, #0
 800baf2:	d102      	bne.n	800bafa <d_type+0x6d6>
 800baf4:	f04f 0300 	mov.w	r3, #0
 800baf8:	e04c      	b.n	800bb94 <d_type+0x770>
 800bafa:	6878      	ldr	r0, [r7, #4]
 800bafc:	f7fe fe8e 	bl	800a81c <d_number>
 800bb00:	687b      	ldr	r3, [r7, #4]
 800bb02:	68db      	ldr	r3, [r3, #12]
 800bb04:	781b      	ldrb	r3, [r3, #0]
 800bb06:	2b00      	cmp	r3, #0
 800bb08:	d007      	beq.n	800bb1a <d_type+0x6f6>
 800bb0a:	687b      	ldr	r3, [r7, #4]
 800bb0c:	68da      	ldr	r2, [r3, #12]
 800bb0e:	7813      	ldrb	r3, [r2, #0]
 800bb10:	f102 0101 	add.w	r1, r2, #1
 800bb14:	687a      	ldr	r2, [r7, #4]
 800bb16:	60d1      	str	r1, [r2, #12]
 800bb18:	e001      	b.n	800bb1e <d_type+0x6fa>
 800bb1a:	f04f 0300 	mov.w	r3, #0
 800bb1e:	74fb      	strb	r3, [r7, #19]
 800bb20:	68bb      	ldr	r3, [r7, #8]
 800bb22:	7cfa      	ldrb	r2, [r7, #19]
 800bb24:	2a73      	cmp	r2, #115	; 0x73
 800bb26:	bf14      	ite	ne
 800bb28:	2200      	movne	r2, #0
 800bb2a:	2201      	moveq	r2, #1
 800bb2c:	b2d2      	uxtb	r2, r2
 800bb2e:	815a      	strh	r2, [r3, #10]
 800bb30:	e01a      	b.n	800bb68 <d_type+0x744>
 800bb32:	6878      	ldr	r0, [r7, #4]
 800bb34:	f000 fa54 	bl	800bfe0 <d_vector_type>
 800bb38:	4603      	mov	r3, r0
 800bb3a:	60bb      	str	r3, [r7, #8]
 800bb3c:	f04f 0301 	mov.w	r3, #1
 800bb40:	617b      	str	r3, [r7, #20]
 800bb42:	e011      	b.n	800bb68 <d_type+0x744>
 800bb44:	6878      	ldr	r0, [r7, #4]
 800bb46:	491c      	ldr	r1, [pc, #112]	; (800bbb8 <d_type+0x794>)
 800bb48:	f7fe f96a 	bl	8009e20 <d_make_builtin_type>
 800bb4c:	4603      	mov	r3, r0
 800bb4e:	60bb      	str	r3, [r7, #8]
 800bb50:	687b      	ldr	r3, [r7, #4]
 800bb52:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800bb54:	68bb      	ldr	r3, [r7, #8]
 800bb56:	685b      	ldr	r3, [r3, #4]
 800bb58:	685b      	ldr	r3, [r3, #4]
 800bb5a:	18d2      	adds	r2, r2, r3
 800bb5c:	687b      	ldr	r3, [r7, #4]
 800bb5e:	631a      	str	r2, [r3, #48]	; 0x30
 800bb60:	e002      	b.n	800bb68 <d_type+0x744>
 800bb62:	f04f 0300 	mov.w	r3, #0
 800bb66:	e015      	b.n	800bb94 <d_type+0x770>
 800bb68:	e005      	b.n	800bb76 <d_type+0x752>
 800bb6a:	f04f 0300 	mov.w	r3, #0
 800bb6e:	e011      	b.n	800bb94 <d_type+0x770>
 800bb70:	bf00      	nop
 800bb72:	e000      	b.n	800bb76 <d_type+0x752>
 800bb74:	bf00      	nop
 800bb76:	697b      	ldr	r3, [r7, #20]
 800bb78:	2b00      	cmp	r3, #0
 800bb7a:	d00a      	beq.n	800bb92 <d_type+0x76e>
 800bb7c:	68bb      	ldr	r3, [r7, #8]
 800bb7e:	6878      	ldr	r0, [r7, #4]
 800bb80:	4619      	mov	r1, r3
 800bb82:	f001 f9af 	bl	800cee4 <d_add_substitution>
 800bb86:	4603      	mov	r3, r0
 800bb88:	2b00      	cmp	r3, #0
 800bb8a:	d102      	bne.n	800bb92 <d_type+0x76e>
 800bb8c:	f04f 0300 	mov.w	r3, #0
 800bb90:	e000      	b.n	800bb94 <d_type+0x770>
 800bb92:	68bb      	ldr	r3, [r7, #8]
 800bb94:	4618      	mov	r0, r3
 800bb96:	f107 071c 	add.w	r7, r7, #28
 800bb9a:	46bd      	mov	sp, r7
 800bb9c:	bd90      	pop	{r4, r7, pc}
 800bb9e:	bf00      	nop
 800bba0:	0801f46c 	.word	0x0801f46c
 800bba4:	0801f480 	.word	0x0801f480
 800bba8:	0801f494 	.word	0x0801f494
 800bbac:	0801f4a8 	.word	0x0801f4a8
 800bbb0:	0801f4bc 	.word	0x0801f4bc
 800bbb4:	0801f4d0 	.word	0x0801f4d0
 800bbb8:	0801f4e4 	.word	0x0801f4e4

0800bbbc <d_cv_qualifiers>:
 800bbbc:	b580      	push	{r7, lr}
 800bbbe:	b086      	sub	sp, #24
 800bbc0:	af00      	add	r7, sp, #0
 800bbc2:	60f8      	str	r0, [r7, #12]
 800bbc4:	60b9      	str	r1, [r7, #8]
 800bbc6:	607a      	str	r2, [r7, #4]
 800bbc8:	68bb      	ldr	r3, [r7, #8]
 800bbca:	617b      	str	r3, [r7, #20]
 800bbcc:	68fb      	ldr	r3, [r7, #12]
 800bbce:	68db      	ldr	r3, [r3, #12]
 800bbd0:	781b      	ldrb	r3, [r3, #0]
 800bbd2:	74fb      	strb	r3, [r7, #19]
 800bbd4:	e059      	b.n	800bc8a <d_cv_qualifiers+0xce>
 800bbd6:	68fb      	ldr	r3, [r7, #12]
 800bbd8:	68db      	ldr	r3, [r3, #12]
 800bbda:	f103 0201 	add.w	r2, r3, #1
 800bbde:	68fb      	ldr	r3, [r7, #12]
 800bbe0:	60da      	str	r2, [r3, #12]
 800bbe2:	7cfb      	ldrb	r3, [r7, #19]
 800bbe4:	2b72      	cmp	r3, #114	; 0x72
 800bbe6:	d110      	bne.n	800bc0a <d_cv_qualifiers+0x4e>
 800bbe8:	687b      	ldr	r3, [r7, #4]
 800bbea:	2b00      	cmp	r3, #0
 800bbec:	d002      	beq.n	800bbf4 <d_cv_qualifiers+0x38>
 800bbee:	f04f 031a 	mov.w	r3, #26
 800bbf2:	e001      	b.n	800bbf8 <d_cv_qualifiers+0x3c>
 800bbf4:	f04f 0317 	mov.w	r3, #23
 800bbf8:	74bb      	strb	r3, [r7, #18]
 800bbfa:	68fb      	ldr	r3, [r7, #12]
 800bbfc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bbfe:	f103 0309 	add.w	r3, r3, #9
 800bc02:	461a      	mov	r2, r3
 800bc04:	68fb      	ldr	r3, [r7, #12]
 800bc06:	631a      	str	r2, [r3, #48]	; 0x30
 800bc08:	e023      	b.n	800bc52 <d_cv_qualifiers+0x96>
 800bc0a:	7cfb      	ldrb	r3, [r7, #19]
 800bc0c:	2b56      	cmp	r3, #86	; 0x56
 800bc0e:	d110      	bne.n	800bc32 <d_cv_qualifiers+0x76>
 800bc10:	687b      	ldr	r3, [r7, #4]
 800bc12:	2b00      	cmp	r3, #0
 800bc14:	d002      	beq.n	800bc1c <d_cv_qualifiers+0x60>
 800bc16:	f04f 031b 	mov.w	r3, #27
 800bc1a:	e001      	b.n	800bc20 <d_cv_qualifiers+0x64>
 800bc1c:	f04f 0318 	mov.w	r3, #24
 800bc20:	74bb      	strb	r3, [r7, #18]
 800bc22:	68fb      	ldr	r3, [r7, #12]
 800bc24:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bc26:	f103 0309 	add.w	r3, r3, #9
 800bc2a:	461a      	mov	r2, r3
 800bc2c:	68fb      	ldr	r3, [r7, #12]
 800bc2e:	631a      	str	r2, [r3, #48]	; 0x30
 800bc30:	e00f      	b.n	800bc52 <d_cv_qualifiers+0x96>
 800bc32:	687b      	ldr	r3, [r7, #4]
 800bc34:	2b00      	cmp	r3, #0
 800bc36:	d002      	beq.n	800bc3e <d_cv_qualifiers+0x82>
 800bc38:	f04f 031c 	mov.w	r3, #28
 800bc3c:	e001      	b.n	800bc42 <d_cv_qualifiers+0x86>
 800bc3e:	f04f 0319 	mov.w	r3, #25
 800bc42:	74bb      	strb	r3, [r7, #18]
 800bc44:	68fb      	ldr	r3, [r7, #12]
 800bc46:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bc48:	f103 0306 	add.w	r3, r3, #6
 800bc4c:	461a      	mov	r2, r3
 800bc4e:	68fb      	ldr	r3, [r7, #12]
 800bc50:	631a      	str	r2, [r3, #48]	; 0x30
 800bc52:	7cbb      	ldrb	r3, [r7, #18]
 800bc54:	68f8      	ldr	r0, [r7, #12]
 800bc56:	4619      	mov	r1, r3
 800bc58:	f04f 0200 	mov.w	r2, #0
 800bc5c:	f04f 0300 	mov.w	r3, #0
 800bc60:	f7fd ffc0 	bl	8009be4 <d_make_comp>
 800bc64:	4602      	mov	r2, r0
 800bc66:	68bb      	ldr	r3, [r7, #8]
 800bc68:	601a      	str	r2, [r3, #0]
 800bc6a:	68bb      	ldr	r3, [r7, #8]
 800bc6c:	681b      	ldr	r3, [r3, #0]
 800bc6e:	2b00      	cmp	r3, #0
 800bc70:	d102      	bne.n	800bc78 <d_cv_qualifiers+0xbc>
 800bc72:	f04f 0300 	mov.w	r3, #0
 800bc76:	e03e      	b.n	800bcf6 <d_cv_qualifiers+0x13a>
 800bc78:	68bb      	ldr	r3, [r7, #8]
 800bc7a:	681b      	ldr	r3, [r3, #0]
 800bc7c:	f103 0304 	add.w	r3, r3, #4
 800bc80:	60bb      	str	r3, [r7, #8]
 800bc82:	68fb      	ldr	r3, [r7, #12]
 800bc84:	68db      	ldr	r3, [r3, #12]
 800bc86:	781b      	ldrb	r3, [r3, #0]
 800bc88:	74fb      	strb	r3, [r7, #19]
 800bc8a:	7cfb      	ldrb	r3, [r7, #19]
 800bc8c:	2b72      	cmp	r3, #114	; 0x72
 800bc8e:	d0a2      	beq.n	800bbd6 <d_cv_qualifiers+0x1a>
 800bc90:	7cfb      	ldrb	r3, [r7, #19]
 800bc92:	2b56      	cmp	r3, #86	; 0x56
 800bc94:	d09f      	beq.n	800bbd6 <d_cv_qualifiers+0x1a>
 800bc96:	7cfb      	ldrb	r3, [r7, #19]
 800bc98:	2b4b      	cmp	r3, #75	; 0x4b
 800bc9a:	d09c      	beq.n	800bbd6 <d_cv_qualifiers+0x1a>
 800bc9c:	687b      	ldr	r3, [r7, #4]
 800bc9e:	2b00      	cmp	r3, #0
 800bca0:	d128      	bne.n	800bcf4 <d_cv_qualifiers+0x138>
 800bca2:	7cfb      	ldrb	r3, [r7, #19]
 800bca4:	2b46      	cmp	r3, #70	; 0x46
 800bca6:	d125      	bne.n	800bcf4 <d_cv_qualifiers+0x138>
 800bca8:	e020      	b.n	800bcec <d_cv_qualifiers+0x130>
 800bcaa:	697b      	ldr	r3, [r7, #20]
 800bcac:	681b      	ldr	r3, [r3, #0]
 800bcae:	781b      	ldrb	r3, [r3, #0]
 800bcb0:	2b18      	cmp	r3, #24
 800bcb2:	d009      	beq.n	800bcc8 <d_cv_qualifiers+0x10c>
 800bcb4:	2b19      	cmp	r3, #25
 800bcb6:	d00d      	beq.n	800bcd4 <d_cv_qualifiers+0x118>
 800bcb8:	2b17      	cmp	r3, #23
 800bcba:	d111      	bne.n	800bce0 <d_cv_qualifiers+0x124>
 800bcbc:	697b      	ldr	r3, [r7, #20]
 800bcbe:	681b      	ldr	r3, [r3, #0]
 800bcc0:	f04f 021a 	mov.w	r2, #26
 800bcc4:	701a      	strb	r2, [r3, #0]
 800bcc6:	e00c      	b.n	800bce2 <d_cv_qualifiers+0x126>
 800bcc8:	697b      	ldr	r3, [r7, #20]
 800bcca:	681b      	ldr	r3, [r3, #0]
 800bccc:	f04f 021b 	mov.w	r2, #27
 800bcd0:	701a      	strb	r2, [r3, #0]
 800bcd2:	e006      	b.n	800bce2 <d_cv_qualifiers+0x126>
 800bcd4:	697b      	ldr	r3, [r7, #20]
 800bcd6:	681b      	ldr	r3, [r3, #0]
 800bcd8:	f04f 021c 	mov.w	r2, #28
 800bcdc:	701a      	strb	r2, [r3, #0]
 800bcde:	e000      	b.n	800bce2 <d_cv_qualifiers+0x126>
 800bce0:	bf00      	nop
 800bce2:	697b      	ldr	r3, [r7, #20]
 800bce4:	681b      	ldr	r3, [r3, #0]
 800bce6:	f103 0304 	add.w	r3, r3, #4
 800bcea:	617b      	str	r3, [r7, #20]
 800bcec:	697a      	ldr	r2, [r7, #20]
 800bcee:	68bb      	ldr	r3, [r7, #8]
 800bcf0:	429a      	cmp	r2, r3
 800bcf2:	d1da      	bne.n	800bcaa <d_cv_qualifiers+0xee>
 800bcf4:	68bb      	ldr	r3, [r7, #8]
 800bcf6:	4618      	mov	r0, r3
 800bcf8:	f107 0718 	add.w	r7, r7, #24
 800bcfc:	46bd      	mov	sp, r7
 800bcfe:	bd80      	pop	{r7, pc}

0800bd00 <d_function_type>:
 800bd00:	b580      	push	{r7, lr}
 800bd02:	b084      	sub	sp, #16
 800bd04:	af00      	add	r7, sp, #0
 800bd06:	6078      	str	r0, [r7, #4]
 800bd08:	687b      	ldr	r3, [r7, #4]
 800bd0a:	68db      	ldr	r3, [r3, #12]
 800bd0c:	781b      	ldrb	r3, [r3, #0]
 800bd0e:	2b46      	cmp	r3, #70	; 0x46
 800bd10:	d108      	bne.n	800bd24 <d_function_type+0x24>
 800bd12:	687b      	ldr	r3, [r7, #4]
 800bd14:	68db      	ldr	r3, [r3, #12]
 800bd16:	f103 0201 	add.w	r2, r3, #1
 800bd1a:	687b      	ldr	r3, [r7, #4]
 800bd1c:	60da      	str	r2, [r3, #12]
 800bd1e:	f04f 0300 	mov.w	r3, #0
 800bd22:	e001      	b.n	800bd28 <d_function_type+0x28>
 800bd24:	f04f 0301 	mov.w	r3, #1
 800bd28:	2b00      	cmp	r3, #0
 800bd2a:	d002      	beq.n	800bd32 <d_function_type+0x32>
 800bd2c:	f04f 0300 	mov.w	r3, #0
 800bd30:	e026      	b.n	800bd80 <d_function_type+0x80>
 800bd32:	687b      	ldr	r3, [r7, #4]
 800bd34:	68db      	ldr	r3, [r3, #12]
 800bd36:	781b      	ldrb	r3, [r3, #0]
 800bd38:	2b59      	cmp	r3, #89	; 0x59
 800bd3a:	d105      	bne.n	800bd48 <d_function_type+0x48>
 800bd3c:	687b      	ldr	r3, [r7, #4]
 800bd3e:	68db      	ldr	r3, [r3, #12]
 800bd40:	f103 0201 	add.w	r2, r3, #1
 800bd44:	687b      	ldr	r3, [r7, #4]
 800bd46:	60da      	str	r2, [r3, #12]
 800bd48:	6878      	ldr	r0, [r7, #4]
 800bd4a:	f04f 0101 	mov.w	r1, #1
 800bd4e:	f000 f87f 	bl	800be50 <d_bare_function_type>
 800bd52:	60f8      	str	r0, [r7, #12]
 800bd54:	687b      	ldr	r3, [r7, #4]
 800bd56:	68db      	ldr	r3, [r3, #12]
 800bd58:	781b      	ldrb	r3, [r3, #0]
 800bd5a:	2b45      	cmp	r3, #69	; 0x45
 800bd5c:	d108      	bne.n	800bd70 <d_function_type+0x70>
 800bd5e:	687b      	ldr	r3, [r7, #4]
 800bd60:	68db      	ldr	r3, [r3, #12]
 800bd62:	f103 0201 	add.w	r2, r3, #1
 800bd66:	687b      	ldr	r3, [r7, #4]
 800bd68:	60da      	str	r2, [r3, #12]
 800bd6a:	f04f 0300 	mov.w	r3, #0
 800bd6e:	e001      	b.n	800bd74 <d_function_type+0x74>
 800bd70:	f04f 0301 	mov.w	r3, #1
 800bd74:	2b00      	cmp	r3, #0
 800bd76:	d002      	beq.n	800bd7e <d_function_type+0x7e>
 800bd78:	f04f 0300 	mov.w	r3, #0
 800bd7c:	e000      	b.n	800bd80 <d_function_type+0x80>
 800bd7e:	68fb      	ldr	r3, [r7, #12]
 800bd80:	4618      	mov	r0, r3
 800bd82:	f107 0710 	add.w	r7, r7, #16
 800bd86:	46bd      	mov	sp, r7
 800bd88:	bd80      	pop	{r7, pc}
 800bd8a:	bf00      	nop

0800bd8c <d_parmlist>:
 800bd8c:	b580      	push	{r7, lr}
 800bd8e:	b086      	sub	sp, #24
 800bd90:	af00      	add	r7, sp, #0
 800bd92:	6078      	str	r0, [r7, #4]
 800bd94:	f04f 0300 	mov.w	r3, #0
 800bd98:	60bb      	str	r3, [r7, #8]
 800bd9a:	f107 0308 	add.w	r3, r7, #8
 800bd9e:	617b      	str	r3, [r7, #20]
 800bda0:	687b      	ldr	r3, [r7, #4]
 800bda2:	68db      	ldr	r3, [r3, #12]
 800bda4:	781b      	ldrb	r3, [r3, #0]
 800bda6:	74fb      	strb	r3, [r7, #19]
 800bda8:	7cfb      	ldrb	r3, [r7, #19]
 800bdaa:	2b00      	cmp	r3, #0
 800bdac:	d027      	beq.n	800bdfe <d_parmlist+0x72>
 800bdae:	7cfb      	ldrb	r3, [r7, #19]
 800bdb0:	2b45      	cmp	r3, #69	; 0x45
 800bdb2:	d024      	beq.n	800bdfe <d_parmlist+0x72>
 800bdb4:	7cfb      	ldrb	r3, [r7, #19]
 800bdb6:	2b2e      	cmp	r3, #46	; 0x2e
 800bdb8:	d021      	beq.n	800bdfe <d_parmlist+0x72>
 800bdba:	6878      	ldr	r0, [r7, #4]
 800bdbc:	f7ff fb32 	bl	800b424 <d_type>
 800bdc0:	60f8      	str	r0, [r7, #12]
 800bdc2:	68fb      	ldr	r3, [r7, #12]
 800bdc4:	2b00      	cmp	r3, #0
 800bdc6:	d102      	bne.n	800bdce <d_parmlist+0x42>
 800bdc8:	f04f 0300 	mov.w	r3, #0
 800bdcc:	e03a      	b.n	800be44 <d_parmlist+0xb8>
 800bdce:	6878      	ldr	r0, [r7, #4]
 800bdd0:	f04f 012a 	mov.w	r1, #42	; 0x2a
 800bdd4:	68fa      	ldr	r2, [r7, #12]
 800bdd6:	f04f 0300 	mov.w	r3, #0
 800bdda:	f7fd ff03 	bl	8009be4 <d_make_comp>
 800bdde:	4602      	mov	r2, r0
 800bde0:	697b      	ldr	r3, [r7, #20]
 800bde2:	601a      	str	r2, [r3, #0]
 800bde4:	697b      	ldr	r3, [r7, #20]
 800bde6:	681b      	ldr	r3, [r3, #0]
 800bde8:	2b00      	cmp	r3, #0
 800bdea:	d102      	bne.n	800bdf2 <d_parmlist+0x66>
 800bdec:	f04f 0300 	mov.w	r3, #0
 800bdf0:	e028      	b.n	800be44 <d_parmlist+0xb8>
 800bdf2:	697b      	ldr	r3, [r7, #20]
 800bdf4:	681b      	ldr	r3, [r3, #0]
 800bdf6:	f103 0308 	add.w	r3, r3, #8
 800bdfa:	617b      	str	r3, [r7, #20]
 800bdfc:	e7d0      	b.n	800bda0 <d_parmlist+0x14>
 800bdfe:	68bb      	ldr	r3, [r7, #8]
 800be00:	2b00      	cmp	r3, #0
 800be02:	d102      	bne.n	800be0a <d_parmlist+0x7e>
 800be04:	f04f 0300 	mov.w	r3, #0
 800be08:	e01c      	b.n	800be44 <d_parmlist+0xb8>
 800be0a:	68bb      	ldr	r3, [r7, #8]
 800be0c:	689b      	ldr	r3, [r3, #8]
 800be0e:	2b00      	cmp	r3, #0
 800be10:	d117      	bne.n	800be42 <d_parmlist+0xb6>
 800be12:	68bb      	ldr	r3, [r7, #8]
 800be14:	685b      	ldr	r3, [r3, #4]
 800be16:	781b      	ldrb	r3, [r3, #0]
 800be18:	2b23      	cmp	r3, #35	; 0x23
 800be1a:	d112      	bne.n	800be42 <d_parmlist+0xb6>
 800be1c:	68bb      	ldr	r3, [r7, #8]
 800be1e:	685b      	ldr	r3, [r3, #4]
 800be20:	685b      	ldr	r3, [r3, #4]
 800be22:	7c1b      	ldrb	r3, [r3, #16]
 800be24:	2b09      	cmp	r3, #9
 800be26:	d10c      	bne.n	800be42 <d_parmlist+0xb6>
 800be28:	687b      	ldr	r3, [r7, #4]
 800be2a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800be2c:	68bb      	ldr	r3, [r7, #8]
 800be2e:	685b      	ldr	r3, [r3, #4]
 800be30:	685b      	ldr	r3, [r3, #4]
 800be32:	685b      	ldr	r3, [r3, #4]
 800be34:	1ad2      	subs	r2, r2, r3
 800be36:	687b      	ldr	r3, [r7, #4]
 800be38:	631a      	str	r2, [r3, #48]	; 0x30
 800be3a:	68bb      	ldr	r3, [r7, #8]
 800be3c:	f04f 0200 	mov.w	r2, #0
 800be40:	605a      	str	r2, [r3, #4]
 800be42:	68bb      	ldr	r3, [r7, #8]
 800be44:	4618      	mov	r0, r3
 800be46:	f107 0718 	add.w	r7, r7, #24
 800be4a:	46bd      	mov	sp, r7
 800be4c:	bd80      	pop	{r7, pc}
 800be4e:	bf00      	nop

0800be50 <d_bare_function_type>:
 800be50:	b580      	push	{r7, lr}
 800be52:	b086      	sub	sp, #24
 800be54:	af00      	add	r7, sp, #0
 800be56:	6078      	str	r0, [r7, #4]
 800be58:	6039      	str	r1, [r7, #0]
 800be5a:	687b      	ldr	r3, [r7, #4]
 800be5c:	68db      	ldr	r3, [r3, #12]
 800be5e:	781b      	ldrb	r3, [r3, #0]
 800be60:	74fb      	strb	r3, [r7, #19]
 800be62:	7cfb      	ldrb	r3, [r7, #19]
 800be64:	2b4a      	cmp	r3, #74	; 0x4a
 800be66:	d108      	bne.n	800be7a <d_bare_function_type+0x2a>
 800be68:	687b      	ldr	r3, [r7, #4]
 800be6a:	68db      	ldr	r3, [r3, #12]
 800be6c:	f103 0201 	add.w	r2, r3, #1
 800be70:	687b      	ldr	r3, [r7, #4]
 800be72:	60da      	str	r2, [r3, #12]
 800be74:	f04f 0301 	mov.w	r3, #1
 800be78:	603b      	str	r3, [r7, #0]
 800be7a:	683b      	ldr	r3, [r7, #0]
 800be7c:	2b00      	cmp	r3, #0
 800be7e:	d009      	beq.n	800be94 <d_bare_function_type+0x44>
 800be80:	6878      	ldr	r0, [r7, #4]
 800be82:	f7ff facf 	bl	800b424 <d_type>
 800be86:	6178      	str	r0, [r7, #20]
 800be88:	697b      	ldr	r3, [r7, #20]
 800be8a:	2b00      	cmp	r3, #0
 800be8c:	d105      	bne.n	800be9a <d_bare_function_type+0x4a>
 800be8e:	f04f 0300 	mov.w	r3, #0
 800be92:	e014      	b.n	800bebe <d_bare_function_type+0x6e>
 800be94:	f04f 0300 	mov.w	r3, #0
 800be98:	617b      	str	r3, [r7, #20]
 800be9a:	6878      	ldr	r0, [r7, #4]
 800be9c:	f7ff ff76 	bl	800bd8c <d_parmlist>
 800bea0:	60f8      	str	r0, [r7, #12]
 800bea2:	68fb      	ldr	r3, [r7, #12]
 800bea4:	2b00      	cmp	r3, #0
 800bea6:	d102      	bne.n	800beae <d_bare_function_type+0x5e>
 800bea8:	f04f 0300 	mov.w	r3, #0
 800beac:	e007      	b.n	800bebe <d_bare_function_type+0x6e>
 800beae:	6878      	ldr	r0, [r7, #4]
 800beb0:	f04f 0125 	mov.w	r1, #37	; 0x25
 800beb4:	697a      	ldr	r2, [r7, #20]
 800beb6:	68fb      	ldr	r3, [r7, #12]
 800beb8:	f7fd fe94 	bl	8009be4 <d_make_comp>
 800bebc:	4603      	mov	r3, r0
 800bebe:	4618      	mov	r0, r3
 800bec0:	f107 0718 	add.w	r7, r7, #24
 800bec4:	46bd      	mov	sp, r7
 800bec6:	bd80      	pop	{r7, pc}

0800bec8 <d_class_enum_type>:
 800bec8:	b580      	push	{r7, lr}
 800beca:	b082      	sub	sp, #8
 800becc:	af00      	add	r7, sp, #0
 800bece:	6078      	str	r0, [r7, #4]
 800bed0:	6878      	ldr	r0, [r7, #4]
 800bed2:	f7fe fa41 	bl	800a358 <d_name>
 800bed6:	4603      	mov	r3, r0
 800bed8:	4618      	mov	r0, r3
 800beda:	f107 0708 	add.w	r7, r7, #8
 800bede:	46bd      	mov	sp, r7
 800bee0:	bd80      	pop	{r7, pc}
 800bee2:	bf00      	nop

0800bee4 <d_array_type>:
 800bee4:	b580      	push	{r7, lr}
 800bee6:	b086      	sub	sp, #24
 800bee8:	af00      	add	r7, sp, #0
 800beea:	6078      	str	r0, [r7, #4]
 800beec:	687b      	ldr	r3, [r7, #4]
 800beee:	68db      	ldr	r3, [r3, #12]
 800bef0:	781b      	ldrb	r3, [r3, #0]
 800bef2:	2b41      	cmp	r3, #65	; 0x41
 800bef4:	d108      	bne.n	800bf08 <d_array_type+0x24>
 800bef6:	687b      	ldr	r3, [r7, #4]
 800bef8:	68db      	ldr	r3, [r3, #12]
 800befa:	f103 0201 	add.w	r2, r3, #1
 800befe:	687b      	ldr	r3, [r7, #4]
 800bf00:	60da      	str	r2, [r3, #12]
 800bf02:	f04f 0300 	mov.w	r3, #0
 800bf06:	e001      	b.n	800bf0c <d_array_type+0x28>
 800bf08:	f04f 0301 	mov.w	r3, #1
 800bf0c:	2b00      	cmp	r3, #0
 800bf0e:	d002      	beq.n	800bf16 <d_array_type+0x32>
 800bf10:	f04f 0300 	mov.w	r3, #0
 800bf14:	e05f      	b.n	800bfd6 <d_array_type+0xf2>
 800bf16:	687b      	ldr	r3, [r7, #4]
 800bf18:	68db      	ldr	r3, [r3, #12]
 800bf1a:	781b      	ldrb	r3, [r3, #0]
 800bf1c:	74fb      	strb	r3, [r7, #19]
 800bf1e:	7cfb      	ldrb	r3, [r7, #19]
 800bf20:	2b5f      	cmp	r3, #95	; 0x5f
 800bf22:	d103      	bne.n	800bf2c <d_array_type+0x48>
 800bf24:	f04f 0300 	mov.w	r3, #0
 800bf28:	617b      	str	r3, [r7, #20]
 800bf2a:	e034      	b.n	800bf96 <d_array_type+0xb2>
 800bf2c:	7cfb      	ldrb	r3, [r7, #19]
 800bf2e:	2b2f      	cmp	r3, #47	; 0x2f
 800bf30:	d926      	bls.n	800bf80 <d_array_type+0x9c>
 800bf32:	7cfb      	ldrb	r3, [r7, #19]
 800bf34:	2b39      	cmp	r3, #57	; 0x39
 800bf36:	d823      	bhi.n	800bf80 <d_array_type+0x9c>
 800bf38:	687b      	ldr	r3, [r7, #4]
 800bf3a:	68db      	ldr	r3, [r3, #12]
 800bf3c:	60fb      	str	r3, [r7, #12]
 800bf3e:	687b      	ldr	r3, [r7, #4]
 800bf40:	68db      	ldr	r3, [r3, #12]
 800bf42:	f103 0201 	add.w	r2, r3, #1
 800bf46:	687b      	ldr	r3, [r7, #4]
 800bf48:	60da      	str	r2, [r3, #12]
 800bf4a:	687b      	ldr	r3, [r7, #4]
 800bf4c:	68db      	ldr	r3, [r3, #12]
 800bf4e:	781b      	ldrb	r3, [r3, #0]
 800bf50:	74fb      	strb	r3, [r7, #19]
 800bf52:	7cfb      	ldrb	r3, [r7, #19]
 800bf54:	2b2f      	cmp	r3, #47	; 0x2f
 800bf56:	d902      	bls.n	800bf5e <d_array_type+0x7a>
 800bf58:	7cfb      	ldrb	r3, [r7, #19]
 800bf5a:	2b39      	cmp	r3, #57	; 0x39
 800bf5c:	d9ef      	bls.n	800bf3e <d_array_type+0x5a>
 800bf5e:	687b      	ldr	r3, [r7, #4]
 800bf60:	68db      	ldr	r3, [r3, #12]
 800bf62:	461a      	mov	r2, r3
 800bf64:	68fb      	ldr	r3, [r7, #12]
 800bf66:	1ad3      	subs	r3, r2, r3
 800bf68:	6878      	ldr	r0, [r7, #4]
 800bf6a:	68f9      	ldr	r1, [r7, #12]
 800bf6c:	461a      	mov	r2, r3
 800bf6e:	f7fd ff3b 	bl	8009de8 <d_make_name>
 800bf72:	6178      	str	r0, [r7, #20]
 800bf74:	697b      	ldr	r3, [r7, #20]
 800bf76:	2b00      	cmp	r3, #0
 800bf78:	d10c      	bne.n	800bf94 <d_array_type+0xb0>
 800bf7a:	f04f 0300 	mov.w	r3, #0
 800bf7e:	e02a      	b.n	800bfd6 <d_array_type+0xf2>
 800bf80:	6878      	ldr	r0, [r7, #4]
 800bf82:	f000 fa63 	bl	800c44c <d_expression>
 800bf86:	6178      	str	r0, [r7, #20]
 800bf88:	697b      	ldr	r3, [r7, #20]
 800bf8a:	2b00      	cmp	r3, #0
 800bf8c:	d103      	bne.n	800bf96 <d_array_type+0xb2>
 800bf8e:	f04f 0300 	mov.w	r3, #0
 800bf92:	e020      	b.n	800bfd6 <d_array_type+0xf2>
 800bf94:	bf00      	nop
 800bf96:	687b      	ldr	r3, [r7, #4]
 800bf98:	68db      	ldr	r3, [r3, #12]
 800bf9a:	781b      	ldrb	r3, [r3, #0]
 800bf9c:	2b5f      	cmp	r3, #95	; 0x5f
 800bf9e:	d108      	bne.n	800bfb2 <d_array_type+0xce>
 800bfa0:	687b      	ldr	r3, [r7, #4]
 800bfa2:	68db      	ldr	r3, [r3, #12]
 800bfa4:	f103 0201 	add.w	r2, r3, #1
 800bfa8:	687b      	ldr	r3, [r7, #4]
 800bfaa:	60da      	str	r2, [r3, #12]
 800bfac:	f04f 0300 	mov.w	r3, #0
 800bfb0:	e001      	b.n	800bfb6 <d_array_type+0xd2>
 800bfb2:	f04f 0301 	mov.w	r3, #1
 800bfb6:	2b00      	cmp	r3, #0
 800bfb8:	d002      	beq.n	800bfc0 <d_array_type+0xdc>
 800bfba:	f04f 0300 	mov.w	r3, #0
 800bfbe:	e00a      	b.n	800bfd6 <d_array_type+0xf2>
 800bfc0:	6878      	ldr	r0, [r7, #4]
 800bfc2:	f7ff fa2f 	bl	800b424 <d_type>
 800bfc6:	4603      	mov	r3, r0
 800bfc8:	6878      	ldr	r0, [r7, #4]
 800bfca:	f04f 0126 	mov.w	r1, #38	; 0x26
 800bfce:	697a      	ldr	r2, [r7, #20]
 800bfd0:	f7fd fe08 	bl	8009be4 <d_make_comp>
 800bfd4:	4603      	mov	r3, r0
 800bfd6:	4618      	mov	r0, r3
 800bfd8:	f107 0718 	add.w	r7, r7, #24
 800bfdc:	46bd      	mov	sp, r7
 800bfde:	bd80      	pop	{r7, pc}

0800bfe0 <d_vector_type>:
 800bfe0:	b580      	push	{r7, lr}
 800bfe2:	b084      	sub	sp, #16
 800bfe4:	af00      	add	r7, sp, #0
 800bfe6:	6078      	str	r0, [r7, #4]
 800bfe8:	687b      	ldr	r3, [r7, #4]
 800bfea:	68db      	ldr	r3, [r3, #12]
 800bfec:	781b      	ldrb	r3, [r3, #0]
 800bfee:	72fb      	strb	r3, [r7, #11]
 800bff0:	7afb      	ldrb	r3, [r7, #11]
 800bff2:	2b5f      	cmp	r3, #95	; 0x5f
 800bff4:	d10a      	bne.n	800c00c <d_vector_type+0x2c>
 800bff6:	687b      	ldr	r3, [r7, #4]
 800bff8:	68db      	ldr	r3, [r3, #12]
 800bffa:	f103 0201 	add.w	r2, r3, #1
 800bffe:	687b      	ldr	r3, [r7, #4]
 800c000:	60da      	str	r2, [r3, #12]
 800c002:	6878      	ldr	r0, [r7, #4]
 800c004:	f000 fa22 	bl	800c44c <d_expression>
 800c008:	60f8      	str	r0, [r7, #12]
 800c00a:	e003      	b.n	800c014 <d_vector_type+0x34>
 800c00c:	6878      	ldr	r0, [r7, #4]
 800c00e:	f7fe fc51 	bl	800a8b4 <d_number_component>
 800c012:	60f8      	str	r0, [r7, #12]
 800c014:	68fb      	ldr	r3, [r7, #12]
 800c016:	2b00      	cmp	r3, #0
 800c018:	d102      	bne.n	800c020 <d_vector_type+0x40>
 800c01a:	f04f 0300 	mov.w	r3, #0
 800c01e:	e01f      	b.n	800c060 <d_vector_type+0x80>
 800c020:	687b      	ldr	r3, [r7, #4]
 800c022:	68db      	ldr	r3, [r3, #12]
 800c024:	781b      	ldrb	r3, [r3, #0]
 800c026:	2b5f      	cmp	r3, #95	; 0x5f
 800c028:	d108      	bne.n	800c03c <d_vector_type+0x5c>
 800c02a:	687b      	ldr	r3, [r7, #4]
 800c02c:	68db      	ldr	r3, [r3, #12]
 800c02e:	f103 0201 	add.w	r2, r3, #1
 800c032:	687b      	ldr	r3, [r7, #4]
 800c034:	60da      	str	r2, [r3, #12]
 800c036:	f04f 0300 	mov.w	r3, #0
 800c03a:	e001      	b.n	800c040 <d_vector_type+0x60>
 800c03c:	f04f 0301 	mov.w	r3, #1
 800c040:	2b00      	cmp	r3, #0
 800c042:	d002      	beq.n	800c04a <d_vector_type+0x6a>
 800c044:	f04f 0300 	mov.w	r3, #0
 800c048:	e00a      	b.n	800c060 <d_vector_type+0x80>
 800c04a:	6878      	ldr	r0, [r7, #4]
 800c04c:	f7ff f9ea 	bl	800b424 <d_type>
 800c050:	4603      	mov	r3, r0
 800c052:	6878      	ldr	r0, [r7, #4]
 800c054:	f04f 0129 	mov.w	r1, #41	; 0x29
 800c058:	68fa      	ldr	r2, [r7, #12]
 800c05a:	f7fd fdc3 	bl	8009be4 <d_make_comp>
 800c05e:	4603      	mov	r3, r0
 800c060:	4618      	mov	r0, r3
 800c062:	f107 0710 	add.w	r7, r7, #16
 800c066:	46bd      	mov	sp, r7
 800c068:	bd80      	pop	{r7, pc}
 800c06a:	bf00      	nop

0800c06c <d_pointer_to_member_type>:
 800c06c:	b580      	push	{r7, lr}
 800c06e:	b086      	sub	sp, #24
 800c070:	af00      	add	r7, sp, #0
 800c072:	6078      	str	r0, [r7, #4]
 800c074:	687b      	ldr	r3, [r7, #4]
 800c076:	68db      	ldr	r3, [r3, #12]
 800c078:	781b      	ldrb	r3, [r3, #0]
 800c07a:	2b4d      	cmp	r3, #77	; 0x4d
 800c07c:	d108      	bne.n	800c090 <d_pointer_to_member_type+0x24>
 800c07e:	687b      	ldr	r3, [r7, #4]
 800c080:	68db      	ldr	r3, [r3, #12]
 800c082:	f103 0201 	add.w	r2, r3, #1
 800c086:	687b      	ldr	r3, [r7, #4]
 800c088:	60da      	str	r2, [r3, #12]
 800c08a:	f04f 0300 	mov.w	r3, #0
 800c08e:	e001      	b.n	800c094 <d_pointer_to_member_type+0x28>
 800c090:	f04f 0301 	mov.w	r3, #1
 800c094:	2b00      	cmp	r3, #0
 800c096:	d002      	beq.n	800c09e <d_pointer_to_member_type+0x32>
 800c098:	f04f 0300 	mov.w	r3, #0
 800c09c:	e03c      	b.n	800c118 <d_pointer_to_member_type+0xac>
 800c09e:	6878      	ldr	r0, [r7, #4]
 800c0a0:	f7ff f9c0 	bl	800b424 <d_type>
 800c0a4:	6178      	str	r0, [r7, #20]
 800c0a6:	f107 030c 	add.w	r3, r7, #12
 800c0aa:	6878      	ldr	r0, [r7, #4]
 800c0ac:	4619      	mov	r1, r3
 800c0ae:	f04f 0201 	mov.w	r2, #1
 800c0b2:	f7ff fd83 	bl	800bbbc <d_cv_qualifiers>
 800c0b6:	6138      	str	r0, [r7, #16]
 800c0b8:	693b      	ldr	r3, [r7, #16]
 800c0ba:	2b00      	cmp	r3, #0
 800c0bc:	d102      	bne.n	800c0c4 <d_pointer_to_member_type+0x58>
 800c0be:	f04f 0300 	mov.w	r3, #0
 800c0c2:	e029      	b.n	800c118 <d_pointer_to_member_type+0xac>
 800c0c4:	6878      	ldr	r0, [r7, #4]
 800c0c6:	f7ff f9ad 	bl	800b424 <d_type>
 800c0ca:	4602      	mov	r2, r0
 800c0cc:	693b      	ldr	r3, [r7, #16]
 800c0ce:	601a      	str	r2, [r3, #0]
 800c0d0:	693b      	ldr	r3, [r7, #16]
 800c0d2:	681b      	ldr	r3, [r3, #0]
 800c0d4:	2b00      	cmp	r3, #0
 800c0d6:	d102      	bne.n	800c0de <d_pointer_to_member_type+0x72>
 800c0d8:	f04f 0300 	mov.w	r3, #0
 800c0dc:	e01c      	b.n	800c118 <d_pointer_to_member_type+0xac>
 800c0de:	f107 030c 	add.w	r3, r7, #12
 800c0e2:	693a      	ldr	r2, [r7, #16]
 800c0e4:	429a      	cmp	r2, r3
 800c0e6:	d00f      	beq.n	800c108 <d_pointer_to_member_type+0x9c>
 800c0e8:	693b      	ldr	r3, [r7, #16]
 800c0ea:	681b      	ldr	r3, [r3, #0]
 800c0ec:	781b      	ldrb	r3, [r3, #0]
 800c0ee:	2b25      	cmp	r3, #37	; 0x25
 800c0f0:	d00a      	beq.n	800c108 <d_pointer_to_member_type+0x9c>
 800c0f2:	68fb      	ldr	r3, [r7, #12]
 800c0f4:	6878      	ldr	r0, [r7, #4]
 800c0f6:	4619      	mov	r1, r3
 800c0f8:	f000 fef4 	bl	800cee4 <d_add_substitution>
 800c0fc:	4603      	mov	r3, r0
 800c0fe:	2b00      	cmp	r3, #0
 800c100:	d102      	bne.n	800c108 <d_pointer_to_member_type+0x9c>
 800c102:	f04f 0300 	mov.w	r3, #0
 800c106:	e007      	b.n	800c118 <d_pointer_to_member_type+0xac>
 800c108:	68fb      	ldr	r3, [r7, #12]
 800c10a:	6878      	ldr	r0, [r7, #4]
 800c10c:	f04f 0127 	mov.w	r1, #39	; 0x27
 800c110:	697a      	ldr	r2, [r7, #20]
 800c112:	f7fd fd67 	bl	8009be4 <d_make_comp>
 800c116:	4603      	mov	r3, r0
 800c118:	4618      	mov	r0, r3
 800c11a:	f107 0718 	add.w	r7, r7, #24
 800c11e:	46bd      	mov	sp, r7
 800c120:	bd80      	pop	{r7, pc}
 800c122:	bf00      	nop

0800c124 <d_compact_number>:
 800c124:	b580      	push	{r7, lr}
 800c126:	b084      	sub	sp, #16
 800c128:	af00      	add	r7, sp, #0
 800c12a:	6078      	str	r0, [r7, #4]
 800c12c:	687b      	ldr	r3, [r7, #4]
 800c12e:	68db      	ldr	r3, [r3, #12]
 800c130:	781b      	ldrb	r3, [r3, #0]
 800c132:	2b5f      	cmp	r3, #95	; 0x5f
 800c134:	d103      	bne.n	800c13e <d_compact_number+0x1a>
 800c136:	f04f 0300 	mov.w	r3, #0
 800c13a:	60fb      	str	r3, [r7, #12]
 800c13c:	e00e      	b.n	800c15c <d_compact_number+0x38>
 800c13e:	687b      	ldr	r3, [r7, #4]
 800c140:	68db      	ldr	r3, [r3, #12]
 800c142:	781b      	ldrb	r3, [r3, #0]
 800c144:	2b6e      	cmp	r3, #110	; 0x6e
 800c146:	d102      	bne.n	800c14e <d_compact_number+0x2a>
 800c148:	f04f 33ff 	mov.w	r3, #4294967295
 800c14c:	e01c      	b.n	800c188 <d_compact_number+0x64>
 800c14e:	6878      	ldr	r0, [r7, #4]
 800c150:	f7fe fb64 	bl	800a81c <d_number>
 800c154:	4603      	mov	r3, r0
 800c156:	f103 0301 	add.w	r3, r3, #1
 800c15a:	60fb      	str	r3, [r7, #12]
 800c15c:	687b      	ldr	r3, [r7, #4]
 800c15e:	68db      	ldr	r3, [r3, #12]
 800c160:	781b      	ldrb	r3, [r3, #0]
 800c162:	2b5f      	cmp	r3, #95	; 0x5f
 800c164:	d108      	bne.n	800c178 <d_compact_number+0x54>
 800c166:	687b      	ldr	r3, [r7, #4]
 800c168:	68db      	ldr	r3, [r3, #12]
 800c16a:	f103 0201 	add.w	r2, r3, #1
 800c16e:	687b      	ldr	r3, [r7, #4]
 800c170:	60da      	str	r2, [r3, #12]
 800c172:	f04f 0300 	mov.w	r3, #0
 800c176:	e001      	b.n	800c17c <d_compact_number+0x58>
 800c178:	f04f 0301 	mov.w	r3, #1
 800c17c:	2b00      	cmp	r3, #0
 800c17e:	d002      	beq.n	800c186 <d_compact_number+0x62>
 800c180:	f04f 33ff 	mov.w	r3, #4294967295
 800c184:	e000      	b.n	800c188 <d_compact_number+0x64>
 800c186:	68fb      	ldr	r3, [r7, #12]
 800c188:	4618      	mov	r0, r3
 800c18a:	f107 0710 	add.w	r7, r7, #16
 800c18e:	46bd      	mov	sp, r7
 800c190:	bd80      	pop	{r7, pc}
 800c192:	bf00      	nop

0800c194 <d_template_param>:
 800c194:	b580      	push	{r7, lr}
 800c196:	b084      	sub	sp, #16
 800c198:	af00      	add	r7, sp, #0
 800c19a:	6078      	str	r0, [r7, #4]
 800c19c:	687b      	ldr	r3, [r7, #4]
 800c19e:	68db      	ldr	r3, [r3, #12]
 800c1a0:	781b      	ldrb	r3, [r3, #0]
 800c1a2:	2b54      	cmp	r3, #84	; 0x54
 800c1a4:	d108      	bne.n	800c1b8 <d_template_param+0x24>
 800c1a6:	687b      	ldr	r3, [r7, #4]
 800c1a8:	68db      	ldr	r3, [r3, #12]
 800c1aa:	f103 0201 	add.w	r2, r3, #1
 800c1ae:	687b      	ldr	r3, [r7, #4]
 800c1b0:	60da      	str	r2, [r3, #12]
 800c1b2:	f04f 0300 	mov.w	r3, #0
 800c1b6:	e001      	b.n	800c1bc <d_template_param+0x28>
 800c1b8:	f04f 0301 	mov.w	r3, #1
 800c1bc:	2b00      	cmp	r3, #0
 800c1be:	d002      	beq.n	800c1c6 <d_template_param+0x32>
 800c1c0:	f04f 0300 	mov.w	r3, #0
 800c1c4:	e014      	b.n	800c1f0 <d_template_param+0x5c>
 800c1c6:	6878      	ldr	r0, [r7, #4]
 800c1c8:	f7ff ffac 	bl	800c124 <d_compact_number>
 800c1cc:	60f8      	str	r0, [r7, #12]
 800c1ce:	68fb      	ldr	r3, [r7, #12]
 800c1d0:	2b00      	cmp	r3, #0
 800c1d2:	da02      	bge.n	800c1da <d_template_param+0x46>
 800c1d4:	f04f 0300 	mov.w	r3, #0
 800c1d8:	e00a      	b.n	800c1f0 <d_template_param+0x5c>
 800c1da:	687b      	ldr	r3, [r7, #4]
 800c1dc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800c1de:	f103 0201 	add.w	r2, r3, #1
 800c1e2:	687b      	ldr	r3, [r7, #4]
 800c1e4:	629a      	str	r2, [r3, #40]	; 0x28
 800c1e6:	6878      	ldr	r0, [r7, #4]
 800c1e8:	68f9      	ldr	r1, [r7, #12]
 800c1ea:	f7fd fec9 	bl	8009f80 <d_make_template_param>
 800c1ee:	4603      	mov	r3, r0
 800c1f0:	4618      	mov	r0, r3
 800c1f2:	f107 0710 	add.w	r7, r7, #16
 800c1f6:	46bd      	mov	sp, r7
 800c1f8:	bd80      	pop	{r7, pc}
 800c1fa:	bf00      	nop

0800c1fc <d_template_args>:
 800c1fc:	b580      	push	{r7, lr}
 800c1fe:	b086      	sub	sp, #24
 800c200:	af00      	add	r7, sp, #0
 800c202:	6078      	str	r0, [r7, #4]
 800c204:	687b      	ldr	r3, [r7, #4]
 800c206:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c208:	613b      	str	r3, [r7, #16]
 800c20a:	687b      	ldr	r3, [r7, #4]
 800c20c:	68db      	ldr	r3, [r3, #12]
 800c20e:	781b      	ldrb	r3, [r3, #0]
 800c210:	2b49      	cmp	r3, #73	; 0x49
 800c212:	d007      	beq.n	800c224 <d_template_args+0x28>
 800c214:	687b      	ldr	r3, [r7, #4]
 800c216:	68db      	ldr	r3, [r3, #12]
 800c218:	781b      	ldrb	r3, [r3, #0]
 800c21a:	2b4a      	cmp	r3, #74	; 0x4a
 800c21c:	d002      	beq.n	800c224 <d_template_args+0x28>
 800c21e:	f04f 0300 	mov.w	r3, #0
 800c222:	e054      	b.n	800c2ce <d_template_args+0xd2>
 800c224:	687b      	ldr	r3, [r7, #4]
 800c226:	68db      	ldr	r3, [r3, #12]
 800c228:	f103 0201 	add.w	r2, r3, #1
 800c22c:	687b      	ldr	r3, [r7, #4]
 800c22e:	60da      	str	r2, [r3, #12]
 800c230:	687b      	ldr	r3, [r7, #4]
 800c232:	68db      	ldr	r3, [r3, #12]
 800c234:	781b      	ldrb	r3, [r3, #0]
 800c236:	2b45      	cmp	r3, #69	; 0x45
 800c238:	d110      	bne.n	800c25c <d_template_args+0x60>
 800c23a:	687b      	ldr	r3, [r7, #4]
 800c23c:	68db      	ldr	r3, [r3, #12]
 800c23e:	f103 0201 	add.w	r2, r3, #1
 800c242:	687b      	ldr	r3, [r7, #4]
 800c244:	60da      	str	r2, [r3, #12]
 800c246:	6878      	ldr	r0, [r7, #4]
 800c248:	f04f 012b 	mov.w	r1, #43	; 0x2b
 800c24c:	f04f 0200 	mov.w	r2, #0
 800c250:	f04f 0300 	mov.w	r3, #0
 800c254:	f7fd fcc6 	bl	8009be4 <d_make_comp>
 800c258:	4603      	mov	r3, r0
 800c25a:	e038      	b.n	800c2ce <d_template_args+0xd2>
 800c25c:	f04f 0300 	mov.w	r3, #0
 800c260:	60bb      	str	r3, [r7, #8]
 800c262:	f107 0308 	add.w	r3, r7, #8
 800c266:	617b      	str	r3, [r7, #20]
 800c268:	e000      	b.n	800c26c <d_template_args+0x70>
 800c26a:	bf00      	nop
 800c26c:	6878      	ldr	r0, [r7, #4]
 800c26e:	f000 f833 	bl	800c2d8 <d_template_arg>
 800c272:	60f8      	str	r0, [r7, #12]
 800c274:	68fb      	ldr	r3, [r7, #12]
 800c276:	2b00      	cmp	r3, #0
 800c278:	d102      	bne.n	800c280 <d_template_args+0x84>
 800c27a:	f04f 0300 	mov.w	r3, #0
 800c27e:	e026      	b.n	800c2ce <d_template_args+0xd2>
 800c280:	6878      	ldr	r0, [r7, #4]
 800c282:	f04f 012b 	mov.w	r1, #43	; 0x2b
 800c286:	68fa      	ldr	r2, [r7, #12]
 800c288:	f04f 0300 	mov.w	r3, #0
 800c28c:	f7fd fcaa 	bl	8009be4 <d_make_comp>
 800c290:	4602      	mov	r2, r0
 800c292:	697b      	ldr	r3, [r7, #20]
 800c294:	601a      	str	r2, [r3, #0]
 800c296:	697b      	ldr	r3, [r7, #20]
 800c298:	681b      	ldr	r3, [r3, #0]
 800c29a:	2b00      	cmp	r3, #0
 800c29c:	d102      	bne.n	800c2a4 <d_template_args+0xa8>
 800c29e:	f04f 0300 	mov.w	r3, #0
 800c2a2:	e014      	b.n	800c2ce <d_template_args+0xd2>
 800c2a4:	697b      	ldr	r3, [r7, #20]
 800c2a6:	681b      	ldr	r3, [r3, #0]
 800c2a8:	f103 0308 	add.w	r3, r3, #8
 800c2ac:	617b      	str	r3, [r7, #20]
 800c2ae:	687b      	ldr	r3, [r7, #4]
 800c2b0:	68db      	ldr	r3, [r3, #12]
 800c2b2:	781b      	ldrb	r3, [r3, #0]
 800c2b4:	2b45      	cmp	r3, #69	; 0x45
 800c2b6:	d1d8      	bne.n	800c26a <d_template_args+0x6e>
 800c2b8:	687b      	ldr	r3, [r7, #4]
 800c2ba:	68db      	ldr	r3, [r3, #12]
 800c2bc:	f103 0201 	add.w	r2, r3, #1
 800c2c0:	687b      	ldr	r3, [r7, #4]
 800c2c2:	60da      	str	r2, [r3, #12]
 800c2c4:	bf00      	nop
 800c2c6:	687b      	ldr	r3, [r7, #4]
 800c2c8:	693a      	ldr	r2, [r7, #16]
 800c2ca:	62da      	str	r2, [r3, #44]	; 0x2c
 800c2cc:	68bb      	ldr	r3, [r7, #8]
 800c2ce:	4618      	mov	r0, r3
 800c2d0:	f107 0718 	add.w	r7, r7, #24
 800c2d4:	46bd      	mov	sp, r7
 800c2d6:	bd80      	pop	{r7, pc}

0800c2d8 <d_template_arg>:
 800c2d8:	b580      	push	{r7, lr}
 800c2da:	b084      	sub	sp, #16
 800c2dc:	af00      	add	r7, sp, #0
 800c2de:	6078      	str	r0, [r7, #4]
 800c2e0:	687b      	ldr	r3, [r7, #4]
 800c2e2:	68db      	ldr	r3, [r3, #12]
 800c2e4:	781b      	ldrb	r3, [r3, #0]
 800c2e6:	f1a3 0349 	sub.w	r3, r3, #73	; 0x49
 800c2ea:	2b0f      	cmp	r3, #15
 800c2ec:	d84d      	bhi.n	800c38a <d_template_arg+0xb2>
 800c2ee:	a201      	add	r2, pc, #4	; (adr r2, 800c2f4 <d_template_arg+0x1c>)
 800c2f0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c2f4:	0800c381 	.word	0x0800c381
 800c2f8:	0800c381 	.word	0x0800c381
 800c2fc:	0800c38b 	.word	0x0800c38b
 800c300:	0800c377 	.word	0x0800c377
 800c304:	0800c38b 	.word	0x0800c38b
 800c308:	0800c38b 	.word	0x0800c38b
 800c30c:	0800c38b 	.word	0x0800c38b
 800c310:	0800c38b 	.word	0x0800c38b
 800c314:	0800c38b 	.word	0x0800c38b
 800c318:	0800c38b 	.word	0x0800c38b
 800c31c:	0800c38b 	.word	0x0800c38b
 800c320:	0800c38b 	.word	0x0800c38b
 800c324:	0800c38b 	.word	0x0800c38b
 800c328:	0800c38b 	.word	0x0800c38b
 800c32c:	0800c38b 	.word	0x0800c38b
 800c330:	0800c335 	.word	0x0800c335
 800c334:	687b      	ldr	r3, [r7, #4]
 800c336:	68db      	ldr	r3, [r3, #12]
 800c338:	f103 0201 	add.w	r2, r3, #1
 800c33c:	687b      	ldr	r3, [r7, #4]
 800c33e:	60da      	str	r2, [r3, #12]
 800c340:	6878      	ldr	r0, [r7, #4]
 800c342:	f000 f883 	bl	800c44c <d_expression>
 800c346:	60f8      	str	r0, [r7, #12]
 800c348:	687b      	ldr	r3, [r7, #4]
 800c34a:	68db      	ldr	r3, [r3, #12]
 800c34c:	781b      	ldrb	r3, [r3, #0]
 800c34e:	2b45      	cmp	r3, #69	; 0x45
 800c350:	d108      	bne.n	800c364 <d_template_arg+0x8c>
 800c352:	687b      	ldr	r3, [r7, #4]
 800c354:	68db      	ldr	r3, [r3, #12]
 800c356:	f103 0201 	add.w	r2, r3, #1
 800c35a:	687b      	ldr	r3, [r7, #4]
 800c35c:	60da      	str	r2, [r3, #12]
 800c35e:	f04f 0300 	mov.w	r3, #0
 800c362:	e001      	b.n	800c368 <d_template_arg+0x90>
 800c364:	f04f 0301 	mov.w	r3, #1
 800c368:	2b00      	cmp	r3, #0
 800c36a:	d002      	beq.n	800c372 <d_template_arg+0x9a>
 800c36c:	f04f 0300 	mov.w	r3, #0
 800c370:	e00f      	b.n	800c392 <d_template_arg+0xba>
 800c372:	68fb      	ldr	r3, [r7, #12]
 800c374:	e00d      	b.n	800c392 <d_template_arg+0xba>
 800c376:	6878      	ldr	r0, [r7, #4]
 800c378:	f000 fb10 	bl	800c99c <d_expr_primary>
 800c37c:	4603      	mov	r3, r0
 800c37e:	e008      	b.n	800c392 <d_template_arg+0xba>
 800c380:	6878      	ldr	r0, [r7, #4]
 800c382:	f7ff ff3b 	bl	800c1fc <d_template_args>
 800c386:	4603      	mov	r3, r0
 800c388:	e003      	b.n	800c392 <d_template_arg+0xba>
 800c38a:	6878      	ldr	r0, [r7, #4]
 800c38c:	f7ff f84a 	bl	800b424 <d_type>
 800c390:	4603      	mov	r3, r0
 800c392:	4618      	mov	r0, r3
 800c394:	f107 0710 	add.w	r7, r7, #16
 800c398:	46bd      	mov	sp, r7
 800c39a:	bd80      	pop	{r7, pc}

0800c39c <d_exprlist>:
 800c39c:	b580      	push	{r7, lr}
 800c39e:	b086      	sub	sp, #24
 800c3a0:	af00      	add	r7, sp, #0
 800c3a2:	6078      	str	r0, [r7, #4]
 800c3a4:	460b      	mov	r3, r1
 800c3a6:	70fb      	strb	r3, [r7, #3]
 800c3a8:	f04f 0300 	mov.w	r3, #0
 800c3ac:	60fb      	str	r3, [r7, #12]
 800c3ae:	f107 030c 	add.w	r3, r7, #12
 800c3b2:	617b      	str	r3, [r7, #20]
 800c3b4:	687b      	ldr	r3, [r7, #4]
 800c3b6:	68db      	ldr	r3, [r3, #12]
 800c3b8:	781b      	ldrb	r3, [r3, #0]
 800c3ba:	78fa      	ldrb	r2, [r7, #3]
 800c3bc:	429a      	cmp	r2, r3
 800c3be:	d111      	bne.n	800c3e4 <d_exprlist+0x48>
 800c3c0:	687b      	ldr	r3, [r7, #4]
 800c3c2:	68db      	ldr	r3, [r3, #12]
 800c3c4:	f103 0201 	add.w	r2, r3, #1
 800c3c8:	687b      	ldr	r3, [r7, #4]
 800c3ca:	60da      	str	r2, [r3, #12]
 800c3cc:	6878      	ldr	r0, [r7, #4]
 800c3ce:	f04f 012a 	mov.w	r1, #42	; 0x2a
 800c3d2:	f04f 0200 	mov.w	r2, #0
 800c3d6:	f04f 0300 	mov.w	r3, #0
 800c3da:	f7fd fc03 	bl	8009be4 <d_make_comp>
 800c3de:	4603      	mov	r3, r0
 800c3e0:	e02f      	b.n	800c442 <d_exprlist+0xa6>
 800c3e2:	bf00      	nop
 800c3e4:	6878      	ldr	r0, [r7, #4]
 800c3e6:	f000 f831 	bl	800c44c <d_expression>
 800c3ea:	6138      	str	r0, [r7, #16]
 800c3ec:	693b      	ldr	r3, [r7, #16]
 800c3ee:	2b00      	cmp	r3, #0
 800c3f0:	d102      	bne.n	800c3f8 <d_exprlist+0x5c>
 800c3f2:	f04f 0300 	mov.w	r3, #0
 800c3f6:	e024      	b.n	800c442 <d_exprlist+0xa6>
 800c3f8:	6878      	ldr	r0, [r7, #4]
 800c3fa:	f04f 012a 	mov.w	r1, #42	; 0x2a
 800c3fe:	693a      	ldr	r2, [r7, #16]
 800c400:	f04f 0300 	mov.w	r3, #0
 800c404:	f7fd fbee 	bl	8009be4 <d_make_comp>
 800c408:	4602      	mov	r2, r0
 800c40a:	697b      	ldr	r3, [r7, #20]
 800c40c:	601a      	str	r2, [r3, #0]
 800c40e:	697b      	ldr	r3, [r7, #20]
 800c410:	681b      	ldr	r3, [r3, #0]
 800c412:	2b00      	cmp	r3, #0
 800c414:	d102      	bne.n	800c41c <d_exprlist+0x80>
 800c416:	f04f 0300 	mov.w	r3, #0
 800c41a:	e012      	b.n	800c442 <d_exprlist+0xa6>
 800c41c:	697b      	ldr	r3, [r7, #20]
 800c41e:	681b      	ldr	r3, [r3, #0]
 800c420:	f103 0308 	add.w	r3, r3, #8
 800c424:	617b      	str	r3, [r7, #20]
 800c426:	687b      	ldr	r3, [r7, #4]
 800c428:	68db      	ldr	r3, [r3, #12]
 800c42a:	781b      	ldrb	r3, [r3, #0]
 800c42c:	78fa      	ldrb	r2, [r7, #3]
 800c42e:	429a      	cmp	r2, r3
 800c430:	d1d7      	bne.n	800c3e2 <d_exprlist+0x46>
 800c432:	687b      	ldr	r3, [r7, #4]
 800c434:	68db      	ldr	r3, [r3, #12]
 800c436:	f103 0201 	add.w	r2, r3, #1
 800c43a:	687b      	ldr	r3, [r7, #4]
 800c43c:	60da      	str	r2, [r3, #12]
 800c43e:	bf00      	nop
 800c440:	68fb      	ldr	r3, [r7, #12]
 800c442:	4618      	mov	r0, r3
 800c444:	f107 0718 	add.w	r7, r7, #24
 800c448:	46bd      	mov	sp, r7
 800c44a:	bd80      	pop	{r7, pc}

0800c44c <d_expression>:
 800c44c:	b580      	push	{r7, lr}
 800c44e:	b092      	sub	sp, #72	; 0x48
 800c450:	af00      	add	r7, sp, #0
 800c452:	6078      	str	r0, [r7, #4]
 800c454:	687b      	ldr	r3, [r7, #4]
 800c456:	68db      	ldr	r3, [r3, #12]
 800c458:	781b      	ldrb	r3, [r3, #0]
 800c45a:	77fb      	strb	r3, [r7, #31]
 800c45c:	7ffb      	ldrb	r3, [r7, #31]
 800c45e:	2b4c      	cmp	r3, #76	; 0x4c
 800c460:	d104      	bne.n	800c46c <d_expression+0x20>
 800c462:	6878      	ldr	r0, [r7, #4]
 800c464:	f000 fa9a 	bl	800c99c <d_expr_primary>
 800c468:	4603      	mov	r3, r0
 800c46a:	e292      	b.n	800c992 <d_expression+0x546>
 800c46c:	7ffb      	ldrb	r3, [r7, #31]
 800c46e:	2b54      	cmp	r3, #84	; 0x54
 800c470:	d104      	bne.n	800c47c <d_expression+0x30>
 800c472:	6878      	ldr	r0, [r7, #4]
 800c474:	f7ff fe8e 	bl	800c194 <d_template_param>
 800c478:	4603      	mov	r3, r0
 800c47a:	e28a      	b.n	800c992 <d_expression+0x546>
 800c47c:	7ffb      	ldrb	r3, [r7, #31]
 800c47e:	2b73      	cmp	r3, #115	; 0x73
 800c480:	d135      	bne.n	800c4ee <d_expression+0xa2>
 800c482:	687b      	ldr	r3, [r7, #4]
 800c484:	68db      	ldr	r3, [r3, #12]
 800c486:	f103 0301 	add.w	r3, r3, #1
 800c48a:	781b      	ldrb	r3, [r3, #0]
 800c48c:	2b72      	cmp	r3, #114	; 0x72
 800c48e:	d12e      	bne.n	800c4ee <d_expression+0xa2>
 800c490:	687b      	ldr	r3, [r7, #4]
 800c492:	68db      	ldr	r3, [r3, #12]
 800c494:	f103 0202 	add.w	r2, r3, #2
 800c498:	687b      	ldr	r3, [r7, #4]
 800c49a:	60da      	str	r2, [r3, #12]
 800c49c:	6878      	ldr	r0, [r7, #4]
 800c49e:	f7fe ffc1 	bl	800b424 <d_type>
 800c4a2:	61b8      	str	r0, [r7, #24]
 800c4a4:	6878      	ldr	r0, [r7, #4]
 800c4a6:	f7fe f909 	bl	800a6bc <d_unqualified_name>
 800c4aa:	6178      	str	r0, [r7, #20]
 800c4ac:	687b      	ldr	r3, [r7, #4]
 800c4ae:	68db      	ldr	r3, [r3, #12]
 800c4b0:	781b      	ldrb	r3, [r3, #0]
 800c4b2:	2b49      	cmp	r3, #73	; 0x49
 800c4b4:	d008      	beq.n	800c4c8 <d_expression+0x7c>
 800c4b6:	6878      	ldr	r0, [r7, #4]
 800c4b8:	f04f 0101 	mov.w	r1, #1
 800c4bc:	69ba      	ldr	r2, [r7, #24]
 800c4be:	697b      	ldr	r3, [r7, #20]
 800c4c0:	f7fd fb90 	bl	8009be4 <d_make_comp>
 800c4c4:	4603      	mov	r3, r0
 800c4c6:	e264      	b.n	800c992 <d_expression+0x546>
 800c4c8:	6878      	ldr	r0, [r7, #4]
 800c4ca:	f7ff fe97 	bl	800c1fc <d_template_args>
 800c4ce:	4603      	mov	r3, r0
 800c4d0:	6878      	ldr	r0, [r7, #4]
 800c4d2:	f04f 0104 	mov.w	r1, #4
 800c4d6:	697a      	ldr	r2, [r7, #20]
 800c4d8:	f7fd fb84 	bl	8009be4 <d_make_comp>
 800c4dc:	4603      	mov	r3, r0
 800c4de:	6878      	ldr	r0, [r7, #4]
 800c4e0:	f04f 0101 	mov.w	r1, #1
 800c4e4:	69ba      	ldr	r2, [r7, #24]
 800c4e6:	f7fd fb7d 	bl	8009be4 <d_make_comp>
 800c4ea:	4603      	mov	r3, r0
 800c4ec:	e251      	b.n	800c992 <d_expression+0x546>
 800c4ee:	7ffb      	ldrb	r3, [r7, #31]
 800c4f0:	2b73      	cmp	r3, #115	; 0x73
 800c4f2:	d11a      	bne.n	800c52a <d_expression+0xde>
 800c4f4:	687b      	ldr	r3, [r7, #4]
 800c4f6:	68db      	ldr	r3, [r3, #12]
 800c4f8:	f103 0301 	add.w	r3, r3, #1
 800c4fc:	781b      	ldrb	r3, [r3, #0]
 800c4fe:	2b70      	cmp	r3, #112	; 0x70
 800c500:	d113      	bne.n	800c52a <d_expression+0xde>
 800c502:	687b      	ldr	r3, [r7, #4]
 800c504:	68db      	ldr	r3, [r3, #12]
 800c506:	f103 0202 	add.w	r2, r3, #2
 800c50a:	687b      	ldr	r3, [r7, #4]
 800c50c:	60da      	str	r2, [r3, #12]
 800c50e:	6878      	ldr	r0, [r7, #4]
 800c510:	f7ff ff9c 	bl	800c44c <d_expression>
 800c514:	4603      	mov	r3, r0
 800c516:	6878      	ldr	r0, [r7, #4]
 800c518:	f04f 0145 	mov.w	r1, #69	; 0x45
 800c51c:	461a      	mov	r2, r3
 800c51e:	f04f 0300 	mov.w	r3, #0
 800c522:	f7fd fb5f 	bl	8009be4 <d_make_comp>
 800c526:	4603      	mov	r3, r0
 800c528:	e233      	b.n	800c992 <d_expression+0x546>
 800c52a:	7ffb      	ldrb	r3, [r7, #31]
 800c52c:	2b66      	cmp	r3, #102	; 0x66
 800c52e:	d12e      	bne.n	800c58e <d_expression+0x142>
 800c530:	687b      	ldr	r3, [r7, #4]
 800c532:	68db      	ldr	r3, [r3, #12]
 800c534:	f103 0301 	add.w	r3, r3, #1
 800c538:	781b      	ldrb	r3, [r3, #0]
 800c53a:	2b70      	cmp	r3, #112	; 0x70
 800c53c:	d127      	bne.n	800c58e <d_expression+0x142>
 800c53e:	687b      	ldr	r3, [r7, #4]
 800c540:	68db      	ldr	r3, [r3, #12]
 800c542:	f103 0202 	add.w	r2, r3, #2
 800c546:	687b      	ldr	r3, [r7, #4]
 800c548:	60da      	str	r2, [r3, #12]
 800c54a:	687b      	ldr	r3, [r7, #4]
 800c54c:	68db      	ldr	r3, [r3, #12]
 800c54e:	781b      	ldrb	r3, [r3, #0]
 800c550:	2b54      	cmp	r3, #84	; 0x54
 800c552:	d109      	bne.n	800c568 <d_expression+0x11c>
 800c554:	687b      	ldr	r3, [r7, #4]
 800c556:	68db      	ldr	r3, [r3, #12]
 800c558:	f103 0201 	add.w	r2, r3, #1
 800c55c:	687b      	ldr	r3, [r7, #4]
 800c55e:	60da      	str	r2, [r3, #12]
 800c560:	f04f 0300 	mov.w	r3, #0
 800c564:	647b      	str	r3, [r7, #68]	; 0x44
 800c566:	e00c      	b.n	800c582 <d_expression+0x136>
 800c568:	6878      	ldr	r0, [r7, #4]
 800c56a:	f7ff fddb 	bl	800c124 <d_compact_number>
 800c56e:	4603      	mov	r3, r0
 800c570:	f103 0301 	add.w	r3, r3, #1
 800c574:	647b      	str	r3, [r7, #68]	; 0x44
 800c576:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c578:	2b00      	cmp	r3, #0
 800c57a:	d102      	bne.n	800c582 <d_expression+0x136>
 800c57c:	f04f 0300 	mov.w	r3, #0
 800c580:	e207      	b.n	800c992 <d_expression+0x546>
 800c582:	6878      	ldr	r0, [r7, #4]
 800c584:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800c586:	f7fd fd15 	bl	8009fb4 <d_make_function_param>
 800c58a:	4603      	mov	r3, r0
 800c58c:	e201      	b.n	800c992 <d_expression+0x546>
 800c58e:	7ffb      	ldrb	r3, [r7, #31]
 800c590:	2b2f      	cmp	r3, #47	; 0x2f
 800c592:	d902      	bls.n	800c59a <d_expression+0x14e>
 800c594:	7ffb      	ldrb	r3, [r7, #31]
 800c596:	2b39      	cmp	r3, #57	; 0x39
 800c598:	d909      	bls.n	800c5ae <d_expression+0x162>
 800c59a:	7ffb      	ldrb	r3, [r7, #31]
 800c59c:	2b6f      	cmp	r3, #111	; 0x6f
 800c59e:	d12c      	bne.n	800c5fa <d_expression+0x1ae>
 800c5a0:	687b      	ldr	r3, [r7, #4]
 800c5a2:	68db      	ldr	r3, [r3, #12]
 800c5a4:	f103 0301 	add.w	r3, r3, #1
 800c5a8:	781b      	ldrb	r3, [r3, #0]
 800c5aa:	2b6e      	cmp	r3, #110	; 0x6e
 800c5ac:	d125      	bne.n	800c5fa <d_expression+0x1ae>
 800c5ae:	7ffb      	ldrb	r3, [r7, #31]
 800c5b0:	2b6f      	cmp	r3, #111	; 0x6f
 800c5b2:	d105      	bne.n	800c5c0 <d_expression+0x174>
 800c5b4:	687b      	ldr	r3, [r7, #4]
 800c5b6:	68db      	ldr	r3, [r3, #12]
 800c5b8:	f103 0202 	add.w	r2, r3, #2
 800c5bc:	687b      	ldr	r3, [r7, #4]
 800c5be:	60da      	str	r2, [r3, #12]
 800c5c0:	6878      	ldr	r0, [r7, #4]
 800c5c2:	f7fe f87b 	bl	800a6bc <d_unqualified_name>
 800c5c6:	60b8      	str	r0, [r7, #8]
 800c5c8:	68bb      	ldr	r3, [r7, #8]
 800c5ca:	2b00      	cmp	r3, #0
 800c5cc:	d102      	bne.n	800c5d4 <d_expression+0x188>
 800c5ce:	f04f 0300 	mov.w	r3, #0
 800c5d2:	e1de      	b.n	800c992 <d_expression+0x546>
 800c5d4:	687b      	ldr	r3, [r7, #4]
 800c5d6:	68db      	ldr	r3, [r3, #12]
 800c5d8:	781b      	ldrb	r3, [r3, #0]
 800c5da:	2b49      	cmp	r3, #73	; 0x49
 800c5dc:	d10b      	bne.n	800c5f6 <d_expression+0x1aa>
 800c5de:	6878      	ldr	r0, [r7, #4]
 800c5e0:	f7ff fe0c 	bl	800c1fc <d_template_args>
 800c5e4:	4603      	mov	r3, r0
 800c5e6:	6878      	ldr	r0, [r7, #4]
 800c5e8:	f04f 0104 	mov.w	r1, #4
 800c5ec:	68ba      	ldr	r2, [r7, #8]
 800c5ee:	f7fd faf9 	bl	8009be4 <d_make_comp>
 800c5f2:	4603      	mov	r3, r0
 800c5f4:	e1cd      	b.n	800c992 <d_expression+0x546>
 800c5f6:	68bb      	ldr	r3, [r7, #8]
 800c5f8:	e1cb      	b.n	800c992 <d_expression+0x546>
 800c5fa:	7ffb      	ldrb	r3, [r7, #31]
 800c5fc:	2b69      	cmp	r3, #105	; 0x69
 800c5fe:	d002      	beq.n	800c606 <d_expression+0x1ba>
 800c600:	7ffb      	ldrb	r3, [r7, #31]
 800c602:	2b74      	cmp	r3, #116	; 0x74
 800c604:	d124      	bne.n	800c650 <d_expression+0x204>
 800c606:	687b      	ldr	r3, [r7, #4]
 800c608:	68db      	ldr	r3, [r3, #12]
 800c60a:	f103 0301 	add.w	r3, r3, #1
 800c60e:	781b      	ldrb	r3, [r3, #0]
 800c610:	2b6c      	cmp	r3, #108	; 0x6c
 800c612:	d11d      	bne.n	800c650 <d_expression+0x204>
 800c614:	f04f 0300 	mov.w	r3, #0
 800c618:	643b      	str	r3, [r7, #64]	; 0x40
 800c61a:	7ffb      	ldrb	r3, [r7, #31]
 800c61c:	2b74      	cmp	r3, #116	; 0x74
 800c61e:	d103      	bne.n	800c628 <d_expression+0x1dc>
 800c620:	6878      	ldr	r0, [r7, #4]
 800c622:	f7fe feff 	bl	800b424 <d_type>
 800c626:	6438      	str	r0, [r7, #64]	; 0x40
 800c628:	687b      	ldr	r3, [r7, #4]
 800c62a:	68db      	ldr	r3, [r3, #12]
 800c62c:	f103 0202 	add.w	r2, r3, #2
 800c630:	687b      	ldr	r3, [r7, #4]
 800c632:	60da      	str	r2, [r3, #12]
 800c634:	6878      	ldr	r0, [r7, #4]
 800c636:	f04f 0145 	mov.w	r1, #69	; 0x45
 800c63a:	f7ff feaf 	bl	800c39c <d_exprlist>
 800c63e:	4603      	mov	r3, r0
 800c640:	6878      	ldr	r0, [r7, #4]
 800c642:	f04f 012c 	mov.w	r1, #44	; 0x2c
 800c646:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800c648:	f7fd facc 	bl	8009be4 <d_make_comp>
 800c64c:	4603      	mov	r3, r0
 800c64e:	e1a0      	b.n	800c992 <d_expression+0x546>
 800c650:	f04f 0300 	mov.w	r3, #0
 800c654:	63fb      	str	r3, [r7, #60]	; 0x3c
 800c656:	6878      	ldr	r0, [r7, #4]
 800c658:	f7fe f9b8 	bl	800a9cc <d_operator_name>
 800c65c:	6138      	str	r0, [r7, #16]
 800c65e:	693b      	ldr	r3, [r7, #16]
 800c660:	2b00      	cmp	r3, #0
 800c662:	d102      	bne.n	800c66a <d_expression+0x21e>
 800c664:	f04f 0300 	mov.w	r3, #0
 800c668:	e193      	b.n	800c992 <d_expression+0x546>
 800c66a:	693b      	ldr	r3, [r7, #16]
 800c66c:	781b      	ldrb	r3, [r3, #0]
 800c66e:	2b2d      	cmp	r3, #45	; 0x2d
 800c670:	d123      	bne.n	800c6ba <d_expression+0x26e>
 800c672:	693b      	ldr	r3, [r7, #16]
 800c674:	685b      	ldr	r3, [r3, #4]
 800c676:	681b      	ldr	r3, [r3, #0]
 800c678:	63fb      	str	r3, [r7, #60]	; 0x3c
 800c67a:	687b      	ldr	r3, [r7, #4]
 800c67c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c67e:	693b      	ldr	r3, [r7, #16]
 800c680:	685b      	ldr	r3, [r3, #4]
 800c682:	689b      	ldr	r3, [r3, #8]
 800c684:	f1a3 0302 	sub.w	r3, r3, #2
 800c688:	18d2      	adds	r2, r2, r3
 800c68a:	687b      	ldr	r3, [r7, #4]
 800c68c:	631a      	str	r2, [r3, #48]	; 0x30
 800c68e:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800c690:	f24f 61d4 	movw	r1, #63188	; 0xf6d4
 800c694:	f6c0 0101 	movt	r1, #2049	; 0x801
 800c698:	f006 f922 	bl	80128e0 <strcmp>
 800c69c:	4603      	mov	r3, r0
 800c69e:	2b00      	cmp	r3, #0
 800c6a0:	d10b      	bne.n	800c6ba <d_expression+0x26e>
 800c6a2:	6878      	ldr	r0, [r7, #4]
 800c6a4:	f7fe febe 	bl	800b424 <d_type>
 800c6a8:	4603      	mov	r3, r0
 800c6aa:	6878      	ldr	r0, [r7, #4]
 800c6ac:	f04f 0131 	mov.w	r1, #49	; 0x31
 800c6b0:	693a      	ldr	r2, [r7, #16]
 800c6b2:	f7fd fa97 	bl	8009be4 <d_make_comp>
 800c6b6:	4603      	mov	r3, r0
 800c6b8:	e16b      	b.n	800c992 <d_expression+0x546>
 800c6ba:	693b      	ldr	r3, [r7, #16]
 800c6bc:	781b      	ldrb	r3, [r3, #0]
 800c6be:	2b2e      	cmp	r3, #46	; 0x2e
 800c6c0:	d00b      	beq.n	800c6da <d_expression+0x28e>
 800c6c2:	2b2f      	cmp	r3, #47	; 0x2f
 800c6c4:	d00d      	beq.n	800c6e2 <d_expression+0x296>
 800c6c6:	2b2d      	cmp	r3, #45	; 0x2d
 800c6c8:	d002      	beq.n	800c6d0 <d_expression+0x284>
 800c6ca:	f04f 0300 	mov.w	r3, #0
 800c6ce:	e160      	b.n	800c992 <d_expression+0x546>
 800c6d0:	693b      	ldr	r3, [r7, #16]
 800c6d2:	685b      	ldr	r3, [r3, #4]
 800c6d4:	68db      	ldr	r3, [r3, #12]
 800c6d6:	63bb      	str	r3, [r7, #56]	; 0x38
 800c6d8:	e007      	b.n	800c6ea <d_expression+0x29e>
 800c6da:	693b      	ldr	r3, [r7, #16]
 800c6dc:	685b      	ldr	r3, [r3, #4]
 800c6de:	63bb      	str	r3, [r7, #56]	; 0x38
 800c6e0:	e003      	b.n	800c6ea <d_expression+0x29e>
 800c6e2:	f04f 0301 	mov.w	r3, #1
 800c6e6:	63bb      	str	r3, [r7, #56]	; 0x38
 800c6e8:	bf00      	nop
 800c6ea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c6ec:	2b03      	cmp	r3, #3
 800c6ee:	f200 814e 	bhi.w	800c98e <d_expression+0x542>
 800c6f2:	a201      	add	r2, pc, #4	; (adr r2, 800c6f8 <d_expression+0x2ac>)
 800c6f4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c6f8:	0800c709 	.word	0x0800c709
 800c6fc:	0800c71d 	.word	0x0800c71d
 800c700:	0800c7d7 	.word	0x0800c7d7
 800c704:	0800c87b 	.word	0x0800c87b
 800c708:	6878      	ldr	r0, [r7, #4]
 800c70a:	f04f 0130 	mov.w	r1, #48	; 0x30
 800c70e:	693a      	ldr	r2, [r7, #16]
 800c710:	f04f 0300 	mov.w	r3, #0
 800c714:	f7fd fa66 	bl	8009be4 <d_make_comp>
 800c718:	4603      	mov	r3, r0
 800c71a:	e13a      	b.n	800c992 <d_expression+0x546>
 800c71c:	f04f 0300 	mov.w	r3, #0
 800c720:	633b      	str	r3, [r7, #48]	; 0x30
 800c722:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c724:	2b00      	cmp	r3, #0
 800c726:	d020      	beq.n	800c76a <d_expression+0x31e>
 800c728:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c72a:	781b      	ldrb	r3, [r3, #0]
 800c72c:	2b70      	cmp	r3, #112	; 0x70
 800c72e:	d003      	beq.n	800c738 <d_expression+0x2ec>
 800c730:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c732:	781b      	ldrb	r3, [r3, #0]
 800c734:	2b6d      	cmp	r3, #109	; 0x6d
 800c736:	d118      	bne.n	800c76a <d_expression+0x31e>
 800c738:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c73a:	f103 0301 	add.w	r3, r3, #1
 800c73e:	781a      	ldrb	r2, [r3, #0]
 800c740:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c742:	781b      	ldrb	r3, [r3, #0]
 800c744:	429a      	cmp	r2, r3
 800c746:	d110      	bne.n	800c76a <d_expression+0x31e>
 800c748:	687b      	ldr	r3, [r7, #4]
 800c74a:	68db      	ldr	r3, [r3, #12]
 800c74c:	781b      	ldrb	r3, [r3, #0]
 800c74e:	2b5f      	cmp	r3, #95	; 0x5f
 800c750:	d108      	bne.n	800c764 <d_expression+0x318>
 800c752:	687b      	ldr	r3, [r7, #4]
 800c754:	68db      	ldr	r3, [r3, #12]
 800c756:	f103 0201 	add.w	r2, r3, #1
 800c75a:	687b      	ldr	r3, [r7, #4]
 800c75c:	60da      	str	r2, [r3, #12]
 800c75e:	f04f 0300 	mov.w	r3, #0
 800c762:	e001      	b.n	800c768 <d_expression+0x31c>
 800c764:	f04f 0301 	mov.w	r3, #1
 800c768:	633b      	str	r3, [r7, #48]	; 0x30
 800c76a:	693b      	ldr	r3, [r7, #16]
 800c76c:	781b      	ldrb	r3, [r3, #0]
 800c76e:	2b2f      	cmp	r3, #47	; 0x2f
 800c770:	d111      	bne.n	800c796 <d_expression+0x34a>
 800c772:	687b      	ldr	r3, [r7, #4]
 800c774:	68db      	ldr	r3, [r3, #12]
 800c776:	781b      	ldrb	r3, [r3, #0]
 800c778:	2b5f      	cmp	r3, #95	; 0x5f
 800c77a:	d10c      	bne.n	800c796 <d_expression+0x34a>
 800c77c:	687b      	ldr	r3, [r7, #4]
 800c77e:	68db      	ldr	r3, [r3, #12]
 800c780:	f103 0201 	add.w	r2, r3, #1
 800c784:	687b      	ldr	r3, [r7, #4]
 800c786:	60da      	str	r2, [r3, #12]
 800c788:	6878      	ldr	r0, [r7, #4]
 800c78a:	f04f 0145 	mov.w	r1, #69	; 0x45
 800c78e:	f7ff fe05 	bl	800c39c <d_exprlist>
 800c792:	6378      	str	r0, [r7, #52]	; 0x34
 800c794:	e003      	b.n	800c79e <d_expression+0x352>
 800c796:	6878      	ldr	r0, [r7, #4]
 800c798:	f7ff fe58 	bl	800c44c <d_expression>
 800c79c:	6378      	str	r0, [r7, #52]	; 0x34
 800c79e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c7a0:	2b00      	cmp	r3, #0
 800c7a2:	d00f      	beq.n	800c7c4 <d_expression+0x378>
 800c7a4:	6878      	ldr	r0, [r7, #4]
 800c7a6:	f04f 0133 	mov.w	r1, #51	; 0x33
 800c7aa:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800c7ac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c7ae:	f7fd fa19 	bl	8009be4 <d_make_comp>
 800c7b2:	4603      	mov	r3, r0
 800c7b4:	6878      	ldr	r0, [r7, #4]
 800c7b6:	f04f 0131 	mov.w	r1, #49	; 0x31
 800c7ba:	693a      	ldr	r2, [r7, #16]
 800c7bc:	f7fd fa12 	bl	8009be4 <d_make_comp>
 800c7c0:	4603      	mov	r3, r0
 800c7c2:	e0e6      	b.n	800c992 <d_expression+0x546>
 800c7c4:	6878      	ldr	r0, [r7, #4]
 800c7c6:	f04f 0131 	mov.w	r1, #49	; 0x31
 800c7ca:	693a      	ldr	r2, [r7, #16]
 800c7cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c7ce:	f7fd fa09 	bl	8009be4 <d_make_comp>
 800c7d2:	4603      	mov	r3, r0
 800c7d4:	e0dd      	b.n	800c992 <d_expression+0x546>
 800c7d6:	6878      	ldr	r0, [r7, #4]
 800c7d8:	f7ff fe38 	bl	800c44c <d_expression>
 800c7dc:	60f8      	str	r0, [r7, #12]
 800c7de:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800c7e0:	f24f 515c 	movw	r1, #62812	; 0xf55c
 800c7e4:	f6c0 0101 	movt	r1, #2049	; 0x801
 800c7e8:	f006 f87a 	bl	80128e0 <strcmp>
 800c7ec:	4603      	mov	r3, r0
 800c7ee:	2b00      	cmp	r3, #0
 800c7f0:	d106      	bne.n	800c800 <d_expression+0x3b4>
 800c7f2:	6878      	ldr	r0, [r7, #4]
 800c7f4:	f04f 0145 	mov.w	r1, #69	; 0x45
 800c7f8:	f7ff fdd0 	bl	800c39c <d_exprlist>
 800c7fc:	62f8      	str	r0, [r7, #44]	; 0x2c
 800c7fe:	e02c      	b.n	800c85a <d_expression+0x40e>
 800c800:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800c802:	f24f 51a8 	movw	r1, #62888	; 0xf5a8
 800c806:	f6c0 0101 	movt	r1, #2049	; 0x801
 800c80a:	f006 f869 	bl	80128e0 <strcmp>
 800c80e:	4603      	mov	r3, r0
 800c810:	2b00      	cmp	r3, #0
 800c812:	d009      	beq.n	800c828 <d_expression+0x3dc>
 800c814:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800c816:	f24f 61a4 	movw	r1, #63140	; 0xf6a4
 800c81a:	f6c0 0101 	movt	r1, #2049	; 0x801
 800c81e:	f006 f85f 	bl	80128e0 <strcmp>
 800c822:	4603      	mov	r3, r0
 800c824:	2b00      	cmp	r3, #0
 800c826:	d114      	bne.n	800c852 <d_expression+0x406>
 800c828:	6878      	ldr	r0, [r7, #4]
 800c82a:	f7fd ff47 	bl	800a6bc <d_unqualified_name>
 800c82e:	62f8      	str	r0, [r7, #44]	; 0x2c
 800c830:	687b      	ldr	r3, [r7, #4]
 800c832:	68db      	ldr	r3, [r3, #12]
 800c834:	781b      	ldrb	r3, [r3, #0]
 800c836:	2b49      	cmp	r3, #73	; 0x49
 800c838:	d10f      	bne.n	800c85a <d_expression+0x40e>
 800c83a:	6878      	ldr	r0, [r7, #4]
 800c83c:	f7ff fcde 	bl	800c1fc <d_template_args>
 800c840:	4603      	mov	r3, r0
 800c842:	6878      	ldr	r0, [r7, #4]
 800c844:	f04f 0104 	mov.w	r1, #4
 800c848:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c84a:	f7fd f9cb 	bl	8009be4 <d_make_comp>
 800c84e:	62f8      	str	r0, [r7, #44]	; 0x2c
 800c850:	e003      	b.n	800c85a <d_expression+0x40e>
 800c852:	6878      	ldr	r0, [r7, #4]
 800c854:	f7ff fdfa 	bl	800c44c <d_expression>
 800c858:	62f8      	str	r0, [r7, #44]	; 0x2c
 800c85a:	6878      	ldr	r0, [r7, #4]
 800c85c:	f04f 0133 	mov.w	r1, #51	; 0x33
 800c860:	68fa      	ldr	r2, [r7, #12]
 800c862:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c864:	f7fd f9be 	bl	8009be4 <d_make_comp>
 800c868:	4603      	mov	r3, r0
 800c86a:	6878      	ldr	r0, [r7, #4]
 800c86c:	f04f 0132 	mov.w	r1, #50	; 0x32
 800c870:	693a      	ldr	r2, [r7, #16]
 800c872:	f7fd f9b7 	bl	8009be4 <d_make_comp>
 800c876:	4603      	mov	r3, r0
 800c878:	e08b      	b.n	800c992 <d_expression+0x546>
 800c87a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800c87c:	f24f 61ac 	movw	r1, #63148	; 0xf6ac
 800c880:	f6c0 0101 	movt	r1, #2049	; 0x801
 800c884:	f006 f82c 	bl	80128e0 <strcmp>
 800c888:	4603      	mov	r3, r0
 800c88a:	2b00      	cmp	r3, #0
 800c88c:	d10c      	bne.n	800c8a8 <d_expression+0x45c>
 800c88e:	6878      	ldr	r0, [r7, #4]
 800c890:	f7ff fddc 	bl	800c44c <d_expression>
 800c894:	62b8      	str	r0, [r7, #40]	; 0x28
 800c896:	6878      	ldr	r0, [r7, #4]
 800c898:	f7ff fdd8 	bl	800c44c <d_expression>
 800c89c:	6278      	str	r0, [r7, #36]	; 0x24
 800c89e:	6878      	ldr	r0, [r7, #4]
 800c8a0:	f7ff fdd4 	bl	800c44c <d_expression>
 800c8a4:	6238      	str	r0, [r7, #32]
 800c8a6:	e05b      	b.n	800c960 <d_expression+0x514>
 800c8a8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c8aa:	781b      	ldrb	r3, [r3, #0]
 800c8ac:	2b6e      	cmp	r3, #110	; 0x6e
 800c8ae:	d154      	bne.n	800c95a <d_expression+0x50e>
 800c8b0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c8b2:	f103 0301 	add.w	r3, r3, #1
 800c8b6:	781b      	ldrb	r3, [r3, #0]
 800c8b8:	2b77      	cmp	r3, #119	; 0x77
 800c8ba:	d008      	beq.n	800c8ce <d_expression+0x482>
 800c8bc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c8be:	f103 0301 	add.w	r3, r3, #1
 800c8c2:	781b      	ldrb	r3, [r3, #0]
 800c8c4:	2b61      	cmp	r3, #97	; 0x61
 800c8c6:	d002      	beq.n	800c8ce <d_expression+0x482>
 800c8c8:	f04f 0300 	mov.w	r3, #0
 800c8cc:	e061      	b.n	800c992 <d_expression+0x546>
 800c8ce:	6878      	ldr	r0, [r7, #4]
 800c8d0:	f04f 015f 	mov.w	r1, #95	; 0x5f
 800c8d4:	f7ff fd62 	bl	800c39c <d_exprlist>
 800c8d8:	62b8      	str	r0, [r7, #40]	; 0x28
 800c8da:	6878      	ldr	r0, [r7, #4]
 800c8dc:	f7fe fda2 	bl	800b424 <d_type>
 800c8e0:	6278      	str	r0, [r7, #36]	; 0x24
 800c8e2:	687b      	ldr	r3, [r7, #4]
 800c8e4:	68db      	ldr	r3, [r3, #12]
 800c8e6:	781b      	ldrb	r3, [r3, #0]
 800c8e8:	2b45      	cmp	r3, #69	; 0x45
 800c8ea:	d109      	bne.n	800c900 <d_expression+0x4b4>
 800c8ec:	687b      	ldr	r3, [r7, #4]
 800c8ee:	68db      	ldr	r3, [r3, #12]
 800c8f0:	f103 0201 	add.w	r2, r3, #1
 800c8f4:	687b      	ldr	r3, [r7, #4]
 800c8f6:	60da      	str	r2, [r3, #12]
 800c8f8:	f04f 0300 	mov.w	r3, #0
 800c8fc:	623b      	str	r3, [r7, #32]
 800c8fe:	e02f      	b.n	800c960 <d_expression+0x514>
 800c900:	687b      	ldr	r3, [r7, #4]
 800c902:	68db      	ldr	r3, [r3, #12]
 800c904:	781b      	ldrb	r3, [r3, #0]
 800c906:	2b70      	cmp	r3, #112	; 0x70
 800c908:	d113      	bne.n	800c932 <d_expression+0x4e6>
 800c90a:	687b      	ldr	r3, [r7, #4]
 800c90c:	68db      	ldr	r3, [r3, #12]
 800c90e:	f103 0301 	add.w	r3, r3, #1
 800c912:	781b      	ldrb	r3, [r3, #0]
 800c914:	2b69      	cmp	r3, #105	; 0x69
 800c916:	d10c      	bne.n	800c932 <d_expression+0x4e6>
 800c918:	687b      	ldr	r3, [r7, #4]
 800c91a:	68db      	ldr	r3, [r3, #12]
 800c91c:	f103 0202 	add.w	r2, r3, #2
 800c920:	687b      	ldr	r3, [r7, #4]
 800c922:	60da      	str	r2, [r3, #12]
 800c924:	6878      	ldr	r0, [r7, #4]
 800c926:	f04f 0145 	mov.w	r1, #69	; 0x45
 800c92a:	f7ff fd37 	bl	800c39c <d_exprlist>
 800c92e:	6238      	str	r0, [r7, #32]
 800c930:	e016      	b.n	800c960 <d_expression+0x514>
 800c932:	687b      	ldr	r3, [r7, #4]
 800c934:	68db      	ldr	r3, [r3, #12]
 800c936:	781b      	ldrb	r3, [r3, #0]
 800c938:	2b69      	cmp	r3, #105	; 0x69
 800c93a:	d10b      	bne.n	800c954 <d_expression+0x508>
 800c93c:	687b      	ldr	r3, [r7, #4]
 800c93e:	68db      	ldr	r3, [r3, #12]
 800c940:	f103 0301 	add.w	r3, r3, #1
 800c944:	781b      	ldrb	r3, [r3, #0]
 800c946:	2b6c      	cmp	r3, #108	; 0x6c
 800c948:	d104      	bne.n	800c954 <d_expression+0x508>
 800c94a:	6878      	ldr	r0, [r7, #4]
 800c94c:	f7ff fd7e 	bl	800c44c <d_expression>
 800c950:	6238      	str	r0, [r7, #32]
 800c952:	e005      	b.n	800c960 <d_expression+0x514>
 800c954:	f04f 0300 	mov.w	r3, #0
 800c958:	e01b      	b.n	800c992 <d_expression+0x546>
 800c95a:	f04f 0300 	mov.w	r3, #0
 800c95e:	e018      	b.n	800c992 <d_expression+0x546>
 800c960:	6878      	ldr	r0, [r7, #4]
 800c962:	f04f 0136 	mov.w	r1, #54	; 0x36
 800c966:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800c968:	6a3b      	ldr	r3, [r7, #32]
 800c96a:	f7fd f93b 	bl	8009be4 <d_make_comp>
 800c96e:	4603      	mov	r3, r0
 800c970:	6878      	ldr	r0, [r7, #4]
 800c972:	f04f 0135 	mov.w	r1, #53	; 0x35
 800c976:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800c978:	f7fd f934 	bl	8009be4 <d_make_comp>
 800c97c:	4603      	mov	r3, r0
 800c97e:	6878      	ldr	r0, [r7, #4]
 800c980:	f04f 0134 	mov.w	r1, #52	; 0x34
 800c984:	693a      	ldr	r2, [r7, #16]
 800c986:	f7fd f92d 	bl	8009be4 <d_make_comp>
 800c98a:	4603      	mov	r3, r0
 800c98c:	e001      	b.n	800c992 <d_expression+0x546>
 800c98e:	f04f 0300 	mov.w	r3, #0
 800c992:	4618      	mov	r0, r3
 800c994:	f107 0748 	add.w	r7, r7, #72	; 0x48
 800c998:	46bd      	mov	sp, r7
 800c99a:	bd80      	pop	{r7, pc}

0800c99c <d_expr_primary>:
 800c99c:	b580      	push	{r7, lr}
 800c99e:	b086      	sub	sp, #24
 800c9a0:	af00      	add	r7, sp, #0
 800c9a2:	6078      	str	r0, [r7, #4]
 800c9a4:	687b      	ldr	r3, [r7, #4]
 800c9a6:	68db      	ldr	r3, [r3, #12]
 800c9a8:	781b      	ldrb	r3, [r3, #0]
 800c9aa:	2b4c      	cmp	r3, #76	; 0x4c
 800c9ac:	d108      	bne.n	800c9c0 <d_expr_primary+0x24>
 800c9ae:	687b      	ldr	r3, [r7, #4]
 800c9b0:	68db      	ldr	r3, [r3, #12]
 800c9b2:	f103 0201 	add.w	r2, r3, #1
 800c9b6:	687b      	ldr	r3, [r7, #4]
 800c9b8:	60da      	str	r2, [r3, #12]
 800c9ba:	f04f 0300 	mov.w	r3, #0
 800c9be:	e001      	b.n	800c9c4 <d_expr_primary+0x28>
 800c9c0:	f04f 0301 	mov.w	r3, #1
 800c9c4:	2b00      	cmp	r3, #0
 800c9c6:	d002      	beq.n	800c9ce <d_expr_primary+0x32>
 800c9c8:	f04f 0300 	mov.w	r3, #0
 800c9cc:	e07b      	b.n	800cac6 <d_expr_primary+0x12a>
 800c9ce:	687b      	ldr	r3, [r7, #4]
 800c9d0:	68db      	ldr	r3, [r3, #12]
 800c9d2:	781b      	ldrb	r3, [r3, #0]
 800c9d4:	2b5f      	cmp	r3, #95	; 0x5f
 800c9d6:	d004      	beq.n	800c9e2 <d_expr_primary+0x46>
 800c9d8:	687b      	ldr	r3, [r7, #4]
 800c9da:	68db      	ldr	r3, [r3, #12]
 800c9dc:	781b      	ldrb	r3, [r3, #0]
 800c9de:	2b5a      	cmp	r3, #90	; 0x5a
 800c9e0:	d106      	bne.n	800c9f0 <d_expr_primary+0x54>
 800c9e2:	6878      	ldr	r0, [r7, #4]
 800c9e4:	f04f 0100 	mov.w	r1, #0
 800c9e8:	f7fd fb1c 	bl	800a024 <d_mangled_name>
 800c9ec:	6178      	str	r0, [r7, #20]
 800c9ee:	e054      	b.n	800ca9a <d_expr_primary+0xfe>
 800c9f0:	6878      	ldr	r0, [r7, #4]
 800c9f2:	f7fe fd17 	bl	800b424 <d_type>
 800c9f6:	60f8      	str	r0, [r7, #12]
 800c9f8:	68fb      	ldr	r3, [r7, #12]
 800c9fa:	2b00      	cmp	r3, #0
 800c9fc:	d102      	bne.n	800ca04 <d_expr_primary+0x68>
 800c9fe:	f04f 0300 	mov.w	r3, #0
 800ca02:	e060      	b.n	800cac6 <d_expr_primary+0x12a>
 800ca04:	68fb      	ldr	r3, [r7, #12]
 800ca06:	781b      	ldrb	r3, [r3, #0]
 800ca08:	2b23      	cmp	r3, #35	; 0x23
 800ca0a:	d10c      	bne.n	800ca26 <d_expr_primary+0x8a>
 800ca0c:	68fb      	ldr	r3, [r7, #12]
 800ca0e:	685b      	ldr	r3, [r3, #4]
 800ca10:	7c1b      	ldrb	r3, [r3, #16]
 800ca12:	2b00      	cmp	r3, #0
 800ca14:	d007      	beq.n	800ca26 <d_expr_primary+0x8a>
 800ca16:	687b      	ldr	r3, [r7, #4]
 800ca18:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ca1a:	68fb      	ldr	r3, [r7, #12]
 800ca1c:	685b      	ldr	r3, [r3, #4]
 800ca1e:	685b      	ldr	r3, [r3, #4]
 800ca20:	1ad2      	subs	r2, r2, r3
 800ca22:	687b      	ldr	r3, [r7, #4]
 800ca24:	631a      	str	r2, [r3, #48]	; 0x30
 800ca26:	f04f 0337 	mov.w	r3, #55	; 0x37
 800ca2a:	74fb      	strb	r3, [r7, #19]
 800ca2c:	687b      	ldr	r3, [r7, #4]
 800ca2e:	68db      	ldr	r3, [r3, #12]
 800ca30:	781b      	ldrb	r3, [r3, #0]
 800ca32:	2b6e      	cmp	r3, #110	; 0x6e
 800ca34:	d108      	bne.n	800ca48 <d_expr_primary+0xac>
 800ca36:	f04f 0338 	mov.w	r3, #56	; 0x38
 800ca3a:	74fb      	strb	r3, [r7, #19]
 800ca3c:	687b      	ldr	r3, [r7, #4]
 800ca3e:	68db      	ldr	r3, [r3, #12]
 800ca40:	f103 0201 	add.w	r2, r3, #1
 800ca44:	687b      	ldr	r3, [r7, #4]
 800ca46:	60da      	str	r2, [r3, #12]
 800ca48:	687b      	ldr	r3, [r7, #4]
 800ca4a:	68db      	ldr	r3, [r3, #12]
 800ca4c:	60bb      	str	r3, [r7, #8]
 800ca4e:	e00d      	b.n	800ca6c <d_expr_primary+0xd0>
 800ca50:	687b      	ldr	r3, [r7, #4]
 800ca52:	68db      	ldr	r3, [r3, #12]
 800ca54:	781b      	ldrb	r3, [r3, #0]
 800ca56:	2b00      	cmp	r3, #0
 800ca58:	d102      	bne.n	800ca60 <d_expr_primary+0xc4>
 800ca5a:	f04f 0300 	mov.w	r3, #0
 800ca5e:	e032      	b.n	800cac6 <d_expr_primary+0x12a>
 800ca60:	687b      	ldr	r3, [r7, #4]
 800ca62:	68db      	ldr	r3, [r3, #12]
 800ca64:	f103 0201 	add.w	r2, r3, #1
 800ca68:	687b      	ldr	r3, [r7, #4]
 800ca6a:	60da      	str	r2, [r3, #12]
 800ca6c:	687b      	ldr	r3, [r7, #4]
 800ca6e:	68db      	ldr	r3, [r3, #12]
 800ca70:	781b      	ldrb	r3, [r3, #0]
 800ca72:	2b45      	cmp	r3, #69	; 0x45
 800ca74:	d1ec      	bne.n	800ca50 <d_expr_primary+0xb4>
 800ca76:	687b      	ldr	r3, [r7, #4]
 800ca78:	68db      	ldr	r3, [r3, #12]
 800ca7a:	461a      	mov	r2, r3
 800ca7c:	68bb      	ldr	r3, [r7, #8]
 800ca7e:	1ad3      	subs	r3, r2, r3
 800ca80:	6878      	ldr	r0, [r7, #4]
 800ca82:	68b9      	ldr	r1, [r7, #8]
 800ca84:	461a      	mov	r2, r3
 800ca86:	f7fd f9af 	bl	8009de8 <d_make_name>
 800ca8a:	4603      	mov	r3, r0
 800ca8c:	7cfa      	ldrb	r2, [r7, #19]
 800ca8e:	6878      	ldr	r0, [r7, #4]
 800ca90:	4611      	mov	r1, r2
 800ca92:	68fa      	ldr	r2, [r7, #12]
 800ca94:	f7fd f8a6 	bl	8009be4 <d_make_comp>
 800ca98:	6178      	str	r0, [r7, #20]
 800ca9a:	687b      	ldr	r3, [r7, #4]
 800ca9c:	68db      	ldr	r3, [r3, #12]
 800ca9e:	781b      	ldrb	r3, [r3, #0]
 800caa0:	2b45      	cmp	r3, #69	; 0x45
 800caa2:	d108      	bne.n	800cab6 <d_expr_primary+0x11a>
 800caa4:	687b      	ldr	r3, [r7, #4]
 800caa6:	68db      	ldr	r3, [r3, #12]
 800caa8:	f103 0201 	add.w	r2, r3, #1
 800caac:	687b      	ldr	r3, [r7, #4]
 800caae:	60da      	str	r2, [r3, #12]
 800cab0:	f04f 0300 	mov.w	r3, #0
 800cab4:	e001      	b.n	800caba <d_expr_primary+0x11e>
 800cab6:	f04f 0301 	mov.w	r3, #1
 800caba:	2b00      	cmp	r3, #0
 800cabc:	d002      	beq.n	800cac4 <d_expr_primary+0x128>
 800cabe:	f04f 0300 	mov.w	r3, #0
 800cac2:	e000      	b.n	800cac6 <d_expr_primary+0x12a>
 800cac4:	697b      	ldr	r3, [r7, #20]
 800cac6:	4618      	mov	r0, r3
 800cac8:	f107 0718 	add.w	r7, r7, #24
 800cacc:	46bd      	mov	sp, r7
 800cace:	bd80      	pop	{r7, pc}

0800cad0 <d_local_name>:
 800cad0:	b580      	push	{r7, lr}
 800cad2:	b086      	sub	sp, #24
 800cad4:	af00      	add	r7, sp, #0
 800cad6:	6078      	str	r0, [r7, #4]
 800cad8:	687b      	ldr	r3, [r7, #4]
 800cada:	68db      	ldr	r3, [r3, #12]
 800cadc:	781b      	ldrb	r3, [r3, #0]
 800cade:	2b5a      	cmp	r3, #90	; 0x5a
 800cae0:	d108      	bne.n	800caf4 <d_local_name+0x24>
 800cae2:	687b      	ldr	r3, [r7, #4]
 800cae4:	68db      	ldr	r3, [r3, #12]
 800cae6:	f103 0201 	add.w	r2, r3, #1
 800caea:	687b      	ldr	r3, [r7, #4]
 800caec:	60da      	str	r2, [r3, #12]
 800caee:	f04f 0300 	mov.w	r3, #0
 800caf2:	e001      	b.n	800caf8 <d_local_name+0x28>
 800caf4:	f04f 0301 	mov.w	r3, #1
 800caf8:	2b00      	cmp	r3, #0
 800cafa:	d002      	beq.n	800cb02 <d_local_name+0x32>
 800cafc:	f04f 0300 	mov.w	r3, #0
 800cb00:	e080      	b.n	800cc04 <d_local_name+0x134>
 800cb02:	6878      	ldr	r0, [r7, #4]
 800cb04:	f04f 0100 	mov.w	r1, #0
 800cb08:	f7fd fbb2 	bl	800a270 <d_encoding>
 800cb0c:	60f8      	str	r0, [r7, #12]
 800cb0e:	687b      	ldr	r3, [r7, #4]
 800cb10:	68db      	ldr	r3, [r3, #12]
 800cb12:	781b      	ldrb	r3, [r3, #0]
 800cb14:	2b45      	cmp	r3, #69	; 0x45
 800cb16:	d108      	bne.n	800cb2a <d_local_name+0x5a>
 800cb18:	687b      	ldr	r3, [r7, #4]
 800cb1a:	68db      	ldr	r3, [r3, #12]
 800cb1c:	f103 0201 	add.w	r2, r3, #1
 800cb20:	687b      	ldr	r3, [r7, #4]
 800cb22:	60da      	str	r2, [r3, #12]
 800cb24:	f04f 0300 	mov.w	r3, #0
 800cb28:	e001      	b.n	800cb2e <d_local_name+0x5e>
 800cb2a:	f04f 0301 	mov.w	r3, #1
 800cb2e:	2b00      	cmp	r3, #0
 800cb30:	d002      	beq.n	800cb38 <d_local_name+0x68>
 800cb32:	f04f 0300 	mov.w	r3, #0
 800cb36:	e065      	b.n	800cc04 <d_local_name+0x134>
 800cb38:	687b      	ldr	r3, [r7, #4]
 800cb3a:	68db      	ldr	r3, [r3, #12]
 800cb3c:	781b      	ldrb	r3, [r3, #0]
 800cb3e:	2b73      	cmp	r3, #115	; 0x73
 800cb40:	d120      	bne.n	800cb84 <d_local_name+0xb4>
 800cb42:	687b      	ldr	r3, [r7, #4]
 800cb44:	68db      	ldr	r3, [r3, #12]
 800cb46:	f103 0201 	add.w	r2, r3, #1
 800cb4a:	687b      	ldr	r3, [r7, #4]
 800cb4c:	60da      	str	r2, [r3, #12]
 800cb4e:	6878      	ldr	r0, [r7, #4]
 800cb50:	f000 f85e 	bl	800cc10 <d_discriminator>
 800cb54:	4603      	mov	r3, r0
 800cb56:	2b00      	cmp	r3, #0
 800cb58:	d102      	bne.n	800cb60 <d_local_name+0x90>
 800cb5a:	f04f 0300 	mov.w	r3, #0
 800cb5e:	e051      	b.n	800cc04 <d_local_name+0x134>
 800cb60:	6878      	ldr	r0, [r7, #4]
 800cb62:	f64f 21a4 	movw	r1, #64164	; 0xfaa4
 800cb66:	f6c0 0101 	movt	r1, #2049	; 0x801
 800cb6a:	f04f 020e 	mov.w	r2, #14
 800cb6e:	f7fd f93b 	bl	8009de8 <d_make_name>
 800cb72:	4603      	mov	r3, r0
 800cb74:	6878      	ldr	r0, [r7, #4]
 800cb76:	f04f 0102 	mov.w	r1, #2
 800cb7a:	68fa      	ldr	r2, [r7, #12]
 800cb7c:	f7fd f832 	bl	8009be4 <d_make_comp>
 800cb80:	4603      	mov	r3, r0
 800cb82:	e03f      	b.n	800cc04 <d_local_name+0x134>
 800cb84:	f04f 33ff 	mov.w	r3, #4294967295
 800cb88:	613b      	str	r3, [r7, #16]
 800cb8a:	687b      	ldr	r3, [r7, #4]
 800cb8c:	68db      	ldr	r3, [r3, #12]
 800cb8e:	781b      	ldrb	r3, [r3, #0]
 800cb90:	2b64      	cmp	r3, #100	; 0x64
 800cb92:	d10f      	bne.n	800cbb4 <d_local_name+0xe4>
 800cb94:	687b      	ldr	r3, [r7, #4]
 800cb96:	68db      	ldr	r3, [r3, #12]
 800cb98:	f103 0201 	add.w	r2, r3, #1
 800cb9c:	687b      	ldr	r3, [r7, #4]
 800cb9e:	60da      	str	r2, [r3, #12]
 800cba0:	6878      	ldr	r0, [r7, #4]
 800cba2:	f7ff fabf 	bl	800c124 <d_compact_number>
 800cba6:	6138      	str	r0, [r7, #16]
 800cba8:	693b      	ldr	r3, [r7, #16]
 800cbaa:	2b00      	cmp	r3, #0
 800cbac:	da02      	bge.n	800cbb4 <d_local_name+0xe4>
 800cbae:	f04f 0300 	mov.w	r3, #0
 800cbb2:	e027      	b.n	800cc04 <d_local_name+0x134>
 800cbb4:	6878      	ldr	r0, [r7, #4]
 800cbb6:	f7fd fbcf 	bl	800a358 <d_name>
 800cbba:	6178      	str	r0, [r7, #20]
 800cbbc:	697b      	ldr	r3, [r7, #20]
 800cbbe:	2b00      	cmp	r3, #0
 800cbc0:	d00f      	beq.n	800cbe2 <d_local_name+0x112>
 800cbc2:	697b      	ldr	r3, [r7, #20]
 800cbc4:	781b      	ldrb	r3, [r3, #0]
 800cbc6:	2b40      	cmp	r3, #64	; 0x40
 800cbc8:	d00a      	beq.n	800cbe0 <d_local_name+0x110>
 800cbca:	2b42      	cmp	r3, #66	; 0x42
 800cbcc:	d008      	beq.n	800cbe0 <d_local_name+0x110>
 800cbce:	6878      	ldr	r0, [r7, #4]
 800cbd0:	f000 f81e 	bl	800cc10 <d_discriminator>
 800cbd4:	4603      	mov	r3, r0
 800cbd6:	2b00      	cmp	r3, #0
 800cbd8:	d103      	bne.n	800cbe2 <d_local_name+0x112>
 800cbda:	f04f 0300 	mov.w	r3, #0
 800cbde:	e011      	b.n	800cc04 <d_local_name+0x134>
 800cbe0:	bf00      	nop
 800cbe2:	693b      	ldr	r3, [r7, #16]
 800cbe4:	2b00      	cmp	r3, #0
 800cbe6:	db05      	blt.n	800cbf4 <d_local_name+0x124>
 800cbe8:	6878      	ldr	r0, [r7, #4]
 800cbea:	6939      	ldr	r1, [r7, #16]
 800cbec:	697a      	ldr	r2, [r7, #20]
 800cbee:	f7fd f96d 	bl	8009ecc <d_make_default_arg>
 800cbf2:	6178      	str	r0, [r7, #20]
 800cbf4:	6878      	ldr	r0, [r7, #4]
 800cbf6:	f04f 0102 	mov.w	r1, #2
 800cbfa:	68fa      	ldr	r2, [r7, #12]
 800cbfc:	697b      	ldr	r3, [r7, #20]
 800cbfe:	f7fc fff1 	bl	8009be4 <d_make_comp>
 800cc02:	4603      	mov	r3, r0
 800cc04:	4618      	mov	r0, r3
 800cc06:	f107 0718 	add.w	r7, r7, #24
 800cc0a:	46bd      	mov	sp, r7
 800cc0c:	bd80      	pop	{r7, pc}
 800cc0e:	bf00      	nop

0800cc10 <d_discriminator>:
 800cc10:	b580      	push	{r7, lr}
 800cc12:	b084      	sub	sp, #16
 800cc14:	af00      	add	r7, sp, #0
 800cc16:	6078      	str	r0, [r7, #4]
 800cc18:	687b      	ldr	r3, [r7, #4]
 800cc1a:	68db      	ldr	r3, [r3, #12]
 800cc1c:	781b      	ldrb	r3, [r3, #0]
 800cc1e:	2b5f      	cmp	r3, #95	; 0x5f
 800cc20:	d002      	beq.n	800cc28 <d_discriminator+0x18>
 800cc22:	f04f 0301 	mov.w	r3, #1
 800cc26:	e011      	b.n	800cc4c <d_discriminator+0x3c>
 800cc28:	687b      	ldr	r3, [r7, #4]
 800cc2a:	68db      	ldr	r3, [r3, #12]
 800cc2c:	f103 0201 	add.w	r2, r3, #1
 800cc30:	687b      	ldr	r3, [r7, #4]
 800cc32:	60da      	str	r2, [r3, #12]
 800cc34:	6878      	ldr	r0, [r7, #4]
 800cc36:	f7fd fdf1 	bl	800a81c <d_number>
 800cc3a:	60f8      	str	r0, [r7, #12]
 800cc3c:	68fb      	ldr	r3, [r7, #12]
 800cc3e:	2b00      	cmp	r3, #0
 800cc40:	da02      	bge.n	800cc48 <d_discriminator+0x38>
 800cc42:	f04f 0300 	mov.w	r3, #0
 800cc46:	e001      	b.n	800cc4c <d_discriminator+0x3c>
 800cc48:	f04f 0301 	mov.w	r3, #1
 800cc4c:	4618      	mov	r0, r3
 800cc4e:	f107 0710 	add.w	r7, r7, #16
 800cc52:	46bd      	mov	sp, r7
 800cc54:	bd80      	pop	{r7, pc}
 800cc56:	bf00      	nop

0800cc58 <d_lambda>:
 800cc58:	b580      	push	{r7, lr}
 800cc5a:	b086      	sub	sp, #24
 800cc5c:	af00      	add	r7, sp, #0
 800cc5e:	6078      	str	r0, [r7, #4]
 800cc60:	687b      	ldr	r3, [r7, #4]
 800cc62:	68db      	ldr	r3, [r3, #12]
 800cc64:	781b      	ldrb	r3, [r3, #0]
 800cc66:	2b55      	cmp	r3, #85	; 0x55
 800cc68:	d108      	bne.n	800cc7c <d_lambda+0x24>
 800cc6a:	687b      	ldr	r3, [r7, #4]
 800cc6c:	68db      	ldr	r3, [r3, #12]
 800cc6e:	f103 0201 	add.w	r2, r3, #1
 800cc72:	687b      	ldr	r3, [r7, #4]
 800cc74:	60da      	str	r2, [r3, #12]
 800cc76:	f04f 0300 	mov.w	r3, #0
 800cc7a:	e001      	b.n	800cc80 <d_lambda+0x28>
 800cc7c:	f04f 0301 	mov.w	r3, #1
 800cc80:	2b00      	cmp	r3, #0
 800cc82:	d002      	beq.n	800cc8a <d_lambda+0x32>
 800cc84:	f04f 0300 	mov.w	r3, #0
 800cc88:	e059      	b.n	800cd3e <d_lambda+0xe6>
 800cc8a:	687b      	ldr	r3, [r7, #4]
 800cc8c:	68db      	ldr	r3, [r3, #12]
 800cc8e:	781b      	ldrb	r3, [r3, #0]
 800cc90:	2b6c      	cmp	r3, #108	; 0x6c
 800cc92:	d108      	bne.n	800cca6 <d_lambda+0x4e>
 800cc94:	687b      	ldr	r3, [r7, #4]
 800cc96:	68db      	ldr	r3, [r3, #12]
 800cc98:	f103 0201 	add.w	r2, r3, #1
 800cc9c:	687b      	ldr	r3, [r7, #4]
 800cc9e:	60da      	str	r2, [r3, #12]
 800cca0:	f04f 0300 	mov.w	r3, #0
 800cca4:	e001      	b.n	800ccaa <d_lambda+0x52>
 800cca6:	f04f 0301 	mov.w	r3, #1
 800ccaa:	2b00      	cmp	r3, #0
 800ccac:	d002      	beq.n	800ccb4 <d_lambda+0x5c>
 800ccae:	f04f 0300 	mov.w	r3, #0
 800ccb2:	e044      	b.n	800cd3e <d_lambda+0xe6>
 800ccb4:	6878      	ldr	r0, [r7, #4]
 800ccb6:	f7ff f869 	bl	800bd8c <d_parmlist>
 800ccba:	6178      	str	r0, [r7, #20]
 800ccbc:	697b      	ldr	r3, [r7, #20]
 800ccbe:	2b00      	cmp	r3, #0
 800ccc0:	d102      	bne.n	800ccc8 <d_lambda+0x70>
 800ccc2:	f04f 0300 	mov.w	r3, #0
 800ccc6:	e03a      	b.n	800cd3e <d_lambda+0xe6>
 800ccc8:	687b      	ldr	r3, [r7, #4]
 800ccca:	68db      	ldr	r3, [r3, #12]
 800cccc:	781b      	ldrb	r3, [r3, #0]
 800ccce:	2b45      	cmp	r3, #69	; 0x45
 800ccd0:	d108      	bne.n	800cce4 <d_lambda+0x8c>
 800ccd2:	687b      	ldr	r3, [r7, #4]
 800ccd4:	68db      	ldr	r3, [r3, #12]
 800ccd6:	f103 0201 	add.w	r2, r3, #1
 800ccda:	687b      	ldr	r3, [r7, #4]
 800ccdc:	60da      	str	r2, [r3, #12]
 800ccde:	f04f 0300 	mov.w	r3, #0
 800cce2:	e001      	b.n	800cce8 <d_lambda+0x90>
 800cce4:	f04f 0301 	mov.w	r3, #1
 800cce8:	2b00      	cmp	r3, #0
 800ccea:	d002      	beq.n	800ccf2 <d_lambda+0x9a>
 800ccec:	f04f 0300 	mov.w	r3, #0
 800ccf0:	e025      	b.n	800cd3e <d_lambda+0xe6>
 800ccf2:	6878      	ldr	r0, [r7, #4]
 800ccf4:	f7ff fa16 	bl	800c124 <d_compact_number>
 800ccf8:	6138      	str	r0, [r7, #16]
 800ccfa:	693b      	ldr	r3, [r7, #16]
 800ccfc:	2b00      	cmp	r3, #0
 800ccfe:	da02      	bge.n	800cd06 <d_lambda+0xae>
 800cd00:	f04f 0300 	mov.w	r3, #0
 800cd04:	e01b      	b.n	800cd3e <d_lambda+0xe6>
 800cd06:	6878      	ldr	r0, [r7, #4]
 800cd08:	f7fc ff44 	bl	8009b94 <d_make_empty>
 800cd0c:	60f8      	str	r0, [r7, #12]
 800cd0e:	68fb      	ldr	r3, [r7, #12]
 800cd10:	2b00      	cmp	r3, #0
 800cd12:	d009      	beq.n	800cd28 <d_lambda+0xd0>
 800cd14:	68fb      	ldr	r3, [r7, #12]
 800cd16:	f04f 0240 	mov.w	r2, #64	; 0x40
 800cd1a:	701a      	strb	r2, [r3, #0]
 800cd1c:	68fb      	ldr	r3, [r7, #12]
 800cd1e:	697a      	ldr	r2, [r7, #20]
 800cd20:	605a      	str	r2, [r3, #4]
 800cd22:	68fb      	ldr	r3, [r7, #12]
 800cd24:	693a      	ldr	r2, [r7, #16]
 800cd26:	609a      	str	r2, [r3, #8]
 800cd28:	6878      	ldr	r0, [r7, #4]
 800cd2a:	68f9      	ldr	r1, [r7, #12]
 800cd2c:	f000 f8da 	bl	800cee4 <d_add_substitution>
 800cd30:	4603      	mov	r3, r0
 800cd32:	2b00      	cmp	r3, #0
 800cd34:	d102      	bne.n	800cd3c <d_lambda+0xe4>
 800cd36:	f04f 0300 	mov.w	r3, #0
 800cd3a:	e000      	b.n	800cd3e <d_lambda+0xe6>
 800cd3c:	68fb      	ldr	r3, [r7, #12]
 800cd3e:	4618      	mov	r0, r3
 800cd40:	f107 0718 	add.w	r7, r7, #24
 800cd44:	46bd      	mov	sp, r7
 800cd46:	bd80      	pop	{r7, pc}

0800cd48 <d_unnamed_type>:
 800cd48:	b580      	push	{r7, lr}
 800cd4a:	b084      	sub	sp, #16
 800cd4c:	af00      	add	r7, sp, #0
 800cd4e:	6078      	str	r0, [r7, #4]
 800cd50:	687b      	ldr	r3, [r7, #4]
 800cd52:	68db      	ldr	r3, [r3, #12]
 800cd54:	781b      	ldrb	r3, [r3, #0]
 800cd56:	2b55      	cmp	r3, #85	; 0x55
 800cd58:	d108      	bne.n	800cd6c <d_unnamed_type+0x24>
 800cd5a:	687b      	ldr	r3, [r7, #4]
 800cd5c:	68db      	ldr	r3, [r3, #12]
 800cd5e:	f103 0201 	add.w	r2, r3, #1
 800cd62:	687b      	ldr	r3, [r7, #4]
 800cd64:	60da      	str	r2, [r3, #12]
 800cd66:	f04f 0300 	mov.w	r3, #0
 800cd6a:	e001      	b.n	800cd70 <d_unnamed_type+0x28>
 800cd6c:	f04f 0301 	mov.w	r3, #1
 800cd70:	2b00      	cmp	r3, #0
 800cd72:	d002      	beq.n	800cd7a <d_unnamed_type+0x32>
 800cd74:	f04f 0300 	mov.w	r3, #0
 800cd78:	e037      	b.n	800cdea <d_unnamed_type+0xa2>
 800cd7a:	687b      	ldr	r3, [r7, #4]
 800cd7c:	68db      	ldr	r3, [r3, #12]
 800cd7e:	781b      	ldrb	r3, [r3, #0]
 800cd80:	2b74      	cmp	r3, #116	; 0x74
 800cd82:	d108      	bne.n	800cd96 <d_unnamed_type+0x4e>
 800cd84:	687b      	ldr	r3, [r7, #4]
 800cd86:	68db      	ldr	r3, [r3, #12]
 800cd88:	f103 0201 	add.w	r2, r3, #1
 800cd8c:	687b      	ldr	r3, [r7, #4]
 800cd8e:	60da      	str	r2, [r3, #12]
 800cd90:	f04f 0300 	mov.w	r3, #0
 800cd94:	e001      	b.n	800cd9a <d_unnamed_type+0x52>
 800cd96:	f04f 0301 	mov.w	r3, #1
 800cd9a:	2b00      	cmp	r3, #0
 800cd9c:	d002      	beq.n	800cda4 <d_unnamed_type+0x5c>
 800cd9e:	f04f 0300 	mov.w	r3, #0
 800cda2:	e022      	b.n	800cdea <d_unnamed_type+0xa2>
 800cda4:	6878      	ldr	r0, [r7, #4]
 800cda6:	f7ff f9bd 	bl	800c124 <d_compact_number>
 800cdaa:	60f8      	str	r0, [r7, #12]
 800cdac:	68fb      	ldr	r3, [r7, #12]
 800cdae:	2b00      	cmp	r3, #0
 800cdb0:	da02      	bge.n	800cdb8 <d_unnamed_type+0x70>
 800cdb2:	f04f 0300 	mov.w	r3, #0
 800cdb6:	e018      	b.n	800cdea <d_unnamed_type+0xa2>
 800cdb8:	6878      	ldr	r0, [r7, #4]
 800cdba:	f7fc feeb 	bl	8009b94 <d_make_empty>
 800cdbe:	60b8      	str	r0, [r7, #8]
 800cdc0:	68bb      	ldr	r3, [r7, #8]
 800cdc2:	2b00      	cmp	r3, #0
 800cdc4:	d006      	beq.n	800cdd4 <d_unnamed_type+0x8c>
 800cdc6:	68bb      	ldr	r3, [r7, #8]
 800cdc8:	f04f 0242 	mov.w	r2, #66	; 0x42
 800cdcc:	701a      	strb	r2, [r3, #0]
 800cdce:	68bb      	ldr	r3, [r7, #8]
 800cdd0:	68fa      	ldr	r2, [r7, #12]
 800cdd2:	605a      	str	r2, [r3, #4]
 800cdd4:	6878      	ldr	r0, [r7, #4]
 800cdd6:	68b9      	ldr	r1, [r7, #8]
 800cdd8:	f000 f884 	bl	800cee4 <d_add_substitution>
 800cddc:	4603      	mov	r3, r0
 800cdde:	2b00      	cmp	r3, #0
 800cde0:	d102      	bne.n	800cde8 <d_unnamed_type+0xa0>
 800cde2:	f04f 0300 	mov.w	r3, #0
 800cde6:	e000      	b.n	800cdea <d_unnamed_type+0xa2>
 800cde8:	68bb      	ldr	r3, [r7, #8]
 800cdea:	4618      	mov	r0, r3
 800cdec:	f107 0710 	add.w	r7, r7, #16
 800cdf0:	46bd      	mov	sp, r7
 800cdf2:	bd80      	pop	{r7, pc}

0800cdf4 <d_clone_suffix>:
 800cdf4:	b580      	push	{r7, lr}
 800cdf6:	b086      	sub	sp, #24
 800cdf8:	af00      	add	r7, sp, #0
 800cdfa:	6078      	str	r0, [r7, #4]
 800cdfc:	6039      	str	r1, [r7, #0]
 800cdfe:	687b      	ldr	r3, [r7, #4]
 800ce00:	68db      	ldr	r3, [r3, #12]
 800ce02:	613b      	str	r3, [r7, #16]
 800ce04:	693b      	ldr	r3, [r7, #16]
 800ce06:	617b      	str	r3, [r7, #20]
 800ce08:	697b      	ldr	r3, [r7, #20]
 800ce0a:	781b      	ldrb	r3, [r3, #0]
 800ce0c:	2b2e      	cmp	r3, #46	; 0x2e
 800ce0e:	d139      	bne.n	800ce84 <d_clone_suffix+0x90>
 800ce10:	697b      	ldr	r3, [r7, #20]
 800ce12:	f103 0301 	add.w	r3, r3, #1
 800ce16:	781b      	ldrb	r3, [r3, #0]
 800ce18:	2b60      	cmp	r3, #96	; 0x60
 800ce1a:	d905      	bls.n	800ce28 <d_clone_suffix+0x34>
 800ce1c:	697b      	ldr	r3, [r7, #20]
 800ce1e:	f103 0301 	add.w	r3, r3, #1
 800ce22:	781b      	ldrb	r3, [r3, #0]
 800ce24:	2b7a      	cmp	r3, #122	; 0x7a
 800ce26:	d905      	bls.n	800ce34 <d_clone_suffix+0x40>
 800ce28:	697b      	ldr	r3, [r7, #20]
 800ce2a:	f103 0301 	add.w	r3, r3, #1
 800ce2e:	781b      	ldrb	r3, [r3, #0]
 800ce30:	2b5f      	cmp	r3, #95	; 0x5f
 800ce32:	d127      	bne.n	800ce84 <d_clone_suffix+0x90>
 800ce34:	697b      	ldr	r3, [r7, #20]
 800ce36:	f103 0302 	add.w	r3, r3, #2
 800ce3a:	617b      	str	r3, [r7, #20]
 800ce3c:	e003      	b.n	800ce46 <d_clone_suffix+0x52>
 800ce3e:	697b      	ldr	r3, [r7, #20]
 800ce40:	f103 0301 	add.w	r3, r3, #1
 800ce44:	617b      	str	r3, [r7, #20]
 800ce46:	697b      	ldr	r3, [r7, #20]
 800ce48:	781b      	ldrb	r3, [r3, #0]
 800ce4a:	2b60      	cmp	r3, #96	; 0x60
 800ce4c:	d903      	bls.n	800ce56 <d_clone_suffix+0x62>
 800ce4e:	697b      	ldr	r3, [r7, #20]
 800ce50:	781b      	ldrb	r3, [r3, #0]
 800ce52:	2b7a      	cmp	r3, #122	; 0x7a
 800ce54:	d9f3      	bls.n	800ce3e <d_clone_suffix+0x4a>
 800ce56:	697b      	ldr	r3, [r7, #20]
 800ce58:	781b      	ldrb	r3, [r3, #0]
 800ce5a:	2b5f      	cmp	r3, #95	; 0x5f
 800ce5c:	d0ef      	beq.n	800ce3e <d_clone_suffix+0x4a>
 800ce5e:	e011      	b.n	800ce84 <d_clone_suffix+0x90>
 800ce60:	697b      	ldr	r3, [r7, #20]
 800ce62:	f103 0302 	add.w	r3, r3, #2
 800ce66:	617b      	str	r3, [r7, #20]
 800ce68:	e003      	b.n	800ce72 <d_clone_suffix+0x7e>
 800ce6a:	697b      	ldr	r3, [r7, #20]
 800ce6c:	f103 0301 	add.w	r3, r3, #1
 800ce70:	617b      	str	r3, [r7, #20]
 800ce72:	697b      	ldr	r3, [r7, #20]
 800ce74:	781b      	ldrb	r3, [r3, #0]
 800ce76:	2b2f      	cmp	r3, #47	; 0x2f
 800ce78:	d905      	bls.n	800ce86 <d_clone_suffix+0x92>
 800ce7a:	697b      	ldr	r3, [r7, #20]
 800ce7c:	781b      	ldrb	r3, [r3, #0]
 800ce7e:	2b39      	cmp	r3, #57	; 0x39
 800ce80:	d9f3      	bls.n	800ce6a <d_clone_suffix+0x76>
 800ce82:	e000      	b.n	800ce86 <d_clone_suffix+0x92>
 800ce84:	bf00      	nop
 800ce86:	697b      	ldr	r3, [r7, #20]
 800ce88:	781b      	ldrb	r3, [r3, #0]
 800ce8a:	2b2e      	cmp	r3, #46	; 0x2e
 800ce8c:	d10b      	bne.n	800cea6 <d_clone_suffix+0xb2>
 800ce8e:	697b      	ldr	r3, [r7, #20]
 800ce90:	f103 0301 	add.w	r3, r3, #1
 800ce94:	781b      	ldrb	r3, [r3, #0]
 800ce96:	2b2f      	cmp	r3, #47	; 0x2f
 800ce98:	d905      	bls.n	800cea6 <d_clone_suffix+0xb2>
 800ce9a:	697b      	ldr	r3, [r7, #20]
 800ce9c:	f103 0301 	add.w	r3, r3, #1
 800cea0:	781b      	ldrb	r3, [r3, #0]
 800cea2:	2b39      	cmp	r3, #57	; 0x39
 800cea4:	d9dc      	bls.n	800ce60 <d_clone_suffix+0x6c>
 800cea6:	687b      	ldr	r3, [r7, #4]
 800cea8:	68da      	ldr	r2, [r3, #12]
 800ceaa:	6979      	ldr	r1, [r7, #20]
 800ceac:	693b      	ldr	r3, [r7, #16]
 800ceae:	1acb      	subs	r3, r1, r3
 800ceb0:	18d2      	adds	r2, r2, r3
 800ceb2:	687b      	ldr	r3, [r7, #4]
 800ceb4:	60da      	str	r2, [r3, #12]
 800ceb6:	697a      	ldr	r2, [r7, #20]
 800ceb8:	693b      	ldr	r3, [r7, #16]
 800ceba:	1ad3      	subs	r3, r2, r3
 800cebc:	6878      	ldr	r0, [r7, #4]
 800cebe:	6939      	ldr	r1, [r7, #16]
 800cec0:	461a      	mov	r2, r3
 800cec2:	f7fc ff91 	bl	8009de8 <d_make_name>
 800cec6:	60f8      	str	r0, [r7, #12]
 800cec8:	6878      	ldr	r0, [r7, #4]
 800ceca:	f04f 0146 	mov.w	r1, #70	; 0x46
 800cece:	683a      	ldr	r2, [r7, #0]
 800ced0:	68fb      	ldr	r3, [r7, #12]
 800ced2:	f7fc fe87 	bl	8009be4 <d_make_comp>
 800ced6:	4603      	mov	r3, r0
 800ced8:	4618      	mov	r0, r3
 800ceda:	f107 0718 	add.w	r7, r7, #24
 800cede:	46bd      	mov	sp, r7
 800cee0:	bd80      	pop	{r7, pc}
 800cee2:	bf00      	nop

0800cee4 <d_add_substitution>:
 800cee4:	b480      	push	{r7}
 800cee6:	b083      	sub	sp, #12
 800cee8:	af00      	add	r7, sp, #0
 800ceea:	6078      	str	r0, [r7, #4]
 800ceec:	6039      	str	r1, [r7, #0]
 800ceee:	683b      	ldr	r3, [r7, #0]
 800cef0:	2b00      	cmp	r3, #0
 800cef2:	d102      	bne.n	800cefa <d_add_substitution+0x16>
 800cef4:	f04f 0300 	mov.w	r3, #0
 800cef8:	e019      	b.n	800cf2e <d_add_substitution+0x4a>
 800cefa:	687b      	ldr	r3, [r7, #4]
 800cefc:	6a1a      	ldr	r2, [r3, #32]
 800cefe:	687b      	ldr	r3, [r7, #4]
 800cf00:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800cf02:	429a      	cmp	r2, r3
 800cf04:	db02      	blt.n	800cf0c <d_add_substitution+0x28>
 800cf06:	f04f 0300 	mov.w	r3, #0
 800cf0a:	e010      	b.n	800cf2e <d_add_substitution+0x4a>
 800cf0c:	687b      	ldr	r3, [r7, #4]
 800cf0e:	69da      	ldr	r2, [r3, #28]
 800cf10:	687b      	ldr	r3, [r7, #4]
 800cf12:	6a1b      	ldr	r3, [r3, #32]
 800cf14:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800cf18:	18d3      	adds	r3, r2, r3
 800cf1a:	683a      	ldr	r2, [r7, #0]
 800cf1c:	601a      	str	r2, [r3, #0]
 800cf1e:	687b      	ldr	r3, [r7, #4]
 800cf20:	6a1b      	ldr	r3, [r3, #32]
 800cf22:	f103 0201 	add.w	r2, r3, #1
 800cf26:	687b      	ldr	r3, [r7, #4]
 800cf28:	621a      	str	r2, [r3, #32]
 800cf2a:	f04f 0301 	mov.w	r3, #1
 800cf2e:	4618      	mov	r0, r3
 800cf30:	f107 070c 	add.w	r7, r7, #12
 800cf34:	46bd      	mov	sp, r7
 800cf36:	bc80      	pop	{r7}
 800cf38:	4770      	bx	lr
 800cf3a:	bf00      	nop

0800cf3c <d_substitution>:
 800cf3c:	b580      	push	{r7, lr}
 800cf3e:	b08c      	sub	sp, #48	; 0x30
 800cf40:	af00      	add	r7, sp, #0
 800cf42:	6078      	str	r0, [r7, #4]
 800cf44:	6039      	str	r1, [r7, #0]
 800cf46:	687b      	ldr	r3, [r7, #4]
 800cf48:	68db      	ldr	r3, [r3, #12]
 800cf4a:	781b      	ldrb	r3, [r3, #0]
 800cf4c:	2b53      	cmp	r3, #83	; 0x53
 800cf4e:	d108      	bne.n	800cf62 <d_substitution+0x26>
 800cf50:	687b      	ldr	r3, [r7, #4]
 800cf52:	68db      	ldr	r3, [r3, #12]
 800cf54:	f103 0201 	add.w	r2, r3, #1
 800cf58:	687b      	ldr	r3, [r7, #4]
 800cf5a:	60da      	str	r2, [r3, #12]
 800cf5c:	f04f 0300 	mov.w	r3, #0
 800cf60:	e001      	b.n	800cf66 <d_substitution+0x2a>
 800cf62:	f04f 0301 	mov.w	r3, #1
 800cf66:	2b00      	cmp	r3, #0
 800cf68:	d002      	beq.n	800cf70 <d_substitution+0x34>
 800cf6a:	f04f 0300 	mov.w	r3, #0
 800cf6e:	e0f7      	b.n	800d160 <d_substitution+0x224>
 800cf70:	687b      	ldr	r3, [r7, #4]
 800cf72:	68db      	ldr	r3, [r3, #12]
 800cf74:	781b      	ldrb	r3, [r3, #0]
 800cf76:	2b00      	cmp	r3, #0
 800cf78:	d007      	beq.n	800cf8a <d_substitution+0x4e>
 800cf7a:	687b      	ldr	r3, [r7, #4]
 800cf7c:	68da      	ldr	r2, [r3, #12]
 800cf7e:	7813      	ldrb	r3, [r2, #0]
 800cf80:	f102 0101 	add.w	r1, r2, #1
 800cf84:	687a      	ldr	r2, [r7, #4]
 800cf86:	60d1      	str	r1, [r2, #12]
 800cf88:	e001      	b.n	800cf8e <d_substitution+0x52>
 800cf8a:	f04f 0300 	mov.w	r3, #0
 800cf8e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 800cf92:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800cf96:	2b5f      	cmp	r3, #95	; 0x5f
 800cf98:	d00f      	beq.n	800cfba <d_substitution+0x7e>
 800cf9a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800cf9e:	2b2f      	cmp	r3, #47	; 0x2f
 800cfa0:	d903      	bls.n	800cfaa <d_substitution+0x6e>
 800cfa2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800cfa6:	2b39      	cmp	r3, #57	; 0x39
 800cfa8:	d907      	bls.n	800cfba <d_substitution+0x7e>
 800cfaa:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800cfae:	2b40      	cmp	r3, #64	; 0x40
 800cfb0:	d974      	bls.n	800d09c <d_substitution+0x160>
 800cfb2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800cfb6:	2b5a      	cmp	r3, #90	; 0x5a
 800cfb8:	d870      	bhi.n	800d09c <d_substitution+0x160>
 800cfba:	f04f 0300 	mov.w	r3, #0
 800cfbe:	62bb      	str	r3, [r7, #40]	; 0x28
 800cfc0:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800cfc4:	2b5f      	cmp	r3, #95	; 0x5f
 800cfc6:	d052      	beq.n	800d06e <d_substitution+0x132>
 800cfc8:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800cfcc:	2b2f      	cmp	r3, #47	; 0x2f
 800cfce:	d912      	bls.n	800cff6 <d_substitution+0xba>
 800cfd0:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800cfd4:	2b39      	cmp	r3, #57	; 0x39
 800cfd6:	d80e      	bhi.n	800cff6 <d_substitution+0xba>
 800cfd8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800cfda:	4613      	mov	r3, r2
 800cfdc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800cfe0:	189b      	adds	r3, r3, r2
 800cfe2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800cfe6:	461a      	mov	r2, r3
 800cfe8:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800cfec:	18d3      	adds	r3, r2, r3
 800cfee:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 800cff2:	627b      	str	r3, [r7, #36]	; 0x24
 800cff4:	e019      	b.n	800d02a <d_substitution+0xee>
 800cff6:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800cffa:	2b40      	cmp	r3, #64	; 0x40
 800cffc:	d912      	bls.n	800d024 <d_substitution+0xe8>
 800cffe:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800d002:	2b5a      	cmp	r3, #90	; 0x5a
 800d004:	d80e      	bhi.n	800d024 <d_substitution+0xe8>
 800d006:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d008:	4613      	mov	r3, r2
 800d00a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800d00e:	189b      	adds	r3, r3, r2
 800d010:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800d014:	461a      	mov	r2, r3
 800d016:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800d01a:	18d3      	adds	r3, r2, r3
 800d01c:	f1a3 0337 	sub.w	r3, r3, #55	; 0x37
 800d020:	627b      	str	r3, [r7, #36]	; 0x24
 800d022:	e002      	b.n	800d02a <d_substitution+0xee>
 800d024:	f04f 0300 	mov.w	r3, #0
 800d028:	e09a      	b.n	800d160 <d_substitution+0x224>
 800d02a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d02c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d02e:	429a      	cmp	r2, r3
 800d030:	d202      	bcs.n	800d038 <d_substitution+0xfc>
 800d032:	f04f 0300 	mov.w	r3, #0
 800d036:	e093      	b.n	800d160 <d_substitution+0x224>
 800d038:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d03a:	62bb      	str	r3, [r7, #40]	; 0x28
 800d03c:	687b      	ldr	r3, [r7, #4]
 800d03e:	68db      	ldr	r3, [r3, #12]
 800d040:	781b      	ldrb	r3, [r3, #0]
 800d042:	2b00      	cmp	r3, #0
 800d044:	d007      	beq.n	800d056 <d_substitution+0x11a>
 800d046:	687b      	ldr	r3, [r7, #4]
 800d048:	68da      	ldr	r2, [r3, #12]
 800d04a:	7813      	ldrb	r3, [r2, #0]
 800d04c:	f102 0101 	add.w	r1, r2, #1
 800d050:	687a      	ldr	r2, [r7, #4]
 800d052:	60d1      	str	r1, [r2, #12]
 800d054:	e001      	b.n	800d05a <d_substitution+0x11e>
 800d056:	f04f 0300 	mov.w	r3, #0
 800d05a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 800d05e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800d062:	2b5f      	cmp	r3, #95	; 0x5f
 800d064:	d1b0      	bne.n	800cfc8 <d_substitution+0x8c>
 800d066:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d068:	f103 0301 	add.w	r3, r3, #1
 800d06c:	62bb      	str	r3, [r7, #40]	; 0x28
 800d06e:	687b      	ldr	r3, [r7, #4]
 800d070:	6a1b      	ldr	r3, [r3, #32]
 800d072:	461a      	mov	r2, r3
 800d074:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d076:	429a      	cmp	r2, r3
 800d078:	d802      	bhi.n	800d080 <d_substitution+0x144>
 800d07a:	f04f 0300 	mov.w	r3, #0
 800d07e:	e06f      	b.n	800d160 <d_substitution+0x224>
 800d080:	687b      	ldr	r3, [r7, #4]
 800d082:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d084:	f103 0201 	add.w	r2, r3, #1
 800d088:	687b      	ldr	r3, [r7, #4]
 800d08a:	629a      	str	r2, [r3, #40]	; 0x28
 800d08c:	687b      	ldr	r3, [r7, #4]
 800d08e:	69da      	ldr	r2, [r3, #28]
 800d090:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d092:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800d096:	18d3      	adds	r3, r2, r3
 800d098:	681b      	ldr	r3, [r3, #0]
 800d09a:	e061      	b.n	800d160 <d_substitution+0x224>
 800d09c:	687b      	ldr	r3, [r7, #4]
 800d09e:	689b      	ldr	r3, [r3, #8]
 800d0a0:	f003 0308 	and.w	r3, r3, #8
 800d0a4:	2b00      	cmp	r3, #0
 800d0a6:	bf0c      	ite	eq
 800d0a8:	2300      	moveq	r3, #0
 800d0aa:	2301      	movne	r3, #1
 800d0ac:	b2db      	uxtb	r3, r3
 800d0ae:	623b      	str	r3, [r7, #32]
 800d0b0:	6a3b      	ldr	r3, [r7, #32]
 800d0b2:	2b00      	cmp	r3, #0
 800d0b4:	d10f      	bne.n	800d0d6 <d_substitution+0x19a>
 800d0b6:	683b      	ldr	r3, [r7, #0]
 800d0b8:	2b00      	cmp	r3, #0
 800d0ba:	d00c      	beq.n	800d0d6 <d_substitution+0x19a>
 800d0bc:	687b      	ldr	r3, [r7, #4]
 800d0be:	68db      	ldr	r3, [r3, #12]
 800d0c0:	781b      	ldrb	r3, [r3, #0]
 800d0c2:	74fb      	strb	r3, [r7, #19]
 800d0c4:	7cfb      	ldrb	r3, [r7, #19]
 800d0c6:	2b43      	cmp	r3, #67	; 0x43
 800d0c8:	d002      	beq.n	800d0d0 <d_substitution+0x194>
 800d0ca:	7cfb      	ldrb	r3, [r7, #19]
 800d0cc:	2b44      	cmp	r3, #68	; 0x44
 800d0ce:	d102      	bne.n	800d0d6 <d_substitution+0x19a>
 800d0d0:	f04f 0301 	mov.w	r3, #1
 800d0d4:	623b      	str	r3, [r7, #32]
 800d0d6:	4b25      	ldr	r3, [pc, #148]	; (800d16c <d_substitution+0x230>)
 800d0d8:	60fb      	str	r3, [r7, #12]
 800d0da:	f64f 4344 	movw	r3, #64580	; 0xfc44
 800d0de:	f6c0 0301 	movt	r3, #2049	; 0x801
 800d0e2:	61fb      	str	r3, [r7, #28]
 800d0e4:	e036      	b.n	800d154 <d_substitution+0x218>
 800d0e6:	69fb      	ldr	r3, [r7, #28]
 800d0e8:	781b      	ldrb	r3, [r3, #0]
 800d0ea:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 800d0ee:	429a      	cmp	r2, r3
 800d0f0:	d12c      	bne.n	800d14c <d_substitution+0x210>
 800d0f2:	69fb      	ldr	r3, [r7, #28]
 800d0f4:	695b      	ldr	r3, [r3, #20]
 800d0f6:	2b00      	cmp	r3, #0
 800d0f8:	d00b      	beq.n	800d112 <d_substitution+0x1d6>
 800d0fa:	69fb      	ldr	r3, [r7, #28]
 800d0fc:	695a      	ldr	r2, [r3, #20]
 800d0fe:	69fb      	ldr	r3, [r7, #28]
 800d100:	699b      	ldr	r3, [r3, #24]
 800d102:	6878      	ldr	r0, [r7, #4]
 800d104:	4611      	mov	r1, r2
 800d106:	461a      	mov	r2, r3
 800d108:	f7fc ff6e 	bl	8009fe8 <d_make_sub>
 800d10c:	4602      	mov	r2, r0
 800d10e:	687b      	ldr	r3, [r7, #4]
 800d110:	62da      	str	r2, [r3, #44]	; 0x2c
 800d112:	6a3b      	ldr	r3, [r7, #32]
 800d114:	2b00      	cmp	r3, #0
 800d116:	d006      	beq.n	800d126 <d_substitution+0x1ea>
 800d118:	69fb      	ldr	r3, [r7, #28]
 800d11a:	68db      	ldr	r3, [r3, #12]
 800d11c:	61bb      	str	r3, [r7, #24]
 800d11e:	69fb      	ldr	r3, [r7, #28]
 800d120:	691b      	ldr	r3, [r3, #16]
 800d122:	617b      	str	r3, [r7, #20]
 800d124:	e005      	b.n	800d132 <d_substitution+0x1f6>
 800d126:	69fb      	ldr	r3, [r7, #28]
 800d128:	685b      	ldr	r3, [r3, #4]
 800d12a:	61bb      	str	r3, [r7, #24]
 800d12c:	69fb      	ldr	r3, [r7, #28]
 800d12e:	689b      	ldr	r3, [r3, #8]
 800d130:	617b      	str	r3, [r7, #20]
 800d132:	687b      	ldr	r3, [r7, #4]
 800d134:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800d136:	697b      	ldr	r3, [r7, #20]
 800d138:	18d2      	adds	r2, r2, r3
 800d13a:	687b      	ldr	r3, [r7, #4]
 800d13c:	631a      	str	r2, [r3, #48]	; 0x30
 800d13e:	6878      	ldr	r0, [r7, #4]
 800d140:	69b9      	ldr	r1, [r7, #24]
 800d142:	697a      	ldr	r2, [r7, #20]
 800d144:	f7fc ff50 	bl	8009fe8 <d_make_sub>
 800d148:	4603      	mov	r3, r0
 800d14a:	e009      	b.n	800d160 <d_substitution+0x224>
 800d14c:	69fb      	ldr	r3, [r7, #28]
 800d14e:	f103 031c 	add.w	r3, r3, #28
 800d152:	61fb      	str	r3, [r7, #28]
 800d154:	69fa      	ldr	r2, [r7, #28]
 800d156:	68fb      	ldr	r3, [r7, #12]
 800d158:	429a      	cmp	r2, r3
 800d15a:	d3c4      	bcc.n	800d0e6 <d_substitution+0x1aa>
 800d15c:	f04f 0300 	mov.w	r3, #0
 800d160:	4618      	mov	r0, r3
 800d162:	f107 0730 	add.w	r7, r7, #48	; 0x30
 800d166:	46bd      	mov	sp, r7
 800d168:	bd80      	pop	{r7, pc}
 800d16a:	bf00      	nop
 800d16c:	0801fd08 	.word	0x0801fd08

0800d170 <d_growable_string_init>:
 800d170:	b580      	push	{r7, lr}
 800d172:	b082      	sub	sp, #8
 800d174:	af00      	add	r7, sp, #0
 800d176:	6078      	str	r0, [r7, #4]
 800d178:	6039      	str	r1, [r7, #0]
 800d17a:	687b      	ldr	r3, [r7, #4]
 800d17c:	f04f 0200 	mov.w	r2, #0
 800d180:	601a      	str	r2, [r3, #0]
 800d182:	687b      	ldr	r3, [r7, #4]
 800d184:	f04f 0200 	mov.w	r2, #0
 800d188:	605a      	str	r2, [r3, #4]
 800d18a:	687b      	ldr	r3, [r7, #4]
 800d18c:	f04f 0200 	mov.w	r2, #0
 800d190:	609a      	str	r2, [r3, #8]
 800d192:	687b      	ldr	r3, [r7, #4]
 800d194:	f04f 0200 	mov.w	r2, #0
 800d198:	60da      	str	r2, [r3, #12]
 800d19a:	683b      	ldr	r3, [r7, #0]
 800d19c:	2b00      	cmp	r3, #0
 800d19e:	d003      	beq.n	800d1a8 <d_growable_string_init+0x38>
 800d1a0:	6878      	ldr	r0, [r7, #4]
 800d1a2:	6839      	ldr	r1, [r7, #0]
 800d1a4:	f000 f804 	bl	800d1b0 <d_growable_string_resize>
 800d1a8:	f107 0708 	add.w	r7, r7, #8
 800d1ac:	46bd      	mov	sp, r7
 800d1ae:	bd80      	pop	{r7, pc}

0800d1b0 <d_growable_string_resize>:
 800d1b0:	b580      	push	{r7, lr}
 800d1b2:	b084      	sub	sp, #16
 800d1b4:	af00      	add	r7, sp, #0
 800d1b6:	6078      	str	r0, [r7, #4]
 800d1b8:	6039      	str	r1, [r7, #0]
 800d1ba:	687b      	ldr	r3, [r7, #4]
 800d1bc:	68db      	ldr	r3, [r3, #12]
 800d1be:	2b00      	cmp	r3, #0
 800d1c0:	d139      	bne.n	800d236 <d_growable_string_resize+0x86>
 800d1c2:	687b      	ldr	r3, [r7, #4]
 800d1c4:	689b      	ldr	r3, [r3, #8]
 800d1c6:	2b00      	cmp	r3, #0
 800d1c8:	d002      	beq.n	800d1d0 <d_growable_string_resize+0x20>
 800d1ca:	687b      	ldr	r3, [r7, #4]
 800d1cc:	689b      	ldr	r3, [r3, #8]
 800d1ce:	e001      	b.n	800d1d4 <d_growable_string_resize+0x24>
 800d1d0:	f04f 0302 	mov.w	r3, #2
 800d1d4:	60fb      	str	r3, [r7, #12]
 800d1d6:	e003      	b.n	800d1e0 <d_growable_string_resize+0x30>
 800d1d8:	68fb      	ldr	r3, [r7, #12]
 800d1da:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800d1de:	60fb      	str	r3, [r7, #12]
 800d1e0:	68fa      	ldr	r2, [r7, #12]
 800d1e2:	683b      	ldr	r3, [r7, #0]
 800d1e4:	429a      	cmp	r2, r3
 800d1e6:	d3f7      	bcc.n	800d1d8 <d_growable_string_resize+0x28>
 800d1e8:	687b      	ldr	r3, [r7, #4]
 800d1ea:	681b      	ldr	r3, [r3, #0]
 800d1ec:	4618      	mov	r0, r3
 800d1ee:	68f9      	ldr	r1, [r7, #12]
 800d1f0:	f004 ff9e 	bl	8012130 <realloc>
 800d1f4:	60b8      	str	r0, [r7, #8]
 800d1f6:	68bb      	ldr	r3, [r7, #8]
 800d1f8:	2b00      	cmp	r3, #0
 800d1fa:	d115      	bne.n	800d228 <d_growable_string_resize+0x78>
 800d1fc:	687b      	ldr	r3, [r7, #4]
 800d1fe:	681b      	ldr	r3, [r3, #0]
 800d200:	4618      	mov	r0, r3
 800d202:	f004 fac3 	bl	801178c <free>
 800d206:	687b      	ldr	r3, [r7, #4]
 800d208:	f04f 0200 	mov.w	r2, #0
 800d20c:	601a      	str	r2, [r3, #0]
 800d20e:	687b      	ldr	r3, [r7, #4]
 800d210:	f04f 0200 	mov.w	r2, #0
 800d214:	605a      	str	r2, [r3, #4]
 800d216:	687b      	ldr	r3, [r7, #4]
 800d218:	f04f 0200 	mov.w	r2, #0
 800d21c:	609a      	str	r2, [r3, #8]
 800d21e:	687b      	ldr	r3, [r7, #4]
 800d220:	f04f 0201 	mov.w	r2, #1
 800d224:	60da      	str	r2, [r3, #12]
 800d226:	e007      	b.n	800d238 <d_growable_string_resize+0x88>
 800d228:	687b      	ldr	r3, [r7, #4]
 800d22a:	68ba      	ldr	r2, [r7, #8]
 800d22c:	601a      	str	r2, [r3, #0]
 800d22e:	687b      	ldr	r3, [r7, #4]
 800d230:	68fa      	ldr	r2, [r7, #12]
 800d232:	609a      	str	r2, [r3, #8]
 800d234:	e000      	b.n	800d238 <d_growable_string_resize+0x88>
 800d236:	bf00      	nop
 800d238:	f107 0710 	add.w	r7, r7, #16
 800d23c:	46bd      	mov	sp, r7
 800d23e:	bd80      	pop	{r7, pc}

0800d240 <d_growable_string_append_buffer>:
 800d240:	b580      	push	{r7, lr}
 800d242:	b086      	sub	sp, #24
 800d244:	af00      	add	r7, sp, #0
 800d246:	60f8      	str	r0, [r7, #12]
 800d248:	60b9      	str	r1, [r7, #8]
 800d24a:	607a      	str	r2, [r7, #4]
 800d24c:	68fb      	ldr	r3, [r7, #12]
 800d24e:	685a      	ldr	r2, [r3, #4]
 800d250:	687b      	ldr	r3, [r7, #4]
 800d252:	18d3      	adds	r3, r2, r3
 800d254:	f103 0301 	add.w	r3, r3, #1
 800d258:	617b      	str	r3, [r7, #20]
 800d25a:	68fb      	ldr	r3, [r7, #12]
 800d25c:	689a      	ldr	r2, [r3, #8]
 800d25e:	697b      	ldr	r3, [r7, #20]
 800d260:	429a      	cmp	r2, r3
 800d262:	d203      	bcs.n	800d26c <d_growable_string_append_buffer+0x2c>
 800d264:	68f8      	ldr	r0, [r7, #12]
 800d266:	6979      	ldr	r1, [r7, #20]
 800d268:	f7ff ffa2 	bl	800d1b0 <d_growable_string_resize>
 800d26c:	68fb      	ldr	r3, [r7, #12]
 800d26e:	68db      	ldr	r3, [r3, #12]
 800d270:	2b00      	cmp	r3, #0
 800d272:	d11a      	bne.n	800d2aa <d_growable_string_append_buffer+0x6a>
 800d274:	68fb      	ldr	r3, [r7, #12]
 800d276:	681a      	ldr	r2, [r3, #0]
 800d278:	68fb      	ldr	r3, [r7, #12]
 800d27a:	685b      	ldr	r3, [r3, #4]
 800d27c:	18d3      	adds	r3, r2, r3
 800d27e:	4618      	mov	r0, r3
 800d280:	68b9      	ldr	r1, [r7, #8]
 800d282:	687a      	ldr	r2, [r7, #4]
 800d284:	f004 fdbe 	bl	8011e04 <memcpy>
 800d288:	68fb      	ldr	r3, [r7, #12]
 800d28a:	681a      	ldr	r2, [r3, #0]
 800d28c:	68fb      	ldr	r3, [r7, #12]
 800d28e:	6859      	ldr	r1, [r3, #4]
 800d290:	687b      	ldr	r3, [r7, #4]
 800d292:	18cb      	adds	r3, r1, r3
 800d294:	18d3      	adds	r3, r2, r3
 800d296:	f04f 0200 	mov.w	r2, #0
 800d29a:	701a      	strb	r2, [r3, #0]
 800d29c:	68fb      	ldr	r3, [r7, #12]
 800d29e:	685a      	ldr	r2, [r3, #4]
 800d2a0:	687b      	ldr	r3, [r7, #4]
 800d2a2:	18d2      	adds	r2, r2, r3
 800d2a4:	68fb      	ldr	r3, [r7, #12]
 800d2a6:	605a      	str	r2, [r3, #4]
 800d2a8:	e000      	b.n	800d2ac <d_growable_string_append_buffer+0x6c>
 800d2aa:	bf00      	nop
 800d2ac:	f107 0718 	add.w	r7, r7, #24
 800d2b0:	46bd      	mov	sp, r7
 800d2b2:	bd80      	pop	{r7, pc}

0800d2b4 <d_growable_string_callback_adapter>:
 800d2b4:	b580      	push	{r7, lr}
 800d2b6:	b086      	sub	sp, #24
 800d2b8:	af00      	add	r7, sp, #0
 800d2ba:	60f8      	str	r0, [r7, #12]
 800d2bc:	60b9      	str	r1, [r7, #8]
 800d2be:	607a      	str	r2, [r7, #4]
 800d2c0:	687b      	ldr	r3, [r7, #4]
 800d2c2:	617b      	str	r3, [r7, #20]
 800d2c4:	6978      	ldr	r0, [r7, #20]
 800d2c6:	68f9      	ldr	r1, [r7, #12]
 800d2c8:	68ba      	ldr	r2, [r7, #8]
 800d2ca:	f7ff ffb9 	bl	800d240 <d_growable_string_append_buffer>
 800d2ce:	f107 0718 	add.w	r7, r7, #24
 800d2d2:	46bd      	mov	sp, r7
 800d2d4:	bd80      	pop	{r7, pc}
 800d2d6:	bf00      	nop

0800d2d8 <d_print_init>:
 800d2d8:	b480      	push	{r7}
 800d2da:	b085      	sub	sp, #20
 800d2dc:	af00      	add	r7, sp, #0
 800d2de:	60f8      	str	r0, [r7, #12]
 800d2e0:	60b9      	str	r1, [r7, #8]
 800d2e2:	607a      	str	r2, [r7, #4]
 800d2e4:	68fb      	ldr	r3, [r7, #12]
 800d2e6:	f04f 0200 	mov.w	r2, #0
 800d2ea:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 800d2ee:	68fb      	ldr	r3, [r7, #12]
 800d2f0:	f04f 0200 	mov.w	r2, #0
 800d2f4:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104
 800d2f8:	68fb      	ldr	r3, [r7, #12]
 800d2fa:	f04f 0200 	mov.w	r2, #0
 800d2fe:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
 800d302:	68fb      	ldr	r3, [r7, #12]
 800d304:	f04f 0200 	mov.w	r2, #0
 800d308:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800d30c:	68fb      	ldr	r3, [r7, #12]
 800d30e:	f04f 0200 	mov.w	r2, #0
 800d312:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
 800d316:	68fb      	ldr	r3, [r7, #12]
 800d318:	f04f 0200 	mov.w	r2, #0
 800d31c:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
 800d320:	68fb      	ldr	r3, [r7, #12]
 800d322:	68ba      	ldr	r2, [r7, #8]
 800d324:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
 800d328:	68fb      	ldr	r3, [r7, #12]
 800d32a:	687a      	ldr	r2, [r7, #4]
 800d32c:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
 800d330:	68fb      	ldr	r3, [r7, #12]
 800d332:	f04f 0200 	mov.w	r2, #0
 800d336:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
 800d33a:	f107 0714 	add.w	r7, r7, #20
 800d33e:	46bd      	mov	sp, r7
 800d340:	bc80      	pop	{r7}
 800d342:	4770      	bx	lr

0800d344 <d_print_error>:
 800d344:	b480      	push	{r7}
 800d346:	b083      	sub	sp, #12
 800d348:	af00      	add	r7, sp, #0
 800d34a:	6078      	str	r0, [r7, #4]
 800d34c:	687b      	ldr	r3, [r7, #4]
 800d34e:	f04f 0201 	mov.w	r2, #1
 800d352:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
 800d356:	f107 070c 	add.w	r7, r7, #12
 800d35a:	46bd      	mov	sp, r7
 800d35c:	bc80      	pop	{r7}
 800d35e:	4770      	bx	lr

0800d360 <d_print_saw_error>:
 800d360:	b480      	push	{r7}
 800d362:	b083      	sub	sp, #12
 800d364:	af00      	add	r7, sp, #0
 800d366:	6078      	str	r0, [r7, #4]
 800d368:	687b      	ldr	r3, [r7, #4]
 800d36a:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800d36e:	2b00      	cmp	r3, #0
 800d370:	bf0c      	ite	eq
 800d372:	2300      	moveq	r3, #0
 800d374:	2301      	movne	r3, #1
 800d376:	b2db      	uxtb	r3, r3
 800d378:	4618      	mov	r0, r3
 800d37a:	f107 070c 	add.w	r7, r7, #12
 800d37e:	46bd      	mov	sp, r7
 800d380:	bc80      	pop	{r7}
 800d382:	4770      	bx	lr

0800d384 <d_print_flush>:
 800d384:	b580      	push	{r7, lr}
 800d386:	b082      	sub	sp, #8
 800d388:	af00      	add	r7, sp, #0
 800d38a:	6078      	str	r0, [r7, #4]
 800d38c:	687b      	ldr	r3, [r7, #4]
 800d38e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800d392:	687a      	ldr	r2, [r7, #4]
 800d394:	f04f 0100 	mov.w	r1, #0
 800d398:	54d1      	strb	r1, [r2, r3]
 800d39a:	687b      	ldr	r3, [r7, #4]
 800d39c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800d3a0:	6878      	ldr	r0, [r7, #4]
 800d3a2:	687a      	ldr	r2, [r7, #4]
 800d3a4:	f8d2 1100 	ldr.w	r1, [r2, #256]	; 0x100
 800d3a8:	687a      	ldr	r2, [r7, #4]
 800d3aa:	f8d2 210c 	ldr.w	r2, [r2, #268]	; 0x10c
 800d3ae:	4798      	blx	r3
 800d3b0:	687b      	ldr	r3, [r7, #4]
 800d3b2:	f04f 0200 	mov.w	r2, #0
 800d3b6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 800d3ba:	687b      	ldr	r3, [r7, #4]
 800d3bc:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 800d3c0:	f103 0201 	add.w	r2, r3, #1
 800d3c4:	687b      	ldr	r3, [r7, #4]
 800d3c6:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
 800d3ca:	f107 0708 	add.w	r7, r7, #8
 800d3ce:	46bd      	mov	sp, r7
 800d3d0:	bd80      	pop	{r7, pc}
 800d3d2:	bf00      	nop

0800d3d4 <d_append_char>:
 800d3d4:	b580      	push	{r7, lr}
 800d3d6:	b082      	sub	sp, #8
 800d3d8:	af00      	add	r7, sp, #0
 800d3da:	6078      	str	r0, [r7, #4]
 800d3dc:	460b      	mov	r3, r1
 800d3de:	70fb      	strb	r3, [r7, #3]
 800d3e0:	687b      	ldr	r3, [r7, #4]
 800d3e2:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800d3e6:	2bff      	cmp	r3, #255	; 0xff
 800d3e8:	d102      	bne.n	800d3f0 <d_append_char+0x1c>
 800d3ea:	6878      	ldr	r0, [r7, #4]
 800d3ec:	f7ff ffca 	bl	800d384 <d_print_flush>
 800d3f0:	687b      	ldr	r3, [r7, #4]
 800d3f2:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800d3f6:	687a      	ldr	r2, [r7, #4]
 800d3f8:	78f9      	ldrb	r1, [r7, #3]
 800d3fa:	54d1      	strb	r1, [r2, r3]
 800d3fc:	f103 0201 	add.w	r2, r3, #1
 800d400:	687b      	ldr	r3, [r7, #4]
 800d402:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 800d406:	687b      	ldr	r3, [r7, #4]
 800d408:	78fa      	ldrb	r2, [r7, #3]
 800d40a:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104
 800d40e:	f107 0708 	add.w	r7, r7, #8
 800d412:	46bd      	mov	sp, r7
 800d414:	bd80      	pop	{r7, pc}
 800d416:	bf00      	nop

0800d418 <d_append_buffer>:
 800d418:	b580      	push	{r7, lr}
 800d41a:	b086      	sub	sp, #24
 800d41c:	af00      	add	r7, sp, #0
 800d41e:	60f8      	str	r0, [r7, #12]
 800d420:	60b9      	str	r1, [r7, #8]
 800d422:	607a      	str	r2, [r7, #4]
 800d424:	f04f 0300 	mov.w	r3, #0
 800d428:	617b      	str	r3, [r7, #20]
 800d42a:	e00b      	b.n	800d444 <d_append_buffer+0x2c>
 800d42c:	68ba      	ldr	r2, [r7, #8]
 800d42e:	697b      	ldr	r3, [r7, #20]
 800d430:	18d3      	adds	r3, r2, r3
 800d432:	781b      	ldrb	r3, [r3, #0]
 800d434:	68f8      	ldr	r0, [r7, #12]
 800d436:	4619      	mov	r1, r3
 800d438:	f7ff ffcc 	bl	800d3d4 <d_append_char>
 800d43c:	697b      	ldr	r3, [r7, #20]
 800d43e:	f103 0301 	add.w	r3, r3, #1
 800d442:	617b      	str	r3, [r7, #20]
 800d444:	697a      	ldr	r2, [r7, #20]
 800d446:	687b      	ldr	r3, [r7, #4]
 800d448:	429a      	cmp	r2, r3
 800d44a:	d3ef      	bcc.n	800d42c <d_append_buffer+0x14>
 800d44c:	f107 0718 	add.w	r7, r7, #24
 800d450:	46bd      	mov	sp, r7
 800d452:	bd80      	pop	{r7, pc}

0800d454 <d_append_string>:
 800d454:	b580      	push	{r7, lr}
 800d456:	b082      	sub	sp, #8
 800d458:	af00      	add	r7, sp, #0
 800d45a:	6078      	str	r0, [r7, #4]
 800d45c:	6039      	str	r1, [r7, #0]
 800d45e:	6838      	ldr	r0, [r7, #0]
 800d460:	f005 fb8a 	bl	8012b78 <strlen>
 800d464:	4603      	mov	r3, r0
 800d466:	6878      	ldr	r0, [r7, #4]
 800d468:	6839      	ldr	r1, [r7, #0]
 800d46a:	461a      	mov	r2, r3
 800d46c:	f7ff ffd4 	bl	800d418 <d_append_buffer>
 800d470:	f107 0708 	add.w	r7, r7, #8
 800d474:	46bd      	mov	sp, r7
 800d476:	bd80      	pop	{r7, pc}

0800d478 <d_append_num>:
 800d478:	b580      	push	{r7, lr}
 800d47a:	b08a      	sub	sp, #40	; 0x28
 800d47c:	af00      	add	r7, sp, #0
 800d47e:	6078      	str	r0, [r7, #4]
 800d480:	6039      	str	r1, [r7, #0]
 800d482:	f107 030c 	add.w	r3, r7, #12
 800d486:	4618      	mov	r0, r3
 800d488:	f64f 5108 	movw	r1, #64776	; 0xfd08
 800d48c:	f6c0 0101 	movt	r1, #2049	; 0x801
 800d490:	683a      	ldr	r2, [r7, #0]
 800d492:	f7fb fa15 	bl	80088c0 <sprintf>
 800d496:	f107 030c 	add.w	r3, r7, #12
 800d49a:	6878      	ldr	r0, [r7, #4]
 800d49c:	4619      	mov	r1, r3
 800d49e:	f7ff ffd9 	bl	800d454 <d_append_string>
 800d4a2:	f107 0728 	add.w	r7, r7, #40	; 0x28
 800d4a6:	46bd      	mov	sp, r7
 800d4a8:	bd80      	pop	{r7, pc}
 800d4aa:	bf00      	nop

0800d4ac <d_last_char>:
 800d4ac:	b480      	push	{r7}
 800d4ae:	b083      	sub	sp, #12
 800d4b0:	af00      	add	r7, sp, #0
 800d4b2:	6078      	str	r0, [r7, #4]
 800d4b4:	687b      	ldr	r3, [r7, #4]
 800d4b6:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
 800d4ba:	4618      	mov	r0, r3
 800d4bc:	f107 070c 	add.w	r7, r7, #12
 800d4c0:	46bd      	mov	sp, r7
 800d4c2:	bc80      	pop	{r7}
 800d4c4:	4770      	bx	lr
 800d4c6:	bf00      	nop

0800d4c8 <d_print_callback>:
 800d4c8:	b590      	push	{r4, r7, lr}
 800d4ca:	b0cf      	sub	sp, #316	; 0x13c
 800d4cc:	af00      	add	r7, sp, #0
 800d4ce:	f107 040c 	add.w	r4, r7, #12
 800d4d2:	6020      	str	r0, [r4, #0]
 800d4d4:	f107 0008 	add.w	r0, r7, #8
 800d4d8:	6001      	str	r1, [r0, #0]
 800d4da:	f107 0104 	add.w	r1, r7, #4
 800d4de:	600a      	str	r2, [r1, #0]
 800d4e0:	463a      	mov	r2, r7
 800d4e2:	6013      	str	r3, [r2, #0]
 800d4e4:	f107 0114 	add.w	r1, r7, #20
 800d4e8:	f107 0204 	add.w	r2, r7, #4
 800d4ec:	463b      	mov	r3, r7
 800d4ee:	4608      	mov	r0, r1
 800d4f0:	6811      	ldr	r1, [r2, #0]
 800d4f2:	681a      	ldr	r2, [r3, #0]
 800d4f4:	f7ff fef0 	bl	800d2d8 <d_print_init>
 800d4f8:	f107 0114 	add.w	r1, r7, #20
 800d4fc:	f107 020c 	add.w	r2, r7, #12
 800d500:	f107 0308 	add.w	r3, r7, #8
 800d504:	4608      	mov	r0, r1
 800d506:	6811      	ldr	r1, [r2, #0]
 800d508:	681a      	ldr	r2, [r3, #0]
 800d50a:	f000 f9dd 	bl	800d8c8 <d_print_comp>
 800d50e:	f107 0314 	add.w	r3, r7, #20
 800d512:	4618      	mov	r0, r3
 800d514:	f7ff ff36 	bl	800d384 <d_print_flush>
 800d518:	f107 0314 	add.w	r3, r7, #20
 800d51c:	4618      	mov	r0, r3
 800d51e:	f7ff ff1f 	bl	800d360 <d_print_saw_error>
 800d522:	4603      	mov	r3, r0
 800d524:	2b00      	cmp	r3, #0
 800d526:	bf14      	ite	ne
 800d528:	2300      	movne	r3, #0
 800d52a:	2301      	moveq	r3, #1
 800d52c:	b2db      	uxtb	r3, r3
 800d52e:	4618      	mov	r0, r3
 800d530:	f507 779e 	add.w	r7, r7, #316	; 0x13c
 800d534:	46bd      	mov	sp, r7
 800d536:	bd90      	pop	{r4, r7, pc}

0800d538 <d_print>:
 800d538:	b580      	push	{r7, lr}
 800d53a:	b088      	sub	sp, #32
 800d53c:	af00      	add	r7, sp, #0
 800d53e:	60f8      	str	r0, [r7, #12]
 800d540:	60b9      	str	r1, [r7, #8]
 800d542:	607a      	str	r2, [r7, #4]
 800d544:	603b      	str	r3, [r7, #0]
 800d546:	687b      	ldr	r3, [r7, #4]
 800d548:	f107 0210 	add.w	r2, r7, #16
 800d54c:	4610      	mov	r0, r2
 800d54e:	4619      	mov	r1, r3
 800d550:	f7ff fe0e 	bl	800d170 <d_growable_string_init>
 800d554:	f107 0310 	add.w	r3, r7, #16
 800d558:	68f8      	ldr	r0, [r7, #12]
 800d55a:	68b9      	ldr	r1, [r7, #8]
 800d55c:	f24d 22b5 	movw	r2, #53941	; 0xd2b5
 800d560:	f6c0 0200 	movt	r2, #2048	; 0x800
 800d564:	f7ff ffb0 	bl	800d4c8 <d_print_callback>
 800d568:	4603      	mov	r3, r0
 800d56a:	2b00      	cmp	r3, #0
 800d56c:	d10a      	bne.n	800d584 <d_print+0x4c>
 800d56e:	693b      	ldr	r3, [r7, #16]
 800d570:	4618      	mov	r0, r3
 800d572:	f004 f90b 	bl	801178c <free>
 800d576:	683b      	ldr	r3, [r7, #0]
 800d578:	f04f 0200 	mov.w	r2, #0
 800d57c:	601a      	str	r2, [r3, #0]
 800d57e:	f04f 0300 	mov.w	r3, #0
 800d582:	e009      	b.n	800d598 <d_print+0x60>
 800d584:	69fb      	ldr	r3, [r7, #28]
 800d586:	2b00      	cmp	r3, #0
 800d588:	d101      	bne.n	800d58e <d_print+0x56>
 800d58a:	69bb      	ldr	r3, [r7, #24]
 800d58c:	e001      	b.n	800d592 <d_print+0x5a>
 800d58e:	f04f 0301 	mov.w	r3, #1
 800d592:	683a      	ldr	r2, [r7, #0]
 800d594:	6013      	str	r3, [r2, #0]
 800d596:	693b      	ldr	r3, [r7, #16]
 800d598:	4618      	mov	r0, r3
 800d59a:	f107 0720 	add.w	r7, r7, #32
 800d59e:	46bd      	mov	sp, r7
 800d5a0:	bd80      	pop	{r7, pc}
 800d5a2:	bf00      	nop

0800d5a4 <d_index_template_argument>:
 800d5a4:	b480      	push	{r7}
 800d5a6:	b085      	sub	sp, #20
 800d5a8:	af00      	add	r7, sp, #0
 800d5aa:	6078      	str	r0, [r7, #4]
 800d5ac:	6039      	str	r1, [r7, #0]
 800d5ae:	687b      	ldr	r3, [r7, #4]
 800d5b0:	60fb      	str	r3, [r7, #12]
 800d5b2:	e010      	b.n	800d5d6 <d_index_template_argument+0x32>
 800d5b4:	68fb      	ldr	r3, [r7, #12]
 800d5b6:	781b      	ldrb	r3, [r3, #0]
 800d5b8:	2b2b      	cmp	r3, #43	; 0x2b
 800d5ba:	d002      	beq.n	800d5c2 <d_index_template_argument+0x1e>
 800d5bc:	f04f 0300 	mov.w	r3, #0
 800d5c0:	e019      	b.n	800d5f6 <d_index_template_argument+0x52>
 800d5c2:	683b      	ldr	r3, [r7, #0]
 800d5c4:	2b00      	cmp	r3, #0
 800d5c6:	dd0a      	ble.n	800d5de <d_index_template_argument+0x3a>
 800d5c8:	683b      	ldr	r3, [r7, #0]
 800d5ca:	f103 33ff 	add.w	r3, r3, #4294967295
 800d5ce:	603b      	str	r3, [r7, #0]
 800d5d0:	68fb      	ldr	r3, [r7, #12]
 800d5d2:	689b      	ldr	r3, [r3, #8]
 800d5d4:	60fb      	str	r3, [r7, #12]
 800d5d6:	68fb      	ldr	r3, [r7, #12]
 800d5d8:	2b00      	cmp	r3, #0
 800d5da:	d1eb      	bne.n	800d5b4 <d_index_template_argument+0x10>
 800d5dc:	e000      	b.n	800d5e0 <d_index_template_argument+0x3c>
 800d5de:	bf00      	nop
 800d5e0:	683b      	ldr	r3, [r7, #0]
 800d5e2:	2b00      	cmp	r3, #0
 800d5e4:	d102      	bne.n	800d5ec <d_index_template_argument+0x48>
 800d5e6:	68fb      	ldr	r3, [r7, #12]
 800d5e8:	2b00      	cmp	r3, #0
 800d5ea:	d102      	bne.n	800d5f2 <d_index_template_argument+0x4e>
 800d5ec:	f04f 0300 	mov.w	r3, #0
 800d5f0:	e001      	b.n	800d5f6 <d_index_template_argument+0x52>
 800d5f2:	68fb      	ldr	r3, [r7, #12]
 800d5f4:	685b      	ldr	r3, [r3, #4]
 800d5f6:	4618      	mov	r0, r3
 800d5f8:	f107 0714 	add.w	r7, r7, #20
 800d5fc:	46bd      	mov	sp, r7
 800d5fe:	bc80      	pop	{r7}
 800d600:	4770      	bx	lr
 800d602:	bf00      	nop

0800d604 <d_lookup_template_argument>:
 800d604:	b580      	push	{r7, lr}
 800d606:	b082      	sub	sp, #8
 800d608:	af00      	add	r7, sp, #0
 800d60a:	6078      	str	r0, [r7, #4]
 800d60c:	6039      	str	r1, [r7, #0]
 800d60e:	687b      	ldr	r3, [r7, #4]
 800d610:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 800d614:	2b00      	cmp	r3, #0
 800d616:	d105      	bne.n	800d624 <d_lookup_template_argument+0x20>
 800d618:	6878      	ldr	r0, [r7, #4]
 800d61a:	f7ff fe93 	bl	800d344 <d_print_error>
 800d61e:	f04f 0300 	mov.w	r3, #0
 800d622:	e00b      	b.n	800d63c <d_lookup_template_argument+0x38>
 800d624:	687b      	ldr	r3, [r7, #4]
 800d626:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 800d62a:	685b      	ldr	r3, [r3, #4]
 800d62c:	689a      	ldr	r2, [r3, #8]
 800d62e:	683b      	ldr	r3, [r7, #0]
 800d630:	685b      	ldr	r3, [r3, #4]
 800d632:	4610      	mov	r0, r2
 800d634:	4619      	mov	r1, r3
 800d636:	f7ff ffb5 	bl	800d5a4 <d_index_template_argument>
 800d63a:	4603      	mov	r3, r0
 800d63c:	4618      	mov	r0, r3
 800d63e:	f107 0708 	add.w	r7, r7, #8
 800d642:	46bd      	mov	sp, r7
 800d644:	bd80      	pop	{r7, pc}
 800d646:	bf00      	nop

0800d648 <d_find_pack>:
 800d648:	b580      	push	{r7, lr}
 800d64a:	b084      	sub	sp, #16
 800d64c:	af00      	add	r7, sp, #0
 800d64e:	6078      	str	r0, [r7, #4]
 800d650:	6039      	str	r1, [r7, #0]
 800d652:	683b      	ldr	r3, [r7, #0]
 800d654:	2b00      	cmp	r3, #0
 800d656:	d102      	bne.n	800d65e <d_find_pack+0x16>
 800d658:	f04f 0300 	mov.w	r3, #0
 800d65c:	e0d6      	b.n	800d80c <d_find_pack+0x1c4>
 800d65e:	683b      	ldr	r3, [r7, #0]
 800d660:	781b      	ldrb	r3, [r3, #0]
 800d662:	2b45      	cmp	r3, #69	; 0x45
 800d664:	f200 80bf 	bhi.w	800d7e6 <d_find_pack+0x19e>
 800d668:	a201      	add	r2, pc, #4	; (adr r2, 800d670 <d_find_pack+0x28>)
 800d66a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d66e:	bf00      	nop
 800d670:	0800d7b1 	.word	0x0800d7b1
 800d674:	0800d7e7 	.word	0x0800d7e7
 800d678:	0800d7e7 	.word	0x0800d7e7
 800d67c:	0800d7e7 	.word	0x0800d7e7
 800d680:	0800d7e7 	.word	0x0800d7e7
 800d684:	0800d789 	.word	0x0800d789
 800d688:	0800d7b1 	.word	0x0800d7b1
 800d68c:	0800d7c7 	.word	0x0800d7c7
 800d690:	0800d7d7 	.word	0x0800d7d7
 800d694:	0800d7e7 	.word	0x0800d7e7
 800d698:	0800d7e7 	.word	0x0800d7e7
 800d69c:	0800d7e7 	.word	0x0800d7e7
 800d6a0:	0800d7e7 	.word	0x0800d7e7
 800d6a4:	0800d7e7 	.word	0x0800d7e7
 800d6a8:	0800d7e7 	.word	0x0800d7e7
 800d6ac:	0800d7e7 	.word	0x0800d7e7
 800d6b0:	0800d7e7 	.word	0x0800d7e7
 800d6b4:	0800d7e7 	.word	0x0800d7e7
 800d6b8:	0800d7e7 	.word	0x0800d7e7
 800d6bc:	0800d7e7 	.word	0x0800d7e7
 800d6c0:	0800d7e7 	.word	0x0800d7e7
 800d6c4:	0800d7e7 	.word	0x0800d7e7
 800d6c8:	0800d7b1 	.word	0x0800d7b1
 800d6cc:	0800d7e7 	.word	0x0800d7e7
 800d6d0:	0800d7e7 	.word	0x0800d7e7
 800d6d4:	0800d7e7 	.word	0x0800d7e7
 800d6d8:	0800d7e7 	.word	0x0800d7e7
 800d6dc:	0800d7e7 	.word	0x0800d7e7
 800d6e0:	0800d7e7 	.word	0x0800d7e7
 800d6e4:	0800d7e7 	.word	0x0800d7e7
 800d6e8:	0800d7e7 	.word	0x0800d7e7
 800d6ec:	0800d7e7 	.word	0x0800d7e7
 800d6f0:	0800d7e7 	.word	0x0800d7e7
 800d6f4:	0800d7e7 	.word	0x0800d7e7
 800d6f8:	0800d7e7 	.word	0x0800d7e7
 800d6fc:	0800d7b1 	.word	0x0800d7b1
 800d700:	0800d7e7 	.word	0x0800d7e7
 800d704:	0800d7e7 	.word	0x0800d7e7
 800d708:	0800d7e7 	.word	0x0800d7e7
 800d70c:	0800d7e7 	.word	0x0800d7e7
 800d710:	0800d7e7 	.word	0x0800d7e7
 800d714:	0800d7e7 	.word	0x0800d7e7
 800d718:	0800d7e7 	.word	0x0800d7e7
 800d71c:	0800d7e7 	.word	0x0800d7e7
 800d720:	0800d7e7 	.word	0x0800d7e7
 800d724:	0800d7b1 	.word	0x0800d7b1
 800d728:	0800d7b7 	.word	0x0800d7b7
 800d72c:	0800d7e7 	.word	0x0800d7e7
 800d730:	0800d7e7 	.word	0x0800d7e7
 800d734:	0800d7e7 	.word	0x0800d7e7
 800d738:	0800d7e7 	.word	0x0800d7e7
 800d73c:	0800d7e7 	.word	0x0800d7e7
 800d740:	0800d7e7 	.word	0x0800d7e7
 800d744:	0800d7e7 	.word	0x0800d7e7
 800d748:	0800d7e7 	.word	0x0800d7e7
 800d74c:	0800d7e7 	.word	0x0800d7e7
 800d750:	0800d7e7 	.word	0x0800d7e7
 800d754:	0800d7e7 	.word	0x0800d7e7
 800d758:	0800d7e7 	.word	0x0800d7e7
 800d75c:	0800d7b1 	.word	0x0800d7b1
 800d760:	0800d7e7 	.word	0x0800d7e7
 800d764:	0800d7e7 	.word	0x0800d7e7
 800d768:	0800d7e7 	.word	0x0800d7e7
 800d76c:	0800d7e7 	.word	0x0800d7e7
 800d770:	0800d7b1 	.word	0x0800d7b1
 800d774:	0800d7e7 	.word	0x0800d7e7
 800d778:	0800d7e7 	.word	0x0800d7e7
 800d77c:	0800d7e7 	.word	0x0800d7e7
 800d780:	0800d7e7 	.word	0x0800d7e7
 800d784:	0800d7ab 	.word	0x0800d7ab
 800d788:	6878      	ldr	r0, [r7, #4]
 800d78a:	6839      	ldr	r1, [r7, #0]
 800d78c:	f7ff ff3a 	bl	800d604 <d_lookup_template_argument>
 800d790:	60f8      	str	r0, [r7, #12]
 800d792:	68fb      	ldr	r3, [r7, #12]
 800d794:	2b00      	cmp	r3, #0
 800d796:	d005      	beq.n	800d7a4 <d_find_pack+0x15c>
 800d798:	68fb      	ldr	r3, [r7, #12]
 800d79a:	781b      	ldrb	r3, [r3, #0]
 800d79c:	2b2b      	cmp	r3, #43	; 0x2b
 800d79e:	d101      	bne.n	800d7a4 <d_find_pack+0x15c>
 800d7a0:	68fb      	ldr	r3, [r7, #12]
 800d7a2:	e033      	b.n	800d80c <d_find_pack+0x1c4>
 800d7a4:	f04f 0300 	mov.w	r3, #0
 800d7a8:	e030      	b.n	800d80c <d_find_pack+0x1c4>
 800d7aa:	f04f 0300 	mov.w	r3, #0
 800d7ae:	e02d      	b.n	800d80c <d_find_pack+0x1c4>
 800d7b0:	f04f 0300 	mov.w	r3, #0
 800d7b4:	e02a      	b.n	800d80c <d_find_pack+0x1c4>
 800d7b6:	683b      	ldr	r3, [r7, #0]
 800d7b8:	689b      	ldr	r3, [r3, #8]
 800d7ba:	6878      	ldr	r0, [r7, #4]
 800d7bc:	4619      	mov	r1, r3
 800d7be:	f7ff ff43 	bl	800d648 <d_find_pack>
 800d7c2:	4603      	mov	r3, r0
 800d7c4:	e022      	b.n	800d80c <d_find_pack+0x1c4>
 800d7c6:	683b      	ldr	r3, [r7, #0]
 800d7c8:	689b      	ldr	r3, [r3, #8]
 800d7ca:	6878      	ldr	r0, [r7, #4]
 800d7cc:	4619      	mov	r1, r3
 800d7ce:	f7ff ff3b 	bl	800d648 <d_find_pack>
 800d7d2:	4603      	mov	r3, r0
 800d7d4:	e01a      	b.n	800d80c <d_find_pack+0x1c4>
 800d7d6:	683b      	ldr	r3, [r7, #0]
 800d7d8:	689b      	ldr	r3, [r3, #8]
 800d7da:	6878      	ldr	r0, [r7, #4]
 800d7dc:	4619      	mov	r1, r3
 800d7de:	f7ff ff33 	bl	800d648 <d_find_pack>
 800d7e2:	4603      	mov	r3, r0
 800d7e4:	e012      	b.n	800d80c <d_find_pack+0x1c4>
 800d7e6:	683b      	ldr	r3, [r7, #0]
 800d7e8:	685b      	ldr	r3, [r3, #4]
 800d7ea:	6878      	ldr	r0, [r7, #4]
 800d7ec:	4619      	mov	r1, r3
 800d7ee:	f7ff ff2b 	bl	800d648 <d_find_pack>
 800d7f2:	60f8      	str	r0, [r7, #12]
 800d7f4:	68fb      	ldr	r3, [r7, #12]
 800d7f6:	2b00      	cmp	r3, #0
 800d7f8:	d001      	beq.n	800d7fe <d_find_pack+0x1b6>
 800d7fa:	68fb      	ldr	r3, [r7, #12]
 800d7fc:	e006      	b.n	800d80c <d_find_pack+0x1c4>
 800d7fe:	683b      	ldr	r3, [r7, #0]
 800d800:	689b      	ldr	r3, [r3, #8]
 800d802:	6878      	ldr	r0, [r7, #4]
 800d804:	4619      	mov	r1, r3
 800d806:	f7ff ff1f 	bl	800d648 <d_find_pack>
 800d80a:	4603      	mov	r3, r0
 800d80c:	4618      	mov	r0, r3
 800d80e:	f107 0710 	add.w	r7, r7, #16
 800d812:	46bd      	mov	sp, r7
 800d814:	bd80      	pop	{r7, pc}
 800d816:	bf00      	nop

0800d818 <d_pack_length>:
 800d818:	b480      	push	{r7}
 800d81a:	b085      	sub	sp, #20
 800d81c:	af00      	add	r7, sp, #0
 800d81e:	6078      	str	r0, [r7, #4]
 800d820:	f04f 0300 	mov.w	r3, #0
 800d824:	60fb      	str	r3, [r7, #12]
 800d826:	e006      	b.n	800d836 <d_pack_length+0x1e>
 800d828:	68fb      	ldr	r3, [r7, #12]
 800d82a:	f103 0301 	add.w	r3, r3, #1
 800d82e:	60fb      	str	r3, [r7, #12]
 800d830:	687b      	ldr	r3, [r7, #4]
 800d832:	689b      	ldr	r3, [r3, #8]
 800d834:	607b      	str	r3, [r7, #4]
 800d836:	687b      	ldr	r3, [r7, #4]
 800d838:	2b00      	cmp	r3, #0
 800d83a:	d007      	beq.n	800d84c <d_pack_length+0x34>
 800d83c:	687b      	ldr	r3, [r7, #4]
 800d83e:	781b      	ldrb	r3, [r3, #0]
 800d840:	2b2b      	cmp	r3, #43	; 0x2b
 800d842:	d103      	bne.n	800d84c <d_pack_length+0x34>
 800d844:	687b      	ldr	r3, [r7, #4]
 800d846:	685b      	ldr	r3, [r3, #4]
 800d848:	2b00      	cmp	r3, #0
 800d84a:	d1ed      	bne.n	800d828 <d_pack_length+0x10>
 800d84c:	68fb      	ldr	r3, [r7, #12]
 800d84e:	4618      	mov	r0, r3
 800d850:	f107 0714 	add.w	r7, r7, #20
 800d854:	46bd      	mov	sp, r7
 800d856:	bc80      	pop	{r7}
 800d858:	4770      	bx	lr
 800d85a:	bf00      	nop

0800d85c <d_print_subexpr>:
 800d85c:	b580      	push	{r7, lr}
 800d85e:	b086      	sub	sp, #24
 800d860:	af00      	add	r7, sp, #0
 800d862:	60f8      	str	r0, [r7, #12]
 800d864:	60b9      	str	r1, [r7, #8]
 800d866:	607a      	str	r2, [r7, #4]
 800d868:	f04f 0300 	mov.w	r3, #0
 800d86c:	617b      	str	r3, [r7, #20]
 800d86e:	687b      	ldr	r3, [r7, #4]
 800d870:	781b      	ldrb	r3, [r3, #0]
 800d872:	2b00      	cmp	r3, #0
 800d874:	d00b      	beq.n	800d88e <d_print_subexpr+0x32>
 800d876:	687b      	ldr	r3, [r7, #4]
 800d878:	781b      	ldrb	r3, [r3, #0]
 800d87a:	2b01      	cmp	r3, #1
 800d87c:	d007      	beq.n	800d88e <d_print_subexpr+0x32>
 800d87e:	687b      	ldr	r3, [r7, #4]
 800d880:	781b      	ldrb	r3, [r3, #0]
 800d882:	2b2c      	cmp	r3, #44	; 0x2c
 800d884:	d003      	beq.n	800d88e <d_print_subexpr+0x32>
 800d886:	687b      	ldr	r3, [r7, #4]
 800d888:	781b      	ldrb	r3, [r3, #0]
 800d88a:	2b06      	cmp	r3, #6
 800d88c:	d102      	bne.n	800d894 <d_print_subexpr+0x38>
 800d88e:	f04f 0301 	mov.w	r3, #1
 800d892:	617b      	str	r3, [r7, #20]
 800d894:	697b      	ldr	r3, [r7, #20]
 800d896:	2b00      	cmp	r3, #0
 800d898:	d104      	bne.n	800d8a4 <d_print_subexpr+0x48>
 800d89a:	68f8      	ldr	r0, [r7, #12]
 800d89c:	f04f 0128 	mov.w	r1, #40	; 0x28
 800d8a0:	f7ff fd98 	bl	800d3d4 <d_append_char>
 800d8a4:	68f8      	ldr	r0, [r7, #12]
 800d8a6:	68b9      	ldr	r1, [r7, #8]
 800d8a8:	687a      	ldr	r2, [r7, #4]
 800d8aa:	f000 f80d 	bl	800d8c8 <d_print_comp>
 800d8ae:	697b      	ldr	r3, [r7, #20]
 800d8b0:	2b00      	cmp	r3, #0
 800d8b2:	d104      	bne.n	800d8be <d_print_subexpr+0x62>
 800d8b4:	68f8      	ldr	r0, [r7, #12]
 800d8b6:	f04f 0129 	mov.w	r1, #41	; 0x29
 800d8ba:	f7ff fd8b 	bl	800d3d4 <d_append_char>
 800d8be:	f107 0718 	add.w	r7, r7, #24
 800d8c2:	46bd      	mov	sp, r7
 800d8c4:	bd80      	pop	{r7, pc}
 800d8c6:	bf00      	nop

0800d8c8 <d_print_comp>:
 800d8c8:	b590      	push	{r4, r7, lr}
 800d8ca:	b0c5      	sub	sp, #276	; 0x114
 800d8cc:	af00      	add	r7, sp, #0
 800d8ce:	f107 030c 	add.w	r3, r7, #12
 800d8d2:	6018      	str	r0, [r3, #0]
 800d8d4:	f107 0308 	add.w	r3, r7, #8
 800d8d8:	6019      	str	r1, [r3, #0]
 800d8da:	f107 0304 	add.w	r3, r7, #4
 800d8de:	601a      	str	r2, [r3, #0]
 800d8e0:	f04f 0300 	mov.w	r3, #0
 800d8e4:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
 800d8e8:	f107 0304 	add.w	r3, r7, #4
 800d8ec:	681b      	ldr	r3, [r3, #0]
 800d8ee:	2b00      	cmp	r3, #0
 800d8f0:	d106      	bne.n	800d900 <d_print_comp+0x38>
 800d8f2:	f107 030c 	add.w	r3, r7, #12
 800d8f6:	6818      	ldr	r0, [r3, #0]
 800d8f8:	f7ff fd24 	bl	800d344 <d_print_error>
 800d8fc:	f001 beae 	b.w	800f65c <d_print_comp+0x1d94>
 800d900:	f107 030c 	add.w	r3, r7, #12
 800d904:	6818      	ldr	r0, [r3, #0]
 800d906:	f7ff fd2b 	bl	800d360 <d_print_saw_error>
 800d90a:	4603      	mov	r3, r0
 800d90c:	2b00      	cmp	r3, #0
 800d90e:	f041 869a 	bne.w	800f646 <d_print_comp+0x1d7e>
 800d912:	f107 0304 	add.w	r3, r7, #4
 800d916:	681b      	ldr	r3, [r3, #0]
 800d918:	781b      	ldrb	r3, [r3, #0]
 800d91a:	2b46      	cmp	r3, #70	; 0x46
 800d91c:	f201 868c 	bhi.w	800f638 <d_print_comp+0x1d70>
 800d920:	a201      	add	r2, pc, #4	; (adr r2, 800d928 <d_print_comp+0x60>)
 800d922:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d926:	bf00      	nop
 800d928:	0800da45 	.word	0x0800da45
 800d92c:	0800da97 	.word	0x0800da97
 800d930:	0800da97 	.word	0x0800da97
 800d934:	0800daff 	.word	0x0800daff
 800d938:	0800de1d 	.word	0x0800de1d
 800d93c:	0800df4b 	.word	0x0800df4b
 800d940:	0800f48f 	.word	0x0800f48f
 800d944:	0800dfe3 	.word	0x0800dfe3
 800d948:	0800e001 	.word	0x0800e001
 800d94c:	0800e02d 	.word	0x0800e02d
 800d950:	0800e05d 	.word	0x0800e05d
 800d954:	0800e08d 	.word	0x0800e08d
 800d958:	0800e0e9 	.word	0x0800e0e9
 800d95c:	0800e119 	.word	0x0800e119
 800d960:	0800e149 	.word	0x0800e149
 800d964:	0800e179 	.word	0x0800e179
 800d968:	0800e1a9 	.word	0x0800e1a9
 800d96c:	0800e1d9 	.word	0x0800e1d9
 800d970:	0800e209 	.word	0x0800e209
 800d974:	0800e239 	.word	0x0800e239
 800d978:	0800e269 	.word	0x0800e269
 800d97c:	0800e2c5 	.word	0x0800e2c5
 800d980:	0800e355 	.word	0x0800e355
 800d984:	0800e377 	.word	0x0800e377
 800d988:	0800e377 	.word	0x0800e377
 800d98c:	0800e377 	.word	0x0800e377
 800d990:	0800e4ab 	.word	0x0800e4ab
 800d994:	0800e4ab 	.word	0x0800e4ab
 800d998:	0800e4ab 	.word	0x0800e4ab
 800d99c:	0800e4ab 	.word	0x0800e4ab
 800d9a0:	0800e4ab 	.word	0x0800e4ab
 800d9a4:	0800e3ff 	.word	0x0800e3ff
 800d9a8:	0800e3ff 	.word	0x0800e3ff
 800d9ac:	0800e4ab 	.word	0x0800e4ab
 800d9b0:	0800e4ab 	.word	0x0800e4ab
 800d9b4:	0800e533 	.word	0x0800e533
 800d9b8:	0800e58d 	.word	0x0800e58d
 800d9bc:	0800e5ab 	.word	0x0800e5ab
 800d9c0:	0800e6ef 	.word	0x0800e6ef
 800d9c4:	0800e895 	.word	0x0800e895
 800d9c8:	0800e90f 	.word	0x0800e90f
 800d9cc:	0800e895 	.word	0x0800e895
 800d9d0:	0800e99d 	.word	0x0800e99d
 800d9d4:	0800e99d 	.word	0x0800e99d
 800d9d8:	0800ea75 	.word	0x0800ea75
 800d9dc:	0800eadd 	.word	0x0800eadd
 800d9e0:	0800eb69 	.word	0x0800eb69
 800d9e4:	0800eb99 	.word	0x0800eb99
 800d9e8:	0800ebc5 	.word	0x0800ebc5
 800d9ec:	0800ebe9 	.word	0x0800ebe9
 800d9f0:	0800ed91 	.word	0x0800ed91
 800d9f4:	0800ef6b 	.word	0x0800ef6b
 800d9f8:	0800ef77 	.word	0x0800ef77
 800d9fc:	0800f0cd 	.word	0x0800f0cd
 800da00:	0800f0cd 	.word	0x0800f0cd
 800da04:	0800f0d9 	.word	0x0800f0d9
 800da08:	0800f0d9 	.word	0x0800f0d9
 800da0c:	0800f305 	.word	0x0800f305
 800da10:	0800f333 	.word	0x0800f333
 800da14:	0800f369 	.word	0x0800f369
 800da18:	0800f2ef 	.word	0x0800f2ef
 800da1c:	0800f381 	.word	0x0800f381
 800da20:	0800f4e7 	.word	0x0800f4e7
 800da24:	0800f515 	.word	0x0800f515
 800da28:	0800f543 	.word	0x0800f543
 800da2c:	0800f639 	.word	0x0800f639
 800da30:	0800f5a9 	.word	0x0800f5a9
 800da34:	0800e2f5 	.word	0x0800e2f5
 800da38:	0800e325 	.word	0x0800e325
 800da3c:	0800f3bd 	.word	0x0800f3bd
 800da40:	0800f5e3 	.word	0x0800f5e3
 800da44:	f107 0308 	add.w	r3, r7, #8
 800da48:	681b      	ldr	r3, [r3, #0]
 800da4a:	f003 0304 	and.w	r3, r3, #4
 800da4e:	2b00      	cmp	r3, #0
 800da50:	d110      	bne.n	800da74 <d_print_comp+0x1ac>
 800da52:	f107 0304 	add.w	r3, r7, #4
 800da56:	681b      	ldr	r3, [r3, #0]
 800da58:	685a      	ldr	r2, [r3, #4]
 800da5a:	f107 0304 	add.w	r3, r7, #4
 800da5e:	681b      	ldr	r3, [r3, #0]
 800da60:	689b      	ldr	r3, [r3, #8]
 800da62:	f107 010c 	add.w	r1, r7, #12
 800da66:	6808      	ldr	r0, [r1, #0]
 800da68:	4611      	mov	r1, r2
 800da6a:	461a      	mov	r2, r3
 800da6c:	f7ff fcd4 	bl	800d418 <d_append_buffer>
 800da70:	f001 bdf4 	b.w	800f65c <d_print_comp+0x1d94>
 800da74:	f107 0304 	add.w	r3, r7, #4
 800da78:	681b      	ldr	r3, [r3, #0]
 800da7a:	685a      	ldr	r2, [r3, #4]
 800da7c:	f107 0304 	add.w	r3, r7, #4
 800da80:	681b      	ldr	r3, [r3, #0]
 800da82:	689b      	ldr	r3, [r3, #8]
 800da84:	f107 010c 	add.w	r1, r7, #12
 800da88:	6808      	ldr	r0, [r1, #0]
 800da8a:	4611      	mov	r1, r2
 800da8c:	461a      	mov	r2, r3
 800da8e:	f001 fde9 	bl	800f664 <d_print_java_identifier>
 800da92:	f001 bde3 	b.w	800f65c <d_print_comp+0x1d94>
 800da96:	f107 0304 	add.w	r3, r7, #4
 800da9a:	681b      	ldr	r3, [r3, #0]
 800da9c:	685b      	ldr	r3, [r3, #4]
 800da9e:	f107 010c 	add.w	r1, r7, #12
 800daa2:	f107 0208 	add.w	r2, r7, #8
 800daa6:	6808      	ldr	r0, [r1, #0]
 800daa8:	6811      	ldr	r1, [r2, #0]
 800daaa:	461a      	mov	r2, r3
 800daac:	f7ff ff0c 	bl	800d8c8 <d_print_comp>
 800dab0:	f107 0308 	add.w	r3, r7, #8
 800dab4:	681b      	ldr	r3, [r3, #0]
 800dab6:	f003 0304 	and.w	r3, r3, #4
 800daba:	2b00      	cmp	r3, #0
 800dabc:	d109      	bne.n	800dad2 <d_print_comp+0x20a>
 800dabe:	f107 030c 	add.w	r3, r7, #12
 800dac2:	6818      	ldr	r0, [r3, #0]
 800dac4:	f24f 51dc 	movw	r1, #62940	; 0xf5dc
 800dac8:	f6c0 0101 	movt	r1, #2049	; 0x801
 800dacc:	f7ff fcc2 	bl	800d454 <d_append_string>
 800dad0:	e006      	b.n	800dae0 <d_print_comp+0x218>
 800dad2:	f107 030c 	add.w	r3, r7, #12
 800dad6:	6818      	ldr	r0, [r3, #0]
 800dad8:	f04f 012e 	mov.w	r1, #46	; 0x2e
 800dadc:	f7ff fc7a 	bl	800d3d4 <d_append_char>
 800dae0:	f107 0304 	add.w	r3, r7, #4
 800dae4:	681b      	ldr	r3, [r3, #0]
 800dae6:	689b      	ldr	r3, [r3, #8]
 800dae8:	f107 010c 	add.w	r1, r7, #12
 800daec:	f107 0208 	add.w	r2, r7, #8
 800daf0:	6808      	ldr	r0, [r1, #0]
 800daf2:	6811      	ldr	r1, [r2, #0]
 800daf4:	461a      	mov	r2, r3
 800daf6:	f7ff fee7 	bl	800d8c8 <d_print_comp>
 800dafa:	f001 bdaf 	b.w	800f65c <d_print_comp+0x1d94>
 800dafe:	f107 030c 	add.w	r3, r7, #12
 800db02:	681b      	ldr	r3, [r3, #0]
 800db04:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800db08:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 800db0c:	f107 030c 	add.w	r3, r7, #12
 800db10:	681b      	ldr	r3, [r3, #0]
 800db12:	f04f 0200 	mov.w	r2, #0
 800db16:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800db1a:	f04f 0300 	mov.w	r3, #0
 800db1e:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 800db22:	f107 0304 	add.w	r3, r7, #4
 800db26:	681b      	ldr	r3, [r3, #0]
 800db28:	685b      	ldr	r3, [r3, #4]
 800db2a:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 800db2e:	e062      	b.n	800dbf6 <d_print_comp+0x32e>
 800db30:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800db34:	2b03      	cmp	r3, #3
 800db36:	d906      	bls.n	800db46 <d_print_comp+0x27e>
 800db38:	f107 030c 	add.w	r3, r7, #12
 800db3c:	6818      	ldr	r0, [r3, #0]
 800db3e:	f7ff fc01 	bl	800d344 <d_print_error>
 800db42:	f001 bd8b 	b.w	800f65c <d_print_comp+0x1d94>
 800db46:	f107 030c 	add.w	r3, r7, #12
 800db4a:	681b      	ldr	r3, [r3, #0]
 800db4c:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 800db50:	f107 0110 	add.w	r1, r7, #16
 800db54:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800db58:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800db5c:	18cb      	adds	r3, r1, r3
 800db5e:	601a      	str	r2, [r3, #0]
 800db60:	f107 0210 	add.w	r2, r7, #16
 800db64:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800db68:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800db6c:	18d2      	adds	r2, r2, r3
 800db6e:	f107 030c 	add.w	r3, r7, #12
 800db72:	681b      	ldr	r3, [r3, #0]
 800db74:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800db78:	f107 0210 	add.w	r2, r7, #16
 800db7c:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800db80:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800db84:	18d3      	adds	r3, r2, r3
 800db86:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 800db8a:	605a      	str	r2, [r3, #4]
 800db8c:	f107 0210 	add.w	r2, r7, #16
 800db90:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800db94:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800db98:	18d3      	adds	r3, r2, r3
 800db9a:	f103 0308 	add.w	r3, r3, #8
 800db9e:	f04f 0200 	mov.w	r2, #0
 800dba2:	601a      	str	r2, [r3, #0]
 800dba4:	f107 030c 	add.w	r3, r7, #12
 800dba8:	681b      	ldr	r3, [r3, #0]
 800dbaa:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
 800dbae:	f107 0110 	add.w	r1, r7, #16
 800dbb2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800dbb6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800dbba:	18cb      	adds	r3, r1, r3
 800dbbc:	f103 0308 	add.w	r3, r3, #8
 800dbc0:	605a      	str	r2, [r3, #4]
 800dbc2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800dbc6:	f103 0301 	add.w	r3, r3, #1
 800dbca:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 800dbce:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800dbd2:	781b      	ldrb	r3, [r3, #0]
 800dbd4:	2b1a      	cmp	r3, #26
 800dbd6:	d009      	beq.n	800dbec <d_print_comp+0x324>
 800dbd8:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800dbdc:	781b      	ldrb	r3, [r3, #0]
 800dbde:	2b1b      	cmp	r3, #27
 800dbe0:	d004      	beq.n	800dbec <d_print_comp+0x324>
 800dbe2:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800dbe6:	781b      	ldrb	r3, [r3, #0]
 800dbe8:	2b1c      	cmp	r3, #28
 800dbea:	d109      	bne.n	800dc00 <d_print_comp+0x338>
 800dbec:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800dbf0:	685b      	ldr	r3, [r3, #4]
 800dbf2:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 800dbf6:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800dbfa:	2b00      	cmp	r3, #0
 800dbfc:	d198      	bne.n	800db30 <d_print_comp+0x268>
 800dbfe:	e000      	b.n	800dc02 <d_print_comp+0x33a>
 800dc00:	bf00      	nop
 800dc02:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800dc06:	2b00      	cmp	r3, #0
 800dc08:	d106      	bne.n	800dc18 <d_print_comp+0x350>
 800dc0a:	f107 030c 	add.w	r3, r7, #12
 800dc0e:	6818      	ldr	r0, [r3, #0]
 800dc10:	f7ff fb98 	bl	800d344 <d_print_error>
 800dc14:	f001 bd22 	b.w	800f65c <d_print_comp+0x1d94>
 800dc18:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800dc1c:	781b      	ldrb	r3, [r3, #0]
 800dc1e:	2b04      	cmp	r3, #4
 800dc20:	d111      	bne.n	800dc46 <d_print_comp+0x37e>
 800dc22:	f107 030c 	add.w	r3, r7, #12
 800dc26:	681b      	ldr	r3, [r3, #0]
 800dc28:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 800dc2c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800dc30:	f107 030c 	add.w	r3, r7, #12
 800dc34:	681b      	ldr	r3, [r3, #0]
 800dc36:	f107 0280 	add.w	r2, r7, #128	; 0x80
 800dc3a:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
 800dc3e:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800dc42:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800dc46:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800dc4a:	781b      	ldrb	r3, [r3, #0]
 800dc4c:	2b02      	cmp	r3, #2
 800dc4e:	f040 8094 	bne.w	800dd7a <d_print_comp+0x4b2>
 800dc52:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800dc56:	689b      	ldr	r3, [r3, #8]
 800dc58:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 800dc5c:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800dc60:	781b      	ldrb	r3, [r3, #0]
 800dc62:	2b41      	cmp	r3, #65	; 0x41
 800dc64:	d178      	bne.n	800dd58 <d_print_comp+0x490>
 800dc66:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800dc6a:	685b      	ldr	r3, [r3, #4]
 800dc6c:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 800dc70:	e072      	b.n	800dd58 <d_print_comp+0x490>
 800dc72:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800dc76:	2b03      	cmp	r3, #3
 800dc78:	d906      	bls.n	800dc88 <d_print_comp+0x3c0>
 800dc7a:	f107 030c 	add.w	r3, r7, #12
 800dc7e:	6818      	ldr	r0, [r3, #0]
 800dc80:	f7ff fb60 	bl	800d344 <d_print_error>
 800dc84:	f001 bcea 	b.w	800f65c <d_print_comp+0x1d94>
 800dc88:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800dc8c:	f103 33ff 	add.w	r3, r3, #4294967295
 800dc90:	f107 0110 	add.w	r1, r7, #16
 800dc94:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 800dc98:	ea4f 1202 	mov.w	r2, r2, lsl #4
 800dc9c:	188a      	adds	r2, r1, r2
 800dc9e:	f107 0110 	add.w	r1, r7, #16
 800dca2:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800dca6:	18cb      	adds	r3, r1, r3
 800dca8:	4614      	mov	r4, r2
 800dcaa:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800dcac:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 800dcb0:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800dcb4:	f103 33ff 	add.w	r3, r3, #4294967295
 800dcb8:	f107 0210 	add.w	r2, r7, #16
 800dcbc:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800dcc0:	18d2      	adds	r2, r2, r3
 800dcc2:	f107 0110 	add.w	r1, r7, #16
 800dcc6:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800dcca:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800dcce:	18cb      	adds	r3, r1, r3
 800dcd0:	601a      	str	r2, [r3, #0]
 800dcd2:	f107 0210 	add.w	r2, r7, #16
 800dcd6:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800dcda:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800dcde:	18d2      	adds	r2, r2, r3
 800dce0:	f107 030c 	add.w	r3, r7, #12
 800dce4:	681b      	ldr	r3, [r3, #0]
 800dce6:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800dcea:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800dcee:	f103 33ff 	add.w	r3, r3, #4294967295
 800dcf2:	f107 0210 	add.w	r2, r7, #16
 800dcf6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800dcfa:	18d3      	adds	r3, r2, r3
 800dcfc:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 800dd00:	605a      	str	r2, [r3, #4]
 800dd02:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800dd06:	f103 33ff 	add.w	r3, r3, #4294967295
 800dd0a:	f107 0210 	add.w	r2, r7, #16
 800dd0e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800dd12:	18d3      	adds	r3, r2, r3
 800dd14:	f103 0308 	add.w	r3, r3, #8
 800dd18:	f04f 0200 	mov.w	r2, #0
 800dd1c:	601a      	str	r2, [r3, #0]
 800dd1e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800dd22:	f103 33ff 	add.w	r3, r3, #4294967295
 800dd26:	f107 020c 	add.w	r2, r7, #12
 800dd2a:	6812      	ldr	r2, [r2, #0]
 800dd2c:	f8d2 2110 	ldr.w	r2, [r2, #272]	; 0x110
 800dd30:	f107 0110 	add.w	r1, r7, #16
 800dd34:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800dd38:	18cb      	adds	r3, r1, r3
 800dd3a:	f103 0308 	add.w	r3, r3, #8
 800dd3e:	605a      	str	r2, [r3, #4]
 800dd40:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800dd44:	f103 0301 	add.w	r3, r3, #1
 800dd48:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 800dd4c:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800dd50:	685b      	ldr	r3, [r3, #4]
 800dd52:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 800dd56:	e000      	b.n	800dd5a <d_print_comp+0x492>
 800dd58:	bf00      	nop
 800dd5a:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800dd5e:	781b      	ldrb	r3, [r3, #0]
 800dd60:	2b1a      	cmp	r3, #26
 800dd62:	d086      	beq.n	800dc72 <d_print_comp+0x3aa>
 800dd64:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800dd68:	781b      	ldrb	r3, [r3, #0]
 800dd6a:	2b1b      	cmp	r3, #27
 800dd6c:	d081      	beq.n	800dc72 <d_print_comp+0x3aa>
 800dd6e:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800dd72:	781b      	ldrb	r3, [r3, #0]
 800dd74:	2b1c      	cmp	r3, #28
 800dd76:	f43f af7c 	beq.w	800dc72 <d_print_comp+0x3aa>
 800dd7a:	f107 0304 	add.w	r3, r7, #4
 800dd7e:	681b      	ldr	r3, [r3, #0]
 800dd80:	689b      	ldr	r3, [r3, #8]
 800dd82:	f107 010c 	add.w	r1, r7, #12
 800dd86:	f107 0208 	add.w	r2, r7, #8
 800dd8a:	6808      	ldr	r0, [r1, #0]
 800dd8c:	6811      	ldr	r1, [r2, #0]
 800dd8e:	461a      	mov	r2, r3
 800dd90:	f7ff fd9a 	bl	800d8c8 <d_print_comp>
 800dd94:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800dd98:	781b      	ldrb	r3, [r3, #0]
 800dd9a:	2b04      	cmp	r3, #4
 800dd9c:	d131      	bne.n	800de02 <d_print_comp+0x53a>
 800dd9e:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800dda2:	f107 030c 	add.w	r3, r7, #12
 800dda6:	681b      	ldr	r3, [r3, #0]
 800dda8:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
 800ddac:	e029      	b.n	800de02 <d_print_comp+0x53a>
 800ddae:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800ddb2:	f103 33ff 	add.w	r3, r3, #4294967295
 800ddb6:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 800ddba:	f107 0210 	add.w	r2, r7, #16
 800ddbe:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800ddc2:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800ddc6:	18d3      	adds	r3, r2, r3
 800ddc8:	f103 0308 	add.w	r3, r3, #8
 800ddcc:	681b      	ldr	r3, [r3, #0]
 800ddce:	2b00      	cmp	r3, #0
 800ddd0:	d117      	bne.n	800de02 <d_print_comp+0x53a>
 800ddd2:	f107 030c 	add.w	r3, r7, #12
 800ddd6:	6818      	ldr	r0, [r3, #0]
 800ddd8:	f04f 0120 	mov.w	r1, #32
 800dddc:	f7ff fafa 	bl	800d3d4 <d_append_char>
 800dde0:	f107 0210 	add.w	r2, r7, #16
 800dde4:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800dde8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800ddec:	18d3      	adds	r3, r2, r3
 800ddee:	685b      	ldr	r3, [r3, #4]
 800ddf0:	f107 010c 	add.w	r1, r7, #12
 800ddf4:	f107 0208 	add.w	r2, r7, #8
 800ddf8:	6808      	ldr	r0, [r1, #0]
 800ddfa:	6811      	ldr	r1, [r2, #0]
 800ddfc:	461a      	mov	r2, r3
 800ddfe:	f001 fd9d 	bl	800f93c <d_print_mod>
 800de02:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800de06:	2b00      	cmp	r3, #0
 800de08:	d1d1      	bne.n	800ddae <d_print_comp+0x4e6>
 800de0a:	f107 030c 	add.w	r3, r7, #12
 800de0e:	681b      	ldr	r3, [r3, #0]
 800de10:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 800de14:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800de18:	f001 bc20 	b.w	800f65c <d_print_comp+0x1d94>
 800de1c:	f107 030c 	add.w	r3, r7, #12
 800de20:	681b      	ldr	r3, [r3, #0]
 800de22:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800de26:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
 800de2a:	f107 030c 	add.w	r3, r7, #12
 800de2e:	681b      	ldr	r3, [r3, #0]
 800de30:	f04f 0200 	mov.w	r2, #0
 800de34:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800de38:	f107 0304 	add.w	r3, r7, #4
 800de3c:	681b      	ldr	r3, [r3, #0]
 800de3e:	685b      	ldr	r3, [r3, #4]
 800de40:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 800de44:	f107 0308 	add.w	r3, r7, #8
 800de48:	681b      	ldr	r3, [r3, #0]
 800de4a:	f003 0304 	and.w	r3, r3, #4
 800de4e:	2b00      	cmp	r3, #0
 800de50:	d02f      	beq.n	800deb2 <d_print_comp+0x5ea>
 800de52:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800de56:	781b      	ldrb	r3, [r3, #0]
 800de58:	2b00      	cmp	r3, #0
 800de5a:	d12a      	bne.n	800deb2 <d_print_comp+0x5ea>
 800de5c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800de60:	689b      	ldr	r3, [r3, #8]
 800de62:	2b06      	cmp	r3, #6
 800de64:	d125      	bne.n	800deb2 <d_print_comp+0x5ea>
 800de66:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800de6a:	685b      	ldr	r3, [r3, #4]
 800de6c:	4618      	mov	r0, r3
 800de6e:	f64f 510c 	movw	r1, #64780	; 0xfd0c
 800de72:	f6c0 0101 	movt	r1, #2049	; 0x801
 800de76:	f04f 0206 	mov.w	r2, #6
 800de7a:	f004 fead 	bl	8012bd8 <strncmp>
 800de7e:	4603      	mov	r3, r0
 800de80:	2b00      	cmp	r3, #0
 800de82:	d116      	bne.n	800deb2 <d_print_comp+0x5ea>
 800de84:	f107 0304 	add.w	r3, r7, #4
 800de88:	681b      	ldr	r3, [r3, #0]
 800de8a:	689b      	ldr	r3, [r3, #8]
 800de8c:	f107 010c 	add.w	r1, r7, #12
 800de90:	f107 0208 	add.w	r2, r7, #8
 800de94:	6808      	ldr	r0, [r1, #0]
 800de96:	6811      	ldr	r1, [r2, #0]
 800de98:	461a      	mov	r2, r3
 800de9a:	f7ff fd15 	bl	800d8c8 <d_print_comp>
 800de9e:	f107 030c 	add.w	r3, r7, #12
 800dea2:	6818      	ldr	r0, [r3, #0]
 800dea4:	f24f 51ec 	movw	r1, #62956	; 0xf5ec
 800dea8:	f6c0 0101 	movt	r1, #2049	; 0x801
 800deac:	f7ff fad2 	bl	800d454 <d_append_string>
 800deb0:	e042      	b.n	800df38 <d_print_comp+0x670>
 800deb2:	f107 020c 	add.w	r2, r7, #12
 800deb6:	f107 0308 	add.w	r3, r7, #8
 800deba:	6810      	ldr	r0, [r2, #0]
 800debc:	6819      	ldr	r1, [r3, #0]
 800debe:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 800dec2:	f7ff fd01 	bl	800d8c8 <d_print_comp>
 800dec6:	f107 030c 	add.w	r3, r7, #12
 800deca:	6818      	ldr	r0, [r3, #0]
 800decc:	f7ff faee 	bl	800d4ac <d_last_char>
 800ded0:	4603      	mov	r3, r0
 800ded2:	2b3c      	cmp	r3, #60	; 0x3c
 800ded4:	d106      	bne.n	800dee4 <d_print_comp+0x61c>
 800ded6:	f107 030c 	add.w	r3, r7, #12
 800deda:	6818      	ldr	r0, [r3, #0]
 800dedc:	f04f 0120 	mov.w	r1, #32
 800dee0:	f7ff fa78 	bl	800d3d4 <d_append_char>
 800dee4:	f107 030c 	add.w	r3, r7, #12
 800dee8:	6818      	ldr	r0, [r3, #0]
 800deea:	f04f 013c 	mov.w	r1, #60	; 0x3c
 800deee:	f7ff fa71 	bl	800d3d4 <d_append_char>
 800def2:	f107 0304 	add.w	r3, r7, #4
 800def6:	681b      	ldr	r3, [r3, #0]
 800def8:	689b      	ldr	r3, [r3, #8]
 800defa:	f107 010c 	add.w	r1, r7, #12
 800defe:	f107 0208 	add.w	r2, r7, #8
 800df02:	6808      	ldr	r0, [r1, #0]
 800df04:	6811      	ldr	r1, [r2, #0]
 800df06:	461a      	mov	r2, r3
 800df08:	f7ff fcde 	bl	800d8c8 <d_print_comp>
 800df0c:	f107 030c 	add.w	r3, r7, #12
 800df10:	6818      	ldr	r0, [r3, #0]
 800df12:	f7ff facb 	bl	800d4ac <d_last_char>
 800df16:	4603      	mov	r3, r0
 800df18:	2b3e      	cmp	r3, #62	; 0x3e
 800df1a:	d106      	bne.n	800df2a <d_print_comp+0x662>
 800df1c:	f107 030c 	add.w	r3, r7, #12
 800df20:	6818      	ldr	r0, [r3, #0]
 800df22:	f04f 0120 	mov.w	r1, #32
 800df26:	f7ff fa55 	bl	800d3d4 <d_append_char>
 800df2a:	f107 030c 	add.w	r3, r7, #12
 800df2e:	6818      	ldr	r0, [r3, #0]
 800df30:	f04f 013e 	mov.w	r1, #62	; 0x3e
 800df34:	f7ff fa4e 	bl	800d3d4 <d_append_char>
 800df38:	f107 030c 	add.w	r3, r7, #12
 800df3c:	681b      	ldr	r3, [r3, #0]
 800df3e:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 800df42:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800df46:	f001 bb89 	b.w	800f65c <d_print_comp+0x1d94>
 800df4a:	f107 020c 	add.w	r2, r7, #12
 800df4e:	f107 0304 	add.w	r3, r7, #4
 800df52:	6810      	ldr	r0, [r2, #0]
 800df54:	6819      	ldr	r1, [r3, #0]
 800df56:	f7ff fb55 	bl	800d604 <d_lookup_template_argument>
 800df5a:	f8c7 00fc 	str.w	r0, [r7, #252]	; 0xfc
 800df5e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800df62:	2b00      	cmp	r3, #0
 800df64:	d010      	beq.n	800df88 <d_print_comp+0x6c0>
 800df66:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800df6a:	781b      	ldrb	r3, [r3, #0]
 800df6c:	2b2b      	cmp	r3, #43	; 0x2b
 800df6e:	d10b      	bne.n	800df88 <d_print_comp+0x6c0>
 800df70:	f107 030c 	add.w	r3, r7, #12
 800df74:	681b      	ldr	r3, [r3, #0]
 800df76:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 800df7a:	f8d7 00fc 	ldr.w	r0, [r7, #252]	; 0xfc
 800df7e:	4619      	mov	r1, r3
 800df80:	f7ff fb10 	bl	800d5a4 <d_index_template_argument>
 800df84:	f8c7 00fc 	str.w	r0, [r7, #252]	; 0xfc
 800df88:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800df8c:	2b00      	cmp	r3, #0
 800df8e:	d106      	bne.n	800df9e <d_print_comp+0x6d6>
 800df90:	f107 030c 	add.w	r3, r7, #12
 800df94:	6818      	ldr	r0, [r3, #0]
 800df96:	f7ff f9d5 	bl	800d344 <d_print_error>
 800df9a:	f001 bb5f 	b.w	800f65c <d_print_comp+0x1d94>
 800df9e:	f107 030c 	add.w	r3, r7, #12
 800dfa2:	681b      	ldr	r3, [r3, #0]
 800dfa4:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 800dfa8:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 800dfac:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800dfb0:	681a      	ldr	r2, [r3, #0]
 800dfb2:	f107 030c 	add.w	r3, r7, #12
 800dfb6:	681b      	ldr	r3, [r3, #0]
 800dfb8:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
 800dfbc:	f107 020c 	add.w	r2, r7, #12
 800dfc0:	f107 0308 	add.w	r3, r7, #8
 800dfc4:	6810      	ldr	r0, [r2, #0]
 800dfc6:	6819      	ldr	r1, [r3, #0]
 800dfc8:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 800dfcc:	f7ff fc7c 	bl	800d8c8 <d_print_comp>
 800dfd0:	f107 030c 	add.w	r3, r7, #12
 800dfd4:	681b      	ldr	r3, [r3, #0]
 800dfd6:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 800dfda:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
 800dfde:	f001 bb3d 	b.w	800f65c <d_print_comp+0x1d94>
 800dfe2:	f107 0304 	add.w	r3, r7, #4
 800dfe6:	681b      	ldr	r3, [r3, #0]
 800dfe8:	689b      	ldr	r3, [r3, #8]
 800dfea:	f107 010c 	add.w	r1, r7, #12
 800dfee:	f107 0208 	add.w	r2, r7, #8
 800dff2:	6808      	ldr	r0, [r1, #0]
 800dff4:	6811      	ldr	r1, [r2, #0]
 800dff6:	461a      	mov	r2, r3
 800dff8:	f7ff fc66 	bl	800d8c8 <d_print_comp>
 800dffc:	f001 bb2e 	b.w	800f65c <d_print_comp+0x1d94>
 800e000:	f107 030c 	add.w	r3, r7, #12
 800e004:	6818      	ldr	r0, [r3, #0]
 800e006:	f04f 017e 	mov.w	r1, #126	; 0x7e
 800e00a:	f7ff f9e3 	bl	800d3d4 <d_append_char>
 800e00e:	f107 0304 	add.w	r3, r7, #4
 800e012:	681b      	ldr	r3, [r3, #0]
 800e014:	689b      	ldr	r3, [r3, #8]
 800e016:	f107 010c 	add.w	r1, r7, #12
 800e01a:	f107 0208 	add.w	r2, r7, #8
 800e01e:	6808      	ldr	r0, [r1, #0]
 800e020:	6811      	ldr	r1, [r2, #0]
 800e022:	461a      	mov	r2, r3
 800e024:	f7ff fc50 	bl	800d8c8 <d_print_comp>
 800e028:	f001 bb18 	b.w	800f65c <d_print_comp+0x1d94>
 800e02c:	f107 030c 	add.w	r3, r7, #12
 800e030:	6818      	ldr	r0, [r3, #0]
 800e032:	f64f 5114 	movw	r1, #64788	; 0xfd14
 800e036:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e03a:	f7ff fa0b 	bl	800d454 <d_append_string>
 800e03e:	f107 0304 	add.w	r3, r7, #4
 800e042:	681b      	ldr	r3, [r3, #0]
 800e044:	685b      	ldr	r3, [r3, #4]
 800e046:	f107 010c 	add.w	r1, r7, #12
 800e04a:	f107 0208 	add.w	r2, r7, #8
 800e04e:	6808      	ldr	r0, [r1, #0]
 800e050:	6811      	ldr	r1, [r2, #0]
 800e052:	461a      	mov	r2, r3
 800e054:	f7ff fc38 	bl	800d8c8 <d_print_comp>
 800e058:	f001 bb00 	b.w	800f65c <d_print_comp+0x1d94>
 800e05c:	f107 030c 	add.w	r3, r7, #12
 800e060:	6818      	ldr	r0, [r3, #0]
 800e062:	f64f 5120 	movw	r1, #64800	; 0xfd20
 800e066:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e06a:	f7ff f9f3 	bl	800d454 <d_append_string>
 800e06e:	f107 0304 	add.w	r3, r7, #4
 800e072:	681b      	ldr	r3, [r3, #0]
 800e074:	685b      	ldr	r3, [r3, #4]
 800e076:	f107 010c 	add.w	r1, r7, #12
 800e07a:	f107 0208 	add.w	r2, r7, #8
 800e07e:	6808      	ldr	r0, [r1, #0]
 800e080:	6811      	ldr	r1, [r2, #0]
 800e082:	461a      	mov	r2, r3
 800e084:	f7ff fc20 	bl	800d8c8 <d_print_comp>
 800e088:	f001 bae8 	b.w	800f65c <d_print_comp+0x1d94>
 800e08c:	f107 030c 	add.w	r3, r7, #12
 800e090:	6818      	ldr	r0, [r3, #0]
 800e092:	f64f 512c 	movw	r1, #64812	; 0xfd2c
 800e096:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e09a:	f7ff f9db 	bl	800d454 <d_append_string>
 800e09e:	f107 0304 	add.w	r3, r7, #4
 800e0a2:	681b      	ldr	r3, [r3, #0]
 800e0a4:	685b      	ldr	r3, [r3, #4]
 800e0a6:	f107 010c 	add.w	r1, r7, #12
 800e0aa:	f107 0208 	add.w	r2, r7, #8
 800e0ae:	6808      	ldr	r0, [r1, #0]
 800e0b0:	6811      	ldr	r1, [r2, #0]
 800e0b2:	461a      	mov	r2, r3
 800e0b4:	f7ff fc08 	bl	800d8c8 <d_print_comp>
 800e0b8:	f107 030c 	add.w	r3, r7, #12
 800e0bc:	6818      	ldr	r0, [r3, #0]
 800e0be:	f64f 5148 	movw	r1, #64840	; 0xfd48
 800e0c2:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e0c6:	f7ff f9c5 	bl	800d454 <d_append_string>
 800e0ca:	f107 0304 	add.w	r3, r7, #4
 800e0ce:	681b      	ldr	r3, [r3, #0]
 800e0d0:	689b      	ldr	r3, [r3, #8]
 800e0d2:	f107 010c 	add.w	r1, r7, #12
 800e0d6:	f107 0208 	add.w	r2, r7, #8
 800e0da:	6808      	ldr	r0, [r1, #0]
 800e0dc:	6811      	ldr	r1, [r2, #0]
 800e0de:	461a      	mov	r2, r3
 800e0e0:	f7ff fbf2 	bl	800d8c8 <d_print_comp>
 800e0e4:	f001 baba 	b.w	800f65c <d_print_comp+0x1d94>
 800e0e8:	f107 030c 	add.w	r3, r7, #12
 800e0ec:	6818      	ldr	r0, [r3, #0]
 800e0ee:	f64f 5150 	movw	r1, #64848	; 0xfd50
 800e0f2:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e0f6:	f7ff f9ad 	bl	800d454 <d_append_string>
 800e0fa:	f107 0304 	add.w	r3, r7, #4
 800e0fe:	681b      	ldr	r3, [r3, #0]
 800e100:	685b      	ldr	r3, [r3, #4]
 800e102:	f107 010c 	add.w	r1, r7, #12
 800e106:	f107 0208 	add.w	r2, r7, #8
 800e10a:	6808      	ldr	r0, [r1, #0]
 800e10c:	6811      	ldr	r1, [r2, #0]
 800e10e:	461a      	mov	r2, r3
 800e110:	f7ff fbda 	bl	800d8c8 <d_print_comp>
 800e114:	f001 baa2 	b.w	800f65c <d_print_comp+0x1d94>
 800e118:	f107 030c 	add.w	r3, r7, #12
 800e11c:	6818      	ldr	r0, [r3, #0]
 800e11e:	f64f 5160 	movw	r1, #64864	; 0xfd60
 800e122:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e126:	f7ff f995 	bl	800d454 <d_append_string>
 800e12a:	f107 0304 	add.w	r3, r7, #4
 800e12e:	681b      	ldr	r3, [r3, #0]
 800e130:	685b      	ldr	r3, [r3, #4]
 800e132:	f107 010c 	add.w	r1, r7, #12
 800e136:	f107 0208 	add.w	r2, r7, #8
 800e13a:	6808      	ldr	r0, [r1, #0]
 800e13c:	6811      	ldr	r1, [r2, #0]
 800e13e:	461a      	mov	r2, r3
 800e140:	f7ff fbc2 	bl	800d8c8 <d_print_comp>
 800e144:	f001 ba8a 	b.w	800f65c <d_print_comp+0x1d94>
 800e148:	f107 030c 	add.w	r3, r7, #12
 800e14c:	6818      	ldr	r0, [r3, #0]
 800e14e:	f64f 5174 	movw	r1, #64884	; 0xfd74
 800e152:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e156:	f7ff f97d 	bl	800d454 <d_append_string>
 800e15a:	f107 0304 	add.w	r3, r7, #4
 800e15e:	681b      	ldr	r3, [r3, #0]
 800e160:	685b      	ldr	r3, [r3, #4]
 800e162:	f107 010c 	add.w	r1, r7, #12
 800e166:	f107 0208 	add.w	r2, r7, #8
 800e16a:	6808      	ldr	r0, [r1, #0]
 800e16c:	6811      	ldr	r1, [r2, #0]
 800e16e:	461a      	mov	r2, r3
 800e170:	f7ff fbaa 	bl	800d8c8 <d_print_comp>
 800e174:	f001 ba72 	b.w	800f65c <d_print_comp+0x1d94>
 800e178:	f107 030c 	add.w	r3, r7, #12
 800e17c:	6818      	ldr	r0, [r3, #0]
 800e17e:	f64f 5188 	movw	r1, #64904	; 0xfd88
 800e182:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e186:	f7ff f965 	bl	800d454 <d_append_string>
 800e18a:	f107 0304 	add.w	r3, r7, #4
 800e18e:	681b      	ldr	r3, [r3, #0]
 800e190:	685b      	ldr	r3, [r3, #4]
 800e192:	f107 010c 	add.w	r1, r7, #12
 800e196:	f107 0208 	add.w	r2, r7, #8
 800e19a:	6808      	ldr	r0, [r1, #0]
 800e19c:	6811      	ldr	r1, [r2, #0]
 800e19e:	461a      	mov	r2, r3
 800e1a0:	f7ff fb92 	bl	800d8c8 <d_print_comp>
 800e1a4:	f001 ba5a 	b.w	800f65c <d_print_comp+0x1d94>
 800e1a8:	f107 030c 	add.w	r3, r7, #12
 800e1ac:	6818      	ldr	r0, [r3, #0]
 800e1ae:	f64f 51a0 	movw	r1, #64928	; 0xfda0
 800e1b2:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e1b6:	f7ff f94d 	bl	800d454 <d_append_string>
 800e1ba:	f107 0304 	add.w	r3, r7, #4
 800e1be:	681b      	ldr	r3, [r3, #0]
 800e1c0:	685b      	ldr	r3, [r3, #4]
 800e1c2:	f107 010c 	add.w	r1, r7, #12
 800e1c6:	f107 0208 	add.w	r2, r7, #8
 800e1ca:	6808      	ldr	r0, [r1, #0]
 800e1cc:	6811      	ldr	r1, [r2, #0]
 800e1ce:	461a      	mov	r2, r3
 800e1d0:	f7ff fb7a 	bl	800d8c8 <d_print_comp>
 800e1d4:	f001 ba42 	b.w	800f65c <d_print_comp+0x1d94>
 800e1d8:	f107 030c 	add.w	r3, r7, #12
 800e1dc:	6818      	ldr	r0, [r3, #0]
 800e1de:	f64f 51b4 	movw	r1, #64948	; 0xfdb4
 800e1e2:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e1e6:	f7ff f935 	bl	800d454 <d_append_string>
 800e1ea:	f107 0304 	add.w	r3, r7, #4
 800e1ee:	681b      	ldr	r3, [r3, #0]
 800e1f0:	685b      	ldr	r3, [r3, #4]
 800e1f2:	f107 010c 	add.w	r1, r7, #12
 800e1f6:	f107 0208 	add.w	r2, r7, #8
 800e1fa:	6808      	ldr	r0, [r1, #0]
 800e1fc:	6811      	ldr	r1, [r2, #0]
 800e1fe:	461a      	mov	r2, r3
 800e200:	f7ff fb62 	bl	800d8c8 <d_print_comp>
 800e204:	f001 ba2a 	b.w	800f65c <d_print_comp+0x1d94>
 800e208:	f107 030c 	add.w	r3, r7, #12
 800e20c:	6818      	ldr	r0, [r3, #0]
 800e20e:	f64f 51d0 	movw	r1, #64976	; 0xfdd0
 800e212:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e216:	f7ff f91d 	bl	800d454 <d_append_string>
 800e21a:	f107 0304 	add.w	r3, r7, #4
 800e21e:	681b      	ldr	r3, [r3, #0]
 800e220:	685b      	ldr	r3, [r3, #4]
 800e222:	f107 010c 	add.w	r1, r7, #12
 800e226:	f107 0208 	add.w	r2, r7, #8
 800e22a:	6808      	ldr	r0, [r1, #0]
 800e22c:	6811      	ldr	r1, [r2, #0]
 800e22e:	461a      	mov	r2, r3
 800e230:	f7ff fb4a 	bl	800d8c8 <d_print_comp>
 800e234:	f001 ba12 	b.w	800f65c <d_print_comp+0x1d94>
 800e238:	f107 030c 	add.w	r3, r7, #12
 800e23c:	6818      	ldr	r0, [r3, #0]
 800e23e:	f64f 51e0 	movw	r1, #64992	; 0xfde0
 800e242:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e246:	f7ff f905 	bl	800d454 <d_append_string>
 800e24a:	f107 0304 	add.w	r3, r7, #4
 800e24e:	681b      	ldr	r3, [r3, #0]
 800e250:	685b      	ldr	r3, [r3, #4]
 800e252:	f107 010c 	add.w	r1, r7, #12
 800e256:	f107 0208 	add.w	r2, r7, #8
 800e25a:	6808      	ldr	r0, [r1, #0]
 800e25c:	6811      	ldr	r1, [r2, #0]
 800e25e:	461a      	mov	r2, r3
 800e260:	f7ff fb32 	bl	800d8c8 <d_print_comp>
 800e264:	f001 b9fa 	b.w	800f65c <d_print_comp+0x1d94>
 800e268:	f107 030c 	add.w	r3, r7, #12
 800e26c:	6818      	ldr	r0, [r3, #0]
 800e26e:	f64f 51f4 	movw	r1, #65012	; 0xfdf4
 800e272:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e276:	f7ff f8ed 	bl	800d454 <d_append_string>
 800e27a:	f107 0304 	add.w	r3, r7, #4
 800e27e:	681b      	ldr	r3, [r3, #0]
 800e280:	689b      	ldr	r3, [r3, #8]
 800e282:	f107 010c 	add.w	r1, r7, #12
 800e286:	f107 0208 	add.w	r2, r7, #8
 800e28a:	6808      	ldr	r0, [r1, #0]
 800e28c:	6811      	ldr	r1, [r2, #0]
 800e28e:	461a      	mov	r2, r3
 800e290:	f7ff fb1a 	bl	800d8c8 <d_print_comp>
 800e294:	f107 030c 	add.w	r3, r7, #12
 800e298:	6818      	ldr	r0, [r3, #0]
 800e29a:	f64f 610c 	movw	r1, #65036	; 0xfe0c
 800e29e:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e2a2:	f7ff f8d7 	bl	800d454 <d_append_string>
 800e2a6:	f107 0304 	add.w	r3, r7, #4
 800e2aa:	681b      	ldr	r3, [r3, #0]
 800e2ac:	685b      	ldr	r3, [r3, #4]
 800e2ae:	f107 010c 	add.w	r1, r7, #12
 800e2b2:	f107 0208 	add.w	r2, r7, #8
 800e2b6:	6808      	ldr	r0, [r1, #0]
 800e2b8:	6811      	ldr	r1, [r2, #0]
 800e2ba:	461a      	mov	r2, r3
 800e2bc:	f7ff fb04 	bl	800d8c8 <d_print_comp>
 800e2c0:	f001 b9cc 	b.w	800f65c <d_print_comp+0x1d94>
 800e2c4:	f107 030c 	add.w	r3, r7, #12
 800e2c8:	6818      	ldr	r0, [r3, #0]
 800e2ca:	f64f 6114 	movw	r1, #65044	; 0xfe14
 800e2ce:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e2d2:	f7ff f8bf 	bl	800d454 <d_append_string>
 800e2d6:	f107 0304 	add.w	r3, r7, #4
 800e2da:	681b      	ldr	r3, [r3, #0]
 800e2dc:	685b      	ldr	r3, [r3, #4]
 800e2de:	f107 010c 	add.w	r1, r7, #12
 800e2e2:	f107 0208 	add.w	r2, r7, #8
 800e2e6:	6808      	ldr	r0, [r1, #0]
 800e2e8:	6811      	ldr	r1, [r2, #0]
 800e2ea:	461a      	mov	r2, r3
 800e2ec:	f7ff faec 	bl	800d8c8 <d_print_comp>
 800e2f0:	f001 b9b4 	b.w	800f65c <d_print_comp+0x1d94>
 800e2f4:	f107 030c 	add.w	r3, r7, #12
 800e2f8:	6818      	ldr	r0, [r3, #0]
 800e2fa:	f64f 6128 	movw	r1, #65064	; 0xfe28
 800e2fe:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e302:	f7ff f8a7 	bl	800d454 <d_append_string>
 800e306:	f107 0304 	add.w	r3, r7, #4
 800e30a:	681b      	ldr	r3, [r3, #0]
 800e30c:	685b      	ldr	r3, [r3, #4]
 800e30e:	f107 010c 	add.w	r1, r7, #12
 800e312:	f107 0208 	add.w	r2, r7, #8
 800e316:	6808      	ldr	r0, [r1, #0]
 800e318:	6811      	ldr	r1, [r2, #0]
 800e31a:	461a      	mov	r2, r3
 800e31c:	f7ff fad4 	bl	800d8c8 <d_print_comp>
 800e320:	f001 b99c 	b.w	800f65c <d_print_comp+0x1d94>
 800e324:	f107 030c 	add.w	r3, r7, #12
 800e328:	6818      	ldr	r0, [r3, #0]
 800e32a:	f64f 6140 	movw	r1, #65088	; 0xfe40
 800e32e:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e332:	f7ff f88f 	bl	800d454 <d_append_string>
 800e336:	f107 0304 	add.w	r3, r7, #4
 800e33a:	681b      	ldr	r3, [r3, #0]
 800e33c:	685b      	ldr	r3, [r3, #4]
 800e33e:	f107 010c 	add.w	r1, r7, #12
 800e342:	f107 0208 	add.w	r2, r7, #8
 800e346:	6808      	ldr	r0, [r1, #0]
 800e348:	6811      	ldr	r1, [r2, #0]
 800e34a:	461a      	mov	r2, r3
 800e34c:	f7ff fabc 	bl	800d8c8 <d_print_comp>
 800e350:	f001 b984 	b.w	800f65c <d_print_comp+0x1d94>
 800e354:	f107 0304 	add.w	r3, r7, #4
 800e358:	681b      	ldr	r3, [r3, #0]
 800e35a:	685a      	ldr	r2, [r3, #4]
 800e35c:	f107 0304 	add.w	r3, r7, #4
 800e360:	681b      	ldr	r3, [r3, #0]
 800e362:	689b      	ldr	r3, [r3, #8]
 800e364:	f107 010c 	add.w	r1, r7, #12
 800e368:	6808      	ldr	r0, [r1, #0]
 800e36a:	4611      	mov	r1, r2
 800e36c:	461a      	mov	r2, r3
 800e36e:	f7ff f853 	bl	800d418 <d_append_buffer>
 800e372:	f001 b973 	b.w	800f65c <d_print_comp+0x1d94>
 800e376:	f107 030c 	add.w	r3, r7, #12
 800e37a:	681b      	ldr	r3, [r3, #0]
 800e37c:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800e380:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 800e384:	e034      	b.n	800e3f0 <d_print_comp+0xb28>
 800e386:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800e38a:	689b      	ldr	r3, [r3, #8]
 800e38c:	2b00      	cmp	r3, #0
 800e38e:	d12a      	bne.n	800e3e6 <d_print_comp+0xb1e>
 800e390:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800e394:	685b      	ldr	r3, [r3, #4]
 800e396:	781b      	ldrb	r3, [r3, #0]
 800e398:	2b17      	cmp	r3, #23
 800e39a:	d00b      	beq.n	800e3b4 <d_print_comp+0xaec>
 800e39c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800e3a0:	685b      	ldr	r3, [r3, #4]
 800e3a2:	781b      	ldrb	r3, [r3, #0]
 800e3a4:	2b18      	cmp	r3, #24
 800e3a6:	d005      	beq.n	800e3b4 <d_print_comp+0xaec>
 800e3a8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800e3ac:	685b      	ldr	r3, [r3, #4]
 800e3ae:	781b      	ldrb	r3, [r3, #0]
 800e3b0:	2b19      	cmp	r3, #25
 800e3b2:	d122      	bne.n	800e3fa <d_print_comp+0xb32>
 800e3b4:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800e3b8:	685b      	ldr	r3, [r3, #4]
 800e3ba:	781a      	ldrb	r2, [r3, #0]
 800e3bc:	f107 0304 	add.w	r3, r7, #4
 800e3c0:	681b      	ldr	r3, [r3, #0]
 800e3c2:	781b      	ldrb	r3, [r3, #0]
 800e3c4:	429a      	cmp	r2, r3
 800e3c6:	d10e      	bne.n	800e3e6 <d_print_comp+0xb1e>
 800e3c8:	f107 0304 	add.w	r3, r7, #4
 800e3cc:	681b      	ldr	r3, [r3, #0]
 800e3ce:	685b      	ldr	r3, [r3, #4]
 800e3d0:	f107 010c 	add.w	r1, r7, #12
 800e3d4:	f107 0208 	add.w	r2, r7, #8
 800e3d8:	6808      	ldr	r0, [r1, #0]
 800e3da:	6811      	ldr	r1, [r2, #0]
 800e3dc:	461a      	mov	r2, r3
 800e3de:	f7ff fa73 	bl	800d8c8 <d_print_comp>
 800e3e2:	f001 b93b 	b.w	800f65c <d_print_comp+0x1d94>
 800e3e6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800e3ea:	681b      	ldr	r3, [r3, #0]
 800e3ec:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 800e3f0:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800e3f4:	2b00      	cmp	r3, #0
 800e3f6:	d1c6      	bne.n	800e386 <d_print_comp+0xabe>
 800e3f8:	e057      	b.n	800e4aa <d_print_comp+0xbe2>
 800e3fa:	bf00      	nop
 800e3fc:	e055      	b.n	800e4aa <d_print_comp+0xbe2>
 800e3fe:	f107 0304 	add.w	r3, r7, #4
 800e402:	681b      	ldr	r3, [r3, #0]
 800e404:	685b      	ldr	r3, [r3, #4]
 800e406:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 800e40a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800e40e:	781b      	ldrb	r3, [r3, #0]
 800e410:	2b05      	cmp	r3, #5
 800e412:	d12c      	bne.n	800e46e <d_print_comp+0xba6>
 800e414:	f107 030c 	add.w	r3, r7, #12
 800e418:	6818      	ldr	r0, [r3, #0]
 800e41a:	f8d7 10f4 	ldr.w	r1, [r7, #244]	; 0xf4
 800e41e:	f7ff f8f1 	bl	800d604 <d_lookup_template_argument>
 800e422:	f8c7 00f0 	str.w	r0, [r7, #240]	; 0xf0
 800e426:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 800e42a:	2b00      	cmp	r3, #0
 800e42c:	d010      	beq.n	800e450 <d_print_comp+0xb88>
 800e42e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 800e432:	781b      	ldrb	r3, [r3, #0]
 800e434:	2b2b      	cmp	r3, #43	; 0x2b
 800e436:	d10b      	bne.n	800e450 <d_print_comp+0xb88>
 800e438:	f107 030c 	add.w	r3, r7, #12
 800e43c:	681b      	ldr	r3, [r3, #0]
 800e43e:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 800e442:	f8d7 00f0 	ldr.w	r0, [r7, #240]	; 0xf0
 800e446:	4619      	mov	r1, r3
 800e448:	f7ff f8ac 	bl	800d5a4 <d_index_template_argument>
 800e44c:	f8c7 00f0 	str.w	r0, [r7, #240]	; 0xf0
 800e450:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 800e454:	2b00      	cmp	r3, #0
 800e456:	d106      	bne.n	800e466 <d_print_comp+0xb9e>
 800e458:	f107 030c 	add.w	r3, r7, #12
 800e45c:	6818      	ldr	r0, [r3, #0]
 800e45e:	f7fe ff71 	bl	800d344 <d_print_error>
 800e462:	f001 b8fb 	b.w	800f65c <d_print_comp+0x1d94>
 800e466:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 800e46a:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 800e46e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800e472:	781b      	ldrb	r3, [r3, #0]
 800e474:	2b1f      	cmp	r3, #31
 800e476:	d008      	beq.n	800e48a <d_print_comp+0xbc2>
 800e478:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800e47c:	781a      	ldrb	r2, [r3, #0]
 800e47e:	f107 0304 	add.w	r3, r7, #4
 800e482:	681b      	ldr	r3, [r3, #0]
 800e484:	781b      	ldrb	r3, [r3, #0]
 800e486:	429a      	cmp	r2, r3
 800e488:	d105      	bne.n	800e496 <d_print_comp+0xbce>
 800e48a:	f107 0304 	add.w	r3, r7, #4
 800e48e:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 800e492:	601a      	str	r2, [r3, #0]
 800e494:	e009      	b.n	800e4aa <d_print_comp+0xbe2>
 800e496:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800e49a:	781b      	ldrb	r3, [r3, #0]
 800e49c:	2b20      	cmp	r3, #32
 800e49e:	d104      	bne.n	800e4aa <d_print_comp+0xbe2>
 800e4a0:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800e4a4:	685b      	ldr	r3, [r3, #4]
 800e4a6:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
 800e4aa:	f107 030c 	add.w	r3, r7, #12
 800e4ae:	681b      	ldr	r3, [r3, #0]
 800e4b0:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800e4b4:	673b      	str	r3, [r7, #112]	; 0x70
 800e4b6:	f107 030c 	add.w	r3, r7, #12
 800e4ba:	681b      	ldr	r3, [r3, #0]
 800e4bc:	f107 0270 	add.w	r2, r7, #112	; 0x70
 800e4c0:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800e4c4:	f107 0304 	add.w	r3, r7, #4
 800e4c8:	681b      	ldr	r3, [r3, #0]
 800e4ca:	677b      	str	r3, [r7, #116]	; 0x74
 800e4cc:	f04f 0300 	mov.w	r3, #0
 800e4d0:	67bb      	str	r3, [r7, #120]	; 0x78
 800e4d2:	f107 030c 	add.w	r3, r7, #12
 800e4d6:	681b      	ldr	r3, [r3, #0]
 800e4d8:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 800e4dc:	67fb      	str	r3, [r7, #124]	; 0x7c
 800e4de:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800e4e2:	2b00      	cmp	r3, #0
 800e4e4:	d105      	bne.n	800e4f2 <d_print_comp+0xc2a>
 800e4e6:	f107 0304 	add.w	r3, r7, #4
 800e4ea:	681b      	ldr	r3, [r3, #0]
 800e4ec:	685b      	ldr	r3, [r3, #4]
 800e4ee:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
 800e4f2:	f107 020c 	add.w	r2, r7, #12
 800e4f6:	f107 0308 	add.w	r3, r7, #8
 800e4fa:	6810      	ldr	r0, [r2, #0]
 800e4fc:	6819      	ldr	r1, [r3, #0]
 800e4fe:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
 800e502:	f7ff f9e1 	bl	800d8c8 <d_print_comp>
 800e506:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800e508:	2b00      	cmp	r3, #0
 800e50a:	d10a      	bne.n	800e522 <d_print_comp+0xc5a>
 800e50c:	f107 010c 	add.w	r1, r7, #12
 800e510:	f107 0208 	add.w	r2, r7, #8
 800e514:	f107 0304 	add.w	r3, r7, #4
 800e518:	6808      	ldr	r0, [r1, #0]
 800e51a:	6811      	ldr	r1, [r2, #0]
 800e51c:	681a      	ldr	r2, [r3, #0]
 800e51e:	f001 fa0d 	bl	800f93c <d_print_mod>
 800e522:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 800e524:	f107 030c 	add.w	r3, r7, #12
 800e528:	681b      	ldr	r3, [r3, #0]
 800e52a:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800e52e:	f001 b895 	b.w	800f65c <d_print_comp+0x1d94>
 800e532:	f107 0308 	add.w	r3, r7, #8
 800e536:	681b      	ldr	r3, [r3, #0]
 800e538:	f003 0304 	and.w	r3, r3, #4
 800e53c:	2b00      	cmp	r3, #0
 800e53e:	d112      	bne.n	800e566 <d_print_comp+0xc9e>
 800e540:	f107 0304 	add.w	r3, r7, #4
 800e544:	681b      	ldr	r3, [r3, #0]
 800e546:	685b      	ldr	r3, [r3, #4]
 800e548:	681a      	ldr	r2, [r3, #0]
 800e54a:	f107 0304 	add.w	r3, r7, #4
 800e54e:	681b      	ldr	r3, [r3, #0]
 800e550:	685b      	ldr	r3, [r3, #4]
 800e552:	685b      	ldr	r3, [r3, #4]
 800e554:	f107 010c 	add.w	r1, r7, #12
 800e558:	6808      	ldr	r0, [r1, #0]
 800e55a:	4611      	mov	r1, r2
 800e55c:	461a      	mov	r2, r3
 800e55e:	f7fe ff5b 	bl	800d418 <d_append_buffer>
 800e562:	f001 b87b 	b.w	800f65c <d_print_comp+0x1d94>
 800e566:	f107 0304 	add.w	r3, r7, #4
 800e56a:	681b      	ldr	r3, [r3, #0]
 800e56c:	685b      	ldr	r3, [r3, #4]
 800e56e:	689a      	ldr	r2, [r3, #8]
 800e570:	f107 0304 	add.w	r3, r7, #4
 800e574:	681b      	ldr	r3, [r3, #0]
 800e576:	685b      	ldr	r3, [r3, #4]
 800e578:	68db      	ldr	r3, [r3, #12]
 800e57a:	f107 010c 	add.w	r1, r7, #12
 800e57e:	6808      	ldr	r0, [r1, #0]
 800e580:	4611      	mov	r1, r2
 800e582:	461a      	mov	r2, r3
 800e584:	f7fe ff48 	bl	800d418 <d_append_buffer>
 800e588:	f001 b868 	b.w	800f65c <d_print_comp+0x1d94>
 800e58c:	f107 0304 	add.w	r3, r7, #4
 800e590:	681b      	ldr	r3, [r3, #0]
 800e592:	685b      	ldr	r3, [r3, #4]
 800e594:	f107 010c 	add.w	r1, r7, #12
 800e598:	f107 0208 	add.w	r2, r7, #8
 800e59c:	6808      	ldr	r0, [r1, #0]
 800e59e:	6811      	ldr	r1, [r2, #0]
 800e5a0:	461a      	mov	r2, r3
 800e5a2:	f7ff f991 	bl	800d8c8 <d_print_comp>
 800e5a6:	f001 b859 	b.w	800f65c <d_print_comp+0x1d94>
 800e5aa:	f107 0308 	add.w	r3, r7, #8
 800e5ae:	681b      	ldr	r3, [r3, #0]
 800e5b0:	f003 0320 	and.w	r3, r3, #32
 800e5b4:	2b00      	cmp	r3, #0
 800e5b6:	d011      	beq.n	800e5dc <d_print_comp+0xd14>
 800e5b8:	f107 0308 	add.w	r3, r7, #8
 800e5bc:	681b      	ldr	r3, [r3, #0]
 800e5be:	f023 0160 	bic.w	r1, r3, #96	; 0x60
 800e5c2:	f107 030c 	add.w	r3, r7, #12
 800e5c6:	681b      	ldr	r3, [r3, #0]
 800e5c8:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800e5cc:	f107 000c 	add.w	r0, r7, #12
 800e5d0:	f107 0204 	add.w	r2, r7, #4
 800e5d4:	6800      	ldr	r0, [r0, #0]
 800e5d6:	6812      	ldr	r2, [r2, #0]
 800e5d8:	f001 fa9e 	bl	800fb18 <d_print_function_type>
 800e5dc:	f107 0304 	add.w	r3, r7, #4
 800e5e0:	681b      	ldr	r3, [r3, #0]
 800e5e2:	685b      	ldr	r3, [r3, #4]
 800e5e4:	2b00      	cmp	r3, #0
 800e5e6:	d017      	beq.n	800e618 <d_print_comp+0xd50>
 800e5e8:	f107 0308 	add.w	r3, r7, #8
 800e5ec:	681b      	ldr	r3, [r3, #0]
 800e5ee:	f003 0320 	and.w	r3, r3, #32
 800e5f2:	2b00      	cmp	r3, #0
 800e5f4:	d010      	beq.n	800e618 <d_print_comp+0xd50>
 800e5f6:	f107 0308 	add.w	r3, r7, #8
 800e5fa:	681b      	ldr	r3, [r3, #0]
 800e5fc:	f023 0260 	bic.w	r2, r3, #96	; 0x60
 800e600:	f107 0304 	add.w	r3, r7, #4
 800e604:	681b      	ldr	r3, [r3, #0]
 800e606:	685b      	ldr	r3, [r3, #4]
 800e608:	f107 010c 	add.w	r1, r7, #12
 800e60c:	6808      	ldr	r0, [r1, #0]
 800e60e:	4611      	mov	r1, r2
 800e610:	461a      	mov	r2, r3
 800e612:	f7ff f959 	bl	800d8c8 <d_print_comp>
 800e616:	e04e      	b.n	800e6b6 <d_print_comp+0xdee>
 800e618:	f107 0304 	add.w	r3, r7, #4
 800e61c:	681b      	ldr	r3, [r3, #0]
 800e61e:	685b      	ldr	r3, [r3, #4]
 800e620:	2b00      	cmp	r3, #0
 800e622:	d048      	beq.n	800e6b6 <d_print_comp+0xdee>
 800e624:	f107 0308 	add.w	r3, r7, #8
 800e628:	681b      	ldr	r3, [r3, #0]
 800e62a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800e62e:	2b00      	cmp	r3, #0
 800e630:	d141      	bne.n	800e6b6 <d_print_comp+0xdee>
 800e632:	f107 030c 	add.w	r3, r7, #12
 800e636:	681b      	ldr	r3, [r3, #0]
 800e638:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800e63c:	663b      	str	r3, [r7, #96]	; 0x60
 800e63e:	f107 030c 	add.w	r3, r7, #12
 800e642:	681b      	ldr	r3, [r3, #0]
 800e644:	f107 0260 	add.w	r2, r7, #96	; 0x60
 800e648:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800e64c:	f107 0304 	add.w	r3, r7, #4
 800e650:	681b      	ldr	r3, [r3, #0]
 800e652:	667b      	str	r3, [r7, #100]	; 0x64
 800e654:	f04f 0300 	mov.w	r3, #0
 800e658:	66bb      	str	r3, [r7, #104]	; 0x68
 800e65a:	f107 030c 	add.w	r3, r7, #12
 800e65e:	681b      	ldr	r3, [r3, #0]
 800e660:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 800e664:	66fb      	str	r3, [r7, #108]	; 0x6c
 800e666:	f107 0308 	add.w	r3, r7, #8
 800e66a:	681b      	ldr	r3, [r3, #0]
 800e66c:	f023 0260 	bic.w	r2, r3, #96	; 0x60
 800e670:	f107 0304 	add.w	r3, r7, #4
 800e674:	681b      	ldr	r3, [r3, #0]
 800e676:	685b      	ldr	r3, [r3, #4]
 800e678:	f107 010c 	add.w	r1, r7, #12
 800e67c:	6808      	ldr	r0, [r1, #0]
 800e67e:	4611      	mov	r1, r2
 800e680:	461a      	mov	r2, r3
 800e682:	f7ff f921 	bl	800d8c8 <d_print_comp>
 800e686:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800e688:	f107 030c 	add.w	r3, r7, #12
 800e68c:	681b      	ldr	r3, [r3, #0]
 800e68e:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800e692:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e694:	2b00      	cmp	r3, #0
 800e696:	f040 87e1 	bne.w	800f65c <d_print_comp+0x1d94>
 800e69a:	f107 0308 	add.w	r3, r7, #8
 800e69e:	681b      	ldr	r3, [r3, #0]
 800e6a0:	f003 0320 	and.w	r3, r3, #32
 800e6a4:	2b00      	cmp	r3, #0
 800e6a6:	d106      	bne.n	800e6b6 <d_print_comp+0xdee>
 800e6a8:	f107 030c 	add.w	r3, r7, #12
 800e6ac:	6818      	ldr	r0, [r3, #0]
 800e6ae:	f04f 0120 	mov.w	r1, #32
 800e6b2:	f7fe fe8f 	bl	800d3d4 <d_append_char>
 800e6b6:	f107 0308 	add.w	r3, r7, #8
 800e6ba:	681b      	ldr	r3, [r3, #0]
 800e6bc:	f003 0320 	and.w	r3, r3, #32
 800e6c0:	2b00      	cmp	r3, #0
 800e6c2:	f040 87c2 	bne.w	800f64a <d_print_comp+0x1d82>
 800e6c6:	f107 0308 	add.w	r3, r7, #8
 800e6ca:	681b      	ldr	r3, [r3, #0]
 800e6cc:	f023 0160 	bic.w	r1, r3, #96	; 0x60
 800e6d0:	f107 030c 	add.w	r3, r7, #12
 800e6d4:	681b      	ldr	r3, [r3, #0]
 800e6d6:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800e6da:	f107 000c 	add.w	r0, r7, #12
 800e6de:	f107 0204 	add.w	r2, r7, #4
 800e6e2:	6800      	ldr	r0, [r0, #0]
 800e6e4:	6812      	ldr	r2, [r2, #0]
 800e6e6:	f001 fa17 	bl	800fb18 <d_print_function_type>
 800e6ea:	f000 bfae 	b.w	800f64a <d_print_comp+0x1d82>
 800e6ee:	f107 030c 	add.w	r3, r7, #12
 800e6f2:	681b      	ldr	r3, [r3, #0]
 800e6f4:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800e6f8:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 800e6fc:	f107 0310 	add.w	r3, r7, #16
 800e700:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 800e704:	601a      	str	r2, [r3, #0]
 800e706:	f107 030c 	add.w	r3, r7, #12
 800e70a:	681b      	ldr	r3, [r3, #0]
 800e70c:	f107 0210 	add.w	r2, r7, #16
 800e710:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800e714:	f107 0310 	add.w	r3, r7, #16
 800e718:	f107 0204 	add.w	r2, r7, #4
 800e71c:	6812      	ldr	r2, [r2, #0]
 800e71e:	605a      	str	r2, [r3, #4]
 800e720:	f107 0310 	add.w	r3, r7, #16
 800e724:	f04f 0200 	mov.w	r2, #0
 800e728:	609a      	str	r2, [r3, #8]
 800e72a:	f107 030c 	add.w	r3, r7, #12
 800e72e:	681b      	ldr	r3, [r3, #0]
 800e730:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
 800e734:	f107 0310 	add.w	r3, r7, #16
 800e738:	60da      	str	r2, [r3, #12]
 800e73a:	f04f 0301 	mov.w	r3, #1
 800e73e:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 800e742:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800e746:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 800e74a:	e045      	b.n	800e7d8 <d_print_comp+0xf10>
 800e74c:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 800e750:	689b      	ldr	r3, [r3, #8]
 800e752:	2b00      	cmp	r3, #0
 800e754:	d13b      	bne.n	800e7ce <d_print_comp+0xf06>
 800e756:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 800e75a:	2b03      	cmp	r3, #3
 800e75c:	d906      	bls.n	800e76c <d_print_comp+0xea4>
 800e75e:	f107 030c 	add.w	r3, r7, #12
 800e762:	6818      	ldr	r0, [r3, #0]
 800e764:	f7fe fdee 	bl	800d344 <d_print_error>
 800e768:	f000 bf78 	b.w	800f65c <d_print_comp+0x1d94>
 800e76c:	f107 0210 	add.w	r2, r7, #16
 800e770:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 800e774:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800e778:	18d2      	adds	r2, r2, r3
 800e77a:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 800e77e:	4614      	mov	r4, r2
 800e780:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800e782:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 800e786:	f107 030c 	add.w	r3, r7, #12
 800e78a:	681b      	ldr	r3, [r3, #0]
 800e78c:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 800e790:	f107 0110 	add.w	r1, r7, #16
 800e794:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 800e798:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800e79c:	18cb      	adds	r3, r1, r3
 800e79e:	601a      	str	r2, [r3, #0]
 800e7a0:	f107 0210 	add.w	r2, r7, #16
 800e7a4:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 800e7a8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800e7ac:	18d2      	adds	r2, r2, r3
 800e7ae:	f107 030c 	add.w	r3, r7, #12
 800e7b2:	681b      	ldr	r3, [r3, #0]
 800e7b4:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800e7b8:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 800e7bc:	f04f 0201 	mov.w	r2, #1
 800e7c0:	609a      	str	r2, [r3, #8]
 800e7c2:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 800e7c6:	f103 0301 	add.w	r3, r3, #1
 800e7ca:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 800e7ce:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 800e7d2:	681b      	ldr	r3, [r3, #0]
 800e7d4:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 800e7d8:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 800e7dc:	2b00      	cmp	r3, #0
 800e7de:	d011      	beq.n	800e804 <d_print_comp+0xf3c>
 800e7e0:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 800e7e4:	685b      	ldr	r3, [r3, #4]
 800e7e6:	781b      	ldrb	r3, [r3, #0]
 800e7e8:	2b17      	cmp	r3, #23
 800e7ea:	d0af      	beq.n	800e74c <d_print_comp+0xe84>
 800e7ec:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 800e7f0:	685b      	ldr	r3, [r3, #4]
 800e7f2:	781b      	ldrb	r3, [r3, #0]
 800e7f4:	2b18      	cmp	r3, #24
 800e7f6:	d0a9      	beq.n	800e74c <d_print_comp+0xe84>
 800e7f8:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 800e7fc:	685b      	ldr	r3, [r3, #4]
 800e7fe:	781b      	ldrb	r3, [r3, #0]
 800e800:	2b19      	cmp	r3, #25
 800e802:	d0a3      	beq.n	800e74c <d_print_comp+0xe84>
 800e804:	f107 0304 	add.w	r3, r7, #4
 800e808:	681b      	ldr	r3, [r3, #0]
 800e80a:	689b      	ldr	r3, [r3, #8]
 800e80c:	f107 010c 	add.w	r1, r7, #12
 800e810:	f107 0208 	add.w	r2, r7, #8
 800e814:	6808      	ldr	r0, [r1, #0]
 800e816:	6811      	ldr	r1, [r2, #0]
 800e818:	461a      	mov	r2, r3
 800e81a:	f7ff f855 	bl	800d8c8 <d_print_comp>
 800e81e:	f107 030c 	add.w	r3, r7, #12
 800e822:	681b      	ldr	r3, [r3, #0]
 800e824:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 800e828:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800e82c:	f107 0310 	add.w	r3, r7, #16
 800e830:	689b      	ldr	r3, [r3, #8]
 800e832:	2b00      	cmp	r3, #0
 800e834:	f040 8712 	bne.w	800f65c <d_print_comp+0x1d94>
 800e838:	e016      	b.n	800e868 <d_print_comp+0xfa0>
 800e83a:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 800e83e:	f103 33ff 	add.w	r3, r3, #4294967295
 800e842:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 800e846:	f107 0210 	add.w	r2, r7, #16
 800e84a:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 800e84e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800e852:	18d3      	adds	r3, r2, r3
 800e854:	685b      	ldr	r3, [r3, #4]
 800e856:	f107 010c 	add.w	r1, r7, #12
 800e85a:	f107 0208 	add.w	r2, r7, #8
 800e85e:	6808      	ldr	r0, [r1, #0]
 800e860:	6811      	ldr	r1, [r2, #0]
 800e862:	461a      	mov	r2, r3
 800e864:	f001 f86a 	bl	800f93c <d_print_mod>
 800e868:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 800e86c:	2b01      	cmp	r3, #1
 800e86e:	d8e4      	bhi.n	800e83a <d_print_comp+0xf72>
 800e870:	f107 030c 	add.w	r3, r7, #12
 800e874:	681b      	ldr	r3, [r3, #0]
 800e876:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800e87a:	f107 000c 	add.w	r0, r7, #12
 800e87e:	f107 0108 	add.w	r1, r7, #8
 800e882:	f107 0204 	add.w	r2, r7, #4
 800e886:	6800      	ldr	r0, [r0, #0]
 800e888:	6809      	ldr	r1, [r1, #0]
 800e88a:	6812      	ldr	r2, [r2, #0]
 800e88c:	f001 f9f2 	bl	800fc74 <d_print_array_type>
 800e890:	f000 bee4 	b.w	800f65c <d_print_comp+0x1d94>
 800e894:	f107 030c 	add.w	r3, r7, #12
 800e898:	681b      	ldr	r3, [r3, #0]
 800e89a:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800e89e:	653b      	str	r3, [r7, #80]	; 0x50
 800e8a0:	f107 030c 	add.w	r3, r7, #12
 800e8a4:	681b      	ldr	r3, [r3, #0]
 800e8a6:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800e8aa:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800e8ae:	f107 0304 	add.w	r3, r7, #4
 800e8b2:	681b      	ldr	r3, [r3, #0]
 800e8b4:	657b      	str	r3, [r7, #84]	; 0x54
 800e8b6:	f04f 0300 	mov.w	r3, #0
 800e8ba:	65bb      	str	r3, [r7, #88]	; 0x58
 800e8bc:	f107 030c 	add.w	r3, r7, #12
 800e8c0:	681b      	ldr	r3, [r3, #0]
 800e8c2:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 800e8c6:	65fb      	str	r3, [r7, #92]	; 0x5c
 800e8c8:	f107 0304 	add.w	r3, r7, #4
 800e8cc:	681b      	ldr	r3, [r3, #0]
 800e8ce:	689b      	ldr	r3, [r3, #8]
 800e8d0:	f107 010c 	add.w	r1, r7, #12
 800e8d4:	f107 0208 	add.w	r2, r7, #8
 800e8d8:	6808      	ldr	r0, [r1, #0]
 800e8da:	6811      	ldr	r1, [r2, #0]
 800e8dc:	461a      	mov	r2, r3
 800e8de:	f7fe fff3 	bl	800d8c8 <d_print_comp>
 800e8e2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800e8e4:	2b00      	cmp	r3, #0
 800e8e6:	d10a      	bne.n	800e8fe <d_print_comp+0x1036>
 800e8e8:	f107 010c 	add.w	r1, r7, #12
 800e8ec:	f107 0208 	add.w	r2, r7, #8
 800e8f0:	f107 0304 	add.w	r3, r7, #4
 800e8f4:	6808      	ldr	r0, [r1, #0]
 800e8f6:	6811      	ldr	r1, [r2, #0]
 800e8f8:	681a      	ldr	r2, [r3, #0]
 800e8fa:	f001 f81f 	bl	800f93c <d_print_mod>
 800e8fe:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800e900:	f107 030c 	add.w	r3, r7, #12
 800e904:	681b      	ldr	r3, [r3, #0]
 800e906:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800e90a:	f000 bea7 	b.w	800f65c <d_print_comp+0x1d94>
 800e90e:	f107 0304 	add.w	r3, r7, #4
 800e912:	681b      	ldr	r3, [r3, #0]
 800e914:	895b      	ldrh	r3, [r3, #10]
 800e916:	2b00      	cmp	r3, #0
 800e918:	d008      	beq.n	800e92c <d_print_comp+0x1064>
 800e91a:	f107 030c 	add.w	r3, r7, #12
 800e91e:	6818      	ldr	r0, [r3, #0]
 800e920:	f64f 615c 	movw	r1, #65116	; 0xfe5c
 800e924:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e928:	f7fe fd94 	bl	800d454 <d_append_string>
 800e92c:	f107 0304 	add.w	r3, r7, #4
 800e930:	681b      	ldr	r3, [r3, #0]
 800e932:	685b      	ldr	r3, [r3, #4]
 800e934:	685a      	ldr	r2, [r3, #4]
 800e936:	4bab      	ldr	r3, [pc, #684]	; (800ebe4 <d_print_comp+0x131c>)
 800e938:	429a      	cmp	r2, r3
 800e93a:	d013      	beq.n	800e964 <d_print_comp+0x109c>
 800e93c:	f107 0304 	add.w	r3, r7, #4
 800e940:	681b      	ldr	r3, [r3, #0]
 800e942:	685b      	ldr	r3, [r3, #4]
 800e944:	f107 010c 	add.w	r1, r7, #12
 800e948:	f107 0208 	add.w	r2, r7, #8
 800e94c:	6808      	ldr	r0, [r1, #0]
 800e94e:	6811      	ldr	r1, [r2, #0]
 800e950:	461a      	mov	r2, r3
 800e952:	f7fe ffb9 	bl	800d8c8 <d_print_comp>
 800e956:	f107 030c 	add.w	r3, r7, #12
 800e95a:	6818      	ldr	r0, [r3, #0]
 800e95c:	f04f 0120 	mov.w	r1, #32
 800e960:	f7fe fd38 	bl	800d3d4 <d_append_char>
 800e964:	f107 0304 	add.w	r3, r7, #4
 800e968:	681b      	ldr	r3, [r3, #0]
 800e96a:	891b      	ldrh	r3, [r3, #8]
 800e96c:	2b00      	cmp	r3, #0
 800e96e:	d00a      	beq.n	800e986 <d_print_comp+0x10be>
 800e970:	f107 030c 	add.w	r3, r7, #12
 800e974:	6818      	ldr	r0, [r3, #0]
 800e976:	f64f 6164 	movw	r1, #65124	; 0xfe64
 800e97a:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e97e:	f7fe fd69 	bl	800d454 <d_append_string>
 800e982:	f000 be6b 	b.w	800f65c <d_print_comp+0x1d94>
 800e986:	f107 030c 	add.w	r3, r7, #12
 800e98a:	6818      	ldr	r0, [r3, #0]
 800e98c:	f64f 616c 	movw	r1, #65132	; 0xfe6c
 800e990:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e994:	f7fe fd5e 	bl	800d454 <d_append_string>
 800e998:	f000 be60 	b.w	800f65c <d_print_comp+0x1d94>
 800e99c:	f107 0304 	add.w	r3, r7, #4
 800e9a0:	681b      	ldr	r3, [r3, #0]
 800e9a2:	685b      	ldr	r3, [r3, #4]
 800e9a4:	2b00      	cmp	r3, #0
 800e9a6:	d00c      	beq.n	800e9c2 <d_print_comp+0x10fa>
 800e9a8:	f107 0304 	add.w	r3, r7, #4
 800e9ac:	681b      	ldr	r3, [r3, #0]
 800e9ae:	685b      	ldr	r3, [r3, #4]
 800e9b0:	f107 010c 	add.w	r1, r7, #12
 800e9b4:	f107 0208 	add.w	r2, r7, #8
 800e9b8:	6808      	ldr	r0, [r1, #0]
 800e9ba:	6811      	ldr	r1, [r2, #0]
 800e9bc:	461a      	mov	r2, r3
 800e9be:	f7fe ff83 	bl	800d8c8 <d_print_comp>
 800e9c2:	f107 0304 	add.w	r3, r7, #4
 800e9c6:	681b      	ldr	r3, [r3, #0]
 800e9c8:	689b      	ldr	r3, [r3, #8]
 800e9ca:	2b00      	cmp	r3, #0
 800e9cc:	f000 863f 	beq.w	800f64e <d_print_comp+0x1d86>
 800e9d0:	f107 030c 	add.w	r3, r7, #12
 800e9d4:	681b      	ldr	r3, [r3, #0]
 800e9d6:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800e9da:	2bfd      	cmp	r3, #253	; 0xfd
 800e9dc:	d904      	bls.n	800e9e8 <d_print_comp+0x1120>
 800e9de:	f107 030c 	add.w	r3, r7, #12
 800e9e2:	6818      	ldr	r0, [r3, #0]
 800e9e4:	f7fe fcce 	bl	800d384 <d_print_flush>
 800e9e8:	f107 030c 	add.w	r3, r7, #12
 800e9ec:	6818      	ldr	r0, [r3, #0]
 800e9ee:	f64f 6174 	movw	r1, #65140	; 0xfe74
 800e9f2:	f6c0 0101 	movt	r1, #2049	; 0x801
 800e9f6:	f7fe fd2d 	bl	800d454 <d_append_string>
 800e9fa:	f107 030c 	add.w	r3, r7, #12
 800e9fe:	681b      	ldr	r3, [r3, #0]
 800ea00:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800ea04:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 800ea08:	f107 030c 	add.w	r3, r7, #12
 800ea0c:	681b      	ldr	r3, [r3, #0]
 800ea0e:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 800ea12:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 800ea16:	f107 0304 	add.w	r3, r7, #4
 800ea1a:	681b      	ldr	r3, [r3, #0]
 800ea1c:	689b      	ldr	r3, [r3, #8]
 800ea1e:	f107 010c 	add.w	r1, r7, #12
 800ea22:	f107 0208 	add.w	r2, r7, #8
 800ea26:	6808      	ldr	r0, [r1, #0]
 800ea28:	6811      	ldr	r1, [r2, #0]
 800ea2a:	461a      	mov	r2, r3
 800ea2c:	f7fe ff4c 	bl	800d8c8 <d_print_comp>
 800ea30:	f107 030c 	add.w	r3, r7, #12
 800ea34:	681b      	ldr	r3, [r3, #0]
 800ea36:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
 800ea3a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800ea3e:	429a      	cmp	r2, r3
 800ea40:	f040 8605 	bne.w	800f64e <d_print_comp+0x1d86>
 800ea44:	f107 030c 	add.w	r3, r7, #12
 800ea48:	681b      	ldr	r3, [r3, #0]
 800ea4a:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 800ea4e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800ea52:	429a      	cmp	r2, r3
 800ea54:	f040 85fb 	bne.w	800f64e <d_print_comp+0x1d86>
 800ea58:	f107 030c 	add.w	r3, r7, #12
 800ea5c:	681b      	ldr	r3, [r3, #0]
 800ea5e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800ea62:	f1a3 0202 	sub.w	r2, r3, #2
 800ea66:	f107 030c 	add.w	r3, r7, #12
 800ea6a:	681b      	ldr	r3, [r3, #0]
 800ea6c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 800ea70:	f000 bded 	b.w	800f64e <d_print_comp+0x1d86>
 800ea74:	f107 0304 	add.w	r3, r7, #4
 800ea78:	681b      	ldr	r3, [r3, #0]
 800ea7a:	685b      	ldr	r3, [r3, #4]
 800ea7c:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 800ea80:	f107 0304 	add.w	r3, r7, #4
 800ea84:	681b      	ldr	r3, [r3, #0]
 800ea86:	689b      	ldr	r3, [r3, #8]
 800ea88:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 800ea8c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800ea90:	2b00      	cmp	r3, #0
 800ea92:	d009      	beq.n	800eaa8 <d_print_comp+0x11e0>
 800ea94:	f107 020c 	add.w	r2, r7, #12
 800ea98:	f107 0308 	add.w	r3, r7, #8
 800ea9c:	6810      	ldr	r0, [r2, #0]
 800ea9e:	6819      	ldr	r1, [r3, #0]
 800eaa0:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 800eaa4:	f7fe ff10 	bl	800d8c8 <d_print_comp>
 800eaa8:	f107 030c 	add.w	r3, r7, #12
 800eaac:	6818      	ldr	r0, [r3, #0]
 800eaae:	f04f 017b 	mov.w	r1, #123	; 0x7b
 800eab2:	f7fe fc8f 	bl	800d3d4 <d_append_char>
 800eab6:	f107 020c 	add.w	r2, r7, #12
 800eaba:	f107 0308 	add.w	r3, r7, #8
 800eabe:	6810      	ldr	r0, [r2, #0]
 800eac0:	6819      	ldr	r1, [r3, #0]
 800eac2:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 800eac6:	f7fe feff 	bl	800d8c8 <d_print_comp>
 800eaca:	f107 030c 	add.w	r3, r7, #12
 800eace:	6818      	ldr	r0, [r3, #0]
 800ead0:	f04f 017d 	mov.w	r1, #125	; 0x7d
 800ead4:	f7fe fc7e 	bl	800d3d4 <d_append_char>
 800ead8:	f000 bdc0 	b.w	800f65c <d_print_comp+0x1d94>
 800eadc:	f107 0304 	add.w	r3, r7, #4
 800eae0:	681b      	ldr	r3, [r3, #0]
 800eae2:	685b      	ldr	r3, [r3, #4]
 800eae4:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 800eae8:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800eaec:	689b      	ldr	r3, [r3, #8]
 800eaee:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 800eaf2:	f107 030c 	add.w	r3, r7, #12
 800eaf6:	6818      	ldr	r0, [r3, #0]
 800eaf8:	f64f 6178 	movw	r1, #65144	; 0xfe78
 800eafc:	f6c0 0101 	movt	r1, #2049	; 0x801
 800eb00:	f7fe fca8 	bl	800d454 <d_append_string>
 800eb04:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800eb08:	685b      	ldr	r3, [r3, #4]
 800eb0a:	781b      	ldrb	r3, [r3, #0]
 800eb0c:	2b60      	cmp	r3, #96	; 0x60
 800eb0e:	d90c      	bls.n	800eb2a <d_print_comp+0x1262>
 800eb10:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800eb14:	685b      	ldr	r3, [r3, #4]
 800eb16:	781b      	ldrb	r3, [r3, #0]
 800eb18:	2b7a      	cmp	r3, #122	; 0x7a
 800eb1a:	d806      	bhi.n	800eb2a <d_print_comp+0x1262>
 800eb1c:	f107 030c 	add.w	r3, r7, #12
 800eb20:	6818      	ldr	r0, [r3, #0]
 800eb22:	f04f 0120 	mov.w	r1, #32
 800eb26:	f7fe fc55 	bl	800d3d4 <d_append_char>
 800eb2a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800eb2e:	685a      	ldr	r2, [r3, #4]
 800eb30:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800eb34:	f103 33ff 	add.w	r3, r3, #4294967295
 800eb38:	18d3      	adds	r3, r2, r3
 800eb3a:	781b      	ldrb	r3, [r3, #0]
 800eb3c:	2b20      	cmp	r3, #32
 800eb3e:	d105      	bne.n	800eb4c <d_print_comp+0x1284>
 800eb40:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800eb44:	f103 33ff 	add.w	r3, r3, #4294967295
 800eb48:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 800eb4c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800eb50:	685a      	ldr	r2, [r3, #4]
 800eb52:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800eb56:	f107 010c 	add.w	r1, r7, #12
 800eb5a:	6808      	ldr	r0, [r1, #0]
 800eb5c:	4611      	mov	r1, r2
 800eb5e:	461a      	mov	r2, r3
 800eb60:	f7fe fc5a 	bl	800d418 <d_append_buffer>
 800eb64:	f000 bd7a 	b.w	800f65c <d_print_comp+0x1d94>
 800eb68:	f107 030c 	add.w	r3, r7, #12
 800eb6c:	6818      	ldr	r0, [r3, #0]
 800eb6e:	f64f 6184 	movw	r1, #65156	; 0xfe84
 800eb72:	f6c0 0101 	movt	r1, #2049	; 0x801
 800eb76:	f7fe fc6d 	bl	800d454 <d_append_string>
 800eb7a:	f107 0304 	add.w	r3, r7, #4
 800eb7e:	681b      	ldr	r3, [r3, #0]
 800eb80:	689b      	ldr	r3, [r3, #8]
 800eb82:	f107 010c 	add.w	r1, r7, #12
 800eb86:	f107 0208 	add.w	r2, r7, #8
 800eb8a:	6808      	ldr	r0, [r1, #0]
 800eb8c:	6811      	ldr	r1, [r2, #0]
 800eb8e:	461a      	mov	r2, r3
 800eb90:	f7fe fe9a 	bl	800d8c8 <d_print_comp>
 800eb94:	f000 bd62 	b.w	800f65c <d_print_comp+0x1d94>
 800eb98:	f107 030c 	add.w	r3, r7, #12
 800eb9c:	6818      	ldr	r0, [r3, #0]
 800eb9e:	f64f 6184 	movw	r1, #65156	; 0xfe84
 800eba2:	f6c0 0101 	movt	r1, #2049	; 0x801
 800eba6:	f7fe fc55 	bl	800d454 <d_append_string>
 800ebaa:	f107 010c 	add.w	r1, r7, #12
 800ebae:	f107 0208 	add.w	r2, r7, #8
 800ebb2:	f107 0304 	add.w	r3, r7, #4
 800ebb6:	6808      	ldr	r0, [r1, #0]
 800ebb8:	6811      	ldr	r1, [r2, #0]
 800ebba:	681a      	ldr	r2, [r3, #0]
 800ebbc:	f001 f8e2 	bl	800fd84 <d_print_cast>
 800ebc0:	f000 bd4c 	b.w	800f65c <d_print_comp+0x1d94>
 800ebc4:	f107 0304 	add.w	r3, r7, #4
 800ebc8:	681b      	ldr	r3, [r3, #0]
 800ebca:	685b      	ldr	r3, [r3, #4]
 800ebcc:	f107 010c 	add.w	r1, r7, #12
 800ebd0:	f107 0208 	add.w	r2, r7, #8
 800ebd4:	6808      	ldr	r0, [r1, #0]
 800ebd6:	6811      	ldr	r1, [r2, #0]
 800ebd8:	461a      	mov	r2, r3
 800ebda:	f001 f8b3 	bl	800fd44 <d_print_expr_op>
 800ebde:	f000 bd3d 	b.w	800f65c <d_print_comp+0x1d94>
 800ebe2:	bf00      	nop
 800ebe4:	0801f304 	.word	0x0801f304
 800ebe8:	f107 0304 	add.w	r3, r7, #4
 800ebec:	681b      	ldr	r3, [r3, #0]
 800ebee:	685b      	ldr	r3, [r3, #4]
 800ebf0:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 800ebf4:	f107 0304 	add.w	r3, r7, #4
 800ebf8:	681b      	ldr	r3, [r3, #0]
 800ebfa:	689b      	ldr	r3, [r3, #8]
 800ebfc:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 800ec00:	f04f 0300 	mov.w	r3, #0
 800ec04:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 800ec08:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800ec0c:	781b      	ldrb	r3, [r3, #0]
 800ec0e:	2b2d      	cmp	r3, #45	; 0x2d
 800ec10:	d146      	bne.n	800eca0 <d_print_comp+0x13d8>
 800ec12:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800ec16:	685b      	ldr	r3, [r3, #4]
 800ec18:	681b      	ldr	r3, [r3, #0]
 800ec1a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 800ec1e:	f8d7 00dc 	ldr.w	r0, [r7, #220]	; 0xdc
 800ec22:	f24f 513c 	movw	r1, #62780	; 0xf53c
 800ec26:	f6c0 0101 	movt	r1, #2049	; 0x801
 800ec2a:	f003 fe59 	bl	80128e0 <strcmp>
 800ec2e:	4603      	mov	r3, r0
 800ec30:	2b00      	cmp	r3, #0
 800ec32:	d115      	bne.n	800ec60 <d_print_comp+0x1398>
 800ec34:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800ec38:	781b      	ldrb	r3, [r3, #0]
 800ec3a:	2b03      	cmp	r3, #3
 800ec3c:	d110      	bne.n	800ec60 <d_print_comp+0x1398>
 800ec3e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800ec42:	685b      	ldr	r3, [r3, #4]
 800ec44:	781b      	ldrb	r3, [r3, #0]
 800ec46:	2b01      	cmp	r3, #1
 800ec48:	d10a      	bne.n	800ec60 <d_print_comp+0x1398>
 800ec4a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800ec4e:	689b      	ldr	r3, [r3, #8]
 800ec50:	781b      	ldrb	r3, [r3, #0]
 800ec52:	2b25      	cmp	r3, #37	; 0x25
 800ec54:	d104      	bne.n	800ec60 <d_print_comp+0x1398>
 800ec56:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800ec5a:	685b      	ldr	r3, [r3, #4]
 800ec5c:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 800ec60:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800ec64:	781b      	ldrb	r3, [r3, #0]
 800ec66:	2b33      	cmp	r3, #51	; 0x33
 800ec68:	d11a      	bne.n	800eca0 <d_print_comp+0x13d8>
 800ec6a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800ec6e:	685b      	ldr	r3, [r3, #4]
 800ec70:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 800ec74:	f107 020c 	add.w	r2, r7, #12
 800ec78:	f107 0308 	add.w	r3, r7, #8
 800ec7c:	6810      	ldr	r0, [r2, #0]
 800ec7e:	6819      	ldr	r1, [r3, #0]
 800ec80:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 800ec84:	f7fe fdea 	bl	800d85c <d_print_subexpr>
 800ec88:	f107 020c 	add.w	r2, r7, #12
 800ec8c:	f107 0308 	add.w	r3, r7, #8
 800ec90:	6810      	ldr	r0, [r2, #0]
 800ec92:	6819      	ldr	r1, [r3, #0]
 800ec94:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 800ec98:	f001 f854 	bl	800fd44 <d_print_expr_op>
 800ec9c:	f000 bcde 	b.w	800f65c <d_print_comp+0x1d94>
 800eca0:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800eca4:	781b      	ldrb	r3, [r3, #0]
 800eca6:	2b2f      	cmp	r3, #47	; 0x2f
 800eca8:	d00a      	beq.n	800ecc0 <d_print_comp+0x13f8>
 800ecaa:	f107 020c 	add.w	r2, r7, #12
 800ecae:	f107 0308 	add.w	r3, r7, #8
 800ecb2:	6810      	ldr	r0, [r2, #0]
 800ecb4:	6819      	ldr	r1, [r3, #0]
 800ecb6:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 800ecba:	f001 f843 	bl	800fd44 <d_print_expr_op>
 800ecbe:	e017      	b.n	800ecf0 <d_print_comp+0x1428>
 800ecc0:	f107 030c 	add.w	r3, r7, #12
 800ecc4:	6818      	ldr	r0, [r3, #0]
 800ecc6:	f04f 0128 	mov.w	r1, #40	; 0x28
 800ecca:	f7fe fb83 	bl	800d3d4 <d_append_char>
 800ecce:	f107 020c 	add.w	r2, r7, #12
 800ecd2:	f107 0308 	add.w	r3, r7, #8
 800ecd6:	6810      	ldr	r0, [r2, #0]
 800ecd8:	6819      	ldr	r1, [r3, #0]
 800ecda:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 800ecde:	f001 f851 	bl	800fd84 <d_print_cast>
 800ece2:	f107 030c 	add.w	r3, r7, #12
 800ece6:	6818      	ldr	r0, [r3, #0]
 800ece8:	f04f 0129 	mov.w	r1, #41	; 0x29
 800ecec:	f7fe fb72 	bl	800d3d4 <d_append_char>
 800ecf0:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800ecf4:	2b00      	cmp	r3, #0
 800ecf6:	d015      	beq.n	800ed24 <d_print_comp+0x145c>
 800ecf8:	f8d7 00dc 	ldr.w	r0, [r7, #220]	; 0xdc
 800ecfc:	f24f 51d8 	movw	r1, #62936	; 0xf5d8
 800ed00:	f6c0 0101 	movt	r1, #2049	; 0x801
 800ed04:	f003 fdec 	bl	80128e0 <strcmp>
 800ed08:	4603      	mov	r3, r0
 800ed0a:	2b00      	cmp	r3, #0
 800ed0c:	d10a      	bne.n	800ed24 <d_print_comp+0x145c>
 800ed0e:	f107 020c 	add.w	r2, r7, #12
 800ed12:	f107 0308 	add.w	r3, r7, #8
 800ed16:	6810      	ldr	r0, [r2, #0]
 800ed18:	6819      	ldr	r1, [r3, #0]
 800ed1a:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 800ed1e:	f7fe fdd3 	bl	800d8c8 <d_print_comp>
 800ed22:	e033      	b.n	800ed8c <d_print_comp+0x14c4>
 800ed24:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800ed28:	2b00      	cmp	r3, #0
 800ed2a:	d023      	beq.n	800ed74 <d_print_comp+0x14ac>
 800ed2c:	f8d7 00dc 	ldr.w	r0, [r7, #220]	; 0xdc
 800ed30:	f24f 61d4 	movw	r1, #63188	; 0xf6d4
 800ed34:	f6c0 0101 	movt	r1, #2049	; 0x801
 800ed38:	f003 fdd2 	bl	80128e0 <strcmp>
 800ed3c:	4603      	mov	r3, r0
 800ed3e:	2b00      	cmp	r3, #0
 800ed40:	d118      	bne.n	800ed74 <d_print_comp+0x14ac>
 800ed42:	f107 030c 	add.w	r3, r7, #12
 800ed46:	6818      	ldr	r0, [r3, #0]
 800ed48:	f04f 0128 	mov.w	r1, #40	; 0x28
 800ed4c:	f7fe fb42 	bl	800d3d4 <d_append_char>
 800ed50:	f107 020c 	add.w	r2, r7, #12
 800ed54:	f107 0308 	add.w	r3, r7, #8
 800ed58:	6810      	ldr	r0, [r2, #0]
 800ed5a:	6819      	ldr	r1, [r3, #0]
 800ed5c:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 800ed60:	f7fe fdb2 	bl	800d8c8 <d_print_comp>
 800ed64:	f107 030c 	add.w	r3, r7, #12
 800ed68:	6818      	ldr	r0, [r3, #0]
 800ed6a:	f04f 0129 	mov.w	r1, #41	; 0x29
 800ed6e:	f7fe fb31 	bl	800d3d4 <d_append_char>
 800ed72:	e00b      	b.n	800ed8c <d_print_comp+0x14c4>
 800ed74:	f107 020c 	add.w	r2, r7, #12
 800ed78:	f107 0308 	add.w	r3, r7, #8
 800ed7c:	6810      	ldr	r0, [r2, #0]
 800ed7e:	6819      	ldr	r1, [r3, #0]
 800ed80:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 800ed84:	f7fe fd6a 	bl	800d85c <d_print_subexpr>
 800ed88:	f000 bc68 	b.w	800f65c <d_print_comp+0x1d94>
 800ed8c:	f000 bc66 	b.w	800f65c <d_print_comp+0x1d94>
 800ed90:	f107 0304 	add.w	r3, r7, #4
 800ed94:	681b      	ldr	r3, [r3, #0]
 800ed96:	689b      	ldr	r3, [r3, #8]
 800ed98:	781b      	ldrb	r3, [r3, #0]
 800ed9a:	2b33      	cmp	r3, #51	; 0x33
 800ed9c:	d006      	beq.n	800edac <d_print_comp+0x14e4>
 800ed9e:	f107 030c 	add.w	r3, r7, #12
 800eda2:	6818      	ldr	r0, [r3, #0]
 800eda4:	f7fe face 	bl	800d344 <d_print_error>
 800eda8:	f000 bc58 	b.w	800f65c <d_print_comp+0x1d94>
 800edac:	f107 0304 	add.w	r3, r7, #4
 800edb0:	681b      	ldr	r3, [r3, #0]
 800edb2:	685b      	ldr	r3, [r3, #4]
 800edb4:	781b      	ldrb	r3, [r3, #0]
 800edb6:	2b2d      	cmp	r3, #45	; 0x2d
 800edb8:	d117      	bne.n	800edea <d_print_comp+0x1522>
 800edba:	f107 0304 	add.w	r3, r7, #4
 800edbe:	681b      	ldr	r3, [r3, #0]
 800edc0:	685b      	ldr	r3, [r3, #4]
 800edc2:	685b      	ldr	r3, [r3, #4]
 800edc4:	689b      	ldr	r3, [r3, #8]
 800edc6:	2b01      	cmp	r3, #1
 800edc8:	d10f      	bne.n	800edea <d_print_comp+0x1522>
 800edca:	f107 0304 	add.w	r3, r7, #4
 800edce:	681b      	ldr	r3, [r3, #0]
 800edd0:	685b      	ldr	r3, [r3, #4]
 800edd2:	685b      	ldr	r3, [r3, #4]
 800edd4:	685b      	ldr	r3, [r3, #4]
 800edd6:	781b      	ldrb	r3, [r3, #0]
 800edd8:	2b3e      	cmp	r3, #62	; 0x3e
 800edda:	d106      	bne.n	800edea <d_print_comp+0x1522>
 800eddc:	f107 030c 	add.w	r3, r7, #12
 800ede0:	6818      	ldr	r0, [r3, #0]
 800ede2:	f04f 0128 	mov.w	r1, #40	; 0x28
 800ede6:	f7fe faf5 	bl	800d3d4 <d_append_char>
 800edea:	f107 0304 	add.w	r3, r7, #4
 800edee:	681b      	ldr	r3, [r3, #0]
 800edf0:	685b      	ldr	r3, [r3, #4]
 800edf2:	685b      	ldr	r3, [r3, #4]
 800edf4:	681b      	ldr	r3, [r3, #0]
 800edf6:	4618      	mov	r0, r3
 800edf8:	f24f 515c 	movw	r1, #62812	; 0xf55c
 800edfc:	f6c0 0101 	movt	r1, #2049	; 0x801
 800ee00:	f003 fd6e 	bl	80128e0 <strcmp>
 800ee04:	4603      	mov	r3, r0
 800ee06:	2b00      	cmp	r3, #0
 800ee08:	d126      	bne.n	800ee58 <d_print_comp+0x1590>
 800ee0a:	f107 0304 	add.w	r3, r7, #4
 800ee0e:	681b      	ldr	r3, [r3, #0]
 800ee10:	689b      	ldr	r3, [r3, #8]
 800ee12:	685b      	ldr	r3, [r3, #4]
 800ee14:	781b      	ldrb	r3, [r3, #0]
 800ee16:	2b03      	cmp	r3, #3
 800ee18:	d11e      	bne.n	800ee58 <d_print_comp+0x1590>
 800ee1a:	f107 0304 	add.w	r3, r7, #4
 800ee1e:	681b      	ldr	r3, [r3, #0]
 800ee20:	689b      	ldr	r3, [r3, #8]
 800ee22:	685b      	ldr	r3, [r3, #4]
 800ee24:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 800ee28:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800ee2c:	689b      	ldr	r3, [r3, #8]
 800ee2e:	781b      	ldrb	r3, [r3, #0]
 800ee30:	2b25      	cmp	r3, #37	; 0x25
 800ee32:	d004      	beq.n	800ee3e <d_print_comp+0x1576>
 800ee34:	f107 030c 	add.w	r3, r7, #12
 800ee38:	6818      	ldr	r0, [r3, #0]
 800ee3a:	f7fe fa83 	bl	800d344 <d_print_error>
 800ee3e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800ee42:	685b      	ldr	r3, [r3, #4]
 800ee44:	f107 010c 	add.w	r1, r7, #12
 800ee48:	f107 0208 	add.w	r2, r7, #8
 800ee4c:	6808      	ldr	r0, [r1, #0]
 800ee4e:	6811      	ldr	r1, [r2, #0]
 800ee50:	461a      	mov	r2, r3
 800ee52:	f7fe fd03 	bl	800d85c <d_print_subexpr>
 800ee56:	e00d      	b.n	800ee74 <d_print_comp+0x15ac>
 800ee58:	f107 0304 	add.w	r3, r7, #4
 800ee5c:	681b      	ldr	r3, [r3, #0]
 800ee5e:	689b      	ldr	r3, [r3, #8]
 800ee60:	685b      	ldr	r3, [r3, #4]
 800ee62:	f107 010c 	add.w	r1, r7, #12
 800ee66:	f107 0208 	add.w	r2, r7, #8
 800ee6a:	6808      	ldr	r0, [r1, #0]
 800ee6c:	6811      	ldr	r1, [r2, #0]
 800ee6e:	461a      	mov	r2, r3
 800ee70:	f7fe fcf4 	bl	800d85c <d_print_subexpr>
 800ee74:	f107 0304 	add.w	r3, r7, #4
 800ee78:	681b      	ldr	r3, [r3, #0]
 800ee7a:	685b      	ldr	r3, [r3, #4]
 800ee7c:	685b      	ldr	r3, [r3, #4]
 800ee7e:	681b      	ldr	r3, [r3, #0]
 800ee80:	4618      	mov	r0, r3
 800ee82:	f24f 51e8 	movw	r1, #62952	; 0xf5e8
 800ee86:	f6c0 0101 	movt	r1, #2049	; 0x801
 800ee8a:	f003 fd29 	bl	80128e0 <strcmp>
 800ee8e:	4603      	mov	r3, r0
 800ee90:	2b00      	cmp	r3, #0
 800ee92:	d11c      	bne.n	800eece <d_print_comp+0x1606>
 800ee94:	f107 030c 	add.w	r3, r7, #12
 800ee98:	6818      	ldr	r0, [r3, #0]
 800ee9a:	f04f 015b 	mov.w	r1, #91	; 0x5b
 800ee9e:	f7fe fa99 	bl	800d3d4 <d_append_char>
 800eea2:	f107 0304 	add.w	r3, r7, #4
 800eea6:	681b      	ldr	r3, [r3, #0]
 800eea8:	689b      	ldr	r3, [r3, #8]
 800eeaa:	689b      	ldr	r3, [r3, #8]
 800eeac:	f107 010c 	add.w	r1, r7, #12
 800eeb0:	f107 0208 	add.w	r2, r7, #8
 800eeb4:	6808      	ldr	r0, [r1, #0]
 800eeb6:	6811      	ldr	r1, [r2, #0]
 800eeb8:	461a      	mov	r2, r3
 800eeba:	f7fe fd05 	bl	800d8c8 <d_print_comp>
 800eebe:	f107 030c 	add.w	r3, r7, #12
 800eec2:	6818      	ldr	r0, [r3, #0]
 800eec4:	f04f 015d 	mov.w	r1, #93	; 0x5d
 800eec8:	f7fe fa84 	bl	800d3d4 <d_append_char>
 800eecc:	e02a      	b.n	800ef24 <d_print_comp+0x165c>
 800eece:	f107 0304 	add.w	r3, r7, #4
 800eed2:	681b      	ldr	r3, [r3, #0]
 800eed4:	685b      	ldr	r3, [r3, #4]
 800eed6:	685b      	ldr	r3, [r3, #4]
 800eed8:	681b      	ldr	r3, [r3, #0]
 800eeda:	4618      	mov	r0, r3
 800eedc:	f24f 515c 	movw	r1, #62812	; 0xf55c
 800eee0:	f6c0 0101 	movt	r1, #2049	; 0x801
 800eee4:	f003 fcfc 	bl	80128e0 <strcmp>
 800eee8:	4603      	mov	r3, r0
 800eeea:	2b00      	cmp	r3, #0
 800eeec:	d00c      	beq.n	800ef08 <d_print_comp+0x1640>
 800eeee:	f107 0304 	add.w	r3, r7, #4
 800eef2:	681b      	ldr	r3, [r3, #0]
 800eef4:	685b      	ldr	r3, [r3, #4]
 800eef6:	f107 010c 	add.w	r1, r7, #12
 800eefa:	f107 0208 	add.w	r2, r7, #8
 800eefe:	6808      	ldr	r0, [r1, #0]
 800ef00:	6811      	ldr	r1, [r2, #0]
 800ef02:	461a      	mov	r2, r3
 800ef04:	f000 ff1e 	bl	800fd44 <d_print_expr_op>
 800ef08:	f107 0304 	add.w	r3, r7, #4
 800ef0c:	681b      	ldr	r3, [r3, #0]
 800ef0e:	689b      	ldr	r3, [r3, #8]
 800ef10:	689b      	ldr	r3, [r3, #8]
 800ef12:	f107 010c 	add.w	r1, r7, #12
 800ef16:	f107 0208 	add.w	r2, r7, #8
 800ef1a:	6808      	ldr	r0, [r1, #0]
 800ef1c:	6811      	ldr	r1, [r2, #0]
 800ef1e:	461a      	mov	r2, r3
 800ef20:	f7fe fc9c 	bl	800d85c <d_print_subexpr>
 800ef24:	f107 0304 	add.w	r3, r7, #4
 800ef28:	681b      	ldr	r3, [r3, #0]
 800ef2a:	685b      	ldr	r3, [r3, #4]
 800ef2c:	781b      	ldrb	r3, [r3, #0]
 800ef2e:	2b2d      	cmp	r3, #45	; 0x2d
 800ef30:	f040 838f 	bne.w	800f652 <d_print_comp+0x1d8a>
 800ef34:	f107 0304 	add.w	r3, r7, #4
 800ef38:	681b      	ldr	r3, [r3, #0]
 800ef3a:	685b      	ldr	r3, [r3, #4]
 800ef3c:	685b      	ldr	r3, [r3, #4]
 800ef3e:	689b      	ldr	r3, [r3, #8]
 800ef40:	2b01      	cmp	r3, #1
 800ef42:	f040 8386 	bne.w	800f652 <d_print_comp+0x1d8a>
 800ef46:	f107 0304 	add.w	r3, r7, #4
 800ef4a:	681b      	ldr	r3, [r3, #0]
 800ef4c:	685b      	ldr	r3, [r3, #4]
 800ef4e:	685b      	ldr	r3, [r3, #4]
 800ef50:	685b      	ldr	r3, [r3, #4]
 800ef52:	781b      	ldrb	r3, [r3, #0]
 800ef54:	2b3e      	cmp	r3, #62	; 0x3e
 800ef56:	f040 837c 	bne.w	800f652 <d_print_comp+0x1d8a>
 800ef5a:	f107 030c 	add.w	r3, r7, #12
 800ef5e:	6818      	ldr	r0, [r3, #0]
 800ef60:	f04f 0129 	mov.w	r1, #41	; 0x29
 800ef64:	f7fe fa36 	bl	800d3d4 <d_append_char>
 800ef68:	e373      	b.n	800f652 <d_print_comp+0x1d8a>
 800ef6a:	f107 030c 	add.w	r3, r7, #12
 800ef6e:	6818      	ldr	r0, [r3, #0]
 800ef70:	f7fe f9e8 	bl	800d344 <d_print_error>
 800ef74:	e372      	b.n	800f65c <d_print_comp+0x1d94>
 800ef76:	f107 0304 	add.w	r3, r7, #4
 800ef7a:	681b      	ldr	r3, [r3, #0]
 800ef7c:	689b      	ldr	r3, [r3, #8]
 800ef7e:	781b      	ldrb	r3, [r3, #0]
 800ef80:	2b35      	cmp	r3, #53	; 0x35
 800ef82:	d107      	bne.n	800ef94 <d_print_comp+0x16cc>
 800ef84:	f107 0304 	add.w	r3, r7, #4
 800ef88:	681b      	ldr	r3, [r3, #0]
 800ef8a:	689b      	ldr	r3, [r3, #8]
 800ef8c:	689b      	ldr	r3, [r3, #8]
 800ef8e:	781b      	ldrb	r3, [r3, #0]
 800ef90:	2b36      	cmp	r3, #54	; 0x36
 800ef92:	d005      	beq.n	800efa0 <d_print_comp+0x16d8>
 800ef94:	f107 030c 	add.w	r3, r7, #12
 800ef98:	6818      	ldr	r0, [r3, #0]
 800ef9a:	f7fe f9d3 	bl	800d344 <d_print_error>
 800ef9e:	e35d      	b.n	800f65c <d_print_comp+0x1d94>
 800efa0:	f107 0304 	add.w	r3, r7, #4
 800efa4:	681b      	ldr	r3, [r3, #0]
 800efa6:	685b      	ldr	r3, [r3, #4]
 800efa8:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 800efac:	f107 0304 	add.w	r3, r7, #4
 800efb0:	681b      	ldr	r3, [r3, #0]
 800efb2:	689b      	ldr	r3, [r3, #8]
 800efb4:	685b      	ldr	r3, [r3, #4]
 800efb6:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 800efba:	f107 0304 	add.w	r3, r7, #4
 800efbe:	681b      	ldr	r3, [r3, #0]
 800efc0:	689b      	ldr	r3, [r3, #8]
 800efc2:	689b      	ldr	r3, [r3, #8]
 800efc4:	685b      	ldr	r3, [r3, #4]
 800efc6:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 800efca:	f107 0304 	add.w	r3, r7, #4
 800efce:	681b      	ldr	r3, [r3, #0]
 800efd0:	689b      	ldr	r3, [r3, #8]
 800efd2:	689b      	ldr	r3, [r3, #8]
 800efd4:	689b      	ldr	r3, [r3, #8]
 800efd6:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 800efda:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800efde:	685b      	ldr	r3, [r3, #4]
 800efe0:	681b      	ldr	r3, [r3, #0]
 800efe2:	4618      	mov	r0, r3
 800efe4:	f24f 61ac 	movw	r1, #63148	; 0xf6ac
 800efe8:	f6c0 0101 	movt	r1, #2049	; 0x801
 800efec:	f003 fc78 	bl	80128e0 <strcmp>
 800eff0:	4603      	mov	r3, r0
 800eff2:	2b00      	cmp	r3, #0
 800eff4:	d131      	bne.n	800f05a <d_print_comp+0x1792>
 800eff6:	f107 020c 	add.w	r2, r7, #12
 800effa:	f107 0308 	add.w	r3, r7, #8
 800effe:	6810      	ldr	r0, [r2, #0]
 800f000:	6819      	ldr	r1, [r3, #0]
 800f002:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 800f006:	f7fe fc29 	bl	800d85c <d_print_subexpr>
 800f00a:	f107 020c 	add.w	r2, r7, #12
 800f00e:	f107 0308 	add.w	r3, r7, #8
 800f012:	6810      	ldr	r0, [r2, #0]
 800f014:	6819      	ldr	r1, [r3, #0]
 800f016:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 800f01a:	f000 fe93 	bl	800fd44 <d_print_expr_op>
 800f01e:	f107 020c 	add.w	r2, r7, #12
 800f022:	f107 0308 	add.w	r3, r7, #8
 800f026:	6810      	ldr	r0, [r2, #0]
 800f028:	6819      	ldr	r1, [r3, #0]
 800f02a:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 800f02e:	f7fe fc15 	bl	800d85c <d_print_subexpr>
 800f032:	f107 030c 	add.w	r3, r7, #12
 800f036:	6818      	ldr	r0, [r3, #0]
 800f038:	f64f 6190 	movw	r1, #65168	; 0xfe90
 800f03c:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f040:	f7fe fa08 	bl	800d454 <d_append_string>
 800f044:	f107 020c 	add.w	r2, r7, #12
 800f048:	f107 0308 	add.w	r3, r7, #8
 800f04c:	6810      	ldr	r0, [r2, #0]
 800f04e:	6819      	ldr	r1, [r3, #0]
 800f050:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 800f054:	f7fe fc02 	bl	800d85c <d_print_subexpr>
 800f058:	e2fd      	b.n	800f656 <d_print_comp+0x1d8e>
 800f05a:	f107 030c 	add.w	r3, r7, #12
 800f05e:	6818      	ldr	r0, [r3, #0]
 800f060:	f64f 6194 	movw	r1, #65172	; 0xfe94
 800f064:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f068:	f7fe f9f4 	bl	800d454 <d_append_string>
 800f06c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800f070:	685b      	ldr	r3, [r3, #4]
 800f072:	2b00      	cmp	r3, #0
 800f074:	d010      	beq.n	800f098 <d_print_comp+0x17d0>
 800f076:	f107 020c 	add.w	r2, r7, #12
 800f07a:	f107 0308 	add.w	r3, r7, #8
 800f07e:	6810      	ldr	r0, [r2, #0]
 800f080:	6819      	ldr	r1, [r3, #0]
 800f082:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 800f086:	f7fe fbe9 	bl	800d85c <d_print_subexpr>
 800f08a:	f107 030c 	add.w	r3, r7, #12
 800f08e:	6818      	ldr	r0, [r3, #0]
 800f090:	f04f 0120 	mov.w	r1, #32
 800f094:	f7fe f99e 	bl	800d3d4 <d_append_char>
 800f098:	f107 020c 	add.w	r2, r7, #12
 800f09c:	f107 0308 	add.w	r3, r7, #8
 800f0a0:	6810      	ldr	r0, [r2, #0]
 800f0a2:	6819      	ldr	r1, [r3, #0]
 800f0a4:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 800f0a8:	f7fe fc0e 	bl	800d8c8 <d_print_comp>
 800f0ac:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800f0b0:	2b00      	cmp	r3, #0
 800f0b2:	f000 82d0 	beq.w	800f656 <d_print_comp+0x1d8e>
 800f0b6:	f107 020c 	add.w	r2, r7, #12
 800f0ba:	f107 0308 	add.w	r3, r7, #8
 800f0be:	6810      	ldr	r0, [r2, #0]
 800f0c0:	6819      	ldr	r1, [r3, #0]
 800f0c2:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 800f0c6:	f7fe fbc9 	bl	800d85c <d_print_subexpr>
 800f0ca:	e2c4      	b.n	800f656 <d_print_comp+0x1d8e>
 800f0cc:	f107 030c 	add.w	r3, r7, #12
 800f0d0:	6818      	ldr	r0, [r3, #0]
 800f0d2:	f7fe f937 	bl	800d344 <d_print_error>
 800f0d6:	e2c1      	b.n	800f65c <d_print_comp+0x1d94>
 800f0d8:	f04f 0300 	mov.w	r3, #0
 800f0dc:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
 800f0e0:	f107 0304 	add.w	r3, r7, #4
 800f0e4:	681b      	ldr	r3, [r3, #0]
 800f0e6:	685b      	ldr	r3, [r3, #4]
 800f0e8:	781b      	ldrb	r3, [r3, #0]
 800f0ea:	2b23      	cmp	r3, #35	; 0x23
 800f0ec:	f040 80b2 	bne.w	800f254 <d_print_comp+0x198c>
 800f0f0:	f107 0304 	add.w	r3, r7, #4
 800f0f4:	681b      	ldr	r3, [r3, #0]
 800f0f6:	685b      	ldr	r3, [r3, #4]
 800f0f8:	685b      	ldr	r3, [r3, #4]
 800f0fa:	7c1b      	ldrb	r3, [r3, #16]
 800f0fc:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
 800f100:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 800f104:	2b01      	cmp	r3, #1
 800f106:	f2c0 80a0 	blt.w	800f24a <d_print_comp+0x1982>
 800f10a:	2b06      	cmp	r3, #6
 800f10c:	dd02      	ble.n	800f114 <d_print_comp+0x184c>
 800f10e:	2b07      	cmp	r3, #7
 800f110:	d066      	beq.n	800f1e0 <d_print_comp+0x1918>
 800f112:	e09a      	b.n	800f24a <d_print_comp+0x1982>
 800f114:	f107 0304 	add.w	r3, r7, #4
 800f118:	681b      	ldr	r3, [r3, #0]
 800f11a:	689b      	ldr	r3, [r3, #8]
 800f11c:	781b      	ldrb	r3, [r3, #0]
 800f11e:	2b00      	cmp	r3, #0
 800f120:	f040 8095 	bne.w	800f24e <d_print_comp+0x1986>
 800f124:	f107 0304 	add.w	r3, r7, #4
 800f128:	681b      	ldr	r3, [r3, #0]
 800f12a:	781b      	ldrb	r3, [r3, #0]
 800f12c:	2b38      	cmp	r3, #56	; 0x38
 800f12e:	d106      	bne.n	800f13e <d_print_comp+0x1876>
 800f130:	f107 030c 	add.w	r3, r7, #12
 800f134:	6818      	ldr	r0, [r3, #0]
 800f136:	f04f 012d 	mov.w	r1, #45	; 0x2d
 800f13a:	f7fe f94b 	bl	800d3d4 <d_append_char>
 800f13e:	f107 0304 	add.w	r3, r7, #4
 800f142:	681b      	ldr	r3, [r3, #0]
 800f144:	689b      	ldr	r3, [r3, #8]
 800f146:	f107 010c 	add.w	r1, r7, #12
 800f14a:	f107 0208 	add.w	r2, r7, #8
 800f14e:	6808      	ldr	r0, [r1, #0]
 800f150:	6811      	ldr	r1, [r2, #0]
 800f152:	461a      	mov	r2, r3
 800f154:	f7fe fbb8 	bl	800d8c8 <d_print_comp>
 800f158:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 800f15c:	f1a3 0302 	sub.w	r3, r3, #2
 800f160:	2b04      	cmp	r3, #4
 800f162:	d83b      	bhi.n	800f1dc <d_print_comp+0x1914>
 800f164:	a201      	add	r2, pc, #4	; (adr r2, 800f16c <d_print_comp+0x18a4>)
 800f166:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f16a:	bf00      	nop
 800f16c:	0800f181 	.word	0x0800f181
 800f170:	0800f191 	.word	0x0800f191
 800f174:	0800f1a1 	.word	0x0800f1a1
 800f178:	0800f1b5 	.word	0x0800f1b5
 800f17c:	0800f1c9 	.word	0x0800f1c9
 800f180:	f107 030c 	add.w	r3, r7, #12
 800f184:	6818      	ldr	r0, [r3, #0]
 800f186:	f04f 0175 	mov.w	r1, #117	; 0x75
 800f18a:	f7fe f923 	bl	800d3d4 <d_append_char>
 800f18e:	e026      	b.n	800f1de <d_print_comp+0x1916>
 800f190:	f107 030c 	add.w	r3, r7, #12
 800f194:	6818      	ldr	r0, [r3, #0]
 800f196:	f04f 016c 	mov.w	r1, #108	; 0x6c
 800f19a:	f7fe f91b 	bl	800d3d4 <d_append_char>
 800f19e:	e01e      	b.n	800f1de <d_print_comp+0x1916>
 800f1a0:	f107 030c 	add.w	r3, r7, #12
 800f1a4:	6818      	ldr	r0, [r3, #0]
 800f1a6:	f64f 619c 	movw	r1, #65180	; 0xfe9c
 800f1aa:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f1ae:	f7fe f951 	bl	800d454 <d_append_string>
 800f1b2:	e014      	b.n	800f1de <d_print_comp+0x1916>
 800f1b4:	f107 030c 	add.w	r3, r7, #12
 800f1b8:	6818      	ldr	r0, [r3, #0]
 800f1ba:	f64f 61a0 	movw	r1, #65184	; 0xfea0
 800f1be:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f1c2:	f7fe f947 	bl	800d454 <d_append_string>
 800f1c6:	e00a      	b.n	800f1de <d_print_comp+0x1916>
 800f1c8:	f107 030c 	add.w	r3, r7, #12
 800f1cc:	6818      	ldr	r0, [r3, #0]
 800f1ce:	f64f 61a4 	movw	r1, #65188	; 0xfea4
 800f1d2:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f1d6:	f7fe f93d 	bl	800d454 <d_append_string>
 800f1da:	e000      	b.n	800f1de <d_print_comp+0x1916>
 800f1dc:	bf00      	nop
 800f1de:	e23d      	b.n	800f65c <d_print_comp+0x1d94>
 800f1e0:	f107 0304 	add.w	r3, r7, #4
 800f1e4:	681b      	ldr	r3, [r3, #0]
 800f1e6:	689b      	ldr	r3, [r3, #8]
 800f1e8:	781b      	ldrb	r3, [r3, #0]
 800f1ea:	2b00      	cmp	r3, #0
 800f1ec:	d131      	bne.n	800f252 <d_print_comp+0x198a>
 800f1ee:	f107 0304 	add.w	r3, r7, #4
 800f1f2:	681b      	ldr	r3, [r3, #0]
 800f1f4:	689b      	ldr	r3, [r3, #8]
 800f1f6:	689b      	ldr	r3, [r3, #8]
 800f1f8:	2b01      	cmp	r3, #1
 800f1fa:	d12a      	bne.n	800f252 <d_print_comp+0x198a>
 800f1fc:	f107 0304 	add.w	r3, r7, #4
 800f200:	681b      	ldr	r3, [r3, #0]
 800f202:	781b      	ldrb	r3, [r3, #0]
 800f204:	2b37      	cmp	r3, #55	; 0x37
 800f206:	d124      	bne.n	800f252 <d_print_comp+0x198a>
 800f208:	f107 0304 	add.w	r3, r7, #4
 800f20c:	681b      	ldr	r3, [r3, #0]
 800f20e:	689b      	ldr	r3, [r3, #8]
 800f210:	685b      	ldr	r3, [r3, #4]
 800f212:	781b      	ldrb	r3, [r3, #0]
 800f214:	2b30      	cmp	r3, #48	; 0x30
 800f216:	d002      	beq.n	800f21e <d_print_comp+0x1956>
 800f218:	2b31      	cmp	r3, #49	; 0x31
 800f21a:	d00a      	beq.n	800f232 <d_print_comp+0x196a>
 800f21c:	e013      	b.n	800f246 <d_print_comp+0x197e>
 800f21e:	f107 030c 	add.w	r3, r7, #12
 800f222:	6818      	ldr	r0, [r3, #0]
 800f224:	f64f 61a8 	movw	r1, #65192	; 0xfea8
 800f228:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f22c:	f7fe f912 	bl	800d454 <d_append_string>
 800f230:	e214      	b.n	800f65c <d_print_comp+0x1d94>
 800f232:	f107 030c 	add.w	r3, r7, #12
 800f236:	6818      	ldr	r0, [r3, #0]
 800f238:	f64f 61b0 	movw	r1, #65200	; 0xfeb0
 800f23c:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f240:	f7fe f908 	bl	800d454 <d_append_string>
 800f244:	e20a      	b.n	800f65c <d_print_comp+0x1d94>
 800f246:	bf00      	nop
 800f248:	e003      	b.n	800f252 <d_print_comp+0x198a>
 800f24a:	bf00      	nop
 800f24c:	e002      	b.n	800f254 <d_print_comp+0x198c>
 800f24e:	bf00      	nop
 800f250:	e000      	b.n	800f254 <d_print_comp+0x198c>
 800f252:	bf00      	nop
 800f254:	f107 030c 	add.w	r3, r7, #12
 800f258:	6818      	ldr	r0, [r3, #0]
 800f25a:	f04f 0128 	mov.w	r1, #40	; 0x28
 800f25e:	f7fe f8b9 	bl	800d3d4 <d_append_char>
 800f262:	f107 0304 	add.w	r3, r7, #4
 800f266:	681b      	ldr	r3, [r3, #0]
 800f268:	685b      	ldr	r3, [r3, #4]
 800f26a:	f107 010c 	add.w	r1, r7, #12
 800f26e:	f107 0208 	add.w	r2, r7, #8
 800f272:	6808      	ldr	r0, [r1, #0]
 800f274:	6811      	ldr	r1, [r2, #0]
 800f276:	461a      	mov	r2, r3
 800f278:	f7fe fb26 	bl	800d8c8 <d_print_comp>
 800f27c:	f107 030c 	add.w	r3, r7, #12
 800f280:	6818      	ldr	r0, [r3, #0]
 800f282:	f04f 0129 	mov.w	r1, #41	; 0x29
 800f286:	f7fe f8a5 	bl	800d3d4 <d_append_char>
 800f28a:	f107 0304 	add.w	r3, r7, #4
 800f28e:	681b      	ldr	r3, [r3, #0]
 800f290:	781b      	ldrb	r3, [r3, #0]
 800f292:	2b38      	cmp	r3, #56	; 0x38
 800f294:	d106      	bne.n	800f2a4 <d_print_comp+0x19dc>
 800f296:	f107 030c 	add.w	r3, r7, #12
 800f29a:	6818      	ldr	r0, [r3, #0]
 800f29c:	f04f 012d 	mov.w	r1, #45	; 0x2d
 800f2a0:	f7fe f898 	bl	800d3d4 <d_append_char>
 800f2a4:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 800f2a8:	2b08      	cmp	r3, #8
 800f2aa:	d106      	bne.n	800f2ba <d_print_comp+0x19f2>
 800f2ac:	f107 030c 	add.w	r3, r7, #12
 800f2b0:	6818      	ldr	r0, [r3, #0]
 800f2b2:	f04f 015b 	mov.w	r1, #91	; 0x5b
 800f2b6:	f7fe f88d 	bl	800d3d4 <d_append_char>
 800f2ba:	f107 0304 	add.w	r3, r7, #4
 800f2be:	681b      	ldr	r3, [r3, #0]
 800f2c0:	689b      	ldr	r3, [r3, #8]
 800f2c2:	f107 010c 	add.w	r1, r7, #12
 800f2c6:	f107 0208 	add.w	r2, r7, #8
 800f2ca:	6808      	ldr	r0, [r1, #0]
 800f2cc:	6811      	ldr	r1, [r2, #0]
 800f2ce:	461a      	mov	r2, r3
 800f2d0:	f7fe fafa 	bl	800d8c8 <d_print_comp>
 800f2d4:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 800f2d8:	2b08      	cmp	r3, #8
 800f2da:	f040 81be 	bne.w	800f65a <d_print_comp+0x1d92>
 800f2de:	f107 030c 	add.w	r3, r7, #12
 800f2e2:	6818      	ldr	r0, [r3, #0]
 800f2e4:	f04f 015d 	mov.w	r1, #93	; 0x5d
 800f2e8:	f7fe f874 	bl	800d3d4 <d_append_char>
 800f2ec:	e1b5      	b.n	800f65a <d_print_comp+0x1d92>
 800f2ee:	f107 0304 	add.w	r3, r7, #4
 800f2f2:	681b      	ldr	r3, [r3, #0]
 800f2f4:	685b      	ldr	r3, [r3, #4]
 800f2f6:	f107 020c 	add.w	r2, r7, #12
 800f2fa:	6810      	ldr	r0, [r2, #0]
 800f2fc:	4619      	mov	r1, r3
 800f2fe:	f7fe f8bb 	bl	800d478 <d_append_num>
 800f302:	e1ab      	b.n	800f65c <d_print_comp+0x1d94>
 800f304:	f107 030c 	add.w	r3, r7, #12
 800f308:	6818      	ldr	r0, [r3, #0]
 800f30a:	f64f 61b8 	movw	r1, #65208	; 0xfeb8
 800f30e:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f312:	f7fe f89f 	bl	800d454 <d_append_string>
 800f316:	f107 0304 	add.w	r3, r7, #4
 800f31a:	681b      	ldr	r3, [r3, #0]
 800f31c:	685b      	ldr	r3, [r3, #4]
 800f31e:	f107 010c 	add.w	r1, r7, #12
 800f322:	f107 0208 	add.w	r2, r7, #8
 800f326:	6808      	ldr	r0, [r1, #0]
 800f328:	6811      	ldr	r1, [r2, #0]
 800f32a:	461a      	mov	r2, r3
 800f32c:	f7fe facc 	bl	800d8c8 <d_print_comp>
 800f330:	e194      	b.n	800f65c <d_print_comp+0x1d94>
 800f332:	f107 0304 	add.w	r3, r7, #4
 800f336:	681b      	ldr	r3, [r3, #0]
 800f338:	685b      	ldr	r3, [r3, #4]
 800f33a:	f107 010c 	add.w	r1, r7, #12
 800f33e:	f107 0208 	add.w	r2, r7, #8
 800f342:	6808      	ldr	r0, [r1, #0]
 800f344:	6811      	ldr	r1, [r2, #0]
 800f346:	461a      	mov	r2, r3
 800f348:	f7fe fabe 	bl	800d8c8 <d_print_comp>
 800f34c:	f107 0304 	add.w	r3, r7, #4
 800f350:	681b      	ldr	r3, [r3, #0]
 800f352:	689b      	ldr	r3, [r3, #8]
 800f354:	f107 010c 	add.w	r1, r7, #12
 800f358:	f107 0208 	add.w	r2, r7, #8
 800f35c:	6808      	ldr	r0, [r1, #0]
 800f35e:	6811      	ldr	r1, [r2, #0]
 800f360:	461a      	mov	r2, r3
 800f362:	f7fe fab1 	bl	800d8c8 <d_print_comp>
 800f366:	e179      	b.n	800f65c <d_print_comp+0x1d94>
 800f368:	f107 0304 	add.w	r3, r7, #4
 800f36c:	681b      	ldr	r3, [r3, #0]
 800f36e:	685b      	ldr	r3, [r3, #4]
 800f370:	b2db      	uxtb	r3, r3
 800f372:	f107 020c 	add.w	r2, r7, #12
 800f376:	6810      	ldr	r0, [r2, #0]
 800f378:	4619      	mov	r1, r3
 800f37a:	f7fe f82b 	bl	800d3d4 <d_append_char>
 800f37e:	e16d      	b.n	800f65c <d_print_comp+0x1d94>
 800f380:	f107 030c 	add.w	r3, r7, #12
 800f384:	6818      	ldr	r0, [r3, #0]
 800f386:	f64f 61c8 	movw	r1, #65224	; 0xfec8
 800f38a:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f38e:	f7fe f861 	bl	800d454 <d_append_string>
 800f392:	f107 0304 	add.w	r3, r7, #4
 800f396:	681b      	ldr	r3, [r3, #0]
 800f398:	685b      	ldr	r3, [r3, #4]
 800f39a:	f107 010c 	add.w	r1, r7, #12
 800f39e:	f107 0208 	add.w	r2, r7, #8
 800f3a2:	6808      	ldr	r0, [r1, #0]
 800f3a4:	6811      	ldr	r1, [r2, #0]
 800f3a6:	461a      	mov	r2, r3
 800f3a8:	f7fe fa8e 	bl	800d8c8 <d_print_comp>
 800f3ac:	f107 030c 	add.w	r3, r7, #12
 800f3b0:	6818      	ldr	r0, [r3, #0]
 800f3b2:	f04f 0129 	mov.w	r1, #41	; 0x29
 800f3b6:	f7fe f80d 	bl	800d3d4 <d_append_char>
 800f3ba:	e14f      	b.n	800f65c <d_print_comp+0x1d94>
 800f3bc:	f107 0304 	add.w	r3, r7, #4
 800f3c0:	681b      	ldr	r3, [r3, #0]
 800f3c2:	685b      	ldr	r3, [r3, #4]
 800f3c4:	f107 020c 	add.w	r2, r7, #12
 800f3c8:	6810      	ldr	r0, [r2, #0]
 800f3ca:	4619      	mov	r1, r3
 800f3cc:	f7fe f93c 	bl	800d648 <d_find_pack>
 800f3d0:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90
 800f3d4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800f3d8:	2b00      	cmp	r3, #0
 800f3da:	d116      	bne.n	800f40a <d_print_comp+0x1b42>
 800f3dc:	f107 0304 	add.w	r3, r7, #4
 800f3e0:	681b      	ldr	r3, [r3, #0]
 800f3e2:	685b      	ldr	r3, [r3, #4]
 800f3e4:	f107 010c 	add.w	r1, r7, #12
 800f3e8:	f107 0208 	add.w	r2, r7, #8
 800f3ec:	6808      	ldr	r0, [r1, #0]
 800f3ee:	6811      	ldr	r1, [r2, #0]
 800f3f0:	461a      	mov	r2, r3
 800f3f2:	f7fe fa33 	bl	800d85c <d_print_subexpr>
 800f3f6:	f107 030c 	add.w	r3, r7, #12
 800f3fa:	6818      	ldr	r0, [r3, #0]
 800f3fc:	f24f 2108 	movw	r1, #61960	; 0xf208
 800f400:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f404:	f7fe f826 	bl	800d454 <d_append_string>
 800f408:	e128      	b.n	800f65c <d_print_comp+0x1d94>
 800f40a:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 800f40e:	f7fe fa03 	bl	800d818 <d_pack_length>
 800f412:	f8c7 008c 	str.w	r0, [r7, #140]	; 0x8c
 800f416:	f107 0304 	add.w	r3, r7, #4
 800f41a:	f107 0204 	add.w	r2, r7, #4
 800f41e:	6812      	ldr	r2, [r2, #0]
 800f420:	6852      	ldr	r2, [r2, #4]
 800f422:	601a      	str	r2, [r3, #0]
 800f424:	f04f 0300 	mov.w	r3, #0
 800f428:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 800f42c:	e028      	b.n	800f480 <d_print_comp+0x1bb8>
 800f42e:	f107 030c 	add.w	r3, r7, #12
 800f432:	681b      	ldr	r3, [r3, #0]
 800f434:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 800f438:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
 800f43c:	f107 010c 	add.w	r1, r7, #12
 800f440:	f107 0208 	add.w	r2, r7, #8
 800f444:	f107 0304 	add.w	r3, r7, #4
 800f448:	6808      	ldr	r0, [r1, #0]
 800f44a:	6811      	ldr	r1, [r2, #0]
 800f44c:	681a      	ldr	r2, [r3, #0]
 800f44e:	f7fe fa3b 	bl	800d8c8 <d_print_comp>
 800f452:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800f456:	f103 32ff 	add.w	r2, r3, #4294967295
 800f45a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800f45e:	429a      	cmp	r2, r3
 800f460:	dd08      	ble.n	800f474 <d_print_comp+0x1bac>
 800f462:	f107 030c 	add.w	r3, r7, #12
 800f466:	6818      	ldr	r0, [r3, #0]
 800f468:	f64f 6174 	movw	r1, #65140	; 0xfe74
 800f46c:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f470:	f7fd fff0 	bl	800d454 <d_append_string>
 800f474:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800f478:	f103 0301 	add.w	r3, r3, #1
 800f47c:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 800f480:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 800f484:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800f488:	429a      	cmp	r2, r3
 800f48a:	dbd0      	blt.n	800f42e <d_print_comp+0x1b66>
 800f48c:	e0e6      	b.n	800f65c <d_print_comp+0x1d94>
 800f48e:	f107 0304 	add.w	r3, r7, #4
 800f492:	681b      	ldr	r3, [r3, #0]
 800f494:	685b      	ldr	r3, [r3, #4]
 800f496:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 800f49a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800f49e:	2b00      	cmp	r3, #0
 800f4a0:	d109      	bne.n	800f4b6 <d_print_comp+0x1bee>
 800f4a2:	f107 030c 	add.w	r3, r7, #12
 800f4a6:	6818      	ldr	r0, [r3, #0]
 800f4a8:	f64f 61d4 	movw	r1, #65236	; 0xfed4
 800f4ac:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f4b0:	f7fd ffd0 	bl	800d454 <d_append_string>
 800f4b4:	e0d2      	b.n	800f65c <d_print_comp+0x1d94>
 800f4b6:	f107 030c 	add.w	r3, r7, #12
 800f4ba:	6818      	ldr	r0, [r3, #0]
 800f4bc:	f64f 61dc 	movw	r1, #65244	; 0xfedc
 800f4c0:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f4c4:	f7fd ffc6 	bl	800d454 <d_append_string>
 800f4c8:	f107 030c 	add.w	r3, r7, #12
 800f4cc:	6818      	ldr	r0, [r3, #0]
 800f4ce:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 800f4d2:	f7fd ffd1 	bl	800d478 <d_append_num>
 800f4d6:	f107 030c 	add.w	r3, r7, #12
 800f4da:	6818      	ldr	r0, [r3, #0]
 800f4dc:	f04f 017d 	mov.w	r1, #125	; 0x7d
 800f4e0:	f7fd ff78 	bl	800d3d4 <d_append_char>
 800f4e4:	e0ba      	b.n	800f65c <d_print_comp+0x1d94>
 800f4e6:	f107 030c 	add.w	r3, r7, #12
 800f4ea:	6818      	ldr	r0, [r3, #0]
 800f4ec:	f64f 61e4 	movw	r1, #65252	; 0xfee4
 800f4f0:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f4f4:	f7fd ffae 	bl	800d454 <d_append_string>
 800f4f8:	f107 0304 	add.w	r3, r7, #4
 800f4fc:	681b      	ldr	r3, [r3, #0]
 800f4fe:	685b      	ldr	r3, [r3, #4]
 800f500:	f107 010c 	add.w	r1, r7, #12
 800f504:	f107 0208 	add.w	r2, r7, #8
 800f508:	6808      	ldr	r0, [r1, #0]
 800f50a:	6811      	ldr	r1, [r2, #0]
 800f50c:	461a      	mov	r2, r3
 800f50e:	f7fe f9db 	bl	800d8c8 <d_print_comp>
 800f512:	e0a3      	b.n	800f65c <d_print_comp+0x1d94>
 800f514:	f107 030c 	add.w	r3, r7, #12
 800f518:	6818      	ldr	r0, [r3, #0]
 800f51a:	f64f 7104 	movw	r1, #65284	; 0xff04
 800f51e:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f522:	f7fd ff97 	bl	800d454 <d_append_string>
 800f526:	f107 0304 	add.w	r3, r7, #4
 800f52a:	681b      	ldr	r3, [r3, #0]
 800f52c:	685b      	ldr	r3, [r3, #4]
 800f52e:	f107 010c 	add.w	r1, r7, #12
 800f532:	f107 0208 	add.w	r2, r7, #8
 800f536:	6808      	ldr	r0, [r1, #0]
 800f538:	6811      	ldr	r1, [r2, #0]
 800f53a:	461a      	mov	r2, r3
 800f53c:	f7fe f9c4 	bl	800d8c8 <d_print_comp>
 800f540:	e08c      	b.n	800f65c <d_print_comp+0x1d94>
 800f542:	f107 030c 	add.w	r3, r7, #12
 800f546:	6818      	ldr	r0, [r3, #0]
 800f548:	f64f 7124 	movw	r1, #65316	; 0xff24
 800f54c:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f550:	f7fd ff80 	bl	800d454 <d_append_string>
 800f554:	f107 0304 	add.w	r3, r7, #4
 800f558:	681b      	ldr	r3, [r3, #0]
 800f55a:	685b      	ldr	r3, [r3, #4]
 800f55c:	f107 010c 	add.w	r1, r7, #12
 800f560:	f107 0208 	add.w	r2, r7, #8
 800f564:	6808      	ldr	r0, [r1, #0]
 800f566:	6811      	ldr	r1, [r2, #0]
 800f568:	461a      	mov	r2, r3
 800f56a:	f7fe f9ad 	bl	800d8c8 <d_print_comp>
 800f56e:	f107 030c 	add.w	r3, r7, #12
 800f572:	6818      	ldr	r0, [r3, #0]
 800f574:	f64f 7130 	movw	r1, #65328	; 0xff30
 800f578:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f57c:	f7fd ff6a 	bl	800d454 <d_append_string>
 800f580:	f107 0304 	add.w	r3, r7, #4
 800f584:	681b      	ldr	r3, [r3, #0]
 800f586:	689b      	ldr	r3, [r3, #8]
 800f588:	f103 0301 	add.w	r3, r3, #1
 800f58c:	f107 020c 	add.w	r2, r7, #12
 800f590:	6810      	ldr	r0, [r2, #0]
 800f592:	4619      	mov	r1, r3
 800f594:	f7fd ff70 	bl	800d478 <d_append_num>
 800f598:	f107 030c 	add.w	r3, r7, #12
 800f59c:	6818      	ldr	r0, [r3, #0]
 800f59e:	f04f 017d 	mov.w	r1, #125	; 0x7d
 800f5a2:	f7fd ff17 	bl	800d3d4 <d_append_char>
 800f5a6:	e059      	b.n	800f65c <d_print_comp+0x1d94>
 800f5a8:	f107 030c 	add.w	r3, r7, #12
 800f5ac:	6818      	ldr	r0, [r3, #0]
 800f5ae:	f64f 7134 	movw	r1, #65332	; 0xff34
 800f5b2:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f5b6:	f7fd ff4d 	bl	800d454 <d_append_string>
 800f5ba:	f107 0304 	add.w	r3, r7, #4
 800f5be:	681b      	ldr	r3, [r3, #0]
 800f5c0:	685b      	ldr	r3, [r3, #4]
 800f5c2:	f103 0301 	add.w	r3, r3, #1
 800f5c6:	f107 020c 	add.w	r2, r7, #12
 800f5ca:	6810      	ldr	r0, [r2, #0]
 800f5cc:	4619      	mov	r1, r3
 800f5ce:	f7fd ff53 	bl	800d478 <d_append_num>
 800f5d2:	f107 030c 	add.w	r3, r7, #12
 800f5d6:	6818      	ldr	r0, [r3, #0]
 800f5d8:	f04f 017d 	mov.w	r1, #125	; 0x7d
 800f5dc:	f7fd fefa 	bl	800d3d4 <d_append_char>
 800f5e0:	e03c      	b.n	800f65c <d_print_comp+0x1d94>
 800f5e2:	f107 0304 	add.w	r3, r7, #4
 800f5e6:	681b      	ldr	r3, [r3, #0]
 800f5e8:	685b      	ldr	r3, [r3, #4]
 800f5ea:	f107 010c 	add.w	r1, r7, #12
 800f5ee:	f107 0208 	add.w	r2, r7, #8
 800f5f2:	6808      	ldr	r0, [r1, #0]
 800f5f4:	6811      	ldr	r1, [r2, #0]
 800f5f6:	461a      	mov	r2, r3
 800f5f8:	f7fe f966 	bl	800d8c8 <d_print_comp>
 800f5fc:	f107 030c 	add.w	r3, r7, #12
 800f600:	6818      	ldr	r0, [r3, #0]
 800f602:	f64f 7144 	movw	r1, #65348	; 0xff44
 800f606:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f60a:	f7fd ff23 	bl	800d454 <d_append_string>
 800f60e:	f107 0304 	add.w	r3, r7, #4
 800f612:	681b      	ldr	r3, [r3, #0]
 800f614:	689b      	ldr	r3, [r3, #8]
 800f616:	f107 010c 	add.w	r1, r7, #12
 800f61a:	f107 0208 	add.w	r2, r7, #8
 800f61e:	6808      	ldr	r0, [r1, #0]
 800f620:	6811      	ldr	r1, [r2, #0]
 800f622:	461a      	mov	r2, r3
 800f624:	f7fe f950 	bl	800d8c8 <d_print_comp>
 800f628:	f107 030c 	add.w	r3, r7, #12
 800f62c:	6818      	ldr	r0, [r3, #0]
 800f62e:	f04f 015d 	mov.w	r1, #93	; 0x5d
 800f632:	f7fd fecf 	bl	800d3d4 <d_append_char>
 800f636:	e011      	b.n	800f65c <d_print_comp+0x1d94>
 800f638:	f107 030c 	add.w	r3, r7, #12
 800f63c:	6818      	ldr	r0, [r3, #0]
 800f63e:	f7fd fe81 	bl	800d344 <d_print_error>
 800f642:	bf00      	nop
 800f644:	e00a      	b.n	800f65c <d_print_comp+0x1d94>
 800f646:	bf00      	nop
 800f648:	e008      	b.n	800f65c <d_print_comp+0x1d94>
 800f64a:	bf00      	nop
 800f64c:	e006      	b.n	800f65c <d_print_comp+0x1d94>
 800f64e:	bf00      	nop
 800f650:	e004      	b.n	800f65c <d_print_comp+0x1d94>
 800f652:	bf00      	nop
 800f654:	e002      	b.n	800f65c <d_print_comp+0x1d94>
 800f656:	bf00      	nop
 800f658:	e000      	b.n	800f65c <d_print_comp+0x1d94>
 800f65a:	bf00      	nop
 800f65c:	f507 778a 	add.w	r7, r7, #276	; 0x114
 800f660:	46bd      	mov	sp, r7
 800f662:	bd90      	pop	{r4, r7, pc}

0800f664 <d_print_java_identifier>:
 800f664:	b580      	push	{r7, lr}
 800f666:	b08a      	sub	sp, #40	; 0x28
 800f668:	af00      	add	r7, sp, #0
 800f66a:	60f8      	str	r0, [r7, #12]
 800f66c:	60b9      	str	r1, [r7, #8]
 800f66e:	607a      	str	r2, [r7, #4]
 800f670:	687b      	ldr	r3, [r7, #4]
 800f672:	68ba      	ldr	r2, [r7, #8]
 800f674:	18d3      	adds	r3, r2, r3
 800f676:	617b      	str	r3, [r7, #20]
 800f678:	68bb      	ldr	r3, [r7, #8]
 800f67a:	627b      	str	r3, [r7, #36]	; 0x24
 800f67c:	e071      	b.n	800f762 <d_print_java_identifier+0xfe>
 800f67e:	697a      	ldr	r2, [r7, #20]
 800f680:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f682:	1ad3      	subs	r3, r2, r3
 800f684:	2b03      	cmp	r3, #3
 800f686:	dd62      	ble.n	800f74e <d_print_java_identifier+0xea>
 800f688:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f68a:	781b      	ldrb	r3, [r3, #0]
 800f68c:	2b5f      	cmp	r3, #95	; 0x5f
 800f68e:	d15e      	bne.n	800f74e <d_print_java_identifier+0xea>
 800f690:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f692:	f103 0301 	add.w	r3, r3, #1
 800f696:	781b      	ldrb	r3, [r3, #0]
 800f698:	2b5f      	cmp	r3, #95	; 0x5f
 800f69a:	d158      	bne.n	800f74e <d_print_java_identifier+0xea>
 800f69c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f69e:	f103 0302 	add.w	r3, r3, #2
 800f6a2:	781b      	ldrb	r3, [r3, #0]
 800f6a4:	2b55      	cmp	r3, #85	; 0x55
 800f6a6:	d152      	bne.n	800f74e <d_print_java_identifier+0xea>
 800f6a8:	f04f 0300 	mov.w	r3, #0
 800f6ac:	623b      	str	r3, [r7, #32]
 800f6ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f6b0:	f103 0303 	add.w	r3, r3, #3
 800f6b4:	61fb      	str	r3, [r7, #28]
 800f6b6:	e032      	b.n	800f71e <d_print_java_identifier+0xba>
 800f6b8:	69fb      	ldr	r3, [r7, #28]
 800f6ba:	781b      	ldrb	r3, [r3, #0]
 800f6bc:	2b2f      	cmp	r3, #47	; 0x2f
 800f6be:	d909      	bls.n	800f6d4 <d_print_java_identifier+0x70>
 800f6c0:	69fb      	ldr	r3, [r7, #28]
 800f6c2:	781b      	ldrb	r3, [r3, #0]
 800f6c4:	2b39      	cmp	r3, #57	; 0x39
 800f6c6:	d805      	bhi.n	800f6d4 <d_print_java_identifier+0x70>
 800f6c8:	69fb      	ldr	r3, [r7, #28]
 800f6ca:	781b      	ldrb	r3, [r3, #0]
 800f6cc:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 800f6d0:	61bb      	str	r3, [r7, #24]
 800f6d2:	e01a      	b.n	800f70a <d_print_java_identifier+0xa6>
 800f6d4:	69fb      	ldr	r3, [r7, #28]
 800f6d6:	781b      	ldrb	r3, [r3, #0]
 800f6d8:	2b40      	cmp	r3, #64	; 0x40
 800f6da:	d909      	bls.n	800f6f0 <d_print_java_identifier+0x8c>
 800f6dc:	69fb      	ldr	r3, [r7, #28]
 800f6de:	781b      	ldrb	r3, [r3, #0]
 800f6e0:	2b46      	cmp	r3, #70	; 0x46
 800f6e2:	d805      	bhi.n	800f6f0 <d_print_java_identifier+0x8c>
 800f6e4:	69fb      	ldr	r3, [r7, #28]
 800f6e6:	781b      	ldrb	r3, [r3, #0]
 800f6e8:	f1a3 0337 	sub.w	r3, r3, #55	; 0x37
 800f6ec:	61bb      	str	r3, [r7, #24]
 800f6ee:	e00c      	b.n	800f70a <d_print_java_identifier+0xa6>
 800f6f0:	69fb      	ldr	r3, [r7, #28]
 800f6f2:	781b      	ldrb	r3, [r3, #0]
 800f6f4:	2b60      	cmp	r3, #96	; 0x60
 800f6f6:	d916      	bls.n	800f726 <d_print_java_identifier+0xc2>
 800f6f8:	69fb      	ldr	r3, [r7, #28]
 800f6fa:	781b      	ldrb	r3, [r3, #0]
 800f6fc:	2b66      	cmp	r3, #102	; 0x66
 800f6fe:	d812      	bhi.n	800f726 <d_print_java_identifier+0xc2>
 800f700:	69fb      	ldr	r3, [r7, #28]
 800f702:	781b      	ldrb	r3, [r3, #0]
 800f704:	f1a3 0357 	sub.w	r3, r3, #87	; 0x57
 800f708:	61bb      	str	r3, [r7, #24]
 800f70a:	6a3b      	ldr	r3, [r7, #32]
 800f70c:	ea4f 1203 	mov.w	r2, r3, lsl #4
 800f710:	69bb      	ldr	r3, [r7, #24]
 800f712:	18d3      	adds	r3, r2, r3
 800f714:	623b      	str	r3, [r7, #32]
 800f716:	69fb      	ldr	r3, [r7, #28]
 800f718:	f103 0301 	add.w	r3, r3, #1
 800f71c:	61fb      	str	r3, [r7, #28]
 800f71e:	69fa      	ldr	r2, [r7, #28]
 800f720:	697b      	ldr	r3, [r7, #20]
 800f722:	429a      	cmp	r2, r3
 800f724:	d3c8      	bcc.n	800f6b8 <d_print_java_identifier+0x54>
 800f726:	69fa      	ldr	r2, [r7, #28]
 800f728:	697b      	ldr	r3, [r7, #20]
 800f72a:	429a      	cmp	r2, r3
 800f72c:	d20f      	bcs.n	800f74e <d_print_java_identifier+0xea>
 800f72e:	69fb      	ldr	r3, [r7, #28]
 800f730:	781b      	ldrb	r3, [r3, #0]
 800f732:	2b5f      	cmp	r3, #95	; 0x5f
 800f734:	d10b      	bne.n	800f74e <d_print_java_identifier+0xea>
 800f736:	6a3b      	ldr	r3, [r7, #32]
 800f738:	2bff      	cmp	r3, #255	; 0xff
 800f73a:	d808      	bhi.n	800f74e <d_print_java_identifier+0xea>
 800f73c:	6a3b      	ldr	r3, [r7, #32]
 800f73e:	b2db      	uxtb	r3, r3
 800f740:	68f8      	ldr	r0, [r7, #12]
 800f742:	4619      	mov	r1, r3
 800f744:	f7fd fe46 	bl	800d3d4 <d_append_char>
 800f748:	69fb      	ldr	r3, [r7, #28]
 800f74a:	627b      	str	r3, [r7, #36]	; 0x24
 800f74c:	e005      	b.n	800f75a <d_print_java_identifier+0xf6>
 800f74e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f750:	781b      	ldrb	r3, [r3, #0]
 800f752:	68f8      	ldr	r0, [r7, #12]
 800f754:	4619      	mov	r1, r3
 800f756:	f7fd fe3d 	bl	800d3d4 <d_append_char>
 800f75a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f75c:	f103 0301 	add.w	r3, r3, #1
 800f760:	627b      	str	r3, [r7, #36]	; 0x24
 800f762:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800f764:	697b      	ldr	r3, [r7, #20]
 800f766:	429a      	cmp	r2, r3
 800f768:	d389      	bcc.n	800f67e <d_print_java_identifier+0x1a>
 800f76a:	f107 0728 	add.w	r7, r7, #40	; 0x28
 800f76e:	46bd      	mov	sp, r7
 800f770:	bd80      	pop	{r7, pc}
 800f772:	bf00      	nop

0800f774 <d_print_mod_list>:
 800f774:	b580      	push	{r7, lr}
 800f776:	b088      	sub	sp, #32
 800f778:	af00      	add	r7, sp, #0
 800f77a:	60f8      	str	r0, [r7, #12]
 800f77c:	60b9      	str	r1, [r7, #8]
 800f77e:	607a      	str	r2, [r7, #4]
 800f780:	603b      	str	r3, [r7, #0]
 800f782:	687b      	ldr	r3, [r7, #4]
 800f784:	2b00      	cmp	r3, #0
 800f786:	f000 80d4 	beq.w	800f932 <d_print_mod_list+0x1be>
 800f78a:	68f8      	ldr	r0, [r7, #12]
 800f78c:	f7fd fde8 	bl	800d360 <d_print_saw_error>
 800f790:	4603      	mov	r3, r0
 800f792:	2b00      	cmp	r3, #0
 800f794:	f040 80cd 	bne.w	800f932 <d_print_mod_list+0x1be>
 800f798:	687b      	ldr	r3, [r7, #4]
 800f79a:	689b      	ldr	r3, [r3, #8]
 800f79c:	2b00      	cmp	r3, #0
 800f79e:	d111      	bne.n	800f7c4 <d_print_mod_list+0x50>
 800f7a0:	683b      	ldr	r3, [r7, #0]
 800f7a2:	2b00      	cmp	r3, #0
 800f7a4:	d117      	bne.n	800f7d6 <d_print_mod_list+0x62>
 800f7a6:	687b      	ldr	r3, [r7, #4]
 800f7a8:	685b      	ldr	r3, [r3, #4]
 800f7aa:	781b      	ldrb	r3, [r3, #0]
 800f7ac:	2b1a      	cmp	r3, #26
 800f7ae:	d009      	beq.n	800f7c4 <d_print_mod_list+0x50>
 800f7b0:	687b      	ldr	r3, [r7, #4]
 800f7b2:	685b      	ldr	r3, [r3, #4]
 800f7b4:	781b      	ldrb	r3, [r3, #0]
 800f7b6:	2b1b      	cmp	r3, #27
 800f7b8:	d004      	beq.n	800f7c4 <d_print_mod_list+0x50>
 800f7ba:	687b      	ldr	r3, [r7, #4]
 800f7bc:	685b      	ldr	r3, [r3, #4]
 800f7be:	781b      	ldrb	r3, [r3, #0]
 800f7c0:	2b1c      	cmp	r3, #28
 800f7c2:	d108      	bne.n	800f7d6 <d_print_mod_list+0x62>
 800f7c4:	687b      	ldr	r3, [r7, #4]
 800f7c6:	681b      	ldr	r3, [r3, #0]
 800f7c8:	68f8      	ldr	r0, [r7, #12]
 800f7ca:	68b9      	ldr	r1, [r7, #8]
 800f7cc:	461a      	mov	r2, r3
 800f7ce:	683b      	ldr	r3, [r7, #0]
 800f7d0:	f7ff ffd0 	bl	800f774 <d_print_mod_list>
 800f7d4:	e0ae      	b.n	800f934 <d_print_mod_list+0x1c0>
 800f7d6:	687b      	ldr	r3, [r7, #4]
 800f7d8:	f04f 0201 	mov.w	r2, #1
 800f7dc:	609a      	str	r2, [r3, #8]
 800f7de:	68fb      	ldr	r3, [r7, #12]
 800f7e0:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 800f7e4:	61bb      	str	r3, [r7, #24]
 800f7e6:	687b      	ldr	r3, [r7, #4]
 800f7e8:	68da      	ldr	r2, [r3, #12]
 800f7ea:	68fb      	ldr	r3, [r7, #12]
 800f7ec:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
 800f7f0:	687b      	ldr	r3, [r7, #4]
 800f7f2:	685b      	ldr	r3, [r3, #4]
 800f7f4:	781b      	ldrb	r3, [r3, #0]
 800f7f6:	2b25      	cmp	r3, #37	; 0x25
 800f7f8:	d10c      	bne.n	800f814 <d_print_mod_list+0xa0>
 800f7fa:	687b      	ldr	r3, [r7, #4]
 800f7fc:	685a      	ldr	r2, [r3, #4]
 800f7fe:	687b      	ldr	r3, [r7, #4]
 800f800:	681b      	ldr	r3, [r3, #0]
 800f802:	68f8      	ldr	r0, [r7, #12]
 800f804:	68b9      	ldr	r1, [r7, #8]
 800f806:	f000 f987 	bl	800fb18 <d_print_function_type>
 800f80a:	68fb      	ldr	r3, [r7, #12]
 800f80c:	69ba      	ldr	r2, [r7, #24]
 800f80e:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
 800f812:	e08f      	b.n	800f934 <d_print_mod_list+0x1c0>
 800f814:	687b      	ldr	r3, [r7, #4]
 800f816:	685b      	ldr	r3, [r3, #4]
 800f818:	781b      	ldrb	r3, [r3, #0]
 800f81a:	2b26      	cmp	r3, #38	; 0x26
 800f81c:	d10c      	bne.n	800f838 <d_print_mod_list+0xc4>
 800f81e:	687b      	ldr	r3, [r7, #4]
 800f820:	685a      	ldr	r2, [r3, #4]
 800f822:	687b      	ldr	r3, [r7, #4]
 800f824:	681b      	ldr	r3, [r3, #0]
 800f826:	68f8      	ldr	r0, [r7, #12]
 800f828:	68b9      	ldr	r1, [r7, #8]
 800f82a:	f000 fa23 	bl	800fc74 <d_print_array_type>
 800f82e:	68fb      	ldr	r3, [r7, #12]
 800f830:	69ba      	ldr	r2, [r7, #24]
 800f832:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
 800f836:	e07d      	b.n	800f934 <d_print_mod_list+0x1c0>
 800f838:	687b      	ldr	r3, [r7, #4]
 800f83a:	685b      	ldr	r3, [r3, #4]
 800f83c:	781b      	ldrb	r3, [r3, #0]
 800f83e:	2b02      	cmp	r3, #2
 800f840:	d163      	bne.n	800f90a <d_print_mod_list+0x196>
 800f842:	68fb      	ldr	r3, [r7, #12]
 800f844:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800f848:	617b      	str	r3, [r7, #20]
 800f84a:	68fb      	ldr	r3, [r7, #12]
 800f84c:	f04f 0200 	mov.w	r2, #0
 800f850:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800f854:	687b      	ldr	r3, [r7, #4]
 800f856:	685b      	ldr	r3, [r3, #4]
 800f858:	685b      	ldr	r3, [r3, #4]
 800f85a:	68f8      	ldr	r0, [r7, #12]
 800f85c:	68b9      	ldr	r1, [r7, #8]
 800f85e:	461a      	mov	r2, r3
 800f860:	f7fe f832 	bl	800d8c8 <d_print_comp>
 800f864:	68fb      	ldr	r3, [r7, #12]
 800f866:	697a      	ldr	r2, [r7, #20]
 800f868:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800f86c:	68bb      	ldr	r3, [r7, #8]
 800f86e:	f003 0304 	and.w	r3, r3, #4
 800f872:	2b00      	cmp	r3, #0
 800f874:	d107      	bne.n	800f886 <d_print_mod_list+0x112>
 800f876:	68f8      	ldr	r0, [r7, #12]
 800f878:	f24f 51dc 	movw	r1, #62940	; 0xf5dc
 800f87c:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f880:	f7fd fde8 	bl	800d454 <d_append_string>
 800f884:	e004      	b.n	800f890 <d_print_mod_list+0x11c>
 800f886:	68f8      	ldr	r0, [r7, #12]
 800f888:	f04f 012e 	mov.w	r1, #46	; 0x2e
 800f88c:	f7fd fda2 	bl	800d3d4 <d_append_char>
 800f890:	687b      	ldr	r3, [r7, #4]
 800f892:	685b      	ldr	r3, [r3, #4]
 800f894:	689b      	ldr	r3, [r3, #8]
 800f896:	61fb      	str	r3, [r7, #28]
 800f898:	69fb      	ldr	r3, [r7, #28]
 800f89a:	781b      	ldrb	r3, [r3, #0]
 800f89c:	2b41      	cmp	r3, #65	; 0x41
 800f89e:	d11d      	bne.n	800f8dc <d_print_mod_list+0x168>
 800f8a0:	68f8      	ldr	r0, [r7, #12]
 800f8a2:	f64f 7150 	movw	r1, #65360	; 0xff50
 800f8a6:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f8aa:	f7fd fdd3 	bl	800d454 <d_append_string>
 800f8ae:	69fb      	ldr	r3, [r7, #28]
 800f8b0:	689b      	ldr	r3, [r3, #8]
 800f8b2:	f103 0301 	add.w	r3, r3, #1
 800f8b6:	68f8      	ldr	r0, [r7, #12]
 800f8b8:	4619      	mov	r1, r3
 800f8ba:	f7fd fddd 	bl	800d478 <d_append_num>
 800f8be:	68f8      	ldr	r0, [r7, #12]
 800f8c0:	f64f 7160 	movw	r1, #65376	; 0xff60
 800f8c4:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f8c8:	f7fd fdc4 	bl	800d454 <d_append_string>
 800f8cc:	69fb      	ldr	r3, [r7, #28]
 800f8ce:	685b      	ldr	r3, [r3, #4]
 800f8d0:	61fb      	str	r3, [r7, #28]
 800f8d2:	e003      	b.n	800f8dc <d_print_mod_list+0x168>
 800f8d4:	69fb      	ldr	r3, [r7, #28]
 800f8d6:	685b      	ldr	r3, [r3, #4]
 800f8d8:	61fb      	str	r3, [r7, #28]
 800f8da:	e000      	b.n	800f8de <d_print_mod_list+0x16a>
 800f8dc:	bf00      	nop
 800f8de:	69fb      	ldr	r3, [r7, #28]
 800f8e0:	781b      	ldrb	r3, [r3, #0]
 800f8e2:	2b1a      	cmp	r3, #26
 800f8e4:	d0f6      	beq.n	800f8d4 <d_print_mod_list+0x160>
 800f8e6:	69fb      	ldr	r3, [r7, #28]
 800f8e8:	781b      	ldrb	r3, [r3, #0]
 800f8ea:	2b1b      	cmp	r3, #27
 800f8ec:	d0f2      	beq.n	800f8d4 <d_print_mod_list+0x160>
 800f8ee:	69fb      	ldr	r3, [r7, #28]
 800f8f0:	781b      	ldrb	r3, [r3, #0]
 800f8f2:	2b1c      	cmp	r3, #28
 800f8f4:	d0ee      	beq.n	800f8d4 <d_print_mod_list+0x160>
 800f8f6:	68f8      	ldr	r0, [r7, #12]
 800f8f8:	68b9      	ldr	r1, [r7, #8]
 800f8fa:	69fa      	ldr	r2, [r7, #28]
 800f8fc:	f7fd ffe4 	bl	800d8c8 <d_print_comp>
 800f900:	68fb      	ldr	r3, [r7, #12]
 800f902:	69ba      	ldr	r2, [r7, #24]
 800f904:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
 800f908:	e014      	b.n	800f934 <d_print_mod_list+0x1c0>
 800f90a:	687b      	ldr	r3, [r7, #4]
 800f90c:	685b      	ldr	r3, [r3, #4]
 800f90e:	68f8      	ldr	r0, [r7, #12]
 800f910:	68b9      	ldr	r1, [r7, #8]
 800f912:	461a      	mov	r2, r3
 800f914:	f000 f812 	bl	800f93c <d_print_mod>
 800f918:	68fb      	ldr	r3, [r7, #12]
 800f91a:	69ba      	ldr	r2, [r7, #24]
 800f91c:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
 800f920:	687b      	ldr	r3, [r7, #4]
 800f922:	681b      	ldr	r3, [r3, #0]
 800f924:	68f8      	ldr	r0, [r7, #12]
 800f926:	68b9      	ldr	r1, [r7, #8]
 800f928:	461a      	mov	r2, r3
 800f92a:	683b      	ldr	r3, [r7, #0]
 800f92c:	f7ff ff22 	bl	800f774 <d_print_mod_list>
 800f930:	e000      	b.n	800f934 <d_print_mod_list+0x1c0>
 800f932:	bf00      	nop
 800f934:	f107 0720 	add.w	r7, r7, #32
 800f938:	46bd      	mov	sp, r7
 800f93a:	bd80      	pop	{r7, pc}

0800f93c <d_print_mod>:
 800f93c:	b580      	push	{r7, lr}
 800f93e:	b084      	sub	sp, #16
 800f940:	af00      	add	r7, sp, #0
 800f942:	60f8      	str	r0, [r7, #12]
 800f944:	60b9      	str	r1, [r7, #8]
 800f946:	607a      	str	r2, [r7, #4]
 800f948:	687b      	ldr	r3, [r7, #4]
 800f94a:	781b      	ldrb	r3, [r3, #0]
 800f94c:	f1a3 0303 	sub.w	r3, r3, #3
 800f950:	2b26      	cmp	r3, #38	; 0x26
 800f952:	f200 80d5 	bhi.w	800fb00 <d_print_mod+0x1c4>
 800f956:	a201      	add	r2, pc, #4	; (adr r2, 800f95c <d_print_mod+0x20>)
 800f958:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f95c:	0800fac9 	.word	0x0800fac9
 800f960:	0800fb01 	.word	0x0800fb01
 800f964:	0800fb01 	.word	0x0800fb01
 800f968:	0800fb01 	.word	0x0800fb01
 800f96c:	0800fb01 	.word	0x0800fb01
 800f970:	0800fb01 	.word	0x0800fb01
 800f974:	0800fb01 	.word	0x0800fb01
 800f978:	0800fb01 	.word	0x0800fb01
 800f97c:	0800fb01 	.word	0x0800fb01
 800f980:	0800fb01 	.word	0x0800fb01
 800f984:	0800fb01 	.word	0x0800fb01
 800f988:	0800fb01 	.word	0x0800fb01
 800f98c:	0800fb01 	.word	0x0800fb01
 800f990:	0800fb01 	.word	0x0800fb01
 800f994:	0800fb01 	.word	0x0800fb01
 800f998:	0800fb01 	.word	0x0800fb01
 800f99c:	0800fb01 	.word	0x0800fb01
 800f9a0:	0800fb01 	.word	0x0800fb01
 800f9a4:	0800fb01 	.word	0x0800fb01
 800f9a8:	0800fb01 	.word	0x0800fb01
 800f9ac:	0800f9f9 	.word	0x0800f9f9
 800f9b0:	0800fa09 	.word	0x0800fa09
 800f9b4:	0800fa19 	.word	0x0800fa19
 800f9b8:	0800f9f9 	.word	0x0800f9f9
 800f9bc:	0800fa09 	.word	0x0800fa09
 800f9c0:	0800fa19 	.word	0x0800fa19
 800f9c4:	0800fa29 	.word	0x0800fa29
 800f9c8:	0800fa43 	.word	0x0800fa43
 800f9cc:	0800fa59 	.word	0x0800fa59
 800f9d0:	0800fa65 	.word	0x0800fa65
 800f9d4:	0800fa75 	.word	0x0800fa75
 800f9d8:	0800fa85 	.word	0x0800fa85
 800f9dc:	0800fb01 	.word	0x0800fb01
 800f9e0:	0800fb01 	.word	0x0800fb01
 800f9e4:	0800fb01 	.word	0x0800fb01
 800f9e8:	0800fb01 	.word	0x0800fb01
 800f9ec:	0800fa95 	.word	0x0800fa95
 800f9f0:	0800fb01 	.word	0x0800fb01
 800f9f4:	0800fad9 	.word	0x0800fad9
 800f9f8:	68f8      	ldr	r0, [r7, #12]
 800f9fa:	f64f 7164 	movw	r1, #65380	; 0xff64
 800f9fe:	f6c0 0101 	movt	r1, #2049	; 0x801
 800fa02:	f7fd fd27 	bl	800d454 <d_append_string>
 800fa06:	e083      	b.n	800fb10 <d_print_mod+0x1d4>
 800fa08:	68f8      	ldr	r0, [r7, #12]
 800fa0a:	f64f 7170 	movw	r1, #65392	; 0xff70
 800fa0e:	f6c0 0101 	movt	r1, #2049	; 0x801
 800fa12:	f7fd fd1f 	bl	800d454 <d_append_string>
 800fa16:	e07b      	b.n	800fb10 <d_print_mod+0x1d4>
 800fa18:	68f8      	ldr	r0, [r7, #12]
 800fa1a:	f64f 717c 	movw	r1, #65404	; 0xff7c
 800fa1e:	f6c0 0101 	movt	r1, #2049	; 0x801
 800fa22:	f7fd fd17 	bl	800d454 <d_append_string>
 800fa26:	e073      	b.n	800fb10 <d_print_mod+0x1d4>
 800fa28:	68f8      	ldr	r0, [r7, #12]
 800fa2a:	f04f 0120 	mov.w	r1, #32
 800fa2e:	f7fd fcd1 	bl	800d3d4 <d_append_char>
 800fa32:	687b      	ldr	r3, [r7, #4]
 800fa34:	689b      	ldr	r3, [r3, #8]
 800fa36:	68f8      	ldr	r0, [r7, #12]
 800fa38:	68b9      	ldr	r1, [r7, #8]
 800fa3a:	461a      	mov	r2, r3
 800fa3c:	f7fd ff44 	bl	800d8c8 <d_print_comp>
 800fa40:	e066      	b.n	800fb10 <d_print_mod+0x1d4>
 800fa42:	68bb      	ldr	r3, [r7, #8]
 800fa44:	f003 0304 	and.w	r3, r3, #4
 800fa48:	2b00      	cmp	r3, #0
 800fa4a:	d160      	bne.n	800fb0e <d_print_mod+0x1d2>
 800fa4c:	68f8      	ldr	r0, [r7, #12]
 800fa4e:	f04f 012a 	mov.w	r1, #42	; 0x2a
 800fa52:	f7fd fcbf 	bl	800d3d4 <d_append_char>
 800fa56:	e05a      	b.n	800fb0e <d_print_mod+0x1d2>
 800fa58:	68f8      	ldr	r0, [r7, #12]
 800fa5a:	f04f 0126 	mov.w	r1, #38	; 0x26
 800fa5e:	f7fd fcb9 	bl	800d3d4 <d_append_char>
 800fa62:	e055      	b.n	800fb10 <d_print_mod+0x1d4>
 800fa64:	68f8      	ldr	r0, [r7, #12]
 800fa66:	f24f 5138 	movw	r1, #62776	; 0xf538
 800fa6a:	f6c0 0101 	movt	r1, #2049	; 0x801
 800fa6e:	f7fd fcf1 	bl	800d454 <d_append_string>
 800fa72:	e04d      	b.n	800fb10 <d_print_mod+0x1d4>
 800fa74:	68f8      	ldr	r0, [r7, #12]
 800fa76:	f64f 7184 	movw	r1, #65412	; 0xff84
 800fa7a:	f6c0 0101 	movt	r1, #2049	; 0x801
 800fa7e:	f7fd fce9 	bl	800d454 <d_append_string>
 800fa82:	e045      	b.n	800fb10 <d_print_mod+0x1d4>
 800fa84:	68f8      	ldr	r0, [r7, #12]
 800fa86:	f64f 7190 	movw	r1, #65424	; 0xff90
 800fa8a:	f6c0 0101 	movt	r1, #2049	; 0x801
 800fa8e:	f7fd fce1 	bl	800d454 <d_append_string>
 800fa92:	e03d      	b.n	800fb10 <d_print_mod+0x1d4>
 800fa94:	68f8      	ldr	r0, [r7, #12]
 800fa96:	f7fd fd09 	bl	800d4ac <d_last_char>
 800fa9a:	4603      	mov	r3, r0
 800fa9c:	2b28      	cmp	r3, #40	; 0x28
 800fa9e:	d004      	beq.n	800faaa <d_print_mod+0x16e>
 800faa0:	68f8      	ldr	r0, [r7, #12]
 800faa2:	f04f 0120 	mov.w	r1, #32
 800faa6:	f7fd fc95 	bl	800d3d4 <d_append_char>
 800faaa:	687b      	ldr	r3, [r7, #4]
 800faac:	685b      	ldr	r3, [r3, #4]
 800faae:	68f8      	ldr	r0, [r7, #12]
 800fab0:	68b9      	ldr	r1, [r7, #8]
 800fab2:	461a      	mov	r2, r3
 800fab4:	f7fd ff08 	bl	800d8c8 <d_print_comp>
 800fab8:	68f8      	ldr	r0, [r7, #12]
 800faba:	f64f 719c 	movw	r1, #65436	; 0xff9c
 800fabe:	f6c0 0101 	movt	r1, #2049	; 0x801
 800fac2:	f7fd fcc7 	bl	800d454 <d_append_string>
 800fac6:	e023      	b.n	800fb10 <d_print_mod+0x1d4>
 800fac8:	687b      	ldr	r3, [r7, #4]
 800faca:	685b      	ldr	r3, [r3, #4]
 800facc:	68f8      	ldr	r0, [r7, #12]
 800face:	68b9      	ldr	r1, [r7, #8]
 800fad0:	461a      	mov	r2, r3
 800fad2:	f7fd fef9 	bl	800d8c8 <d_print_comp>
 800fad6:	e01b      	b.n	800fb10 <d_print_mod+0x1d4>
 800fad8:	68f8      	ldr	r0, [r7, #12]
 800fada:	f64f 71a0 	movw	r1, #65440	; 0xffa0
 800fade:	f6c0 0101 	movt	r1, #2049	; 0x801
 800fae2:	f7fd fcb7 	bl	800d454 <d_append_string>
 800fae6:	687b      	ldr	r3, [r7, #4]
 800fae8:	685b      	ldr	r3, [r3, #4]
 800faea:	68f8      	ldr	r0, [r7, #12]
 800faec:	68b9      	ldr	r1, [r7, #8]
 800faee:	461a      	mov	r2, r3
 800faf0:	f7fd feea 	bl	800d8c8 <d_print_comp>
 800faf4:	68f8      	ldr	r0, [r7, #12]
 800faf6:	f04f 0129 	mov.w	r1, #41	; 0x29
 800fafa:	f7fd fc6b 	bl	800d3d4 <d_append_char>
 800fafe:	e007      	b.n	800fb10 <d_print_mod+0x1d4>
 800fb00:	68f8      	ldr	r0, [r7, #12]
 800fb02:	68b9      	ldr	r1, [r7, #8]
 800fb04:	687a      	ldr	r2, [r7, #4]
 800fb06:	f7fd fedf 	bl	800d8c8 <d_print_comp>
 800fb0a:	bf00      	nop
 800fb0c:	e000      	b.n	800fb10 <d_print_mod+0x1d4>
 800fb0e:	bf00      	nop
 800fb10:	f107 0710 	add.w	r7, r7, #16
 800fb14:	46bd      	mov	sp, r7
 800fb16:	bd80      	pop	{r7, pc}

0800fb18 <d_print_function_type>:
 800fb18:	b580      	push	{r7, lr}
 800fb1a:	b088      	sub	sp, #32
 800fb1c:	af00      	add	r7, sp, #0
 800fb1e:	60f8      	str	r0, [r7, #12]
 800fb20:	60b9      	str	r1, [r7, #8]
 800fb22:	607a      	str	r2, [r7, #4]
 800fb24:	603b      	str	r3, [r7, #0]
 800fb26:	f04f 0300 	mov.w	r3, #0
 800fb2a:	61fb      	str	r3, [r7, #28]
 800fb2c:	f04f 0300 	mov.w	r3, #0
 800fb30:	61bb      	str	r3, [r7, #24]
 800fb32:	683b      	ldr	r3, [r7, #0]
 800fb34:	617b      	str	r3, [r7, #20]
 800fb36:	e032      	b.n	800fb9e <d_print_function_type+0x86>
 800fb38:	697b      	ldr	r3, [r7, #20]
 800fb3a:	689b      	ldr	r3, [r3, #8]
 800fb3c:	2b00      	cmp	r3, #0
 800fb3e:	d132      	bne.n	800fba6 <d_print_function_type+0x8e>
 800fb40:	697b      	ldr	r3, [r7, #20]
 800fb42:	685b      	ldr	r3, [r3, #4]
 800fb44:	781b      	ldrb	r3, [r3, #0]
 800fb46:	f1a3 0317 	sub.w	r3, r3, #23
 800fb4a:	2b10      	cmp	r3, #16
 800fb4c:	d81e      	bhi.n	800fb8c <d_print_function_type+0x74>
 800fb4e:	f04f 0201 	mov.w	r2, #1
 800fb52:	fa02 f203 	lsl.w	r2, r2, r3
 800fb56:	f640 4347 	movw	r3, #3143	; 0xc47
 800fb5a:	f2c0 0301 	movt	r3, #1
 800fb5e:	4013      	ands	r3, r2
 800fb60:	2b00      	cmp	r3, #0
 800fb62:	d10c      	bne.n	800fb7e <d_print_function_type+0x66>
 800fb64:	f402 7360 	and.w	r3, r2, #896	; 0x380
 800fb68:	2b00      	cmp	r3, #0
 800fb6a:	d104      	bne.n	800fb76 <d_print_function_type+0x5e>
 800fb6c:	f002 0338 	and.w	r3, r2, #56	; 0x38
 800fb70:	2b00      	cmp	r3, #0
 800fb72:	d10d      	bne.n	800fb90 <d_print_function_type+0x78>
 800fb74:	e00a      	b.n	800fb8c <d_print_function_type+0x74>
 800fb76:	f04f 0301 	mov.w	r3, #1
 800fb7a:	61fb      	str	r3, [r7, #28]
 800fb7c:	e009      	b.n	800fb92 <d_print_function_type+0x7a>
 800fb7e:	f04f 0301 	mov.w	r3, #1
 800fb82:	61bb      	str	r3, [r7, #24]
 800fb84:	f04f 0301 	mov.w	r3, #1
 800fb88:	61fb      	str	r3, [r7, #28]
 800fb8a:	e002      	b.n	800fb92 <d_print_function_type+0x7a>
 800fb8c:	bf00      	nop
 800fb8e:	e000      	b.n	800fb92 <d_print_function_type+0x7a>
 800fb90:	bf00      	nop
 800fb92:	69fb      	ldr	r3, [r7, #28]
 800fb94:	2b00      	cmp	r3, #0
 800fb96:	d108      	bne.n	800fbaa <d_print_function_type+0x92>
 800fb98:	697b      	ldr	r3, [r7, #20]
 800fb9a:	681b      	ldr	r3, [r3, #0]
 800fb9c:	617b      	str	r3, [r7, #20]
 800fb9e:	697b      	ldr	r3, [r7, #20]
 800fba0:	2b00      	cmp	r3, #0
 800fba2:	d1c9      	bne.n	800fb38 <d_print_function_type+0x20>
 800fba4:	e002      	b.n	800fbac <d_print_function_type+0x94>
 800fba6:	bf00      	nop
 800fba8:	e000      	b.n	800fbac <d_print_function_type+0x94>
 800fbaa:	bf00      	nop
 800fbac:	69fb      	ldr	r3, [r7, #28]
 800fbae:	2b00      	cmp	r3, #0
 800fbb0:	d024      	beq.n	800fbfc <d_print_function_type+0xe4>
 800fbb2:	69bb      	ldr	r3, [r7, #24]
 800fbb4:	2b00      	cmp	r3, #0
 800fbb6:	d10e      	bne.n	800fbd6 <d_print_function_type+0xbe>
 800fbb8:	68f8      	ldr	r0, [r7, #12]
 800fbba:	f7fd fc77 	bl	800d4ac <d_last_char>
 800fbbe:	4603      	mov	r3, r0
 800fbc0:	2b28      	cmp	r3, #40	; 0x28
 800fbc2:	d008      	beq.n	800fbd6 <d_print_function_type+0xbe>
 800fbc4:	68f8      	ldr	r0, [r7, #12]
 800fbc6:	f7fd fc71 	bl	800d4ac <d_last_char>
 800fbca:	4603      	mov	r3, r0
 800fbcc:	2b2a      	cmp	r3, #42	; 0x2a
 800fbce:	d002      	beq.n	800fbd6 <d_print_function_type+0xbe>
 800fbd0:	f04f 0301 	mov.w	r3, #1
 800fbd4:	61bb      	str	r3, [r7, #24]
 800fbd6:	69bb      	ldr	r3, [r7, #24]
 800fbd8:	2b00      	cmp	r3, #0
 800fbda:	d00a      	beq.n	800fbf2 <d_print_function_type+0xda>
 800fbdc:	68f8      	ldr	r0, [r7, #12]
 800fbde:	f7fd fc65 	bl	800d4ac <d_last_char>
 800fbe2:	4603      	mov	r3, r0
 800fbe4:	2b20      	cmp	r3, #32
 800fbe6:	d004      	beq.n	800fbf2 <d_print_function_type+0xda>
 800fbe8:	68f8      	ldr	r0, [r7, #12]
 800fbea:	f04f 0120 	mov.w	r1, #32
 800fbee:	f7fd fbf1 	bl	800d3d4 <d_append_char>
 800fbf2:	68f8      	ldr	r0, [r7, #12]
 800fbf4:	f04f 0128 	mov.w	r1, #40	; 0x28
 800fbf8:	f7fd fbec 	bl	800d3d4 <d_append_char>
 800fbfc:	68fb      	ldr	r3, [r7, #12]
 800fbfe:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800fc02:	613b      	str	r3, [r7, #16]
 800fc04:	68fb      	ldr	r3, [r7, #12]
 800fc06:	f04f 0200 	mov.w	r2, #0
 800fc0a:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800fc0e:	68f8      	ldr	r0, [r7, #12]
 800fc10:	68b9      	ldr	r1, [r7, #8]
 800fc12:	683a      	ldr	r2, [r7, #0]
 800fc14:	f04f 0300 	mov.w	r3, #0
 800fc18:	f7ff fdac 	bl	800f774 <d_print_mod_list>
 800fc1c:	69fb      	ldr	r3, [r7, #28]
 800fc1e:	2b00      	cmp	r3, #0
 800fc20:	d004      	beq.n	800fc2c <d_print_function_type+0x114>
 800fc22:	68f8      	ldr	r0, [r7, #12]
 800fc24:	f04f 0129 	mov.w	r1, #41	; 0x29
 800fc28:	f7fd fbd4 	bl	800d3d4 <d_append_char>
 800fc2c:	68f8      	ldr	r0, [r7, #12]
 800fc2e:	f04f 0128 	mov.w	r1, #40	; 0x28
 800fc32:	f7fd fbcf 	bl	800d3d4 <d_append_char>
 800fc36:	687b      	ldr	r3, [r7, #4]
 800fc38:	689b      	ldr	r3, [r3, #8]
 800fc3a:	2b00      	cmp	r3, #0
 800fc3c:	d006      	beq.n	800fc4c <d_print_function_type+0x134>
 800fc3e:	687b      	ldr	r3, [r7, #4]
 800fc40:	689b      	ldr	r3, [r3, #8]
 800fc42:	68f8      	ldr	r0, [r7, #12]
 800fc44:	68b9      	ldr	r1, [r7, #8]
 800fc46:	461a      	mov	r2, r3
 800fc48:	f7fd fe3e 	bl	800d8c8 <d_print_comp>
 800fc4c:	68f8      	ldr	r0, [r7, #12]
 800fc4e:	f04f 0129 	mov.w	r1, #41	; 0x29
 800fc52:	f7fd fbbf 	bl	800d3d4 <d_append_char>
 800fc56:	68f8      	ldr	r0, [r7, #12]
 800fc58:	68b9      	ldr	r1, [r7, #8]
 800fc5a:	683a      	ldr	r2, [r7, #0]
 800fc5c:	f04f 0301 	mov.w	r3, #1
 800fc60:	f7ff fd88 	bl	800f774 <d_print_mod_list>
 800fc64:	68fb      	ldr	r3, [r7, #12]
 800fc66:	693a      	ldr	r2, [r7, #16]
 800fc68:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800fc6c:	f107 0720 	add.w	r7, r7, #32
 800fc70:	46bd      	mov	sp, r7
 800fc72:	bd80      	pop	{r7, pc}

0800fc74 <d_print_array_type>:
 800fc74:	b580      	push	{r7, lr}
 800fc76:	b088      	sub	sp, #32
 800fc78:	af00      	add	r7, sp, #0
 800fc7a:	60f8      	str	r0, [r7, #12]
 800fc7c:	60b9      	str	r1, [r7, #8]
 800fc7e:	607a      	str	r2, [r7, #4]
 800fc80:	603b      	str	r3, [r7, #0]
 800fc82:	f04f 0301 	mov.w	r3, #1
 800fc86:	61fb      	str	r3, [r7, #28]
 800fc88:	683b      	ldr	r3, [r7, #0]
 800fc8a:	2b00      	cmp	r3, #0
 800fc8c:	d038      	beq.n	800fd00 <d_print_array_type+0x8c>
 800fc8e:	f04f 0300 	mov.w	r3, #0
 800fc92:	61bb      	str	r3, [r7, #24]
 800fc94:	683b      	ldr	r3, [r7, #0]
 800fc96:	617b      	str	r3, [r7, #20]
 800fc98:	e016      	b.n	800fcc8 <d_print_array_type+0x54>
 800fc9a:	697b      	ldr	r3, [r7, #20]
 800fc9c:	689b      	ldr	r3, [r3, #8]
 800fc9e:	2b00      	cmp	r3, #0
 800fca0:	d10f      	bne.n	800fcc2 <d_print_array_type+0x4e>
 800fca2:	697b      	ldr	r3, [r7, #20]
 800fca4:	685b      	ldr	r3, [r3, #4]
 800fca6:	781b      	ldrb	r3, [r3, #0]
 800fca8:	2b26      	cmp	r3, #38	; 0x26
 800fcaa:	d103      	bne.n	800fcb4 <d_print_array_type+0x40>
 800fcac:	f04f 0300 	mov.w	r3, #0
 800fcb0:	61fb      	str	r3, [r7, #28]
 800fcb2:	e00c      	b.n	800fcce <d_print_array_type+0x5a>
 800fcb4:	f04f 0301 	mov.w	r3, #1
 800fcb8:	61bb      	str	r3, [r7, #24]
 800fcba:	f04f 0301 	mov.w	r3, #1
 800fcbe:	61fb      	str	r3, [r7, #28]
 800fcc0:	e005      	b.n	800fcce <d_print_array_type+0x5a>
 800fcc2:	697b      	ldr	r3, [r7, #20]
 800fcc4:	681b      	ldr	r3, [r3, #0]
 800fcc6:	617b      	str	r3, [r7, #20]
 800fcc8:	697b      	ldr	r3, [r7, #20]
 800fcca:	2b00      	cmp	r3, #0
 800fccc:	d1e5      	bne.n	800fc9a <d_print_array_type+0x26>
 800fcce:	69bb      	ldr	r3, [r7, #24]
 800fcd0:	2b00      	cmp	r3, #0
 800fcd2:	d006      	beq.n	800fce2 <d_print_array_type+0x6e>
 800fcd4:	68f8      	ldr	r0, [r7, #12]
 800fcd6:	f64f 71ac 	movw	r1, #65452	; 0xffac
 800fcda:	f6c0 0101 	movt	r1, #2049	; 0x801
 800fcde:	f7fd fbb9 	bl	800d454 <d_append_string>
 800fce2:	68f8      	ldr	r0, [r7, #12]
 800fce4:	68b9      	ldr	r1, [r7, #8]
 800fce6:	683a      	ldr	r2, [r7, #0]
 800fce8:	f04f 0300 	mov.w	r3, #0
 800fcec:	f7ff fd42 	bl	800f774 <d_print_mod_list>
 800fcf0:	69bb      	ldr	r3, [r7, #24]
 800fcf2:	2b00      	cmp	r3, #0
 800fcf4:	d004      	beq.n	800fd00 <d_print_array_type+0x8c>
 800fcf6:	68f8      	ldr	r0, [r7, #12]
 800fcf8:	f04f 0129 	mov.w	r1, #41	; 0x29
 800fcfc:	f7fd fb6a 	bl	800d3d4 <d_append_char>
 800fd00:	69fb      	ldr	r3, [r7, #28]
 800fd02:	2b00      	cmp	r3, #0
 800fd04:	d004      	beq.n	800fd10 <d_print_array_type+0x9c>
 800fd06:	68f8      	ldr	r0, [r7, #12]
 800fd08:	f04f 0120 	mov.w	r1, #32
 800fd0c:	f7fd fb62 	bl	800d3d4 <d_append_char>
 800fd10:	68f8      	ldr	r0, [r7, #12]
 800fd12:	f04f 015b 	mov.w	r1, #91	; 0x5b
 800fd16:	f7fd fb5d 	bl	800d3d4 <d_append_char>
 800fd1a:	687b      	ldr	r3, [r7, #4]
 800fd1c:	685b      	ldr	r3, [r3, #4]
 800fd1e:	2b00      	cmp	r3, #0
 800fd20:	d006      	beq.n	800fd30 <d_print_array_type+0xbc>
 800fd22:	687b      	ldr	r3, [r7, #4]
 800fd24:	685b      	ldr	r3, [r3, #4]
 800fd26:	68f8      	ldr	r0, [r7, #12]
 800fd28:	68b9      	ldr	r1, [r7, #8]
 800fd2a:	461a      	mov	r2, r3
 800fd2c:	f7fd fdcc 	bl	800d8c8 <d_print_comp>
 800fd30:	68f8      	ldr	r0, [r7, #12]
 800fd32:	f04f 015d 	mov.w	r1, #93	; 0x5d
 800fd36:	f7fd fb4d 	bl	800d3d4 <d_append_char>
 800fd3a:	f107 0720 	add.w	r7, r7, #32
 800fd3e:	46bd      	mov	sp, r7
 800fd40:	bd80      	pop	{r7, pc}
 800fd42:	bf00      	nop

0800fd44 <d_print_expr_op>:
 800fd44:	b580      	push	{r7, lr}
 800fd46:	b084      	sub	sp, #16
 800fd48:	af00      	add	r7, sp, #0
 800fd4a:	60f8      	str	r0, [r7, #12]
 800fd4c:	60b9      	str	r1, [r7, #8]
 800fd4e:	607a      	str	r2, [r7, #4]
 800fd50:	687b      	ldr	r3, [r7, #4]
 800fd52:	781b      	ldrb	r3, [r3, #0]
 800fd54:	2b2d      	cmp	r3, #45	; 0x2d
 800fd56:	d10b      	bne.n	800fd70 <d_print_expr_op+0x2c>
 800fd58:	687b      	ldr	r3, [r7, #4]
 800fd5a:	685b      	ldr	r3, [r3, #4]
 800fd5c:	685a      	ldr	r2, [r3, #4]
 800fd5e:	687b      	ldr	r3, [r7, #4]
 800fd60:	685b      	ldr	r3, [r3, #4]
 800fd62:	689b      	ldr	r3, [r3, #8]
 800fd64:	68f8      	ldr	r0, [r7, #12]
 800fd66:	4611      	mov	r1, r2
 800fd68:	461a      	mov	r2, r3
 800fd6a:	f7fd fb55 	bl	800d418 <d_append_buffer>
 800fd6e:	e004      	b.n	800fd7a <d_print_expr_op+0x36>
 800fd70:	68f8      	ldr	r0, [r7, #12]
 800fd72:	68b9      	ldr	r1, [r7, #8]
 800fd74:	687a      	ldr	r2, [r7, #4]
 800fd76:	f7fd fda7 	bl	800d8c8 <d_print_comp>
 800fd7a:	f107 0710 	add.w	r7, r7, #16
 800fd7e:	46bd      	mov	sp, r7
 800fd80:	bd80      	pop	{r7, pc}
 800fd82:	bf00      	nop

0800fd84 <d_print_cast>:
 800fd84:	b580      	push	{r7, lr}
 800fd86:	b088      	sub	sp, #32
 800fd88:	af00      	add	r7, sp, #0
 800fd8a:	60f8      	str	r0, [r7, #12]
 800fd8c:	60b9      	str	r1, [r7, #8]
 800fd8e:	607a      	str	r2, [r7, #4]
 800fd90:	687b      	ldr	r3, [r7, #4]
 800fd92:	685b      	ldr	r3, [r3, #4]
 800fd94:	781b      	ldrb	r3, [r3, #0]
 800fd96:	2b04      	cmp	r3, #4
 800fd98:	d007      	beq.n	800fdaa <d_print_cast+0x26>
 800fd9a:	687b      	ldr	r3, [r7, #4]
 800fd9c:	685b      	ldr	r3, [r3, #4]
 800fd9e:	68f8      	ldr	r0, [r7, #12]
 800fda0:	68b9      	ldr	r1, [r7, #8]
 800fda2:	461a      	mov	r2, r3
 800fda4:	f7fd fd90 	bl	800d8c8 <d_print_comp>
 800fda8:	e04c      	b.n	800fe44 <d_print_cast+0xc0>
 800fdaa:	68fb      	ldr	r3, [r7, #12]
 800fdac:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800fdb0:	61fb      	str	r3, [r7, #28]
 800fdb2:	68fb      	ldr	r3, [r7, #12]
 800fdb4:	f04f 0200 	mov.w	r2, #0
 800fdb8:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800fdbc:	68fb      	ldr	r3, [r7, #12]
 800fdbe:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 800fdc2:	617b      	str	r3, [r7, #20]
 800fdc4:	68fb      	ldr	r3, [r7, #12]
 800fdc6:	f107 0214 	add.w	r2, r7, #20
 800fdca:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
 800fdce:	687b      	ldr	r3, [r7, #4]
 800fdd0:	685b      	ldr	r3, [r3, #4]
 800fdd2:	61bb      	str	r3, [r7, #24]
 800fdd4:	687b      	ldr	r3, [r7, #4]
 800fdd6:	685b      	ldr	r3, [r3, #4]
 800fdd8:	685b      	ldr	r3, [r3, #4]
 800fdda:	68f8      	ldr	r0, [r7, #12]
 800fddc:	68b9      	ldr	r1, [r7, #8]
 800fdde:	461a      	mov	r2, r3
 800fde0:	f7fd fd72 	bl	800d8c8 <d_print_comp>
 800fde4:	697a      	ldr	r2, [r7, #20]
 800fde6:	68fb      	ldr	r3, [r7, #12]
 800fde8:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
 800fdec:	68f8      	ldr	r0, [r7, #12]
 800fdee:	f7fd fb5d 	bl	800d4ac <d_last_char>
 800fdf2:	4603      	mov	r3, r0
 800fdf4:	2b3c      	cmp	r3, #60	; 0x3c
 800fdf6:	d104      	bne.n	800fe02 <d_print_cast+0x7e>
 800fdf8:	68f8      	ldr	r0, [r7, #12]
 800fdfa:	f04f 0120 	mov.w	r1, #32
 800fdfe:	f7fd fae9 	bl	800d3d4 <d_append_char>
 800fe02:	68f8      	ldr	r0, [r7, #12]
 800fe04:	f04f 013c 	mov.w	r1, #60	; 0x3c
 800fe08:	f7fd fae4 	bl	800d3d4 <d_append_char>
 800fe0c:	687b      	ldr	r3, [r7, #4]
 800fe0e:	685b      	ldr	r3, [r3, #4]
 800fe10:	689b      	ldr	r3, [r3, #8]
 800fe12:	68f8      	ldr	r0, [r7, #12]
 800fe14:	68b9      	ldr	r1, [r7, #8]
 800fe16:	461a      	mov	r2, r3
 800fe18:	f7fd fd56 	bl	800d8c8 <d_print_comp>
 800fe1c:	68f8      	ldr	r0, [r7, #12]
 800fe1e:	f7fd fb45 	bl	800d4ac <d_last_char>
 800fe22:	4603      	mov	r3, r0
 800fe24:	2b3e      	cmp	r3, #62	; 0x3e
 800fe26:	d104      	bne.n	800fe32 <d_print_cast+0xae>
 800fe28:	68f8      	ldr	r0, [r7, #12]
 800fe2a:	f04f 0120 	mov.w	r1, #32
 800fe2e:	f7fd fad1 	bl	800d3d4 <d_append_char>
 800fe32:	68f8      	ldr	r0, [r7, #12]
 800fe34:	f04f 013e 	mov.w	r1, #62	; 0x3e
 800fe38:	f7fd facc 	bl	800d3d4 <d_append_char>
 800fe3c:	68fb      	ldr	r3, [r7, #12]
 800fe3e:	69fa      	ldr	r2, [r7, #28]
 800fe40:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
 800fe44:	f107 0720 	add.w	r7, r7, #32
 800fe48:	46bd      	mov	sp, r7
 800fe4a:	bd80      	pop	{r7, pc}

0800fe4c <d_init_info>:
 800fe4c:	b480      	push	{r7}
 800fe4e:	b085      	sub	sp, #20
 800fe50:	af00      	add	r7, sp, #0
 800fe52:	60f8      	str	r0, [r7, #12]
 800fe54:	60b9      	str	r1, [r7, #8]
 800fe56:	607a      	str	r2, [r7, #4]
 800fe58:	603b      	str	r3, [r7, #0]
 800fe5a:	683b      	ldr	r3, [r7, #0]
 800fe5c:	68fa      	ldr	r2, [r7, #12]
 800fe5e:	601a      	str	r2, [r3, #0]
 800fe60:	68fa      	ldr	r2, [r7, #12]
 800fe62:	687b      	ldr	r3, [r7, #4]
 800fe64:	18d2      	adds	r2, r2, r3
 800fe66:	683b      	ldr	r3, [r7, #0]
 800fe68:	605a      	str	r2, [r3, #4]
 800fe6a:	683b      	ldr	r3, [r7, #0]
 800fe6c:	68ba      	ldr	r2, [r7, #8]
 800fe6e:	609a      	str	r2, [r3, #8]
 800fe70:	683b      	ldr	r3, [r7, #0]
 800fe72:	68fa      	ldr	r2, [r7, #12]
 800fe74:	60da      	str	r2, [r3, #12]
 800fe76:	687b      	ldr	r3, [r7, #4]
 800fe78:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800fe7c:	461a      	mov	r2, r3
 800fe7e:	683b      	ldr	r3, [r7, #0]
 800fe80:	619a      	str	r2, [r3, #24]
 800fe82:	683b      	ldr	r3, [r7, #0]
 800fe84:	f04f 0200 	mov.w	r2, #0
 800fe88:	615a      	str	r2, [r3, #20]
 800fe8a:	687a      	ldr	r2, [r7, #4]
 800fe8c:	683b      	ldr	r3, [r7, #0]
 800fe8e:	625a      	str	r2, [r3, #36]	; 0x24
 800fe90:	683b      	ldr	r3, [r7, #0]
 800fe92:	f04f 0200 	mov.w	r2, #0
 800fe96:	621a      	str	r2, [r3, #32]
 800fe98:	683b      	ldr	r3, [r7, #0]
 800fe9a:	f04f 0200 	mov.w	r2, #0
 800fe9e:	629a      	str	r2, [r3, #40]	; 0x28
 800fea0:	683b      	ldr	r3, [r7, #0]
 800fea2:	f04f 0200 	mov.w	r2, #0
 800fea6:	62da      	str	r2, [r3, #44]	; 0x2c
 800fea8:	683b      	ldr	r3, [r7, #0]
 800feaa:	f04f 0200 	mov.w	r2, #0
 800feae:	631a      	str	r2, [r3, #48]	; 0x30
 800feb0:	f107 0714 	add.w	r7, r7, #20
 800feb4:	46bd      	mov	sp, r7
 800feb6:	bc80      	pop	{r7}
 800feb8:	4770      	bx	lr
 800feba:	bf00      	nop

0800febc <d_demangle_callback>:
 800febc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800fec0:	b099      	sub	sp, #100	; 0x64
 800fec2:	af00      	add	r7, sp, #0
 800fec4:	60f8      	str	r0, [r7, #12]
 800fec6:	60b9      	str	r1, [r7, #8]
 800fec8:	607a      	str	r2, [r7, #4]
 800feca:	603b      	str	r3, [r7, #0]
 800fecc:	68fb      	ldr	r3, [r7, #12]
 800fece:	781b      	ldrb	r3, [r3, #0]
 800fed0:	2b5f      	cmp	r3, #95	; 0x5f
 800fed2:	d10a      	bne.n	800feea <d_demangle_callback+0x2e>
 800fed4:	68fb      	ldr	r3, [r7, #12]
 800fed6:	f103 0301 	add.w	r3, r3, #1
 800feda:	781b      	ldrb	r3, [r3, #0]
 800fedc:	2b5a      	cmp	r3, #90	; 0x5a
 800fede:	d104      	bne.n	800feea <d_demangle_callback+0x2e>
 800fee0:	f04f 0301 	mov.w	r3, #1
 800fee4:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
 800fee8:	e049      	b.n	800ff7e <d_demangle_callback+0xc2>
 800feea:	68f8      	ldr	r0, [r7, #12]
 800feec:	f24f 5100 	movw	r1, #62720	; 0xf500
 800fef0:	f6c0 0101 	movt	r1, #2049	; 0x801
 800fef4:	f04f 0208 	mov.w	r2, #8
 800fef8:	f002 fe6e 	bl	8012bd8 <strncmp>
 800fefc:	4603      	mov	r3, r0
 800fefe:	2b00      	cmp	r3, #0
 800ff00:	d131      	bne.n	800ff66 <d_demangle_callback+0xaa>
 800ff02:	68fb      	ldr	r3, [r7, #12]
 800ff04:	f103 0308 	add.w	r3, r3, #8
 800ff08:	781b      	ldrb	r3, [r3, #0]
 800ff0a:	2b2e      	cmp	r3, #46	; 0x2e
 800ff0c:	d00b      	beq.n	800ff26 <d_demangle_callback+0x6a>
 800ff0e:	68fb      	ldr	r3, [r7, #12]
 800ff10:	f103 0308 	add.w	r3, r3, #8
 800ff14:	781b      	ldrb	r3, [r3, #0]
 800ff16:	2b5f      	cmp	r3, #95	; 0x5f
 800ff18:	d005      	beq.n	800ff26 <d_demangle_callback+0x6a>
 800ff1a:	68fb      	ldr	r3, [r7, #12]
 800ff1c:	f103 0308 	add.w	r3, r3, #8
 800ff20:	781b      	ldrb	r3, [r3, #0]
 800ff22:	2b24      	cmp	r3, #36	; 0x24
 800ff24:	d11f      	bne.n	800ff66 <d_demangle_callback+0xaa>
 800ff26:	68fb      	ldr	r3, [r7, #12]
 800ff28:	f103 0309 	add.w	r3, r3, #9
 800ff2c:	781b      	ldrb	r3, [r3, #0]
 800ff2e:	2b44      	cmp	r3, #68	; 0x44
 800ff30:	d005      	beq.n	800ff3e <d_demangle_callback+0x82>
 800ff32:	68fb      	ldr	r3, [r7, #12]
 800ff34:	f103 0309 	add.w	r3, r3, #9
 800ff38:	781b      	ldrb	r3, [r3, #0]
 800ff3a:	2b49      	cmp	r3, #73	; 0x49
 800ff3c:	d113      	bne.n	800ff66 <d_demangle_callback+0xaa>
 800ff3e:	68fb      	ldr	r3, [r7, #12]
 800ff40:	f103 030a 	add.w	r3, r3, #10
 800ff44:	781b      	ldrb	r3, [r3, #0]
 800ff46:	2b5f      	cmp	r3, #95	; 0x5f
 800ff48:	d10d      	bne.n	800ff66 <d_demangle_callback+0xaa>
 800ff4a:	68fb      	ldr	r3, [r7, #12]
 800ff4c:	f103 0309 	add.w	r3, r3, #9
 800ff50:	781b      	ldrb	r3, [r3, #0]
 800ff52:	2b49      	cmp	r3, #73	; 0x49
 800ff54:	d102      	bne.n	800ff5c <d_demangle_callback+0xa0>
 800ff56:	f04f 0302 	mov.w	r3, #2
 800ff5a:	e001      	b.n	800ff60 <d_demangle_callback+0xa4>
 800ff5c:	f04f 0303 	mov.w	r3, #3
 800ff60:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
 800ff64:	e00b      	b.n	800ff7e <d_demangle_callback+0xc2>
 800ff66:	68bb      	ldr	r3, [r7, #8]
 800ff68:	f003 0310 	and.w	r3, r3, #16
 800ff6c:	2b00      	cmp	r3, #0
 800ff6e:	d102      	bne.n	800ff76 <d_demangle_callback+0xba>
 800ff70:	f04f 0300 	mov.w	r3, #0
 800ff74:	e0f0      	b.n	8010158 <d_demangle_callback+0x29c>
 800ff76:	f04f 0300 	mov.w	r3, #0
 800ff7a:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
 800ff7e:	68f8      	ldr	r0, [r7, #12]
 800ff80:	f002 fdfa 	bl	8012b78 <strlen>
 800ff84:	4602      	mov	r2, r0
 800ff86:	f107 0310 	add.w	r3, r7, #16
 800ff8a:	68f8      	ldr	r0, [r7, #12]
 800ff8c:	68b9      	ldr	r1, [r7, #8]
 800ff8e:	f7ff ff5d 	bl	800fe4c <d_init_info>
 800ff92:	466b      	mov	r3, sp
 800ff94:	461e      	mov	r6, r3
 800ff96:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800ff98:	f101 33ff 	add.w	r3, r1, #4294967295
 800ff9c:	657b      	str	r3, [r7, #84]	; 0x54
 800ff9e:	4608      	mov	r0, r1
 800ffa0:	4602      	mov	r2, r0
 800ffa2:	f04f 0300 	mov.w	r3, #0
 800ffa6:	f04f 0060 	mov.w	r0, #96	; 0x60
 800ffaa:	fb00 fc03 	mul.w	ip, r0, r3
 800ffae:	f04f 0000 	mov.w	r0, #0
 800ffb2:	fb00 f002 	mul.w	r0, r0, r2
 800ffb6:	4460      	add	r0, ip
 800ffb8:	f04f 0c60 	mov.w	ip, #96	; 0x60
 800ffbc:	fba2 230c 	umull	r2, r3, r2, ip
 800ffc0:	18c0      	adds	r0, r0, r3
 800ffc2:	4603      	mov	r3, r0
 800ffc4:	460a      	mov	r2, r1
 800ffc6:	4613      	mov	r3, r2
 800ffc8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800ffcc:	189b      	adds	r3, r3, r2
 800ffce:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800ffd2:	4608      	mov	r0, r1
 800ffd4:	4602      	mov	r2, r0
 800ffd6:	f04f 0300 	mov.w	r3, #0
 800ffda:	f04f 0060 	mov.w	r0, #96	; 0x60
 800ffde:	fb00 fc03 	mul.w	ip, r0, r3
 800ffe2:	f04f 0000 	mov.w	r0, #0
 800ffe6:	fb00 f002 	mul.w	r0, r0, r2
 800ffea:	4460      	add	r0, ip
 800ffec:	f04f 0c60 	mov.w	ip, #96	; 0x60
 800fff0:	fba2 230c 	umull	r2, r3, r2, ip
 800fff4:	18c0      	adds	r0, r0, r3
 800fff6:	4603      	mov	r3, r0
 800fff8:	460a      	mov	r2, r1
 800fffa:	4613      	mov	r3, r2
 800fffc:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8010000:	189b      	adds	r3, r3, r2
 8010002:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010006:	f103 0303 	add.w	r3, r3, #3
 801000a:	f103 0307 	add.w	r3, r3, #7
 801000e:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8010012:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8010016:	ebad 0d03 	sub.w	sp, sp, r3
 801001a:	466b      	mov	r3, sp
 801001c:	f103 0303 	add.w	r3, r3, #3
 8010020:	ea4f 0393 	mov.w	r3, r3, lsr #2
 8010024:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010028:	653b      	str	r3, [r7, #80]	; 0x50
 801002a:	6b79      	ldr	r1, [r7, #52]	; 0x34
 801002c:	f101 33ff 	add.w	r3, r1, #4294967295
 8010030:	64fb      	str	r3, [r7, #76]	; 0x4c
 8010032:	4608      	mov	r0, r1
 8010034:	4602      	mov	r2, r0
 8010036:	f04f 0300 	mov.w	r3, #0
 801003a:	ea4f 60d2 	mov.w	r0, r2, lsr #27
 801003e:	ea4f 1943 	mov.w	r9, r3, lsl #5
 8010042:	ea40 0909 	orr.w	r9, r0, r9
 8010046:	ea4f 1842 	mov.w	r8, r2, lsl #5
 801004a:	4608      	mov	r0, r1
 801004c:	4602      	mov	r2, r0
 801004e:	f04f 0300 	mov.w	r3, #0
 8010052:	ea4f 60d2 	mov.w	r0, r2, lsr #27
 8010056:	ea4f 1543 	mov.w	r5, r3, lsl #5
 801005a:	4305      	orrs	r5, r0
 801005c:	ea4f 1442 	mov.w	r4, r2, lsl #5
 8010060:	460b      	mov	r3, r1
 8010062:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010066:	f103 0303 	add.w	r3, r3, #3
 801006a:	f103 0307 	add.w	r3, r3, #7
 801006e:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8010072:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8010076:	ebad 0d03 	sub.w	sp, sp, r3
 801007a:	466b      	mov	r3, sp
 801007c:	f103 0303 	add.w	r3, r3, #3
 8010080:	ea4f 0393 	mov.w	r3, r3, lsr #2
 8010084:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010088:	64bb      	str	r3, [r7, #72]	; 0x48
 801008a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801008c:	623b      	str	r3, [r7, #32]
 801008e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010090:	62fb      	str	r3, [r7, #44]	; 0x2c
 8010092:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 8010096:	2b03      	cmp	r3, #3
 8010098:	d842      	bhi.n	8010120 <d_demangle_callback+0x264>
 801009a:	a201      	add	r2, pc, #4	; (adr r2, 80100a0 <d_demangle_callback+0x1e4>)
 801009c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80100a0:	080100b1 	.word	0x080100b1
 80100a4:	080100bf 	.word	0x080100bf
 80100a8:	080100d1 	.word	0x080100d1
 80100ac:	080100d1 	.word	0x080100d1
 80100b0:	f107 0310 	add.w	r3, r7, #16
 80100b4:	4618      	mov	r0, r3
 80100b6:	f7fb f9b5 	bl	800b424 <d_type>
 80100ba:	65b8      	str	r0, [r7, #88]	; 0x58
 80100bc:	e030      	b.n	8010120 <d_demangle_callback+0x264>
 80100be:	f107 0310 	add.w	r3, r7, #16
 80100c2:	4618      	mov	r0, r3
 80100c4:	f04f 0101 	mov.w	r1, #1
 80100c8:	f7f9 ffac 	bl	800a024 <d_mangled_name>
 80100cc:	65b8      	str	r0, [r7, #88]	; 0x58
 80100ce:	e027      	b.n	8010120 <d_demangle_callback+0x264>
 80100d0:	69fb      	ldr	r3, [r7, #28]
 80100d2:	f103 030b 	add.w	r3, r3, #11
 80100d6:	61fb      	str	r3, [r7, #28]
 80100d8:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 80100dc:	2b02      	cmp	r3, #2
 80100de:	d102      	bne.n	80100e6 <d_demangle_callback+0x22a>
 80100e0:	f04f 043e 	mov.w	r4, #62	; 0x3e
 80100e4:	e001      	b.n	80100ea <d_demangle_callback+0x22e>
 80100e6:	f04f 043f 	mov.w	r4, #63	; 0x3f
 80100ea:	69fb      	ldr	r3, [r7, #28]
 80100ec:	f107 0210 	add.w	r2, r7, #16
 80100f0:	4610      	mov	r0, r2
 80100f2:	4619      	mov	r1, r3
 80100f4:	f7f9 fe4a 	bl	8009d8c <d_make_demangle_mangled_name>
 80100f8:	4603      	mov	r3, r0
 80100fa:	f107 0210 	add.w	r2, r7, #16
 80100fe:	4610      	mov	r0, r2
 8010100:	4621      	mov	r1, r4
 8010102:	461a      	mov	r2, r3
 8010104:	f04f 0300 	mov.w	r3, #0
 8010108:	f7f9 fd6c 	bl	8009be4 <d_make_comp>
 801010c:	65b8      	str	r0, [r7, #88]	; 0x58
 801010e:	69fc      	ldr	r4, [r7, #28]
 8010110:	69fb      	ldr	r3, [r7, #28]
 8010112:	4618      	mov	r0, r3
 8010114:	f002 fd30 	bl	8012b78 <strlen>
 8010118:	4603      	mov	r3, r0
 801011a:	18e3      	adds	r3, r4, r3
 801011c:	61fb      	str	r3, [r7, #28]
 801011e:	bf00      	nop
 8010120:	68bb      	ldr	r3, [r7, #8]
 8010122:	f003 0301 	and.w	r3, r3, #1
 8010126:	2b00      	cmp	r3, #0
 8010128:	d006      	beq.n	8010138 <d_demangle_callback+0x27c>
 801012a:	69fb      	ldr	r3, [r7, #28]
 801012c:	781b      	ldrb	r3, [r3, #0]
 801012e:	2b00      	cmp	r3, #0
 8010130:	d002      	beq.n	8010138 <d_demangle_callback+0x27c>
 8010132:	f04f 0300 	mov.w	r3, #0
 8010136:	65bb      	str	r3, [r7, #88]	; 0x58
 8010138:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801013a:	2b00      	cmp	r3, #0
 801013c:	d007      	beq.n	801014e <d_demangle_callback+0x292>
 801013e:	68b8      	ldr	r0, [r7, #8]
 8010140:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8010142:	687a      	ldr	r2, [r7, #4]
 8010144:	683b      	ldr	r3, [r7, #0]
 8010146:	f7fd f9bf 	bl	800d4c8 <d_print_callback>
 801014a:	4603      	mov	r3, r0
 801014c:	e001      	b.n	8010152 <d_demangle_callback+0x296>
 801014e:	f04f 0300 	mov.w	r3, #0
 8010152:	647b      	str	r3, [r7, #68]	; 0x44
 8010154:	46b5      	mov	sp, r6
 8010156:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010158:	4618      	mov	r0, r3
 801015a:	f107 0764 	add.w	r7, r7, #100	; 0x64
 801015e:	46bd      	mov	sp, r7
 8010160:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08010164 <d_demangle>:
 8010164:	b580      	push	{r7, lr}
 8010166:	b08a      	sub	sp, #40	; 0x28
 8010168:	af00      	add	r7, sp, #0
 801016a:	60f8      	str	r0, [r7, #12]
 801016c:	60b9      	str	r1, [r7, #8]
 801016e:	607a      	str	r2, [r7, #4]
 8010170:	f107 0314 	add.w	r3, r7, #20
 8010174:	4618      	mov	r0, r3
 8010176:	f04f 0100 	mov.w	r1, #0
 801017a:	f7fc fff9 	bl	800d170 <d_growable_string_init>
 801017e:	f107 0314 	add.w	r3, r7, #20
 8010182:	68f8      	ldr	r0, [r7, #12]
 8010184:	68b9      	ldr	r1, [r7, #8]
 8010186:	f24d 22b5 	movw	r2, #53941	; 0xd2b5
 801018a:	f6c0 0200 	movt	r2, #2048	; 0x800
 801018e:	f7ff fe95 	bl	800febc <d_demangle_callback>
 8010192:	6278      	str	r0, [r7, #36]	; 0x24
 8010194:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010196:	2b00      	cmp	r3, #0
 8010198:	d10a      	bne.n	80101b0 <d_demangle+0x4c>
 801019a:	697b      	ldr	r3, [r7, #20]
 801019c:	4618      	mov	r0, r3
 801019e:	f001 faf5 	bl	801178c <free>
 80101a2:	687b      	ldr	r3, [r7, #4]
 80101a4:	f04f 0200 	mov.w	r2, #0
 80101a8:	601a      	str	r2, [r3, #0]
 80101aa:	f04f 0300 	mov.w	r3, #0
 80101ae:	e009      	b.n	80101c4 <d_demangle+0x60>
 80101b0:	6a3b      	ldr	r3, [r7, #32]
 80101b2:	2b00      	cmp	r3, #0
 80101b4:	d101      	bne.n	80101ba <d_demangle+0x56>
 80101b6:	69fb      	ldr	r3, [r7, #28]
 80101b8:	e001      	b.n	80101be <d_demangle+0x5a>
 80101ba:	f04f 0301 	mov.w	r3, #1
 80101be:	687a      	ldr	r2, [r7, #4]
 80101c0:	6013      	str	r3, [r2, #0]
 80101c2:	697b      	ldr	r3, [r7, #20]
 80101c4:	4618      	mov	r0, r3
 80101c6:	f107 0728 	add.w	r7, r7, #40	; 0x28
 80101ca:	46bd      	mov	sp, r7
 80101cc:	bd80      	pop	{r7, pc}
 80101ce:	bf00      	nop

080101d0 <__cxa_demangle>:
 80101d0:	b580      	push	{r7, lr}
 80101d2:	b086      	sub	sp, #24
 80101d4:	af00      	add	r7, sp, #0
 80101d6:	60f8      	str	r0, [r7, #12]
 80101d8:	60b9      	str	r1, [r7, #8]
 80101da:	607a      	str	r2, [r7, #4]
 80101dc:	603b      	str	r3, [r7, #0]
 80101de:	68fb      	ldr	r3, [r7, #12]
 80101e0:	2b00      	cmp	r3, #0
 80101e2:	d109      	bne.n	80101f8 <__cxa_demangle+0x28>
 80101e4:	683b      	ldr	r3, [r7, #0]
 80101e6:	2b00      	cmp	r3, #0
 80101e8:	d003      	beq.n	80101f2 <__cxa_demangle+0x22>
 80101ea:	683b      	ldr	r3, [r7, #0]
 80101ec:	f06f 0202 	mvn.w	r2, #2
 80101f0:	601a      	str	r2, [r3, #0]
 80101f2:	f04f 0300 	mov.w	r3, #0
 80101f6:	e057      	b.n	80102a8 <__cxa_demangle+0xd8>
 80101f8:	68bb      	ldr	r3, [r7, #8]
 80101fa:	2b00      	cmp	r3, #0
 80101fc:	d00c      	beq.n	8010218 <__cxa_demangle+0x48>
 80101fe:	687b      	ldr	r3, [r7, #4]
 8010200:	2b00      	cmp	r3, #0
 8010202:	d109      	bne.n	8010218 <__cxa_demangle+0x48>
 8010204:	683b      	ldr	r3, [r7, #0]
 8010206:	2b00      	cmp	r3, #0
 8010208:	d003      	beq.n	8010212 <__cxa_demangle+0x42>
 801020a:	683b      	ldr	r3, [r7, #0]
 801020c:	f06f 0202 	mvn.w	r2, #2
 8010210:	601a      	str	r2, [r3, #0]
 8010212:	f04f 0300 	mov.w	r3, #0
 8010216:	e047      	b.n	80102a8 <__cxa_demangle+0xd8>
 8010218:	f107 0310 	add.w	r3, r7, #16
 801021c:	68f8      	ldr	r0, [r7, #12]
 801021e:	f04f 0111 	mov.w	r1, #17
 8010222:	461a      	mov	r2, r3
 8010224:	f7ff ff9e 	bl	8010164 <d_demangle>
 8010228:	6178      	str	r0, [r7, #20]
 801022a:	697b      	ldr	r3, [r7, #20]
 801022c:	2b00      	cmp	r3, #0
 801022e:	d111      	bne.n	8010254 <__cxa_demangle+0x84>
 8010230:	683b      	ldr	r3, [r7, #0]
 8010232:	2b00      	cmp	r3, #0
 8010234:	d00b      	beq.n	801024e <__cxa_demangle+0x7e>
 8010236:	693b      	ldr	r3, [r7, #16]
 8010238:	2b01      	cmp	r3, #1
 801023a:	d104      	bne.n	8010246 <__cxa_demangle+0x76>
 801023c:	683b      	ldr	r3, [r7, #0]
 801023e:	f04f 32ff 	mov.w	r2, #4294967295
 8010242:	601a      	str	r2, [r3, #0]
 8010244:	e003      	b.n	801024e <__cxa_demangle+0x7e>
 8010246:	683b      	ldr	r3, [r7, #0]
 8010248:	f06f 0201 	mvn.w	r2, #1
 801024c:	601a      	str	r2, [r3, #0]
 801024e:	f04f 0300 	mov.w	r3, #0
 8010252:	e029      	b.n	80102a8 <__cxa_demangle+0xd8>
 8010254:	68bb      	ldr	r3, [r7, #8]
 8010256:	2b00      	cmp	r3, #0
 8010258:	d106      	bne.n	8010268 <__cxa_demangle+0x98>
 801025a:	687b      	ldr	r3, [r7, #4]
 801025c:	2b00      	cmp	r3, #0
 801025e:	d01b      	beq.n	8010298 <__cxa_demangle+0xc8>
 8010260:	693a      	ldr	r2, [r7, #16]
 8010262:	687b      	ldr	r3, [r7, #4]
 8010264:	601a      	str	r2, [r3, #0]
 8010266:	e017      	b.n	8010298 <__cxa_demangle+0xc8>
 8010268:	6978      	ldr	r0, [r7, #20]
 801026a:	f002 fc85 	bl	8012b78 <strlen>
 801026e:	4602      	mov	r2, r0
 8010270:	687b      	ldr	r3, [r7, #4]
 8010272:	681b      	ldr	r3, [r3, #0]
 8010274:	429a      	cmp	r2, r3
 8010276:	d209      	bcs.n	801028c <__cxa_demangle+0xbc>
 8010278:	68b8      	ldr	r0, [r7, #8]
 801027a:	6979      	ldr	r1, [r7, #20]
 801027c:	f002 fc1e 	bl	8012abc <strcpy>
 8010280:	6978      	ldr	r0, [r7, #20]
 8010282:	f001 fa83 	bl	801178c <free>
 8010286:	68bb      	ldr	r3, [r7, #8]
 8010288:	617b      	str	r3, [r7, #20]
 801028a:	e005      	b.n	8010298 <__cxa_demangle+0xc8>
 801028c:	68b8      	ldr	r0, [r7, #8]
 801028e:	f001 fa7d 	bl	801178c <free>
 8010292:	693a      	ldr	r2, [r7, #16]
 8010294:	687b      	ldr	r3, [r7, #4]
 8010296:	601a      	str	r2, [r3, #0]
 8010298:	683b      	ldr	r3, [r7, #0]
 801029a:	2b00      	cmp	r3, #0
 801029c:	d003      	beq.n	80102a6 <__cxa_demangle+0xd6>
 801029e:	683b      	ldr	r3, [r7, #0]
 80102a0:	f04f 0200 	mov.w	r2, #0
 80102a4:	601a      	str	r2, [r3, #0]
 80102a6:	697b      	ldr	r3, [r7, #20]
 80102a8:	4618      	mov	r0, r3
 80102aa:	f107 0718 	add.w	r7, r7, #24
 80102ae:	46bd      	mov	sp, r7
 80102b0:	bd80      	pop	{r7, pc}
 80102b2:	bf00      	nop

080102b4 <__gcclibcxx_demangle_callback>:
 80102b4:	b580      	push	{r7, lr}
 80102b6:	b086      	sub	sp, #24
 80102b8:	af00      	add	r7, sp, #0
 80102ba:	60f8      	str	r0, [r7, #12]
 80102bc:	60b9      	str	r1, [r7, #8]
 80102be:	607a      	str	r2, [r7, #4]
 80102c0:	68fb      	ldr	r3, [r7, #12]
 80102c2:	2b00      	cmp	r3, #0
 80102c4:	d002      	beq.n	80102cc <__gcclibcxx_demangle_callback+0x18>
 80102c6:	68bb      	ldr	r3, [r7, #8]
 80102c8:	2b00      	cmp	r3, #0
 80102ca:	d102      	bne.n	80102d2 <__gcclibcxx_demangle_callback+0x1e>
 80102cc:	f06f 0302 	mvn.w	r3, #2
 80102d0:	e00f      	b.n	80102f2 <__gcclibcxx_demangle_callback+0x3e>
 80102d2:	68f8      	ldr	r0, [r7, #12]
 80102d4:	f04f 0111 	mov.w	r1, #17
 80102d8:	68ba      	ldr	r2, [r7, #8]
 80102da:	687b      	ldr	r3, [r7, #4]
 80102dc:	f7ff fdee 	bl	800febc <d_demangle_callback>
 80102e0:	6178      	str	r0, [r7, #20]
 80102e2:	697b      	ldr	r3, [r7, #20]
 80102e4:	2b00      	cmp	r3, #0
 80102e6:	d102      	bne.n	80102ee <__gcclibcxx_demangle_callback+0x3a>
 80102e8:	f06f 0301 	mvn.w	r3, #1
 80102ec:	e001      	b.n	80102f2 <__gcclibcxx_demangle_callback+0x3e>
 80102ee:	f04f 0300 	mov.w	r3, #0
 80102f2:	4618      	mov	r0, r3
 80102f4:	f107 0718 	add.w	r7, r7, #24
 80102f8:	46bd      	mov	sp, r7
 80102fa:	bd80      	pop	{r7, pc}

080102fc <selfrel_offset31>:
 80102fc:	6803      	ldr	r3, [r0, #0]
 80102fe:	005a      	lsls	r2, r3, #1
 8010300:	bf4c      	ite	mi
 8010302:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
 8010306:	f023 4300 	bicpl.w	r3, r3, #2147483648	; 0x80000000
 801030a:	18c0      	adds	r0, r0, r3
 801030c:	4770      	bx	lr
 801030e:	bf00      	nop

08010310 <search_EIT_table>:
 8010310:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010314:	4606      	mov	r6, r0
 8010316:	b083      	sub	sp, #12
 8010318:	4691      	mov	r9, r2
 801031a:	2900      	cmp	r1, #0
 801031c:	d027      	beq.n	801036e <search_EIT_table+0x5e>
 801031e:	3901      	subs	r1, #1
 8010320:	2700      	movs	r7, #0
 8010322:	4688      	mov	r8, r1
 8010324:	9101      	str	r1, [sp, #4]
 8010326:	eb07 0408 	add.w	r4, r7, r8
 801032a:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
 801032e:	1064      	asrs	r4, r4, #1
 8010330:	1c65      	adds	r5, r4, #1
 8010332:	eb06 0bc4 	add.w	fp, r6, r4, lsl #3
 8010336:	4658      	mov	r0, fp
 8010338:	f7ff ffe0 	bl	80102fc <selfrel_offset31>
 801033c:	9b01      	ldr	r3, [sp, #4]
 801033e:	42a3      	cmp	r3, r4
 8010340:	4682      	mov	sl, r0
 8010342:	eb06 00c5 	add.w	r0, r6, r5, lsl #3
 8010346:	d014      	beq.n	8010372 <search_EIT_table+0x62>
 8010348:	f7ff ffd8 	bl	80102fc <selfrel_offset31>
 801034c:	3801      	subs	r0, #1
 801034e:	45ca      	cmp	sl, r9
 8010350:	d909      	bls.n	8010366 <search_EIT_table+0x56>
 8010352:	42bc      	cmp	r4, r7
 8010354:	f104 38ff 	add.w	r8, r4, #4294967295
 8010358:	d1e5      	bne.n	8010326 <search_EIT_table+0x16>
 801035a:	f04f 0b00 	mov.w	fp, #0
 801035e:	4658      	mov	r0, fp
 8010360:	b003      	add	sp, #12
 8010362:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010366:	4548      	cmp	r0, r9
 8010368:	462f      	mov	r7, r5
 801036a:	d3dc      	bcc.n	8010326 <search_EIT_table+0x16>
 801036c:	e7f7      	b.n	801035e <search_EIT_table+0x4e>
 801036e:	468b      	mov	fp, r1
 8010370:	e7f5      	b.n	801035e <search_EIT_table+0x4e>
 8010372:	45ca      	cmp	sl, r9
 8010374:	d8ed      	bhi.n	8010352 <search_EIT_table+0x42>
 8010376:	e7f2      	b.n	801035e <search_EIT_table+0x4e>

08010378 <__gnu_unwind_get_pr_addr>:
 8010378:	2801      	cmp	r0, #1
 801037a:	d007      	beq.n	801038c <__gnu_unwind_get_pr_addr+0x14>
 801037c:	2802      	cmp	r0, #2
 801037e:	d007      	beq.n	8010390 <__gnu_unwind_get_pr_addr+0x18>
 8010380:	4b04      	ldr	r3, [pc, #16]	; (8010394 <__gnu_unwind_get_pr_addr+0x1c>)
 8010382:	2800      	cmp	r0, #0
 8010384:	bf0c      	ite	eq
 8010386:	4618      	moveq	r0, r3
 8010388:	2000      	movne	r0, #0
 801038a:	4770      	bx	lr
 801038c:	4802      	ldr	r0, [pc, #8]	; (8010398 <__gnu_unwind_get_pr_addr+0x20>)
 801038e:	4770      	bx	lr
 8010390:	4802      	ldr	r0, [pc, #8]	; (801039c <__gnu_unwind_get_pr_addr+0x24>)
 8010392:	4770      	bx	lr
 8010394:	08010a3d 	.word	0x08010a3d
 8010398:	08010a35 	.word	0x08010a35
 801039c:	08010a2d 	.word	0x08010a2d

080103a0 <restore_non_core_regs>:
 80103a0:	6803      	ldr	r3, [r0, #0]
 80103a2:	b510      	push	{r4, lr}
 80103a4:	4604      	mov	r4, r0
 80103a6:	07d8      	lsls	r0, r3, #31
 80103a8:	d406      	bmi.n	80103b8 <restore_non_core_regs+0x18>
 80103aa:	0799      	lsls	r1, r3, #30
 80103ac:	f104 0048 	add.w	r0, r4, #72	; 0x48
 80103b0:	d509      	bpl.n	80103c6 <restore_non_core_regs+0x26>
 80103b2:	f000 fcc7 	bl	8010d44 <__gnu_Unwind_Restore_VFP_D>
 80103b6:	6823      	ldr	r3, [r4, #0]
 80103b8:	075a      	lsls	r2, r3, #29
 80103ba:	d509      	bpl.n	80103d0 <restore_non_core_regs+0x30>
 80103bc:	0718      	lsls	r0, r3, #28
 80103be:	d50e      	bpl.n	80103de <restore_non_core_regs+0x3e>
 80103c0:	06d9      	lsls	r1, r3, #27
 80103c2:	d513      	bpl.n	80103ec <restore_non_core_regs+0x4c>
 80103c4:	bd10      	pop	{r4, pc}
 80103c6:	f000 fcb5 	bl	8010d34 <__gnu_Unwind_Restore_VFP>
 80103ca:	6823      	ldr	r3, [r4, #0]
 80103cc:	075a      	lsls	r2, r3, #29
 80103ce:	d4f5      	bmi.n	80103bc <restore_non_core_regs+0x1c>
 80103d0:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 80103d4:	f000 fcbe 	bl	8010d54 <__gnu_Unwind_Restore_VFP_D_16_to_31>
 80103d8:	6823      	ldr	r3, [r4, #0]
 80103da:	0718      	lsls	r0, r3, #28
 80103dc:	d4f0      	bmi.n	80103c0 <restore_non_core_regs+0x20>
 80103de:	f504 70d8 	add.w	r0, r4, #432	; 0x1b0
 80103e2:	f000 fcbf 	bl	8010d64 <__gnu_Unwind_Restore_WMMXD>
 80103e6:	6823      	ldr	r3, [r4, #0]
 80103e8:	06d9      	lsls	r1, r3, #27
 80103ea:	d4eb      	bmi.n	80103c4 <restore_non_core_regs+0x24>
 80103ec:	f504 700c 	add.w	r0, r4, #560	; 0x230
 80103f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80103f4:	f000 bcfa 	b.w	8010dec <__gnu_Unwind_Restore_WMMXC>

080103f8 <get_eit_entry>:
 80103f8:	4b25      	ldr	r3, [pc, #148]	; (8010490 <get_eit_entry+0x98>)
 80103fa:	b530      	push	{r4, r5, lr}
 80103fc:	4604      	mov	r4, r0
 80103fe:	b083      	sub	sp, #12
 8010400:	1e8d      	subs	r5, r1, #2
 8010402:	2b00      	cmp	r3, #0
 8010404:	d03c      	beq.n	8010480 <get_eit_entry+0x88>
 8010406:	4628      	mov	r0, r5
 8010408:	a901      	add	r1, sp, #4
 801040a:	f3af 8000 	nop.w
 801040e:	4603      	mov	r3, r0
 8010410:	2b00      	cmp	r3, #0
 8010412:	d021      	beq.n	8010458 <get_eit_entry+0x60>
 8010414:	462a      	mov	r2, r5
 8010416:	9901      	ldr	r1, [sp, #4]
 8010418:	f7ff ff7a 	bl	8010310 <search_EIT_table>
 801041c:	4605      	mov	r5, r0
 801041e:	b1f0      	cbz	r0, 801045e <get_eit_entry+0x66>
 8010420:	f7ff ff6c 	bl	80102fc <selfrel_offset31>
 8010424:	686b      	ldr	r3, [r5, #4]
 8010426:	2b01      	cmp	r3, #1
 8010428:	64a0      	str	r0, [r4, #72]	; 0x48
 801042a:	d011      	beq.n	8010450 <get_eit_entry+0x58>
 801042c:	1d28      	adds	r0, r5, #4
 801042e:	2b00      	cmp	r3, #0
 8010430:	db22      	blt.n	8010478 <get_eit_entry+0x80>
 8010432:	f7ff ff63 	bl	80102fc <selfrel_offset31>
 8010436:	2300      	movs	r3, #0
 8010438:	6523      	str	r3, [r4, #80]	; 0x50
 801043a:	64e0      	str	r0, [r4, #76]	; 0x4c
 801043c:	6803      	ldr	r3, [r0, #0]
 801043e:	2b00      	cmp	r3, #0
 8010440:	db10      	blt.n	8010464 <get_eit_entry+0x6c>
 8010442:	f7ff ff5b 	bl	80102fc <selfrel_offset31>
 8010446:	2300      	movs	r3, #0
 8010448:	6120      	str	r0, [r4, #16]
 801044a:	4618      	mov	r0, r3
 801044c:	b003      	add	sp, #12
 801044e:	bd30      	pop	{r4, r5, pc}
 8010450:	2200      	movs	r2, #0
 8010452:	2305      	movs	r3, #5
 8010454:	6122      	str	r2, [r4, #16]
 8010456:	e7f8      	b.n	801044a <get_eit_entry+0x52>
 8010458:	6123      	str	r3, [r4, #16]
 801045a:	2309      	movs	r3, #9
 801045c:	e7f5      	b.n	801044a <get_eit_entry+0x52>
 801045e:	6120      	str	r0, [r4, #16]
 8010460:	2309      	movs	r3, #9
 8010462:	e7f2      	b.n	801044a <get_eit_entry+0x52>
 8010464:	f3c3 6003 	ubfx	r0, r3, #24, #4
 8010468:	f7ff ff86 	bl	8010378 <__gnu_unwind_get_pr_addr>
 801046c:	2800      	cmp	r0, #0
 801046e:	bf0c      	ite	eq
 8010470:	2309      	moveq	r3, #9
 8010472:	2300      	movne	r3, #0
 8010474:	6120      	str	r0, [r4, #16]
 8010476:	e7e8      	b.n	801044a <get_eit_entry+0x52>
 8010478:	2301      	movs	r3, #1
 801047a:	64e0      	str	r0, [r4, #76]	; 0x4c
 801047c:	6523      	str	r3, [r4, #80]	; 0x50
 801047e:	e7dd      	b.n	801043c <get_eit_entry+0x44>
 8010480:	4b04      	ldr	r3, [pc, #16]	; (8010494 <get_eit_entry+0x9c>)
 8010482:	4a05      	ldr	r2, [pc, #20]	; (8010498 <get_eit_entry+0xa0>)
 8010484:	4618      	mov	r0, r3
 8010486:	1ad3      	subs	r3, r2, r3
 8010488:	10db      	asrs	r3, r3, #3
 801048a:	9301      	str	r3, [sp, #4]
 801048c:	e7c2      	b.n	8010414 <get_eit_entry+0x1c>
 801048e:	bf00      	nop
 8010490:	00000000 	.word	0x00000000
 8010494:	08021570 	.word	0x08021570
 8010498:	08021c70 	.word	0x08021c70

0801049c <_Unwind_decode_typeinfo_ptr.isra.0>:
 801049c:	6803      	ldr	r3, [r0, #0]
 801049e:	b103      	cbz	r3, 80104a2 <_Unwind_decode_typeinfo_ptr.isra.0+0x6>
 80104a0:	181b      	adds	r3, r3, r0
 80104a2:	4618      	mov	r0, r3
 80104a4:	4770      	bx	lr
 80104a6:	bf00      	nop

080104a8 <__gnu_unwind_24bit.isra.1>:
 80104a8:	2009      	movs	r0, #9
 80104aa:	4770      	bx	lr

080104ac <_Unwind_DebugHook>:
 80104ac:	4770      	bx	lr
 80104ae:	bf00      	nop

080104b0 <unwind_phase2_forced>:
 80104b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80104b4:	1d0e      	adds	r6, r1, #4
 80104b6:	4607      	mov	r7, r0
 80104b8:	4690      	mov	r8, r2
 80104ba:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80104bc:	f5ad 6d91 	sub.w	sp, sp, #1160	; 0x488
 80104c0:	ad03      	add	r5, sp, #12
 80104c2:	ac02      	add	r4, sp, #8
 80104c4:	f8d7 900c 	ldr.w	r9, [r7, #12]
 80104c8:	f1b8 0f00 	cmp.w	r8, #0
 80104cc:	bf14      	ite	ne
 80104ce:	f04f 080a 	movne.w	r8, #10
 80104d2:	f04f 0809 	moveq.w	r8, #9
 80104d6:	f8d7 a018 	ldr.w	sl, [r7, #24]
 80104da:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80104dc:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80104de:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80104e0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80104e2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80104e4:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 80104e8:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
 80104ec:	4638      	mov	r0, r7
 80104ee:	6c21      	ldr	r1, [r4, #64]	; 0x40
 80104f0:	2300      	movs	r3, #0
 80104f2:	6023      	str	r3, [r4, #0]
 80104f4:	f7ff ff80 	bl	80103f8 <get_eit_entry>
 80104f8:	4605      	mov	r5, r0
 80104fa:	b19d      	cbz	r5, 8010524 <unwind_phase2_forced+0x74>
 80104fc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80104fe:	463a      	mov	r2, r7
 8010500:	9400      	str	r4, [sp, #0]
 8010502:	2001      	movs	r0, #1
 8010504:	f8cd a004 	str.w	sl, [sp, #4]
 8010508:	f048 0110 	orr.w	r1, r8, #16
 801050c:	6463      	str	r3, [r4, #68]	; 0x44
 801050e:	463b      	mov	r3, r7
 8010510:	47c8      	blx	r9
 8010512:	2800      	cmp	r0, #0
 8010514:	bf18      	it	ne
 8010516:	2509      	movne	r5, #9
 8010518:	4628      	mov	r0, r5
 801051a:	b022      	add	sp, #136	; 0x88
 801051c:	f50d 6d80 	add.w	sp, sp, #1024	; 0x400
 8010520:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8010524:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8010526:	4621      	mov	r1, r4
 8010528:	f44f 7210 	mov.w	r2, #576	; 0x240
 801052c:	a892      	add	r0, sp, #584	; 0x248
 801052e:	617b      	str	r3, [r7, #20]
 8010530:	f001 fc68 	bl	8011e04 <memcpy>
 8010534:	4639      	mov	r1, r7
 8010536:	aa92      	add	r2, sp, #584	; 0x248
 8010538:	693b      	ldr	r3, [r7, #16]
 801053a:	4640      	mov	r0, r8
 801053c:	4798      	blx	r3
 801053e:	9ba0      	ldr	r3, [sp, #640]	; 0x280
 8010540:	9400      	str	r4, [sp, #0]
 8010542:	4641      	mov	r1, r8
 8010544:	f8cd a004 	str.w	sl, [sp, #4]
 8010548:	463a      	mov	r2, r7
 801054a:	6463      	str	r3, [r4, #68]	; 0x44
 801054c:	463b      	mov	r3, r7
 801054e:	4606      	mov	r6, r0
 8010550:	2001      	movs	r0, #1
 8010552:	47c8      	blx	r9
 8010554:	b988      	cbnz	r0, 801057a <unwind_phase2_forced+0xca>
 8010556:	4620      	mov	r0, r4
 8010558:	a992      	add	r1, sp, #584	; 0x248
 801055a:	f44f 7210 	mov.w	r2, #576	; 0x240
 801055e:	f001 fc51 	bl	8011e04 <memcpy>
 8010562:	2e08      	cmp	r6, #8
 8010564:	d107      	bne.n	8010576 <unwind_phase2_forced+0xc6>
 8010566:	4638      	mov	r0, r7
 8010568:	6c21      	ldr	r1, [r4, #64]	; 0x40
 801056a:	f7ff ff45 	bl	80103f8 <get_eit_entry>
 801056e:	f04f 0809 	mov.w	r8, #9
 8010572:	4605      	mov	r5, r0
 8010574:	e7c1      	b.n	80104fa <unwind_phase2_forced+0x4a>
 8010576:	2e07      	cmp	r6, #7
 8010578:	d001      	beq.n	801057e <unwind_phase2_forced+0xce>
 801057a:	2509      	movs	r5, #9
 801057c:	e7cc      	b.n	8010518 <unwind_phase2_forced+0x68>
 801057e:	4628      	mov	r0, r5
 8010580:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8010582:	f7ff ff93 	bl	80104ac <_Unwind_DebugHook>
 8010586:	a803      	add	r0, sp, #12
 8010588:	f000 fbc8 	bl	8010d1c <__restore_core_regs>

0801058c <unwind_phase2>:
 801058c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801058e:	4604      	mov	r4, r0
 8010590:	460d      	mov	r5, r1
 8010592:	4620      	mov	r0, r4
 8010594:	6c29      	ldr	r1, [r5, #64]	; 0x40
 8010596:	f7ff ff2f 	bl	80103f8 <get_eit_entry>
 801059a:	4606      	mov	r6, r0
 801059c:	b950      	cbnz	r0, 80105b4 <unwind_phase2+0x28>
 801059e:	6c2f      	ldr	r7, [r5, #64]	; 0x40
 80105a0:	2001      	movs	r0, #1
 80105a2:	6923      	ldr	r3, [r4, #16]
 80105a4:	4621      	mov	r1, r4
 80105a6:	462a      	mov	r2, r5
 80105a8:	6167      	str	r7, [r4, #20]
 80105aa:	4798      	blx	r3
 80105ac:	2808      	cmp	r0, #8
 80105ae:	d0f0      	beq.n	8010592 <unwind_phase2+0x6>
 80105b0:	2807      	cmp	r0, #7
 80105b2:	d001      	beq.n	80105b8 <unwind_phase2+0x2c>
 80105b4:	f000 fe5c 	bl	8011270 <abort>
 80105b8:	4630      	mov	r0, r6
 80105ba:	6c29      	ldr	r1, [r5, #64]	; 0x40
 80105bc:	f7ff ff76 	bl	80104ac <_Unwind_DebugHook>
 80105c0:	1d28      	adds	r0, r5, #4
 80105c2:	f000 fbab 	bl	8010d1c <__restore_core_regs>
 80105c6:	bf00      	nop

080105c8 <_Unwind_GetCFA>:
 80105c8:	6c40      	ldr	r0, [r0, #68]	; 0x44
 80105ca:	4770      	bx	lr

080105cc <__gnu_Unwind_RaiseException>:
 80105cc:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 80105ce:	b5f0      	push	{r4, r5, r6, r7, lr}
 80105d0:	1d0d      	adds	r5, r1, #4
 80105d2:	640b      	str	r3, [r1, #64]	; 0x40
 80105d4:	460f      	mov	r7, r1
 80105d6:	4606      	mov	r6, r0
 80105d8:	f5ad 7d11 	sub.w	sp, sp, #580	; 0x244
 80105dc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80105de:	ac01      	add	r4, sp, #4
 80105e0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80105e2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80105e4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80105e6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80105e8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80105ea:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 80105ee:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 80105f2:	f04f 33ff 	mov.w	r3, #4294967295
 80105f6:	9300      	str	r3, [sp, #0]
 80105f8:	4630      	mov	r0, r6
 80105fa:	9910      	ldr	r1, [sp, #64]	; 0x40
 80105fc:	f7ff fefc 	bl	80103f8 <get_eit_entry>
 8010600:	b958      	cbnz	r0, 801061a <__gnu_Unwind_RaiseException+0x4e>
 8010602:	6933      	ldr	r3, [r6, #16]
 8010604:	4631      	mov	r1, r6
 8010606:	466a      	mov	r2, sp
 8010608:	4798      	blx	r3
 801060a:	2808      	cmp	r0, #8
 801060c:	4604      	mov	r4, r0
 801060e:	d0f3      	beq.n	80105f8 <__gnu_Unwind_RaiseException+0x2c>
 8010610:	4668      	mov	r0, sp
 8010612:	f7ff fec5 	bl	80103a0 <restore_non_core_regs>
 8010616:	2c06      	cmp	r4, #6
 8010618:	d003      	beq.n	8010622 <__gnu_Unwind_RaiseException+0x56>
 801061a:	2009      	movs	r0, #9
 801061c:	f50d 7d11 	add.w	sp, sp, #580	; 0x244
 8010620:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8010622:	4630      	mov	r0, r6
 8010624:	4639      	mov	r1, r7
 8010626:	f7ff ffb1 	bl	801058c <unwind_phase2>
 801062a:	bf00      	nop

0801062c <__gnu_Unwind_ForcedUnwind>:
 801062c:	b430      	push	{r4, r5}
 801062e:	4604      	mov	r4, r0
 8010630:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 8010632:	60c1      	str	r1, [r0, #12]
 8010634:	4619      	mov	r1, r3
 8010636:	6182      	str	r2, [r0, #24]
 8010638:	2200      	movs	r2, #0
 801063a:	641d      	str	r5, [r3, #64]	; 0x40
 801063c:	bc30      	pop	{r4, r5}
 801063e:	f7ff bf37 	b.w	80104b0 <unwind_phase2_forced>
 8010642:	bf00      	nop

08010644 <__gnu_Unwind_Resume>:
 8010644:	6943      	ldr	r3, [r0, #20]
 8010646:	b570      	push	{r4, r5, r6, lr}
 8010648:	4604      	mov	r4, r0
 801064a:	68c6      	ldr	r6, [r0, #12]
 801064c:	460d      	mov	r5, r1
 801064e:	640b      	str	r3, [r1, #64]	; 0x40
 8010650:	b126      	cbz	r6, 801065c <__gnu_Unwind_Resume+0x18>
 8010652:	2201      	movs	r2, #1
 8010654:	f7ff ff2c 	bl	80104b0 <unwind_phase2_forced>
 8010658:	f000 fe0a 	bl	8011270 <abort>
 801065c:	6903      	ldr	r3, [r0, #16]
 801065e:	4621      	mov	r1, r4
 8010660:	2002      	movs	r0, #2
 8010662:	462a      	mov	r2, r5
 8010664:	4798      	blx	r3
 8010666:	2807      	cmp	r0, #7
 8010668:	d003      	beq.n	8010672 <__gnu_Unwind_Resume+0x2e>
 801066a:	2808      	cmp	r0, #8
 801066c:	d008      	beq.n	8010680 <__gnu_Unwind_Resume+0x3c>
 801066e:	f000 fdff 	bl	8011270 <abort>
 8010672:	4630      	mov	r0, r6
 8010674:	6c29      	ldr	r1, [r5, #64]	; 0x40
 8010676:	f7ff ff19 	bl	80104ac <_Unwind_DebugHook>
 801067a:	1d28      	adds	r0, r5, #4
 801067c:	f000 fb4e 	bl	8010d1c <__restore_core_regs>
 8010680:	4620      	mov	r0, r4
 8010682:	4629      	mov	r1, r5
 8010684:	f7ff ff82 	bl	801058c <unwind_phase2>

08010688 <__gnu_Unwind_Resume_or_Rethrow>:
 8010688:	68c2      	ldr	r2, [r0, #12]
 801068a:	b410      	push	{r4}
 801068c:	b12a      	cbz	r2, 801069a <__gnu_Unwind_Resume_or_Rethrow+0x12>
 801068e:	6bcc      	ldr	r4, [r1, #60]	; 0x3c
 8010690:	2200      	movs	r2, #0
 8010692:	640c      	str	r4, [r1, #64]	; 0x40
 8010694:	bc10      	pop	{r4}
 8010696:	f7ff bf0b 	b.w	80104b0 <unwind_phase2_forced>
 801069a:	bc10      	pop	{r4}
 801069c:	f7ff bf96 	b.w	80105cc <__gnu_Unwind_RaiseException>

080106a0 <_Unwind_Complete>:
 80106a0:	4770      	bx	lr
 80106a2:	bf00      	nop

080106a4 <_Unwind_DeleteException>:
 80106a4:	b508      	push	{r3, lr}
 80106a6:	4601      	mov	r1, r0
 80106a8:	6883      	ldr	r3, [r0, #8]
 80106aa:	b10b      	cbz	r3, 80106b0 <_Unwind_DeleteException+0xc>
 80106ac:	2001      	movs	r0, #1
 80106ae:	4798      	blx	r3
 80106b0:	bd08      	pop	{r3, pc}
 80106b2:	bf00      	nop

080106b4 <_Unwind_VRS_Get>:
 80106b4:	b981      	cbnz	r1, 80106d8 <_Unwind_VRS_Get+0x24>
 80106b6:	2a0f      	cmp	r2, #15
 80106b8:	bf98      	it	ls
 80106ba:	2b00      	cmpls	r3, #0
 80106bc:	bf08      	it	eq
 80106be:	eb00 0282 	addeq.w	r2, r0, r2, lsl #2
 80106c2:	bf0c      	ite	eq
 80106c4:	2300      	moveq	r3, #0
 80106c6:	2301      	movne	r3, #1
 80106c8:	bf01      	itttt	eq
 80106ca:	4618      	moveq	r0, r3
 80106cc:	9b00      	ldreq	r3, [sp, #0]
 80106ce:	6852      	ldreq	r2, [r2, #4]
 80106d0:	601a      	streq	r2, [r3, #0]
 80106d2:	bf18      	it	ne
 80106d4:	2002      	movne	r0, #2
 80106d6:	4770      	bx	lr
 80106d8:	2904      	cmp	r1, #4
 80106da:	bf8c      	ite	hi
 80106dc:	2002      	movhi	r0, #2
 80106de:	2001      	movls	r0, #1
 80106e0:	4770      	bx	lr
 80106e2:	bf00      	nop

080106e4 <_Unwind_GetGR>:
 80106e4:	b500      	push	{lr}
 80106e6:	b085      	sub	sp, #20
 80106e8:	460a      	mov	r2, r1
 80106ea:	2100      	movs	r1, #0
 80106ec:	ab03      	add	r3, sp, #12
 80106ee:	9300      	str	r3, [sp, #0]
 80106f0:	460b      	mov	r3, r1
 80106f2:	f7ff ffdf 	bl	80106b4 <_Unwind_VRS_Get>
 80106f6:	9803      	ldr	r0, [sp, #12]
 80106f8:	b005      	add	sp, #20
 80106fa:	bd00      	pop	{pc}

080106fc <_Unwind_VRS_Set>:
 80106fc:	b981      	cbnz	r1, 8010720 <_Unwind_VRS_Set+0x24>
 80106fe:	2a0f      	cmp	r2, #15
 8010700:	bf98      	it	ls
 8010702:	2b00      	cmpls	r3, #0
 8010704:	bf08      	it	eq
 8010706:	eb00 0282 	addeq.w	r2, r0, r2, lsl #2
 801070a:	bf0c      	ite	eq
 801070c:	2300      	moveq	r3, #0
 801070e:	2301      	movne	r3, #1
 8010710:	bf01      	itttt	eq
 8010712:	9900      	ldreq	r1, [sp, #0]
 8010714:	4618      	moveq	r0, r3
 8010716:	6809      	ldreq	r1, [r1, #0]
 8010718:	6051      	streq	r1, [r2, #4]
 801071a:	bf18      	it	ne
 801071c:	2002      	movne	r0, #2
 801071e:	4770      	bx	lr
 8010720:	2904      	cmp	r1, #4
 8010722:	bf8c      	ite	hi
 8010724:	2002      	movhi	r0, #2
 8010726:	2001      	movls	r0, #1
 8010728:	4770      	bx	lr
 801072a:	bf00      	nop

0801072c <_Unwind_SetGR>:
 801072c:	b530      	push	{r4, r5, lr}
 801072e:	b085      	sub	sp, #20
 8010730:	ac04      	add	r4, sp, #16
 8010732:	460d      	mov	r5, r1
 8010734:	2100      	movs	r1, #0
 8010736:	f844 2d04 	str.w	r2, [r4, #-4]!
 801073a:	460b      	mov	r3, r1
 801073c:	9400      	str	r4, [sp, #0]
 801073e:	462a      	mov	r2, r5
 8010740:	f7ff ffdc 	bl	80106fc <_Unwind_VRS_Set>
 8010744:	b005      	add	sp, #20
 8010746:	bd30      	pop	{r4, r5, pc}

08010748 <__gnu_unwind_pr_common>:
 8010748:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801074c:	461d      	mov	r5, r3
 801074e:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
 8010750:	4617      	mov	r7, r2
 8010752:	b08b      	sub	sp, #44	; 0x2c
 8010754:	460c      	mov	r4, r1
 8010756:	f000 0803 	and.w	r8, r0, #3
 801075a:	f853 2b04 	ldr.w	r2, [r3], #4
 801075e:	9207      	str	r2, [sp, #28]
 8010760:	9308      	str	r3, [sp, #32]
 8010762:	b9ed      	cbnz	r5, 80107a0 <__gnu_unwind_pr_common+0x58>
 8010764:	0212      	lsls	r2, r2, #8
 8010766:	f88d 5025 	strb.w	r5, [sp, #37]	; 0x25
 801076a:	9207      	str	r2, [sp, #28]
 801076c:	2203      	movs	r2, #3
 801076e:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
 8010772:	f1b8 0f02 	cmp.w	r8, #2
 8010776:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8010778:	bf08      	it	eq
 801077a:	6ba3      	ldreq	r3, [r4, #56]	; 0x38
 801077c:	f012 0201 	ands.w	r2, r2, #1
 8010780:	d01c      	beq.n	80107bc <__gnu_unwind_pr_common+0x74>
 8010782:	2200      	movs	r2, #0
 8010784:	9201      	str	r2, [sp, #4]
 8010786:	2d02      	cmp	r5, #2
 8010788:	f340 80b9 	ble.w	80108fe <__gnu_unwind_pr_common+0x1b6>
 801078c:	f7ff fe8c 	bl	80104a8 <__gnu_unwind_24bit.isra.1>
 8010790:	2800      	cmp	r0, #0
 8010792:	f000 80bb 	beq.w	801090c <__gnu_unwind_pr_common+0x1c4>
 8010796:	2309      	movs	r3, #9
 8010798:	4618      	mov	r0, r3
 801079a:	b00b      	add	sp, #44	; 0x2c
 801079c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80107a0:	2d02      	cmp	r5, #2
 80107a2:	dce6      	bgt.n	8010772 <__gnu_unwind_pr_common+0x2a>
 80107a4:	0c11      	lsrs	r1, r2, #16
 80107a6:	f88d 1025 	strb.w	r1, [sp, #37]	; 0x25
 80107aa:	0412      	lsls	r2, r2, #16
 80107ac:	9207      	str	r2, [sp, #28]
 80107ae:	b2c9      	uxtb	r1, r1
 80107b0:	2202      	movs	r2, #2
 80107b2:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
 80107b6:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 80107ba:	e7da      	b.n	8010772 <__gnu_unwind_pr_common+0x2a>
 80107bc:	f000 0008 	and.w	r0, r0, #8
 80107c0:	9201      	str	r2, [sp, #4]
 80107c2:	f104 0258 	add.w	r2, r4, #88	; 0x58
 80107c6:	9202      	str	r2, [sp, #8]
 80107c8:	b2c0      	uxtb	r0, r0
 80107ca:	9003      	str	r0, [sp, #12]
 80107cc:	681e      	ldr	r6, [r3, #0]
 80107ce:	2e00      	cmp	r6, #0
 80107d0:	d0d9      	beq.n	8010786 <__gnu_unwind_pr_common+0x3e>
 80107d2:	2d02      	cmp	r5, #2
 80107d4:	4638      	mov	r0, r7
 80107d6:	bf0b      	itete	eq
 80107d8:	f103 0a08 	addeq.w	sl, r3, #8
 80107dc:	f103 0a04 	addne.w	sl, r3, #4
 80107e0:	f8d3 9004 	ldreq.w	r9, [r3, #4]
 80107e4:	f8b3 9002 	ldrhne.w	r9, [r3, #2]
 80107e8:	bf18      	it	ne
 80107ea:	881e      	ldrhne	r6, [r3, #0]
 80107ec:	210f      	movs	r1, #15
 80107ee:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80107f0:	f029 0b01 	bic.w	fp, r9, #1
 80107f4:	449b      	add	fp, r3
 80107f6:	f7ff ff75 	bl	80106e4 <_Unwind_GetGR>
 80107fa:	4583      	cmp	fp, r0
 80107fc:	d81b      	bhi.n	8010836 <__gnu_unwind_pr_common+0xee>
 80107fe:	f026 0301 	bic.w	r3, r6, #1
 8010802:	f009 0901 	and.w	r9, r9, #1
 8010806:	449b      	add	fp, r3
 8010808:	f006 0601 	and.w	r6, r6, #1
 801080c:	4558      	cmp	r0, fp
 801080e:	ea46 0649 	orr.w	r6, r6, r9, lsl #1
 8010812:	bf2c      	ite	cs
 8010814:	2000      	movcs	r0, #0
 8010816:	2001      	movcc	r0, #1
 8010818:	2e01      	cmp	r6, #1
 801081a:	d015      	beq.n	8010848 <__gnu_unwind_pr_common+0x100>
 801081c:	d233      	bcs.n	8010886 <__gnu_unwind_pr_common+0x13e>
 801081e:	f1b8 0f00 	cmp.w	r8, #0
 8010822:	bf0c      	ite	eq
 8010824:	2000      	moveq	r0, #0
 8010826:	f000 0001 	andne.w	r0, r0, #1
 801082a:	2800      	cmp	r0, #0
 801082c:	f040 80c2 	bne.w	80109b4 <__gnu_unwind_pr_common+0x26c>
 8010830:	f10a 0304 	add.w	r3, sl, #4
 8010834:	e7ca      	b.n	80107cc <__gnu_unwind_pr_common+0x84>
 8010836:	f009 0901 	and.w	r9, r9, #1
 801083a:	f006 0601 	and.w	r6, r6, #1
 801083e:	2000      	movs	r0, #0
 8010840:	ea46 0649 	orr.w	r6, r6, r9, lsl #1
 8010844:	2e01      	cmp	r6, #1
 8010846:	d1e9      	bne.n	801081c <__gnu_unwind_pr_common+0xd4>
 8010848:	f1b8 0f00 	cmp.w	r8, #0
 801084c:	d17d      	bne.n	801094a <__gnu_unwind_pr_common+0x202>
 801084e:	b1b8      	cbz	r0, 8010880 <__gnu_unwind_pr_common+0x138>
 8010850:	f8da 3004 	ldr.w	r3, [sl, #4]
 8010854:	f8da 6000 	ldr.w	r6, [sl]
 8010858:	1c9a      	adds	r2, r3, #2
 801085a:	d09c      	beq.n	8010796 <__gnu_unwind_pr_common+0x4e>
 801085c:	9a02      	ldr	r2, [sp, #8]
 801085e:	3301      	adds	r3, #1
 8010860:	9206      	str	r2, [sp, #24]
 8010862:	f000 808c 	beq.w	801097e <__gnu_unwind_pr_common+0x236>
 8010866:	f10a 0004 	add.w	r0, sl, #4
 801086a:	f7ff fe17 	bl	801049c <_Unwind_decode_typeinfo_ptr.isra.0>
 801086e:	0ff2      	lsrs	r2, r6, #31
 8010870:	ab06      	add	r3, sp, #24
 8010872:	4601      	mov	r1, r0
 8010874:	4620      	mov	r0, r4
 8010876:	f00c f909 	bl	801ca8c <__cxa_type_match>
 801087a:	2800      	cmp	r0, #0
 801087c:	f040 80c3 	bne.w	8010a06 <__gnu_unwind_pr_common+0x2be>
 8010880:	f10a 0308 	add.w	r3, sl, #8
 8010884:	e7a2      	b.n	80107cc <__gnu_unwind_pr_common+0x84>
 8010886:	2e02      	cmp	r6, #2
 8010888:	d185      	bne.n	8010796 <__gnu_unwind_pr_common+0x4e>
 801088a:	f8da 3000 	ldr.w	r3, [sl]
 801088e:	f023 4600 	bic.w	r6, r3, #2147483648	; 0x80000000
 8010892:	f1b8 0f00 	cmp.w	r8, #0
 8010896:	d13e      	bne.n	8010916 <__gnu_unwind_pr_common+0x1ce>
 8010898:	b348      	cbz	r0, 80108ee <__gnu_unwind_pr_common+0x1a6>
 801089a:	9a03      	ldr	r2, [sp, #12]
 801089c:	2a00      	cmp	r2, #0
 801089e:	bf18      	it	ne
 80108a0:	2e00      	cmpne	r6, #0
 80108a2:	d124      	bne.n	80108ee <__gnu_unwind_pr_common+0x1a6>
 80108a4:	2e00      	cmp	r6, #0
 80108a6:	f000 80a5 	beq.w	80109f4 <__gnu_unwind_pr_common+0x2ac>
 80108aa:	f10a 0b04 	add.w	fp, sl, #4
 80108ae:	9704      	str	r7, [sp, #16]
 80108b0:	9505      	str	r5, [sp, #20]
 80108b2:	46c1      	mov	r9, r8
 80108b4:	465d      	mov	r5, fp
 80108b6:	9f02      	ldr	r7, [sp, #8]
 80108b8:	e003      	b.n	80108c2 <__gnu_unwind_pr_common+0x17a>
 80108ba:	45b3      	cmp	fp, r6
 80108bc:	46d9      	mov	r9, fp
 80108be:	f000 808d 	beq.w	80109dc <__gnu_unwind_pr_common+0x294>
 80108c2:	4628      	mov	r0, r5
 80108c4:	9706      	str	r7, [sp, #24]
 80108c6:	f7ff fde9 	bl	801049c <_Unwind_decode_typeinfo_ptr.isra.0>
 80108ca:	2200      	movs	r2, #0
 80108cc:	ab06      	add	r3, sp, #24
 80108ce:	f109 0b01 	add.w	fp, r9, #1
 80108d2:	3504      	adds	r5, #4
 80108d4:	4601      	mov	r1, r0
 80108d6:	4620      	mov	r0, r4
 80108d8:	f00c f8d8 	bl	801ca8c <__cxa_type_match>
 80108dc:	2800      	cmp	r0, #0
 80108de:	d0ec      	beq.n	80108ba <__gnu_unwind_pr_common+0x172>
 80108e0:	454e      	cmp	r6, r9
 80108e2:	9f04      	ldr	r7, [sp, #16]
 80108e4:	9d05      	ldr	r5, [sp, #20]
 80108e6:	f000 8085 	beq.w	80109f4 <__gnu_unwind_pr_common+0x2ac>
 80108ea:	f8da 3000 	ldr.w	r3, [sl]
 80108ee:	2b00      	cmp	r3, #0
 80108f0:	bfb8      	it	lt
 80108f2:	f10a 0a04 	addlt.w	sl, sl, #4
 80108f6:	1c73      	adds	r3, r6, #1
 80108f8:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
 80108fc:	e766      	b.n	80107cc <__gnu_unwind_pr_common+0x84>
 80108fe:	4638      	mov	r0, r7
 8010900:	a907      	add	r1, sp, #28
 8010902:	f000 fb09 	bl	8010f18 <__gnu_unwind_execute>
 8010906:	2800      	cmp	r0, #0
 8010908:	f47f af45 	bne.w	8010796 <__gnu_unwind_pr_common+0x4e>
 801090c:	9b01      	ldr	r3, [sp, #4]
 801090e:	2b00      	cmp	r3, #0
 8010910:	d140      	bne.n	8010994 <__gnu_unwind_pr_common+0x24c>
 8010912:	2308      	movs	r3, #8
 8010914:	e740      	b.n	8010798 <__gnu_unwind_pr_common+0x50>
 8010916:	210d      	movs	r1, #13
 8010918:	4638      	mov	r0, r7
 801091a:	f8d4 9020 	ldr.w	r9, [r4, #32]
 801091e:	f7ff fee1 	bl	80106e4 <_Unwind_GetGR>
 8010922:	4581      	cmp	r9, r0
 8010924:	d1e1      	bne.n	80108ea <__gnu_unwind_pr_common+0x1a2>
 8010926:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8010928:	459a      	cmp	sl, r3
 801092a:	d1de      	bne.n	80108ea <__gnu_unwind_pr_common+0x1a2>
 801092c:	2300      	movs	r3, #0
 801092e:	2204      	movs	r2, #4
 8010930:	62e3      	str	r3, [r4, #44]	; 0x2c
 8010932:	f10a 0304 	add.w	r3, sl, #4
 8010936:	62a6      	str	r6, [r4, #40]	; 0x28
 8010938:	6322      	str	r2, [r4, #48]	; 0x30
 801093a:	6363      	str	r3, [r4, #52]	; 0x34
 801093c:	f8da 3000 	ldr.w	r3, [sl]
 8010940:	2b00      	cmp	r3, #0
 8010942:	db59      	blt.n	80109f8 <__gnu_unwind_pr_common+0x2b0>
 8010944:	2201      	movs	r2, #1
 8010946:	9201      	str	r2, [sp, #4]
 8010948:	e7d5      	b.n	80108f6 <__gnu_unwind_pr_common+0x1ae>
 801094a:	210d      	movs	r1, #13
 801094c:	4638      	mov	r0, r7
 801094e:	6a26      	ldr	r6, [r4, #32]
 8010950:	f7ff fec8 	bl	80106e4 <_Unwind_GetGR>
 8010954:	4286      	cmp	r6, r0
 8010956:	d193      	bne.n	8010880 <__gnu_unwind_pr_common+0x138>
 8010958:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 801095a:	459a      	cmp	sl, r3
 801095c:	d190      	bne.n	8010880 <__gnu_unwind_pr_common+0x138>
 801095e:	4656      	mov	r6, sl
 8010960:	4650      	mov	r0, sl
 8010962:	f7ff fccb 	bl	80102fc <selfrel_offset31>
 8010966:	210f      	movs	r1, #15
 8010968:	4602      	mov	r2, r0
 801096a:	4638      	mov	r0, r7
 801096c:	f7ff fede 	bl	801072c <_Unwind_SetGR>
 8010970:	4638      	mov	r0, r7
 8010972:	2100      	movs	r1, #0
 8010974:	4622      	mov	r2, r4
 8010976:	f7ff fed9 	bl	801072c <_Unwind_SetGR>
 801097a:	2307      	movs	r3, #7
 801097c:	e70c      	b.n	8010798 <__gnu_unwind_pr_common+0x50>
 801097e:	4638      	mov	r0, r7
 8010980:	210d      	movs	r1, #13
 8010982:	f7ff feaf 	bl	80106e4 <_Unwind_GetGR>
 8010986:	4656      	mov	r6, sl
 8010988:	6220      	str	r0, [r4, #32]
 801098a:	9b06      	ldr	r3, [sp, #24]
 801098c:	6263      	str	r3, [r4, #36]	; 0x24
 801098e:	62a6      	str	r6, [r4, #40]	; 0x28
 8010990:	2306      	movs	r3, #6
 8010992:	e701      	b.n	8010798 <__gnu_unwind_pr_common+0x50>
 8010994:	210f      	movs	r1, #15
 8010996:	4638      	mov	r0, r7
 8010998:	f7ff fea4 	bl	80106e4 <_Unwind_GetGR>
 801099c:	210e      	movs	r1, #14
 801099e:	4602      	mov	r2, r0
 80109a0:	4638      	mov	r0, r7
 80109a2:	f7ff fec3 	bl	801072c <_Unwind_SetGR>
 80109a6:	4638      	mov	r0, r7
 80109a8:	210f      	movs	r1, #15
 80109aa:	4a1f      	ldr	r2, [pc, #124]	; (8010a28 <__gnu_unwind_pr_common+0x2e0>)
 80109ac:	f7ff febe 	bl	801072c <_Unwind_SetGR>
 80109b0:	2307      	movs	r3, #7
 80109b2:	e6f1      	b.n	8010798 <__gnu_unwind_pr_common+0x50>
 80109b4:	4650      	mov	r0, sl
 80109b6:	4656      	mov	r6, sl
 80109b8:	f7ff fca0 	bl	80102fc <selfrel_offset31>
 80109bc:	3604      	adds	r6, #4
 80109be:	63a6      	str	r6, [r4, #56]	; 0x38
 80109c0:	4605      	mov	r5, r0
 80109c2:	4620      	mov	r0, r4
 80109c4:	f00c f8ba 	bl	801cb3c <__cxa_begin_cleanup>
 80109c8:	2800      	cmp	r0, #0
 80109ca:	f43f aee4 	beq.w	8010796 <__gnu_unwind_pr_common+0x4e>
 80109ce:	4638      	mov	r0, r7
 80109d0:	210f      	movs	r1, #15
 80109d2:	462a      	mov	r2, r5
 80109d4:	f7ff feaa 	bl	801072c <_Unwind_SetGR>
 80109d8:	2307      	movs	r3, #7
 80109da:	e6dd      	b.n	8010798 <__gnu_unwind_pr_common+0x50>
 80109dc:	9f04      	ldr	r7, [sp, #16]
 80109de:	4656      	mov	r6, sl
 80109e0:	4638      	mov	r0, r7
 80109e2:	210d      	movs	r1, #13
 80109e4:	f7ff fe7e 	bl	80106e4 <_Unwind_GetGR>
 80109e8:	9a06      	ldr	r2, [sp, #24]
 80109ea:	62a6      	str	r6, [r4, #40]	; 0x28
 80109ec:	2306      	movs	r3, #6
 80109ee:	6262      	str	r2, [r4, #36]	; 0x24
 80109f0:	6220      	str	r0, [r4, #32]
 80109f2:	e6d1      	b.n	8010798 <__gnu_unwind_pr_common+0x50>
 80109f4:	4656      	mov	r6, sl
 80109f6:	e7f3      	b.n	80109e0 <__gnu_unwind_pr_common+0x298>
 80109f8:	46b1      	mov	r9, r6
 80109fa:	4656      	mov	r6, sl
 80109fc:	f109 0001 	add.w	r0, r9, #1
 8010a00:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
 8010a04:	e7ad      	b.n	8010962 <__gnu_unwind_pr_common+0x21a>
 8010a06:	4603      	mov	r3, r0
 8010a08:	210d      	movs	r1, #13
 8010a0a:	4638      	mov	r0, r7
 8010a0c:	9300      	str	r3, [sp, #0]
 8010a0e:	f7ff fe69 	bl	80106e4 <_Unwind_GetGR>
 8010a12:	9b00      	ldr	r3, [sp, #0]
 8010a14:	4656      	mov	r6, sl
 8010a16:	2b02      	cmp	r3, #2
 8010a18:	6220      	str	r0, [r4, #32]
 8010a1a:	d1b6      	bne.n	801098a <__gnu_unwind_pr_common+0x242>
 8010a1c:	9a06      	ldr	r2, [sp, #24]
 8010a1e:	4623      	mov	r3, r4
 8010a20:	f843 2f2c 	str.w	r2, [r3, #44]!
 8010a24:	6263      	str	r3, [r4, #36]	; 0x24
 8010a26:	e7b2      	b.n	801098e <__gnu_unwind_pr_common+0x246>
 8010a28:	0801dd01 	.word	0x0801dd01

08010a2c <__aeabi_unwind_cpp_pr2>:
 8010a2c:	2302      	movs	r3, #2
 8010a2e:	f7ff be8b 	b.w	8010748 <__gnu_unwind_pr_common>
 8010a32:	bf00      	nop

08010a34 <__aeabi_unwind_cpp_pr1>:
 8010a34:	2301      	movs	r3, #1
 8010a36:	f7ff be87 	b.w	8010748 <__gnu_unwind_pr_common>
 8010a3a:	bf00      	nop

08010a3c <__aeabi_unwind_cpp_pr0>:
 8010a3c:	2300      	movs	r3, #0
 8010a3e:	f7ff be83 	b.w	8010748 <__gnu_unwind_pr_common>
 8010a42:	bf00      	nop

08010a44 <__gnu_Unwind_Backtrace>:
 8010a44:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8010a46:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010a48:	1d15      	adds	r5, r2, #4
 8010a4a:	6413      	str	r3, [r2, #64]	; 0x40
 8010a4c:	4607      	mov	r7, r0
 8010a4e:	460e      	mov	r6, r1
 8010a50:	f5ad 7d27 	sub.w	sp, sp, #668	; 0x29c
 8010a54:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010a56:	ac17      	add	r4, sp, #92	; 0x5c
 8010a58:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8010a5a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010a5c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8010a5e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010a60:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8010a62:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8010a66:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 8010a6a:	f04f 33ff 	mov.w	r3, #4294967295
 8010a6e:	9316      	str	r3, [sp, #88]	; 0x58
 8010a70:	9926      	ldr	r1, [sp, #152]	; 0x98
 8010a72:	4668      	mov	r0, sp
 8010a74:	f7ff fcc0 	bl	80103f8 <get_eit_entry>
 8010a78:	466a      	mov	r2, sp
 8010a7a:	210c      	movs	r1, #12
 8010a7c:	b9b8      	cbnz	r0, 8010aae <__gnu_Unwind_Backtrace+0x6a>
 8010a7e:	a816      	add	r0, sp, #88	; 0x58
 8010a80:	f7ff fe54 	bl	801072c <_Unwind_SetGR>
 8010a84:	4631      	mov	r1, r6
 8010a86:	a816      	add	r0, sp, #88	; 0x58
 8010a88:	47b8      	blx	r7
 8010a8a:	4669      	mov	r1, sp
 8010a8c:	aa16      	add	r2, sp, #88	; 0x58
 8010a8e:	b970      	cbnz	r0, 8010aae <__gnu_Unwind_Backtrace+0x6a>
 8010a90:	2008      	movs	r0, #8
 8010a92:	9b04      	ldr	r3, [sp, #16]
 8010a94:	4798      	blx	r3
 8010a96:	2809      	cmp	r0, #9
 8010a98:	bf18      	it	ne
 8010a9a:	2805      	cmpne	r0, #5
 8010a9c:	4604      	mov	r4, r0
 8010a9e:	d1e7      	bne.n	8010a70 <__gnu_Unwind_Backtrace+0x2c>
 8010aa0:	a816      	add	r0, sp, #88	; 0x58
 8010aa2:	f7ff fc7d 	bl	80103a0 <restore_non_core_regs>
 8010aa6:	4620      	mov	r0, r4
 8010aa8:	f50d 7d27 	add.w	sp, sp, #668	; 0x29c
 8010aac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8010aae:	2409      	movs	r4, #9
 8010ab0:	e7f6      	b.n	8010aa0 <__gnu_Unwind_Backtrace+0x5c>
 8010ab2:	bf00      	nop

08010ab4 <_Unwind_VRS_Pop>:
 8010ab4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8010ab8:	4604      	mov	r4, r0
 8010aba:	b0e8      	sub	sp, #416	; 0x1a0
 8010abc:	2904      	cmp	r1, #4
 8010abe:	d807      	bhi.n	8010ad0 <_Unwind_VRS_Pop+0x1c>
 8010ac0:	e8df f001 	tbb	[pc, r1]
 8010ac4:	0344462c 	.word	0x0344462c
 8010ac8:	0a          	.byte	0x0a
 8010ac9:	00          	.byte	0x00
 8010aca:	2b03      	cmp	r3, #3
 8010acc:	f000 80c3 	beq.w	8010c56 <_Unwind_VRS_Pop+0x1a2>
 8010ad0:	2002      	movs	r0, #2
 8010ad2:	b068      	add	sp, #416	; 0x1a0
 8010ad4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8010ad8:	2a10      	cmp	r2, #16
 8010ada:	bf98      	it	ls
 8010adc:	2b00      	cmpls	r3, #0
 8010ade:	d1f7      	bne.n	8010ad0 <_Unwind_VRS_Pop+0x1c>
 8010ae0:	6823      	ldr	r3, [r4, #0]
 8010ae2:	06d9      	lsls	r1, r3, #27
 8010ae4:	f100 80db 	bmi.w	8010c9e <_Unwind_VRS_Pop+0x1ea>
 8010ae8:	a802      	add	r0, sp, #8
 8010aea:	9201      	str	r2, [sp, #4]
 8010aec:	f000 f988 	bl	8010e00 <__gnu_Unwind_Save_WMMXC>
 8010af0:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8010af2:	9a01      	ldr	r2, [sp, #4]
 8010af4:	2300      	movs	r3, #0
 8010af6:	2501      	movs	r5, #1
 8010af8:	fa05 f103 	lsl.w	r1, r5, r3
 8010afc:	4211      	tst	r1, r2
 8010afe:	bf1e      	ittt	ne
 8010b00:	ae02      	addne	r6, sp, #8
 8010b02:	f850 1b04 	ldrne.w	r1, [r0], #4
 8010b06:	f846 1023 	strne.w	r1, [r6, r3, lsl #2]
 8010b0a:	3301      	adds	r3, #1
 8010b0c:	2b04      	cmp	r3, #4
 8010b0e:	d1f3      	bne.n	8010af8 <_Unwind_VRS_Pop+0x44>
 8010b10:	63a0      	str	r0, [r4, #56]	; 0x38
 8010b12:	a802      	add	r0, sp, #8
 8010b14:	f000 f96a 	bl	8010dec <__gnu_Unwind_Restore_WMMXC>
 8010b18:	2000      	movs	r0, #0
 8010b1a:	e7da      	b.n	8010ad2 <_Unwind_VRS_Pop+0x1e>
 8010b1c:	2b00      	cmp	r3, #0
 8010b1e:	d1d7      	bne.n	8010ad0 <_Unwind_VRS_Pop+0x1c>
 8010b20:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8010b22:	b297      	uxth	r7, r2
 8010b24:	2601      	movs	r6, #1
 8010b26:	fa06 f103 	lsl.w	r1, r6, r3
 8010b2a:	eb04 0083 	add.w	r0, r4, r3, lsl #2
 8010b2e:	3301      	adds	r3, #1
 8010b30:	4239      	tst	r1, r7
 8010b32:	bf1c      	itt	ne
 8010b34:	f855 1b04 	ldrne.w	r1, [r5], #4
 8010b38:	6041      	strne	r1, [r0, #4]
 8010b3a:	2b10      	cmp	r3, #16
 8010b3c:	d1f3      	bne.n	8010b26 <_Unwind_VRS_Pop+0x72>
 8010b3e:	f412 5000 	ands.w	r0, r2, #8192	; 0x2000
 8010b42:	bf08      	it	eq
 8010b44:	63a5      	streq	r5, [r4, #56]	; 0x38
 8010b46:	d0c4      	beq.n	8010ad2 <_Unwind_VRS_Pop+0x1e>
 8010b48:	2000      	movs	r0, #0
 8010b4a:	e7c2      	b.n	8010ad2 <_Unwind_VRS_Pop+0x1e>
 8010b4c:	2001      	movs	r0, #1
 8010b4e:	e7c0      	b.n	8010ad2 <_Unwind_VRS_Pop+0x1e>
 8010b50:	f003 01fb 	and.w	r1, r3, #251	; 0xfb
 8010b54:	2901      	cmp	r1, #1
 8010b56:	d1bb      	bne.n	8010ad0 <_Unwind_VRS_Pop+0x1c>
 8010b58:	0c15      	lsrs	r5, r2, #16
 8010b5a:	b296      	uxth	r6, r2
 8010b5c:	1972      	adds	r2, r6, r5
 8010b5e:	2b01      	cmp	r3, #1
 8010b60:	bf14      	ite	ne
 8010b62:	2120      	movne	r1, #32
 8010b64:	2110      	moveq	r1, #16
 8010b66:	4291      	cmp	r1, r2
 8010b68:	d3b2      	bcc.n	8010ad0 <_Unwind_VRS_Pop+0x1c>
 8010b6a:	f1b3 0c01 	subs.w	ip, r3, #1
 8010b6e:	f1dc 0700 	rsbs	r7, ip, #0
 8010b72:	eb57 070c 	adcs.w	r7, r7, ip
 8010b76:	2d0f      	cmp	r5, #15
 8010b78:	bf94      	ite	ls
 8010b7a:	2100      	movls	r1, #0
 8010b7c:	2101      	movhi	r1, #1
 8010b7e:	4239      	tst	r1, r7
 8010b80:	d1a6      	bne.n	8010ad0 <_Unwind_VRS_Pop+0x1c>
 8010b82:	46b0      	mov	r8, r6
 8010b84:	b921      	cbnz	r1, 8010b90 <_Unwind_VRS_Pop+0xdc>
 8010b86:	2a10      	cmp	r2, #16
 8010b88:	f240 80ab 	bls.w	8010ce2 <_Unwind_VRS_Pop+0x22e>
 8010b8c:	f1a2 0810 	sub.w	r8, r2, #16
 8010b90:	f1b8 0f00 	cmp.w	r8, #0
 8010b94:	bf18      	it	ne
 8010b96:	2b05      	cmpne	r3, #5
 8010b98:	d19a      	bne.n	8010ad0 <_Unwind_VRS_Pop+0x1c>
 8010b9a:	2d0f      	cmp	r5, #15
 8010b9c:	d80f      	bhi.n	8010bbe <_Unwind_VRS_Pop+0x10a>
 8010b9e:	6822      	ldr	r2, [r4, #0]
 8010ba0:	07d0      	lsls	r0, r2, #31
 8010ba2:	d50c      	bpl.n	8010bbe <_Unwind_VRS_Pop+0x10a>
 8010ba4:	2b05      	cmp	r3, #5
 8010ba6:	f022 0101 	bic.w	r1, r2, #1
 8010baa:	4620      	mov	r0, r4
 8010bac:	6021      	str	r1, [r4, #0]
 8010bae:	f000 80ae 	beq.w	8010d0e <_Unwind_VRS_Pop+0x25a>
 8010bb2:	f022 0203 	bic.w	r2, r2, #3
 8010bb6:	f840 2b48 	str.w	r2, [r0], #72
 8010bba:	f000 f8bf 	bl	8010d3c <__gnu_Unwind_Save_VFP>
 8010bbe:	f1b8 0f00 	cmp.w	r8, #0
 8010bc2:	d002      	beq.n	8010bca <_Unwind_VRS_Pop+0x116>
 8010bc4:	6823      	ldr	r3, [r4, #0]
 8010bc6:	0759      	lsls	r1, r3, #29
 8010bc8:	d47b      	bmi.n	8010cc2 <_Unwind_VRS_Pop+0x20e>
 8010bca:	2f00      	cmp	r7, #0
 8010bcc:	f040 8098 	bne.w	8010d00 <_Unwind_VRS_Pop+0x24c>
 8010bd0:	2d0f      	cmp	r5, #15
 8010bd2:	d96e      	bls.n	8010cb2 <_Unwind_VRS_Pop+0x1fe>
 8010bd4:	f1b8 0f00 	cmp.w	r8, #0
 8010bd8:	f040 808c 	bne.w	8010cf4 <_Unwind_VRS_Pop+0x240>
 8010bdc:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8010bde:	2e00      	cmp	r6, #0
 8010be0:	4601      	mov	r1, r0
 8010be2:	dd10      	ble.n	8010c06 <_Unwind_VRS_Pop+0x152>
 8010be4:	aa46      	add	r2, sp, #280	; 0x118
 8010be6:	ea4f 0c46 	mov.w	ip, r6, lsl #1
 8010bea:	eb02 06c5 	add.w	r6, r2, r5, lsl #3
 8010bee:	f10c 31ff 	add.w	r1, ip, #4294967295
 8010bf2:	4633      	mov	r3, r6
 8010bf4:	1b9a      	subs	r2, r3, r6
 8010bf6:	3901      	subs	r1, #1
 8010bf8:	5812      	ldr	r2, [r2, r0]
 8010bfa:	f843 2b04 	str.w	r2, [r3], #4
 8010bfe:	1c4a      	adds	r2, r1, #1
 8010c00:	d1f8      	bne.n	8010bf4 <_Unwind_VRS_Pop+0x140>
 8010c02:	eb00 018c 	add.w	r1, r0, ip, lsl #2
 8010c06:	f1b8 0f00 	cmp.w	r8, #0
 8010c0a:	d016      	beq.n	8010c3a <_Unwind_VRS_Pop+0x186>
 8010c0c:	2d10      	cmp	r5, #16
 8010c0e:	bf2c      	ite	cs
 8010c10:	4628      	movcs	r0, r5
 8010c12:	2010      	movcc	r0, #16
 8010c14:	aa68      	add	r2, sp, #416	; 0x1a0
 8010c16:	ea4f 0c48 	mov.w	ip, r8, lsl #1
 8010c1a:	1f0e      	subs	r6, r1, #4
 8010c1c:	eb02 00c0 	add.w	r0, r2, r0, lsl #3
 8010c20:	f10c 33ff 	add.w	r3, ip, #4294967295
 8010c24:	f5a0 7002 	sub.w	r0, r0, #520	; 0x208
 8010c28:	f856 2f04 	ldr.w	r2, [r6, #4]!
 8010c2c:	3b01      	subs	r3, #1
 8010c2e:	f840 2b04 	str.w	r2, [r0], #4
 8010c32:	1c5a      	adds	r2, r3, #1
 8010c34:	d1f8      	bne.n	8010c28 <_Unwind_VRS_Pop+0x174>
 8010c36:	eb01 018c 	add.w	r1, r1, ip, lsl #2
 8010c3a:	2f00      	cmp	r7, #0
 8010c3c:	d153      	bne.n	8010ce6 <_Unwind_VRS_Pop+0x232>
 8010c3e:	2d0f      	cmp	r5, #15
 8010c40:	63a1      	str	r1, [r4, #56]	; 0x38
 8010c42:	d93a      	bls.n	8010cba <_Unwind_VRS_Pop+0x206>
 8010c44:	f1b8 0f00 	cmp.w	r8, #0
 8010c48:	f43f af7e 	beq.w	8010b48 <_Unwind_VRS_Pop+0x94>
 8010c4c:	a806      	add	r0, sp, #24
 8010c4e:	f000 f881 	bl	8010d54 <__gnu_Unwind_Restore_VFP_D_16_to_31>
 8010c52:	2000      	movs	r0, #0
 8010c54:	e73d      	b.n	8010ad2 <_Unwind_VRS_Pop+0x1e>
 8010c56:	0c15      	lsrs	r5, r2, #16
 8010c58:	b296      	uxth	r6, r2
 8010c5a:	1973      	adds	r3, r6, r5
 8010c5c:	2b10      	cmp	r3, #16
 8010c5e:	f63f af37 	bhi.w	8010ad0 <_Unwind_VRS_Pop+0x1c>
 8010c62:	6823      	ldr	r3, [r4, #0]
 8010c64:	0718      	lsls	r0, r3, #28
 8010c66:	d434      	bmi.n	8010cd2 <_Unwind_VRS_Pop+0x21e>
 8010c68:	a826      	add	r0, sp, #152	; 0x98
 8010c6a:	0076      	lsls	r6, r6, #1
 8010c6c:	f000 f89c 	bl	8010da8 <__gnu_Unwind_Save_WMMXD>
 8010c70:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8010c72:	ab26      	add	r3, sp, #152	; 0x98
 8010c74:	1e72      	subs	r2, r6, #1
 8010c76:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
 8010c7a:	4603      	mov	r3, r0
 8010c7c:	b14e      	cbz	r6, 8010c92 <_Unwind_VRS_Pop+0x1de>
 8010c7e:	462b      	mov	r3, r5
 8010c80:	1b59      	subs	r1, r3, r5
 8010c82:	3a01      	subs	r2, #1
 8010c84:	5809      	ldr	r1, [r1, r0]
 8010c86:	f843 1b04 	str.w	r1, [r3], #4
 8010c8a:	1c51      	adds	r1, r2, #1
 8010c8c:	d1f8      	bne.n	8010c80 <_Unwind_VRS_Pop+0x1cc>
 8010c8e:	eb00 0386 	add.w	r3, r0, r6, lsl #2
 8010c92:	a826      	add	r0, sp, #152	; 0x98
 8010c94:	63a3      	str	r3, [r4, #56]	; 0x38
 8010c96:	f000 f865 	bl	8010d64 <__gnu_Unwind_Restore_WMMXD>
 8010c9a:	2000      	movs	r0, #0
 8010c9c:	e719      	b.n	8010ad2 <_Unwind_VRS_Pop+0x1e>
 8010c9e:	f023 0310 	bic.w	r3, r3, #16
 8010ca2:	f504 700c 	add.w	r0, r4, #560	; 0x230
 8010ca6:	6023      	str	r3, [r4, #0]
 8010ca8:	9201      	str	r2, [sp, #4]
 8010caa:	f000 f8a9 	bl	8010e00 <__gnu_Unwind_Save_WMMXC>
 8010cae:	9a01      	ldr	r2, [sp, #4]
 8010cb0:	e71a      	b.n	8010ae8 <_Unwind_VRS_Pop+0x34>
 8010cb2:	a846      	add	r0, sp, #280	; 0x118
 8010cb4:	f000 f84a 	bl	8010d4c <__gnu_Unwind_Save_VFP_D>
 8010cb8:	e78c      	b.n	8010bd4 <_Unwind_VRS_Pop+0x120>
 8010cba:	a846      	add	r0, sp, #280	; 0x118
 8010cbc:	f000 f842 	bl	8010d44 <__gnu_Unwind_Restore_VFP_D>
 8010cc0:	e7c0      	b.n	8010c44 <_Unwind_VRS_Pop+0x190>
 8010cc2:	4620      	mov	r0, r4
 8010cc4:	f023 0304 	bic.w	r3, r3, #4
 8010cc8:	f840 3bd0 	str.w	r3, [r0], #208
 8010ccc:	f000 f846 	bl	8010d5c <__gnu_Unwind_Save_VFP_D_16_to_31>
 8010cd0:	e77b      	b.n	8010bca <_Unwind_VRS_Pop+0x116>
 8010cd2:	f023 0308 	bic.w	r3, r3, #8
 8010cd6:	f504 70d8 	add.w	r0, r4, #432	; 0x1b0
 8010cda:	6023      	str	r3, [r4, #0]
 8010cdc:	f000 f864 	bl	8010da8 <__gnu_Unwind_Save_WMMXD>
 8010ce0:	e7c2      	b.n	8010c68 <_Unwind_VRS_Pop+0x1b4>
 8010ce2:	4688      	mov	r8, r1
 8010ce4:	e759      	b.n	8010b9a <_Unwind_VRS_Pop+0xe6>
 8010ce6:	3104      	adds	r1, #4
 8010ce8:	a846      	add	r0, sp, #280	; 0x118
 8010cea:	63a1      	str	r1, [r4, #56]	; 0x38
 8010cec:	f000 f822 	bl	8010d34 <__gnu_Unwind_Restore_VFP>
 8010cf0:	2000      	movs	r0, #0
 8010cf2:	e6ee      	b.n	8010ad2 <_Unwind_VRS_Pop+0x1e>
 8010cf4:	a806      	add	r0, sp, #24
 8010cf6:	f000 f831 	bl	8010d5c <__gnu_Unwind_Save_VFP_D_16_to_31>
 8010cfa:	f1c5 0610 	rsb	r6, r5, #16
 8010cfe:	e76d      	b.n	8010bdc <_Unwind_VRS_Pop+0x128>
 8010d00:	a846      	add	r0, sp, #280	; 0x118
 8010d02:	f000 f81b 	bl	8010d3c <__gnu_Unwind_Save_VFP>
 8010d06:	f1b8 0f00 	cmp.w	r8, #0
 8010d0a:	d1f6      	bne.n	8010cfa <_Unwind_VRS_Pop+0x246>
 8010d0c:	e766      	b.n	8010bdc <_Unwind_VRS_Pop+0x128>
 8010d0e:	f041 0102 	orr.w	r1, r1, #2
 8010d12:	f840 1b48 	str.w	r1, [r0], #72
 8010d16:	f000 f819 	bl	8010d4c <__gnu_Unwind_Save_VFP_D>
 8010d1a:	e750      	b.n	8010bbe <_Unwind_VRS_Pop+0x10a>

08010d1c <__restore_core_regs>:
 8010d1c:	f100 0134 	add.w	r1, r0, #52	; 0x34
 8010d20:	e891 0038 	ldmia.w	r1, {r3, r4, r5}
 8010d24:	469c      	mov	ip, r3
 8010d26:	46a6      	mov	lr, r4
 8010d28:	f84c 5d04 	str.w	r5, [ip, #-4]!
 8010d2c:	e890 0fff 	ldmia.w	r0, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp}
 8010d30:	46e5      	mov	sp, ip
 8010d32:	bd00      	pop	{pc}

08010d34 <__gnu_Unwind_Restore_VFP>:
 8010d34:	ec90 0b21 	fldmiax	r0, {d0-d15}	;@ Deprecated
 8010d38:	4770      	bx	lr
 8010d3a:	bf00      	nop

08010d3c <__gnu_Unwind_Save_VFP>:
 8010d3c:	ec80 0b21 	fstmiax	r0, {d0-d15}	;@ Deprecated
 8010d40:	4770      	bx	lr
 8010d42:	bf00      	nop

08010d44 <__gnu_Unwind_Restore_VFP_D>:
 8010d44:	ec90 0b20 	vldmia	r0, {d0-d15}
 8010d48:	4770      	bx	lr
 8010d4a:	bf00      	nop

08010d4c <__gnu_Unwind_Save_VFP_D>:
 8010d4c:	ec80 0b20 	vstmia	r0, {d0-d15}
 8010d50:	4770      	bx	lr
 8010d52:	bf00      	nop

08010d54 <__gnu_Unwind_Restore_VFP_D_16_to_31>:
 8010d54:	ecd0 0b20 	vldmia	r0, {d16-d31}
 8010d58:	4770      	bx	lr
 8010d5a:	bf00      	nop

08010d5c <__gnu_Unwind_Save_VFP_D_16_to_31>:
 8010d5c:	ecc0 0b20 	vstmia	r0, {d16-d31}
 8010d60:	4770      	bx	lr
 8010d62:	bf00      	nop

08010d64 <__gnu_Unwind_Restore_WMMXD>:
 8010d64:	ecf0 0102 	ldfe	f0, [r0], #8
 8010d68:	ecf0 1102 	ldfe	f1, [r0], #8
 8010d6c:	ecf0 2102 	ldfe	f2, [r0], #8
 8010d70:	ecf0 3102 	ldfe	f3, [r0], #8
 8010d74:	ecf0 4102 	ldfe	f4, [r0], #8
 8010d78:	ecf0 5102 	ldfe	f5, [r0], #8
 8010d7c:	ecf0 6102 	ldfe	f6, [r0], #8
 8010d80:	ecf0 7102 	ldfe	f7, [r0], #8
 8010d84:	ecf0 8102 	ldfp	f0, [r0], #8
 8010d88:	ecf0 9102 	ldfp	f1, [r0], #8
 8010d8c:	ecf0 a102 	ldfp	f2, [r0], #8
 8010d90:	ecf0 b102 	ldfp	f3, [r0], #8
 8010d94:	ecf0 c102 	ldfp	f4, [r0], #8
 8010d98:	ecf0 d102 	ldfp	f5, [r0], #8
 8010d9c:	ecf0 e102 	ldfp	f6, [r0], #8
 8010da0:	ecf0 f102 	ldfp	f7, [r0], #8
 8010da4:	4770      	bx	lr
 8010da6:	bf00      	nop

08010da8 <__gnu_Unwind_Save_WMMXD>:
 8010da8:	ece0 0102 	stfe	f0, [r0], #8
 8010dac:	ece0 1102 	stfe	f1, [r0], #8
 8010db0:	ece0 2102 	stfe	f2, [r0], #8
 8010db4:	ece0 3102 	stfe	f3, [r0], #8
 8010db8:	ece0 4102 	stfe	f4, [r0], #8
 8010dbc:	ece0 5102 	stfe	f5, [r0], #8
 8010dc0:	ece0 6102 	stfe	f6, [r0], #8
 8010dc4:	ece0 7102 	stfe	f7, [r0], #8
 8010dc8:	ece0 8102 	stfp	f0, [r0], #8
 8010dcc:	ece0 9102 	stfp	f1, [r0], #8
 8010dd0:	ece0 a102 	stfp	f2, [r0], #8
 8010dd4:	ece0 b102 	stfp	f3, [r0], #8
 8010dd8:	ece0 c102 	stfp	f4, [r0], #8
 8010ddc:	ece0 d102 	stfp	f5, [r0], #8
 8010de0:	ece0 e102 	stfp	f6, [r0], #8
 8010de4:	ece0 f102 	stfp	f7, [r0], #8
 8010de8:	4770      	bx	lr
 8010dea:	bf00      	nop

08010dec <__gnu_Unwind_Restore_WMMXC>:
 8010dec:	fcb0 8101 	ldc2	1, cr8, [r0], #4
 8010df0:	fcb0 9101 	ldc2	1, cr9, [r0], #4
 8010df4:	fcb0 a101 	ldc2	1, cr10, [r0], #4
 8010df8:	fcb0 b101 	ldc2	1, cr11, [r0], #4
 8010dfc:	4770      	bx	lr
 8010dfe:	bf00      	nop

08010e00 <__gnu_Unwind_Save_WMMXC>:
 8010e00:	fca0 8101 	stc2	1, cr8, [r0], #4
 8010e04:	fca0 9101 	stc2	1, cr9, [r0], #4
 8010e08:	fca0 a101 	stc2	1, cr10, [r0], #4
 8010e0c:	fca0 b101 	stc2	1, cr11, [r0], #4
 8010e10:	4770      	bx	lr
 8010e12:	bf00      	nop

08010e14 <_Unwind_RaiseException>:
 8010e14:	46ec      	mov	ip, sp
 8010e16:	b500      	push	{lr}
 8010e18:	e92d 5000 	stmdb	sp!, {ip, lr}
 8010e1c:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8010e20:	f04f 0300 	mov.w	r3, #0
 8010e24:	e92d 000c 	stmdb	sp!, {r2, r3}
 8010e28:	a901      	add	r1, sp, #4
 8010e2a:	f7ff fbcf 	bl	80105cc <__gnu_Unwind_RaiseException>
 8010e2e:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8010e32:	b012      	add	sp, #72	; 0x48
 8010e34:	4770      	bx	lr
 8010e36:	bf00      	nop

08010e38 <_Unwind_Resume>:
 8010e38:	46ec      	mov	ip, sp
 8010e3a:	b500      	push	{lr}
 8010e3c:	e92d 5000 	stmdb	sp!, {ip, lr}
 8010e40:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8010e44:	f04f 0300 	mov.w	r3, #0
 8010e48:	e92d 000c 	stmdb	sp!, {r2, r3}
 8010e4c:	a901      	add	r1, sp, #4
 8010e4e:	f7ff fbf9 	bl	8010644 <__gnu_Unwind_Resume>
 8010e52:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8010e56:	b012      	add	sp, #72	; 0x48
 8010e58:	4770      	bx	lr
 8010e5a:	bf00      	nop

08010e5c <_Unwind_Resume_or_Rethrow>:
 8010e5c:	46ec      	mov	ip, sp
 8010e5e:	b500      	push	{lr}
 8010e60:	e92d 5000 	stmdb	sp!, {ip, lr}
 8010e64:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8010e68:	f04f 0300 	mov.w	r3, #0
 8010e6c:	e92d 000c 	stmdb	sp!, {r2, r3}
 8010e70:	a901      	add	r1, sp, #4
 8010e72:	f7ff fc09 	bl	8010688 <__gnu_Unwind_Resume_or_Rethrow>
 8010e76:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8010e7a:	b012      	add	sp, #72	; 0x48
 8010e7c:	4770      	bx	lr
 8010e7e:	bf00      	nop

08010e80 <_Unwind_ForcedUnwind>:
 8010e80:	46ec      	mov	ip, sp
 8010e82:	b500      	push	{lr}
 8010e84:	e92d 5000 	stmdb	sp!, {ip, lr}
 8010e88:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8010e8c:	f04f 0300 	mov.w	r3, #0
 8010e90:	e92d 000c 	stmdb	sp!, {r2, r3}
 8010e94:	ab01      	add	r3, sp, #4
 8010e96:	f7ff fbc9 	bl	801062c <__gnu_Unwind_ForcedUnwind>
 8010e9a:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8010e9e:	b012      	add	sp, #72	; 0x48
 8010ea0:	4770      	bx	lr
 8010ea2:	bf00      	nop

08010ea4 <_Unwind_Backtrace>:
 8010ea4:	46ec      	mov	ip, sp
 8010ea6:	b500      	push	{lr}
 8010ea8:	e92d 5000 	stmdb	sp!, {ip, lr}
 8010eac:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8010eb0:	f04f 0300 	mov.w	r3, #0
 8010eb4:	e92d 000c 	stmdb	sp!, {r2, r3}
 8010eb8:	aa01      	add	r2, sp, #4
 8010eba:	f7ff fdc3 	bl	8010a44 <__gnu_Unwind_Backtrace>
 8010ebe:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8010ec2:	b012      	add	sp, #72	; 0x48
 8010ec4:	4770      	bx	lr
 8010ec6:	bf00      	nop

08010ec8 <next_unwind_byte>:
 8010ec8:	7a02      	ldrb	r2, [r0, #8]
 8010eca:	4603      	mov	r3, r0
 8010ecc:	b91a      	cbnz	r2, 8010ed6 <next_unwind_byte+0xe>
 8010ece:	7a42      	ldrb	r2, [r0, #9]
 8010ed0:	b942      	cbnz	r2, 8010ee4 <next_unwind_byte+0x1c>
 8010ed2:	20b0      	movs	r0, #176	; 0xb0
 8010ed4:	4770      	bx	lr
 8010ed6:	6800      	ldr	r0, [r0, #0]
 8010ed8:	3a01      	subs	r2, #1
 8010eda:	721a      	strb	r2, [r3, #8]
 8010edc:	0202      	lsls	r2, r0, #8
 8010ede:	0e00      	lsrs	r0, r0, #24
 8010ee0:	601a      	str	r2, [r3, #0]
 8010ee2:	4770      	bx	lr
 8010ee4:	6841      	ldr	r1, [r0, #4]
 8010ee6:	3a01      	subs	r2, #1
 8010ee8:	7242      	strb	r2, [r0, #9]
 8010eea:	2203      	movs	r2, #3
 8010eec:	f851 0b04 	ldr.w	r0, [r1], #4
 8010ef0:	721a      	strb	r2, [r3, #8]
 8010ef2:	6059      	str	r1, [r3, #4]
 8010ef4:	e7f2      	b.n	8010edc <next_unwind_byte+0x14>
 8010ef6:	bf00      	nop

08010ef8 <_Unwind_GetGR.constprop.0>:
 8010ef8:	b500      	push	{lr}
 8010efa:	b085      	sub	sp, #20
 8010efc:	2100      	movs	r1, #0
 8010efe:	220c      	movs	r2, #12
 8010f00:	eb0d 0302 	add.w	r3, sp, r2
 8010f04:	9300      	str	r3, [sp, #0]
 8010f06:	460b      	mov	r3, r1
 8010f08:	f7ff fbd4 	bl	80106b4 <_Unwind_VRS_Get>
 8010f0c:	9803      	ldr	r0, [sp, #12]
 8010f0e:	b005      	add	sp, #20
 8010f10:	bd00      	pop	{pc}
 8010f12:	bf00      	nop

08010f14 <unwind_UCB_from_context>:
 8010f14:	f7ff bff0 	b.w	8010ef8 <_Unwind_GetGR.constprop.0>

08010f18 <__gnu_unwind_execute>:
 8010f18:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8010f1c:	4606      	mov	r6, r0
 8010f1e:	b085      	sub	sp, #20
 8010f20:	460d      	mov	r5, r1
 8010f22:	f04f 0800 	mov.w	r8, #0
 8010f26:	4628      	mov	r0, r5
 8010f28:	f7ff ffce 	bl	8010ec8 <next_unwind_byte>
 8010f2c:	28b0      	cmp	r0, #176	; 0xb0
 8010f2e:	4604      	mov	r4, r0
 8010f30:	f000 80bf 	beq.w	80110b2 <__gnu_unwind_execute+0x19a>
 8010f34:	f020 027f 	bic.w	r2, r0, #127	; 0x7f
 8010f38:	b2d1      	uxtb	r1, r2
 8010f3a:	b301      	cbz	r1, 8010f7e <__gnu_unwind_execute+0x66>
 8010f3c:	f000 02f0 	and.w	r2, r0, #240	; 0xf0
 8010f40:	2a80      	cmp	r2, #128	; 0x80
 8010f42:	d07a      	beq.n	801103a <__gnu_unwind_execute+0x122>
 8010f44:	2a90      	cmp	r2, #144	; 0x90
 8010f46:	d03a      	beq.n	8010fbe <__gnu_unwind_execute+0xa6>
 8010f48:	2aa0      	cmp	r2, #160	; 0xa0
 8010f4a:	d046      	beq.n	8010fda <__gnu_unwind_execute+0xc2>
 8010f4c:	2ab0      	cmp	r2, #176	; 0xb0
 8010f4e:	d05b      	beq.n	8011008 <__gnu_unwind_execute+0xf0>
 8010f50:	2ac0      	cmp	r2, #192	; 0xc0
 8010f52:	f000 808a 	beq.w	801106a <__gnu_unwind_execute+0x152>
 8010f56:	f000 03f8 	and.w	r3, r0, #248	; 0xf8
 8010f5a:	2bd0      	cmp	r3, #208	; 0xd0
 8010f5c:	d10b      	bne.n	8010f76 <__gnu_unwind_execute+0x5e>
 8010f5e:	f000 0407 	and.w	r4, r0, #7
 8010f62:	2101      	movs	r1, #1
 8010f64:	1c62      	adds	r2, r4, #1
 8010f66:	4630      	mov	r0, r6
 8010f68:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8010f6c:	2305      	movs	r3, #5
 8010f6e:	f7ff fda1 	bl	8010ab4 <_Unwind_VRS_Pop>
 8010f72:	2800      	cmp	r0, #0
 8010f74:	d0d7      	beq.n	8010f26 <__gnu_unwind_execute+0xe>
 8010f76:	2009      	movs	r0, #9
 8010f78:	b005      	add	sp, #20
 8010f7a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8010f7e:	ea4f 0980 	mov.w	r9, r0, lsl #2
 8010f82:	f004 0440 	and.w	r4, r4, #64	; 0x40
 8010f86:	460b      	mov	r3, r1
 8010f88:	af03      	add	r7, sp, #12
 8010f8a:	4630      	mov	r0, r6
 8010f8c:	fa5f f989 	uxtb.w	r9, r9
 8010f90:	9700      	str	r7, [sp, #0]
 8010f92:	220d      	movs	r2, #13
 8010f94:	b2e4      	uxtb	r4, r4
 8010f96:	f7ff fb8d 	bl	80106b4 <_Unwind_VRS_Get>
 8010f9a:	f109 0904 	add.w	r9, r9, #4
 8010f9e:	9b03      	ldr	r3, [sp, #12]
 8010fa0:	b94c      	cbnz	r4, 8010fb6 <__gnu_unwind_execute+0x9e>
 8010fa2:	444b      	add	r3, r9
 8010fa4:	9303      	str	r3, [sp, #12]
 8010fa6:	2100      	movs	r1, #0
 8010fa8:	9700      	str	r7, [sp, #0]
 8010faa:	4630      	mov	r0, r6
 8010fac:	220d      	movs	r2, #13
 8010fae:	460b      	mov	r3, r1
 8010fb0:	f7ff fba4 	bl	80106fc <_Unwind_VRS_Set>
 8010fb4:	e7b7      	b.n	8010f26 <__gnu_unwind_execute+0xe>
 8010fb6:	ebc9 0303 	rsb	r3, r9, r3
 8010fba:	9303      	str	r3, [sp, #12]
 8010fbc:	e7f3      	b.n	8010fa6 <__gnu_unwind_execute+0x8e>
 8010fbe:	f000 030d 	and.w	r3, r0, #13
 8010fc2:	2b0d      	cmp	r3, #13
 8010fc4:	d0d7      	beq.n	8010f76 <__gnu_unwind_execute+0x5e>
 8010fc6:	2100      	movs	r1, #0
 8010fc8:	af03      	add	r7, sp, #12
 8010fca:	f000 020f 	and.w	r2, r0, #15
 8010fce:	460b      	mov	r3, r1
 8010fd0:	9700      	str	r7, [sp, #0]
 8010fd2:	4630      	mov	r0, r6
 8010fd4:	f7ff fb6e 	bl	80106b4 <_Unwind_VRS_Get>
 8010fd8:	e7e5      	b.n	8010fa6 <__gnu_unwind_execute+0x8e>
 8010fda:	f000 0308 	and.w	r3, r0, #8
 8010fde:	43c4      	mvns	r4, r0
 8010fe0:	f44f 627f 	mov.w	r2, #4080	; 0xff0
 8010fe4:	f004 0407 	and.w	r4, r4, #7
 8010fe8:	b2db      	uxtb	r3, r3
 8010fea:	fa42 f204 	asr.w	r2, r2, r4
 8010fee:	f402 627f 	and.w	r2, r2, #4080	; 0xff0
 8010ff2:	b10b      	cbz	r3, 8010ff8 <__gnu_unwind_execute+0xe0>
 8010ff4:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8010ff8:	2100      	movs	r1, #0
 8010ffa:	4630      	mov	r0, r6
 8010ffc:	460b      	mov	r3, r1
 8010ffe:	f7ff fd59 	bl	8010ab4 <_Unwind_VRS_Pop>
 8011002:	2800      	cmp	r0, #0
 8011004:	d1b7      	bne.n	8010f76 <__gnu_unwind_execute+0x5e>
 8011006:	e78e      	b.n	8010f26 <__gnu_unwind_execute+0xe>
 8011008:	28b1      	cmp	r0, #177	; 0xb1
 801100a:	d076      	beq.n	80110fa <__gnu_unwind_execute+0x1e2>
 801100c:	28b2      	cmp	r0, #178	; 0xb2
 801100e:	f000 8087 	beq.w	8011120 <__gnu_unwind_execute+0x208>
 8011012:	28b3      	cmp	r0, #179	; 0xb3
 8011014:	f000 80b6 	beq.w	8011184 <__gnu_unwind_execute+0x26c>
 8011018:	f000 03fc 	and.w	r3, r0, #252	; 0xfc
 801101c:	2bb4      	cmp	r3, #180	; 0xb4
 801101e:	d05e      	beq.n	80110de <__gnu_unwind_execute+0x1c6>
 8011020:	f000 0207 	and.w	r2, r0, #7
 8011024:	2101      	movs	r1, #1
 8011026:	1852      	adds	r2, r2, r1
 8011028:	4630      	mov	r0, r6
 801102a:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 801102e:	460b      	mov	r3, r1
 8011030:	f7ff fd40 	bl	8010ab4 <_Unwind_VRS_Pop>
 8011034:	2800      	cmp	r0, #0
 8011036:	d19e      	bne.n	8010f76 <__gnu_unwind_execute+0x5e>
 8011038:	e775      	b.n	8010f26 <__gnu_unwind_execute+0xe>
 801103a:	4628      	mov	r0, r5
 801103c:	0224      	lsls	r4, r4, #8
 801103e:	f7ff ff43 	bl	8010ec8 <next_unwind_byte>
 8011042:	4304      	orrs	r4, r0
 8011044:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
 8011048:	d095      	beq.n	8010f76 <__gnu_unwind_execute+0x5e>
 801104a:	0522      	lsls	r2, r4, #20
 801104c:	2100      	movs	r1, #0
 801104e:	4630      	mov	r0, r6
 8011050:	460b      	mov	r3, r1
 8011052:	0c12      	lsrs	r2, r2, #16
 8011054:	0124      	lsls	r4, r4, #4
 8011056:	f7ff fd2d 	bl	8010ab4 <_Unwind_VRS_Pop>
 801105a:	2800      	cmp	r0, #0
 801105c:	d18b      	bne.n	8010f76 <__gnu_unwind_execute+0x5e>
 801105e:	f414 4f00 	tst.w	r4, #32768	; 0x8000
 8011062:	bf18      	it	ne
 8011064:	f04f 0801 	movne.w	r8, #1
 8011068:	e75d      	b.n	8010f26 <__gnu_unwind_execute+0xe>
 801106a:	28c6      	cmp	r0, #198	; 0xc6
 801106c:	f000 809d 	beq.w	80111aa <__gnu_unwind_execute+0x292>
 8011070:	28c7      	cmp	r0, #199	; 0xc7
 8011072:	f000 80a4 	beq.w	80111be <__gnu_unwind_execute+0x2a6>
 8011076:	f000 03f8 	and.w	r3, r0, #248	; 0xf8
 801107a:	2bc0      	cmp	r3, #192	; 0xc0
 801107c:	f000 80b2 	beq.w	80111e4 <__gnu_unwind_execute+0x2cc>
 8011080:	28c8      	cmp	r0, #200	; 0xc8
 8011082:	f000 80bd 	beq.w	8011200 <__gnu_unwind_execute+0x2e8>
 8011086:	28c9      	cmp	r0, #201	; 0xc9
 8011088:	f47f af75 	bne.w	8010f76 <__gnu_unwind_execute+0x5e>
 801108c:	4628      	mov	r0, r5
 801108e:	f7ff ff1b 	bl	8010ec8 <next_unwind_byte>
 8011092:	f000 030f 	and.w	r3, r0, #15
 8011096:	f000 02f0 	and.w	r2, r0, #240	; 0xf0
 801109a:	3301      	adds	r3, #1
 801109c:	4630      	mov	r0, r6
 801109e:	ea43 3202 	orr.w	r2, r3, r2, lsl #12
 80110a2:	2101      	movs	r1, #1
 80110a4:	2305      	movs	r3, #5
 80110a6:	f7ff fd05 	bl	8010ab4 <_Unwind_VRS_Pop>
 80110aa:	2800      	cmp	r0, #0
 80110ac:	f47f af63 	bne.w	8010f76 <__gnu_unwind_execute+0x5e>
 80110b0:	e739      	b.n	8010f26 <__gnu_unwind_execute+0xe>
 80110b2:	2000      	movs	r0, #0
 80110b4:	f1b8 0f00 	cmp.w	r8, #0
 80110b8:	f47f af5e 	bne.w	8010f78 <__gnu_unwind_execute+0x60>
 80110bc:	ac03      	add	r4, sp, #12
 80110be:	4641      	mov	r1, r8
 80110c0:	220e      	movs	r2, #14
 80110c2:	4643      	mov	r3, r8
 80110c4:	9400      	str	r4, [sp, #0]
 80110c6:	4630      	mov	r0, r6
 80110c8:	f7ff faf4 	bl	80106b4 <_Unwind_VRS_Get>
 80110cc:	9400      	str	r4, [sp, #0]
 80110ce:	4630      	mov	r0, r6
 80110d0:	4641      	mov	r1, r8
 80110d2:	220f      	movs	r2, #15
 80110d4:	4643      	mov	r3, r8
 80110d6:	f7ff fb11 	bl	80106fc <_Unwind_VRS_Set>
 80110da:	4640      	mov	r0, r8
 80110dc:	e74c      	b.n	8010f78 <__gnu_unwind_execute+0x60>
 80110de:	f000 0203 	and.w	r2, r0, #3
 80110e2:	2102      	movs	r1, #2
 80110e4:	3201      	adds	r2, #1
 80110e6:	4630      	mov	r0, r6
 80110e8:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80110ec:	460b      	mov	r3, r1
 80110ee:	f7ff fce1 	bl	8010ab4 <_Unwind_VRS_Pop>
 80110f2:	2800      	cmp	r0, #0
 80110f4:	f47f af3f 	bne.w	8010f76 <__gnu_unwind_execute+0x5e>
 80110f8:	e715      	b.n	8010f26 <__gnu_unwind_execute+0xe>
 80110fa:	4628      	mov	r0, r5
 80110fc:	f7ff fee4 	bl	8010ec8 <next_unwind_byte>
 8011100:	4602      	mov	r2, r0
 8011102:	2800      	cmp	r0, #0
 8011104:	f43f af37 	beq.w	8010f76 <__gnu_unwind_execute+0x5e>
 8011108:	f010 01f0 	ands.w	r1, r0, #240	; 0xf0
 801110c:	f47f af33 	bne.w	8010f76 <__gnu_unwind_execute+0x5e>
 8011110:	4630      	mov	r0, r6
 8011112:	460b      	mov	r3, r1
 8011114:	f7ff fcce 	bl	8010ab4 <_Unwind_VRS_Pop>
 8011118:	2800      	cmp	r0, #0
 801111a:	f47f af2c 	bne.w	8010f76 <__gnu_unwind_execute+0x5e>
 801111e:	e702      	b.n	8010f26 <__gnu_unwind_execute+0xe>
 8011120:	2100      	movs	r1, #0
 8011122:	220d      	movs	r2, #13
 8011124:	460b      	mov	r3, r1
 8011126:	af03      	add	r7, sp, #12
 8011128:	4630      	mov	r0, r6
 801112a:	9700      	str	r7, [sp, #0]
 801112c:	f7ff fac2 	bl	80106b4 <_Unwind_VRS_Get>
 8011130:	4628      	mov	r0, r5
 8011132:	f7ff fec9 	bl	8010ec8 <next_unwind_byte>
 8011136:	2402      	movs	r4, #2
 8011138:	f020 037f 	bic.w	r3, r0, #127	; 0x7f
 801113c:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011140:	d00f      	beq.n	8011162 <__gnu_unwind_execute+0x24a>
 8011142:	f000 027f 	and.w	r2, r0, #127	; 0x7f
 8011146:	9b03      	ldr	r3, [sp, #12]
 8011148:	4628      	mov	r0, r5
 801114a:	fa02 f204 	lsl.w	r2, r2, r4
 801114e:	3407      	adds	r4, #7
 8011150:	189b      	adds	r3, r3, r2
 8011152:	9303      	str	r3, [sp, #12]
 8011154:	f7ff feb8 	bl	8010ec8 <next_unwind_byte>
 8011158:	f020 037f 	bic.w	r3, r0, #127	; 0x7f
 801115c:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011160:	d1ef      	bne.n	8011142 <__gnu_unwind_execute+0x22a>
 8011162:	9b03      	ldr	r3, [sp, #12]
 8011164:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 8011168:	2100      	movs	r1, #0
 801116a:	9700      	str	r7, [sp, #0]
 801116c:	fa00 f404 	lsl.w	r4, r0, r4
 8011170:	f503 7701 	add.w	r7, r3, #516	; 0x204
 8011174:	4630      	mov	r0, r6
 8011176:	220d      	movs	r2, #13
 8011178:	460b      	mov	r3, r1
 801117a:	193c      	adds	r4, r7, r4
 801117c:	9403      	str	r4, [sp, #12]
 801117e:	f7ff fabd 	bl	80106fc <_Unwind_VRS_Set>
 8011182:	e6d0      	b.n	8010f26 <__gnu_unwind_execute+0xe>
 8011184:	4628      	mov	r0, r5
 8011186:	f7ff fe9f 	bl	8010ec8 <next_unwind_byte>
 801118a:	2101      	movs	r1, #1
 801118c:	f000 030f 	and.w	r3, r0, #15
 8011190:	f000 02f0 	and.w	r2, r0, #240	; 0xf0
 8011194:	3301      	adds	r3, #1
 8011196:	ea43 3202 	orr.w	r2, r3, r2, lsl #12
 801119a:	4630      	mov	r0, r6
 801119c:	460b      	mov	r3, r1
 801119e:	f7ff fc89 	bl	8010ab4 <_Unwind_VRS_Pop>
 80111a2:	2800      	cmp	r0, #0
 80111a4:	f47f aee7 	bne.w	8010f76 <__gnu_unwind_execute+0x5e>
 80111a8:	e6bd      	b.n	8010f26 <__gnu_unwind_execute+0xe>
 80111aa:	4628      	mov	r0, r5
 80111ac:	f7ff fe8c 	bl	8010ec8 <next_unwind_byte>
 80111b0:	2103      	movs	r1, #3
 80111b2:	f000 030f 	and.w	r3, r0, #15
 80111b6:	f000 02f0 	and.w	r2, r0, #240	; 0xf0
 80111ba:	3301      	adds	r3, #1
 80111bc:	e7eb      	b.n	8011196 <__gnu_unwind_execute+0x27e>
 80111be:	4628      	mov	r0, r5
 80111c0:	f7ff fe82 	bl	8010ec8 <next_unwind_byte>
 80111c4:	4602      	mov	r2, r0
 80111c6:	2800      	cmp	r0, #0
 80111c8:	f43f aed5 	beq.w	8010f76 <__gnu_unwind_execute+0x5e>
 80111cc:	f010 03f0 	ands.w	r3, r0, #240	; 0xf0
 80111d0:	f47f aed1 	bne.w	8010f76 <__gnu_unwind_execute+0x5e>
 80111d4:	4630      	mov	r0, r6
 80111d6:	2104      	movs	r1, #4
 80111d8:	f7ff fc6c 	bl	8010ab4 <_Unwind_VRS_Pop>
 80111dc:	2800      	cmp	r0, #0
 80111de:	f47f aeca 	bne.w	8010f76 <__gnu_unwind_execute+0x5e>
 80111e2:	e6a0      	b.n	8010f26 <__gnu_unwind_execute+0xe>
 80111e4:	f000 020f 	and.w	r2, r0, #15
 80111e8:	2103      	movs	r1, #3
 80111ea:	3201      	adds	r2, #1
 80111ec:	4630      	mov	r0, r6
 80111ee:	f442 2220 	orr.w	r2, r2, #655360	; 0xa0000
 80111f2:	460b      	mov	r3, r1
 80111f4:	f7ff fc5e 	bl	8010ab4 <_Unwind_VRS_Pop>
 80111f8:	2800      	cmp	r0, #0
 80111fa:	f47f aebc 	bne.w	8010f76 <__gnu_unwind_execute+0x5e>
 80111fe:	e692      	b.n	8010f26 <__gnu_unwind_execute+0xe>
 8011200:	4628      	mov	r0, r5
 8011202:	f7ff fe61 	bl	8010ec8 <next_unwind_byte>
 8011206:	f000 02f0 	and.w	r2, r0, #240	; 0xf0
 801120a:	f000 030f 	and.w	r3, r0, #15
 801120e:	3210      	adds	r2, #16
 8011210:	e743      	b.n	801109a <__gnu_unwind_execute+0x182>
 8011212:	bf00      	nop

08011214 <__gnu_unwind_frame>:
 8011214:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8011216:	4608      	mov	r0, r1
 8011218:	b530      	push	{r4, r5, lr}
 801121a:	b085      	sub	sp, #20
 801121c:	685a      	ldr	r2, [r3, #4]
 801121e:	f103 0408 	add.w	r4, r3, #8
 8011222:	2503      	movs	r5, #3
 8011224:	f88d 500c 	strb.w	r5, [sp, #12]
 8011228:	79db      	ldrb	r3, [r3, #7]
 801122a:	a901      	add	r1, sp, #4
 801122c:	0212      	lsls	r2, r2, #8
 801122e:	9402      	str	r4, [sp, #8]
 8011230:	9201      	str	r2, [sp, #4]
 8011232:	f88d 300d 	strb.w	r3, [sp, #13]
 8011236:	f7ff fe6f 	bl	8010f18 <__gnu_unwind_execute>
 801123a:	b005      	add	sp, #20
 801123c:	bd30      	pop	{r4, r5, pc}
 801123e:	bf00      	nop

08011240 <_Unwind_GetRegionStart>:
 8011240:	b508      	push	{r3, lr}
 8011242:	f7ff fe67 	bl	8010f14 <unwind_UCB_from_context>
 8011246:	6c80      	ldr	r0, [r0, #72]	; 0x48
 8011248:	bd08      	pop	{r3, pc}
 801124a:	bf00      	nop

0801124c <_Unwind_GetLanguageSpecificData>:
 801124c:	b508      	push	{r3, lr}
 801124e:	f7ff fe61 	bl	8010f14 <unwind_UCB_from_context>
 8011252:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8011254:	79da      	ldrb	r2, [r3, #7]
 8011256:	eb03 0082 	add.w	r0, r3, r2, lsl #2
 801125a:	3008      	adds	r0, #8
 801125c:	bd08      	pop	{r3, pc}
 801125e:	bf00      	nop

08011260 <_Unwind_GetDataRelBase>:
 8011260:	b508      	push	{r3, lr}
 8011262:	f000 f805 	bl	8011270 <abort>
 8011266:	bf00      	nop

08011268 <_Unwind_GetTextRelBase>:
 8011268:	b508      	push	{r3, lr}
 801126a:	f000 f801 	bl	8011270 <abort>
 801126e:	bf00      	nop

08011270 <abort>:
 8011270:	b508      	push	{r3, lr}
 8011272:	2006      	movs	r0, #6
 8011274:	f001 fa7c 	bl	8012770 <raise>
 8011278:	2001      	movs	r0, #1
 801127a:	f7f7 fa15 	bl	80086a8 <_exit>
 801127e:	bf00      	nop

08011280 <atexit>:
 8011280:	4601      	mov	r1, r0
 8011282:	2000      	movs	r0, #0
 8011284:	4602      	mov	r2, r0
 8011286:	4603      	mov	r3, r0
 8011288:	f001 bdcc 	b.w	8012e24 <__register_exitproc>

0801128c <exit>:
 801128c:	b508      	push	{r3, lr}
 801128e:	2100      	movs	r1, #0
 8011290:	4604      	mov	r4, r0
 8011292:	f001 fe1f 	bl	8012ed4 <__call_exitprocs>
 8011296:	4b04      	ldr	r3, [pc, #16]	; (80112a8 <exit+0x1c>)
 8011298:	6818      	ldr	r0, [r3, #0]
 801129a:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 801129c:	b103      	cbz	r3, 80112a0 <exit+0x14>
 801129e:	4798      	blx	r3
 80112a0:	4620      	mov	r0, r4
 80112a2:	f7f7 fa01 	bl	80086a8 <_exit>
 80112a6:	bf00      	nop
 80112a8:	0801ffb0 	.word	0x0801ffb0

080112ac <__libc_fini_array>:
 80112ac:	b538      	push	{r3, r4, r5, lr}
 80112ae:	4d08      	ldr	r5, [pc, #32]	; (80112d0 <__libc_fini_array+0x24>)
 80112b0:	4c08      	ldr	r4, [pc, #32]	; (80112d4 <__libc_fini_array+0x28>)
 80112b2:	1b64      	subs	r4, r4, r5
 80112b4:	10a4      	asrs	r4, r4, #2
 80112b6:	bf18      	it	ne
 80112b8:	eb05 0584 	addne.w	r5, r5, r4, lsl #2
 80112bc:	d004      	beq.n	80112c8 <__libc_fini_array+0x1c>
 80112be:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 80112c2:	4798      	blx	r3
 80112c4:	3c01      	subs	r4, #1
 80112c6:	d1fa      	bne.n	80112be <__libc_fini_array+0x12>
 80112c8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80112cc:	f00c bed6 	b.w	801e07c <_fini>
 80112d0:	08021c78 	.word	0x08021c78
 80112d4:	08021c7c 	.word	0x08021c7c

080112d8 <_fputc_r>:
 80112d8:	b510      	push	{r4, lr}
 80112da:	4604      	mov	r4, r0
 80112dc:	b082      	sub	sp, #8
 80112de:	b138      	cbz	r0, 80112f0 <_fputc_r+0x18>
 80112e0:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80112e2:	b92b      	cbnz	r3, 80112f0 <_fputc_r+0x18>
 80112e4:	9101      	str	r1, [sp, #4]
 80112e6:	9200      	str	r2, [sp, #0]
 80112e8:	f001 ff8a 	bl	8013200 <__sinit>
 80112ec:	9a00      	ldr	r2, [sp, #0]
 80112ee:	9901      	ldr	r1, [sp, #4]
 80112f0:	4620      	mov	r0, r4
 80112f2:	b002      	add	sp, #8
 80112f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80112f8:	f000 be7c 	b.w	8011ff4 <_putc_r>

080112fc <fputc>:
 80112fc:	b570      	push	{r4, r5, r6, lr}
 80112fe:	4606      	mov	r6, r0
 8011300:	4c07      	ldr	r4, [pc, #28]	; (8011320 <fputc+0x24>)
 8011302:	460d      	mov	r5, r1
 8011304:	6820      	ldr	r0, [r4, #0]
 8011306:	b120      	cbz	r0, 8011312 <fputc+0x16>
 8011308:	6b83      	ldr	r3, [r0, #56]	; 0x38
 801130a:	b913      	cbnz	r3, 8011312 <fputc+0x16>
 801130c:	f001 ff78 	bl	8013200 <__sinit>
 8011310:	6820      	ldr	r0, [r4, #0]
 8011312:	4631      	mov	r1, r6
 8011314:	462a      	mov	r2, r5
 8011316:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 801131a:	f000 be6b 	b.w	8011ff4 <_putc_r>
 801131e:	bf00      	nop
 8011320:	200000b0 	.word	0x200000b0

08011324 <_fputs_r>:
 8011324:	b530      	push	{r4, r5, lr}
 8011326:	b087      	sub	sp, #28
 8011328:	4605      	mov	r5, r0
 801132a:	4608      	mov	r0, r1
 801132c:	4614      	mov	r4, r2
 801132e:	9101      	str	r1, [sp, #4]
 8011330:	f001 fc22 	bl	8012b78 <strlen>
 8011334:	ab01      	add	r3, sp, #4
 8011336:	9303      	str	r3, [sp, #12]
 8011338:	2301      	movs	r3, #1
 801133a:	9304      	str	r3, [sp, #16]
 801133c:	9005      	str	r0, [sp, #20]
 801133e:	9002      	str	r0, [sp, #8]
 8011340:	b10d      	cbz	r5, 8011346 <_fputs_r+0x22>
 8011342:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8011344:	b193      	cbz	r3, 801136c <_fputs_r+0x48>
 8011346:	89a3      	ldrh	r3, [r4, #12]
 8011348:	f403 5200 	and.w	r2, r3, #8192	; 0x2000
 801134c:	b212      	sxth	r2, r2
 801134e:	b932      	cbnz	r2, 801135e <_fputs_r+0x3a>
 8011350:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8011352:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8011356:	81a3      	strh	r3, [r4, #12]
 8011358:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 801135c:	6662      	str	r2, [r4, #100]	; 0x64
 801135e:	4628      	mov	r0, r5
 8011360:	4621      	mov	r1, r4
 8011362:	aa03      	add	r2, sp, #12
 8011364:	f000 f810 	bl	8011388 <__sfvwrite_r>
 8011368:	b007      	add	sp, #28
 801136a:	bd30      	pop	{r4, r5, pc}
 801136c:	4628      	mov	r0, r5
 801136e:	f001 ff47 	bl	8013200 <__sinit>
 8011372:	e7e8      	b.n	8011346 <_fputs_r+0x22>

08011374 <fputs>:
 8011374:	f240 03b0 	movw	r3, #176	; 0xb0
 8011378:	460a      	mov	r2, r1
 801137a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801137e:	4601      	mov	r1, r0
 8011380:	6818      	ldr	r0, [r3, #0]
 8011382:	f7ff bfcf 	b.w	8011324 <_fputs_r>
 8011386:	bf00      	nop

08011388 <__sfvwrite_r>:
 8011388:	6893      	ldr	r3, [r2, #8]
 801138a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801138e:	4690      	mov	r8, r2
 8011390:	b085      	sub	sp, #20
 8011392:	4681      	mov	r9, r0
 8011394:	460c      	mov	r4, r1
 8011396:	2b00      	cmp	r3, #0
 8011398:	d02b      	beq.n	80113f2 <__sfvwrite_r+0x6a>
 801139a:	898b      	ldrh	r3, [r1, #12]
 801139c:	f003 0208 	and.w	r2, r3, #8
 80113a0:	b212      	sxth	r2, r2
 80113a2:	2a00      	cmp	r2, #0
 80113a4:	d029      	beq.n	80113fa <__sfvwrite_r+0x72>
 80113a6:	690a      	ldr	r2, [r1, #16]
 80113a8:	2a00      	cmp	r2, #0
 80113aa:	d026      	beq.n	80113fa <__sfvwrite_r+0x72>
 80113ac:	f003 0202 	and.w	r2, r3, #2
 80113b0:	f8d8 5000 	ldr.w	r5, [r8]
 80113b4:	b212      	sxth	r2, r2
 80113b6:	2a00      	cmp	r2, #0
 80113b8:	d02e      	beq.n	8011418 <__sfvwrite_r+0x90>
 80113ba:	f04f 0a00 	mov.w	sl, #0
 80113be:	4657      	mov	r7, sl
 80113c0:	f5b7 6f80 	cmp.w	r7, #1024	; 0x400
 80113c4:	bf34      	ite	cc
 80113c6:	463b      	movcc	r3, r7
 80113c8:	f44f 6380 	movcs.w	r3, #1024	; 0x400
 80113cc:	4652      	mov	r2, sl
 80113ce:	4648      	mov	r0, r9
 80113d0:	2f00      	cmp	r7, #0
 80113d2:	d05d      	beq.n	8011490 <__sfvwrite_r+0x108>
 80113d4:	69e1      	ldr	r1, [r4, #28]
 80113d6:	6a66      	ldr	r6, [r4, #36]	; 0x24
 80113d8:	47b0      	blx	r6
 80113da:	2800      	cmp	r0, #0
 80113dc:	4482      	add	sl, r0
 80113de:	ebc0 0707 	rsb	r7, r0, r7
 80113e2:	dd67      	ble.n	80114b4 <__sfvwrite_r+0x12c>
 80113e4:	f8d8 3008 	ldr.w	r3, [r8, #8]
 80113e8:	1a18      	subs	r0, r3, r0
 80113ea:	f8c8 0008 	str.w	r0, [r8, #8]
 80113ee:	2800      	cmp	r0, #0
 80113f0:	d1e6      	bne.n	80113c0 <__sfvwrite_r+0x38>
 80113f2:	2000      	movs	r0, #0
 80113f4:	b005      	add	sp, #20
 80113f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80113fa:	4648      	mov	r0, r9
 80113fc:	4621      	mov	r1, r4
 80113fe:	f001 fca3 	bl	8012d48 <__swsetup_r>
 8011402:	2800      	cmp	r0, #0
 8011404:	f040 814b 	bne.w	801169e <__sfvwrite_r+0x316>
 8011408:	89a3      	ldrh	r3, [r4, #12]
 801140a:	f8d8 5000 	ldr.w	r5, [r8]
 801140e:	f003 0202 	and.w	r2, r3, #2
 8011412:	b212      	sxth	r2, r2
 8011414:	2a00      	cmp	r2, #0
 8011416:	d1d0      	bne.n	80113ba <__sfvwrite_r+0x32>
 8011418:	f013 0a01 	ands.w	sl, r3, #1
 801141c:	d151      	bne.n	80114c2 <__sfvwrite_r+0x13a>
 801141e:	4656      	mov	r6, sl
 8011420:	2e00      	cmp	r6, #0
 8011422:	d030      	beq.n	8011486 <__sfvwrite_r+0xfe>
 8011424:	f403 7200 	and.w	r2, r3, #512	; 0x200
 8011428:	68a7      	ldr	r7, [r4, #8]
 801142a:	4619      	mov	r1, r3
 801142c:	b212      	sxth	r2, r2
 801142e:	2a00      	cmp	r2, #0
 8011430:	f000 8083 	beq.w	801153a <__sfvwrite_r+0x1b2>
 8011434:	42be      	cmp	r6, r7
 8011436:	46bc      	mov	ip, r7
 8011438:	f0c0 80b0 	bcc.w	801159c <__sfvwrite_r+0x214>
 801143c:	f401 6190 	and.w	r1, r1, #1152	; 0x480
 8011440:	2900      	cmp	r1, #0
 8011442:	f040 80cc 	bne.w	80115de <__sfvwrite_r+0x256>
 8011446:	6820      	ldr	r0, [r4, #0]
 8011448:	46b3      	mov	fp, r6
 801144a:	9703      	str	r7, [sp, #12]
 801144c:	4637      	mov	r7, r6
 801144e:	4662      	mov	r2, ip
 8011450:	4651      	mov	r1, sl
 8011452:	f8cd c004 	str.w	ip, [sp, #4]
 8011456:	f000 fd1f 	bl	8011e98 <memmove>
 801145a:	68a1      	ldr	r1, [r4, #8]
 801145c:	6822      	ldr	r2, [r4, #0]
 801145e:	f8dd c004 	ldr.w	ip, [sp, #4]
 8011462:	9b03      	ldr	r3, [sp, #12]
 8011464:	4462      	add	r2, ip
 8011466:	6022      	str	r2, [r4, #0]
 8011468:	1ac9      	subs	r1, r1, r3
 801146a:	60a1      	str	r1, [r4, #8]
 801146c:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8011470:	44da      	add	sl, fp
 8011472:	ebcb 0606 	rsb	r6, fp, r6
 8011476:	1bd7      	subs	r7, r2, r7
 8011478:	f8c8 7008 	str.w	r7, [r8, #8]
 801147c:	2f00      	cmp	r7, #0
 801147e:	d0b8      	beq.n	80113f2 <__sfvwrite_r+0x6a>
 8011480:	89a3      	ldrh	r3, [r4, #12]
 8011482:	2e00      	cmp	r6, #0
 8011484:	d1ce      	bne.n	8011424 <__sfvwrite_r+0x9c>
 8011486:	f8d5 a000 	ldr.w	sl, [r5]
 801148a:	686e      	ldr	r6, [r5, #4]
 801148c:	3508      	adds	r5, #8
 801148e:	e7c7      	b.n	8011420 <__sfvwrite_r+0x98>
 8011490:	f8d5 a000 	ldr.w	sl, [r5]
 8011494:	686f      	ldr	r7, [r5, #4]
 8011496:	3508      	adds	r5, #8
 8011498:	e792      	b.n	80113c0 <__sfvwrite_r+0x38>
 801149a:	f000 fe53 	bl	8012144 <_realloc_r>
 801149e:	4603      	mov	r3, r0
 80114a0:	2800      	cmp	r0, #0
 80114a2:	f040 80c8 	bne.w	8011636 <__sfvwrite_r+0x2ae>
 80114a6:	4648      	mov	r0, r9
 80114a8:	6921      	ldr	r1, [r4, #16]
 80114aa:	f001 ff7f 	bl	80133ac <_free_r>
 80114ae:	230c      	movs	r3, #12
 80114b0:	f8c9 3000 	str.w	r3, [r9]
 80114b4:	89a3      	ldrh	r3, [r4, #12]
 80114b6:	f04f 30ff 	mov.w	r0, #4294967295
 80114ba:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80114be:	81a3      	strh	r3, [r4, #12]
 80114c0:	e798      	b.n	80113f4 <__sfvwrite_r+0x6c>
 80114c2:	4692      	mov	sl, r2
 80114c4:	4694      	mov	ip, r2
 80114c6:	4693      	mov	fp, r2
 80114c8:	4617      	mov	r7, r2
 80114ca:	2f00      	cmp	r7, #0
 80114cc:	d02e      	beq.n	801152c <__sfvwrite_r+0x1a4>
 80114ce:	f1bc 0f00 	cmp.w	ip, #0
 80114d2:	d076      	beq.n	80115c2 <__sfvwrite_r+0x23a>
 80114d4:	6820      	ldr	r0, [r4, #0]
 80114d6:	45ba      	cmp	sl, r7
 80114d8:	bf34      	ite	cc
 80114da:	4653      	movcc	r3, sl
 80114dc:	463b      	movcs	r3, r7
 80114de:	6922      	ldr	r2, [r4, #16]
 80114e0:	68a6      	ldr	r6, [r4, #8]
 80114e2:	4290      	cmp	r0, r2
 80114e4:	f8d4 e014 	ldr.w	lr, [r4, #20]
 80114e8:	d903      	bls.n	80114f2 <__sfvwrite_r+0x16a>
 80114ea:	4476      	add	r6, lr
 80114ec:	42b3      	cmp	r3, r6
 80114ee:	f300 80af 	bgt.w	8011650 <__sfvwrite_r+0x2c8>
 80114f2:	4573      	cmp	r3, lr
 80114f4:	db35      	blt.n	8011562 <__sfvwrite_r+0x1da>
 80114f6:	6a66      	ldr	r6, [r4, #36]	; 0x24
 80114f8:	4648      	mov	r0, r9
 80114fa:	69e1      	ldr	r1, [r4, #28]
 80114fc:	465a      	mov	r2, fp
 80114fe:	f8cd c004 	str.w	ip, [sp, #4]
 8011502:	4673      	mov	r3, lr
 8011504:	47b0      	blx	r6
 8011506:	f8dd c004 	ldr.w	ip, [sp, #4]
 801150a:	1e06      	subs	r6, r0, #0
 801150c:	ddd2      	ble.n	80114b4 <__sfvwrite_r+0x12c>
 801150e:	ebba 0a06 	subs.w	sl, sl, r6
 8011512:	d03b      	beq.n	801158c <__sfvwrite_r+0x204>
 8011514:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8011518:	44b3      	add	fp, r6
 801151a:	1bbf      	subs	r7, r7, r6
 801151c:	1b9e      	subs	r6, r3, r6
 801151e:	f8c8 6008 	str.w	r6, [r8, #8]
 8011522:	2e00      	cmp	r6, #0
 8011524:	f43f af65 	beq.w	80113f2 <__sfvwrite_r+0x6a>
 8011528:	2f00      	cmp	r7, #0
 801152a:	d1d0      	bne.n	80114ce <__sfvwrite_r+0x146>
 801152c:	f8d5 b000 	ldr.w	fp, [r5]
 8011530:	f04f 0c00 	mov.w	ip, #0
 8011534:	686f      	ldr	r7, [r5, #4]
 8011536:	3508      	adds	r5, #8
 8011538:	e7c7      	b.n	80114ca <__sfvwrite_r+0x142>
 801153a:	6820      	ldr	r0, [r4, #0]
 801153c:	6923      	ldr	r3, [r4, #16]
 801153e:	4298      	cmp	r0, r3
 8011540:	d903      	bls.n	801154a <__sfvwrite_r+0x1c2>
 8011542:	42be      	cmp	r6, r7
 8011544:	46bb      	mov	fp, r7
 8011546:	f200 8096 	bhi.w	8011676 <__sfvwrite_r+0x2ee>
 801154a:	6963      	ldr	r3, [r4, #20]
 801154c:	429e      	cmp	r6, r3
 801154e:	d32b      	bcc.n	80115a8 <__sfvwrite_r+0x220>
 8011550:	6a67      	ldr	r7, [r4, #36]	; 0x24
 8011552:	4648      	mov	r0, r9
 8011554:	69e1      	ldr	r1, [r4, #28]
 8011556:	4652      	mov	r2, sl
 8011558:	47b8      	blx	r7
 801155a:	1e07      	subs	r7, r0, #0
 801155c:	ddaa      	ble.n	80114b4 <__sfvwrite_r+0x12c>
 801155e:	46bb      	mov	fp, r7
 8011560:	e784      	b.n	801146c <__sfvwrite_r+0xe4>
 8011562:	461a      	mov	r2, r3
 8011564:	461e      	mov	r6, r3
 8011566:	4659      	mov	r1, fp
 8011568:	9302      	str	r3, [sp, #8]
 801156a:	f8cd c004 	str.w	ip, [sp, #4]
 801156e:	f000 fc93 	bl	8011e98 <memmove>
 8011572:	9b02      	ldr	r3, [sp, #8]
 8011574:	ebba 0a06 	subs.w	sl, sl, r6
 8011578:	68a1      	ldr	r1, [r4, #8]
 801157a:	6822      	ldr	r2, [r4, #0]
 801157c:	ebc3 0101 	rsb	r1, r3, r1
 8011580:	f8dd c004 	ldr.w	ip, [sp, #4]
 8011584:	4413      	add	r3, r2
 8011586:	60a1      	str	r1, [r4, #8]
 8011588:	6023      	str	r3, [r4, #0]
 801158a:	d1c3      	bne.n	8011514 <__sfvwrite_r+0x18c>
 801158c:	4648      	mov	r0, r9
 801158e:	4621      	mov	r1, r4
 8011590:	f001 fdbc 	bl	801310c <_fflush_r>
 8011594:	2800      	cmp	r0, #0
 8011596:	d18d      	bne.n	80114b4 <__sfvwrite_r+0x12c>
 8011598:	46d4      	mov	ip, sl
 801159a:	e7bb      	b.n	8011514 <__sfvwrite_r+0x18c>
 801159c:	6820      	ldr	r0, [r4, #0]
 801159e:	46b3      	mov	fp, r6
 80115a0:	9603      	str	r6, [sp, #12]
 80115a2:	4637      	mov	r7, r6
 80115a4:	46b4      	mov	ip, r6
 80115a6:	e752      	b.n	801144e <__sfvwrite_r+0xc6>
 80115a8:	4651      	mov	r1, sl
 80115aa:	4632      	mov	r2, r6
 80115ac:	f000 fc74 	bl	8011e98 <memmove>
 80115b0:	68a1      	ldr	r1, [r4, #8]
 80115b2:	6822      	ldr	r2, [r4, #0]
 80115b4:	4637      	mov	r7, r6
 80115b6:	1b89      	subs	r1, r1, r6
 80115b8:	46b3      	mov	fp, r6
 80115ba:	1992      	adds	r2, r2, r6
 80115bc:	60a1      	str	r1, [r4, #8]
 80115be:	6022      	str	r2, [r4, #0]
 80115c0:	e754      	b.n	801146c <__sfvwrite_r+0xe4>
 80115c2:	4658      	mov	r0, fp
 80115c4:	210a      	movs	r1, #10
 80115c6:	463a      	mov	r2, r7
 80115c8:	f000 fba0 	bl	8011d0c <memchr>
 80115cc:	2800      	cmp	r0, #0
 80115ce:	d061      	beq.n	8011694 <__sfvwrite_r+0x30c>
 80115d0:	f100 0a01 	add.w	sl, r0, #1
 80115d4:	f04f 0c01 	mov.w	ip, #1
 80115d8:	ebcb 0a0a 	rsb	sl, fp, sl
 80115dc:	e77a      	b.n	80114d4 <__sfvwrite_r+0x14c>
 80115de:	6967      	ldr	r7, [r4, #20]
 80115e0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80115e4:	6822      	ldr	r2, [r4, #0]
 80115e6:	6921      	ldr	r1, [r4, #16]
 80115e8:	b21b      	sxth	r3, r3
 80115ea:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 80115ee:	ebc1 0b02 	rsb	fp, r1, r2
 80115f2:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
 80115f6:	f10b 0001 	add.w	r0, fp, #1
 80115fa:	1980      	adds	r0, r0, r6
 80115fc:	107f      	asrs	r7, r7, #1
 80115fe:	4287      	cmp	r7, r0
 8011600:	463a      	mov	r2, r7
 8011602:	bf38      	it	cc
 8011604:	4607      	movcc	r7, r0
 8011606:	4648      	mov	r0, r9
 8011608:	bf38      	it	cc
 801160a:	463a      	movcc	r2, r7
 801160c:	2b00      	cmp	r3, #0
 801160e:	f43f af44 	beq.w	801149a <__sfvwrite_r+0x112>
 8011612:	4611      	mov	r1, r2
 8011614:	f000 f8c2 	bl	801179c <_malloc_r>
 8011618:	2800      	cmp	r0, #0
 801161a:	f43f af48 	beq.w	80114ae <__sfvwrite_r+0x126>
 801161e:	6921      	ldr	r1, [r4, #16]
 8011620:	465a      	mov	r2, fp
 8011622:	9002      	str	r0, [sp, #8]
 8011624:	f000 fbee 	bl	8011e04 <memcpy>
 8011628:	89a2      	ldrh	r2, [r4, #12]
 801162a:	9b02      	ldr	r3, [sp, #8]
 801162c:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 8011630:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8011634:	81a2      	strh	r2, [r4, #12]
 8011636:	ebcb 0207 	rsb	r2, fp, r7
 801163a:	eb03 000b 	add.w	r0, r3, fp
 801163e:	6167      	str	r7, [r4, #20]
 8011640:	46b3      	mov	fp, r6
 8011642:	6123      	str	r3, [r4, #16]
 8011644:	4637      	mov	r7, r6
 8011646:	9603      	str	r6, [sp, #12]
 8011648:	46b4      	mov	ip, r6
 801164a:	6020      	str	r0, [r4, #0]
 801164c:	60a2      	str	r2, [r4, #8]
 801164e:	e6fe      	b.n	801144e <__sfvwrite_r+0xc6>
 8011650:	4659      	mov	r1, fp
 8011652:	4632      	mov	r2, r6
 8011654:	f8cd c004 	str.w	ip, [sp, #4]
 8011658:	f000 fc1e 	bl	8011e98 <memmove>
 801165c:	6823      	ldr	r3, [r4, #0]
 801165e:	4648      	mov	r0, r9
 8011660:	4621      	mov	r1, r4
 8011662:	199b      	adds	r3, r3, r6
 8011664:	6023      	str	r3, [r4, #0]
 8011666:	f001 fd51 	bl	801310c <_fflush_r>
 801166a:	f8dd c004 	ldr.w	ip, [sp, #4]
 801166e:	2800      	cmp	r0, #0
 8011670:	f43f af4d 	beq.w	801150e <__sfvwrite_r+0x186>
 8011674:	e71e      	b.n	80114b4 <__sfvwrite_r+0x12c>
 8011676:	4651      	mov	r1, sl
 8011678:	463a      	mov	r2, r7
 801167a:	f000 fc0d 	bl	8011e98 <memmove>
 801167e:	6822      	ldr	r2, [r4, #0]
 8011680:	4648      	mov	r0, r9
 8011682:	4621      	mov	r1, r4
 8011684:	19d2      	adds	r2, r2, r7
 8011686:	6022      	str	r2, [r4, #0]
 8011688:	f001 fd40 	bl	801310c <_fflush_r>
 801168c:	2800      	cmp	r0, #0
 801168e:	f43f aeed 	beq.w	801146c <__sfvwrite_r+0xe4>
 8011692:	e70f      	b.n	80114b4 <__sfvwrite_r+0x12c>
 8011694:	f107 0a01 	add.w	sl, r7, #1
 8011698:	f04f 0c01 	mov.w	ip, #1
 801169c:	e71a      	b.n	80114d4 <__sfvwrite_r+0x14c>
 801169e:	f04f 30ff 	mov.w	r0, #4294967295
 80116a2:	e6a7      	b.n	80113f4 <__sfvwrite_r+0x6c>

080116a4 <_fwrite_r>:
 80116a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80116a8:	b086      	sub	sp, #24
 80116aa:	fb02 f603 	mul.w	r6, r2, r3
 80116ae:	461d      	mov	r5, r3
 80116b0:	4690      	mov	r8, r2
 80116b2:	ab01      	add	r3, sp, #4
 80116b4:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 80116b6:	4607      	mov	r7, r0
 80116b8:	9303      	str	r3, [sp, #12]
 80116ba:	2301      	movs	r3, #1
 80116bc:	9101      	str	r1, [sp, #4]
 80116be:	9304      	str	r3, [sp, #16]
 80116c0:	9602      	str	r6, [sp, #8]
 80116c2:	9605      	str	r6, [sp, #20]
 80116c4:	b108      	cbz	r0, 80116ca <_fwrite_r+0x26>
 80116c6:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80116c8:	b1db      	cbz	r3, 8011702 <_fwrite_r+0x5e>
 80116ca:	89a3      	ldrh	r3, [r4, #12]
 80116cc:	f403 5200 	and.w	r2, r3, #8192	; 0x2000
 80116d0:	b212      	sxth	r2, r2
 80116d2:	b932      	cbnz	r2, 80116e2 <_fwrite_r+0x3e>
 80116d4:	6e62      	ldr	r2, [r4, #100]	; 0x64
 80116d6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80116da:	81a3      	strh	r3, [r4, #12]
 80116dc:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80116e0:	6662      	str	r2, [r4, #100]	; 0x64
 80116e2:	4638      	mov	r0, r7
 80116e4:	4621      	mov	r1, r4
 80116e6:	aa03      	add	r2, sp, #12
 80116e8:	f7ff fe4e 	bl	8011388 <__sfvwrite_r>
 80116ec:	b128      	cbz	r0, 80116fa <_fwrite_r+0x56>
 80116ee:	9805      	ldr	r0, [sp, #20]
 80116f0:	4641      	mov	r1, r8
 80116f2:	1a30      	subs	r0, r6, r0
 80116f4:	f002 f8e8 	bl	80138c8 <__aeabi_uidiv>
 80116f8:	4605      	mov	r5, r0
 80116fa:	4628      	mov	r0, r5
 80116fc:	b006      	add	sp, #24
 80116fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8011702:	f001 fd7d 	bl	8013200 <__sinit>
 8011706:	e7e0      	b.n	80116ca <_fwrite_r+0x26>

08011708 <fwrite>:
 8011708:	b5f0      	push	{r4, r5, r6, r7, lr}
 801170a:	f240 04b0 	movw	r4, #176	; 0xb0
 801170e:	b083      	sub	sp, #12
 8011710:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8011714:	4607      	mov	r7, r0
 8011716:	460e      	mov	r6, r1
 8011718:	4615      	mov	r5, r2
 801171a:	9300      	str	r3, [sp, #0]
 801171c:	6820      	ldr	r0, [r4, #0]
 801171e:	4639      	mov	r1, r7
 8011720:	4632      	mov	r2, r6
 8011722:	462b      	mov	r3, r5
 8011724:	f7ff ffbe 	bl	80116a4 <_fwrite_r>
 8011728:	b003      	add	sp, #12
 801172a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801172c <__libc_init_array>:
 801172c:	b570      	push	{r4, r5, r6, lr}
 801172e:	4d0f      	ldr	r5, [pc, #60]	; (801176c <__libc_init_array+0x40>)
 8011730:	4e0f      	ldr	r6, [pc, #60]	; (8011770 <__libc_init_array+0x44>)
 8011732:	1b76      	subs	r6, r6, r5
 8011734:	10b6      	asrs	r6, r6, #2
 8011736:	d007      	beq.n	8011748 <__libc_init_array+0x1c>
 8011738:	3d04      	subs	r5, #4
 801173a:	2400      	movs	r4, #0
 801173c:	f855 3f04 	ldr.w	r3, [r5, #4]!
 8011740:	3401      	adds	r4, #1
 8011742:	4798      	blx	r3
 8011744:	42a6      	cmp	r6, r4
 8011746:	d1f9      	bne.n	801173c <__libc_init_array+0x10>
 8011748:	4d0a      	ldr	r5, [pc, #40]	; (8011774 <__libc_init_array+0x48>)
 801174a:	f00c fc91 	bl	801e070 <_init>
 801174e:	4e0a      	ldr	r6, [pc, #40]	; (8011778 <__libc_init_array+0x4c>)
 8011750:	1b76      	subs	r6, r6, r5
 8011752:	10b6      	asrs	r6, r6, #2
 8011754:	d008      	beq.n	8011768 <__libc_init_array+0x3c>
 8011756:	3d04      	subs	r5, #4
 8011758:	2400      	movs	r4, #0
 801175a:	f855 3f04 	ldr.w	r3, [r5, #4]!
 801175e:	3401      	adds	r4, #1
 8011760:	4798      	blx	r3
 8011762:	42a6      	cmp	r6, r4
 8011764:	d1f9      	bne.n	801175a <__libc_init_array+0x2e>
 8011766:	bd70      	pop	{r4, r5, r6, pc}
 8011768:	bd70      	pop	{r4, r5, r6, pc}
 801176a:	bf00      	nop
 801176c:	08021c70 	.word	0x08021c70
 8011770:	08021c70 	.word	0x08021c70
 8011774:	08021c70 	.word	0x08021c70
 8011778:	08021c78 	.word	0x08021c78

0801177c <malloc>:
 801177c:	f240 03b0 	movw	r3, #176	; 0xb0
 8011780:	4601      	mov	r1, r0
 8011782:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011786:	6818      	ldr	r0, [r3, #0]
 8011788:	f000 b808 	b.w	801179c <_malloc_r>

0801178c <free>:
 801178c:	f240 03b0 	movw	r3, #176	; 0xb0
 8011790:	4601      	mov	r1, r0
 8011792:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011796:	6818      	ldr	r0, [r3, #0]
 8011798:	f001 be08 	b.w	80133ac <_free_r>

0801179c <_malloc_r>:
 801179c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80117a0:	f101 040b 	add.w	r4, r1, #11
 80117a4:	2c16      	cmp	r4, #22
 80117a6:	b083      	sub	sp, #12
 80117a8:	4606      	mov	r6, r0
 80117aa:	d92d      	bls.n	8011808 <_malloc_r+0x6c>
 80117ac:	f024 0407 	bic.w	r4, r4, #7
 80117b0:	0fe3      	lsrs	r3, r4, #31
 80117b2:	428c      	cmp	r4, r1
 80117b4:	bf2c      	ite	cs
 80117b6:	4619      	movcs	r1, r3
 80117b8:	f043 0101 	orrcc.w	r1, r3, #1
 80117bc:	2900      	cmp	r1, #0
 80117be:	d12c      	bne.n	801181a <_malloc_r+0x7e>
 80117c0:	4630      	mov	r0, r6
 80117c2:	f000 fc13 	bl	8011fec <__malloc_lock>
 80117c6:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 80117ca:	d22b      	bcs.n	8011824 <_malloc_r+0x88>
 80117cc:	ea4f 0cd4 	mov.w	ip, r4, lsr #3
 80117d0:	4fb9      	ldr	r7, [pc, #740]	; (8011ab8 <_malloc_r+0x31c>)
 80117d2:	eb07 02cc 	add.w	r2, r7, ip, lsl #3
 80117d6:	68d3      	ldr	r3, [r2, #12]
 80117d8:	4293      	cmp	r3, r2
 80117da:	f000 8200 	beq.w	8011bde <_malloc_r+0x442>
 80117de:	6859      	ldr	r1, [r3, #4]
 80117e0:	f103 0808 	add.w	r8, r3, #8
 80117e4:	68da      	ldr	r2, [r3, #12]
 80117e6:	4630      	mov	r0, r6
 80117e8:	f021 0403 	bic.w	r4, r1, #3
 80117ec:	6899      	ldr	r1, [r3, #8]
 80117ee:	191b      	adds	r3, r3, r4
 80117f0:	685c      	ldr	r4, [r3, #4]
 80117f2:	60ca      	str	r2, [r1, #12]
 80117f4:	f044 0401 	orr.w	r4, r4, #1
 80117f8:	6091      	str	r1, [r2, #8]
 80117fa:	605c      	str	r4, [r3, #4]
 80117fc:	f000 fbf8 	bl	8011ff0 <__malloc_unlock>
 8011800:	4640      	mov	r0, r8
 8011802:	b003      	add	sp, #12
 8011804:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8011808:	2300      	movs	r3, #0
 801180a:	2410      	movs	r4, #16
 801180c:	428c      	cmp	r4, r1
 801180e:	bf2c      	ite	cs
 8011810:	4619      	movcs	r1, r3
 8011812:	f043 0101 	orrcc.w	r1, r3, #1
 8011816:	2900      	cmp	r1, #0
 8011818:	d0d2      	beq.n	80117c0 <_malloc_r+0x24>
 801181a:	230c      	movs	r3, #12
 801181c:	f04f 0800 	mov.w	r8, #0
 8011820:	6033      	str	r3, [r6, #0]
 8011822:	e7ed      	b.n	8011800 <_malloc_r+0x64>
 8011824:	ea5f 2c54 	movs.w	ip, r4, lsr #9
 8011828:	bf04      	itt	eq
 801182a:	ea4f 0cd4 	moveq.w	ip, r4, lsr #3
 801182e:	ea4f 054c 	moveq.w	r5, ip, lsl #1
 8011832:	f040 8089 	bne.w	8011948 <_malloc_r+0x1ac>
 8011836:	4fa0      	ldr	r7, [pc, #640]	; (8011ab8 <_malloc_r+0x31c>)
 8011838:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 801183c:	68eb      	ldr	r3, [r5, #12]
 801183e:	429d      	cmp	r5, r3
 8011840:	d106      	bne.n	8011850 <_malloc_r+0xb4>
 8011842:	e00d      	b.n	8011860 <_malloc_r+0xc4>
 8011844:	2a00      	cmp	r2, #0
 8011846:	f280 8149 	bge.w	8011adc <_malloc_r+0x340>
 801184a:	68db      	ldr	r3, [r3, #12]
 801184c:	429d      	cmp	r5, r3
 801184e:	d007      	beq.n	8011860 <_malloc_r+0xc4>
 8011850:	6859      	ldr	r1, [r3, #4]
 8011852:	f021 0103 	bic.w	r1, r1, #3
 8011856:	1b0a      	subs	r2, r1, r4
 8011858:	2a0f      	cmp	r2, #15
 801185a:	ddf3      	ble.n	8011844 <_malloc_r+0xa8>
 801185c:	f10c 3cff 	add.w	ip, ip, #4294967295
 8011860:	f10c 0c01 	add.w	ip, ip, #1
 8011864:	4a94      	ldr	r2, [pc, #592]	; (8011ab8 <_malloc_r+0x31c>)
 8011866:	693b      	ldr	r3, [r7, #16]
 8011868:	f102 0e08 	add.w	lr, r2, #8
 801186c:	4573      	cmp	r3, lr
 801186e:	bf08      	it	eq
 8011870:	f8d2 9004 	ldreq.w	r9, [r2, #4]
 8011874:	d022      	beq.n	80118bc <_malloc_r+0x120>
 8011876:	6858      	ldr	r0, [r3, #4]
 8011878:	f020 0003 	bic.w	r0, r0, #3
 801187c:	1b01      	subs	r1, r0, r4
 801187e:	290f      	cmp	r1, #15
 8011880:	f300 8179 	bgt.w	8011b76 <_malloc_r+0x3da>
 8011884:	2900      	cmp	r1, #0
 8011886:	f8c2 e014 	str.w	lr, [r2, #20]
 801188a:	f8c2 e010 	str.w	lr, [r2, #16]
 801188e:	da66      	bge.n	801195e <_malloc_r+0x1c2>
 8011890:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8011894:	f080 8145 	bcs.w	8011b22 <_malloc_r+0x386>
 8011898:	08c1      	lsrs	r1, r0, #3
 801189a:	f04f 0801 	mov.w	r8, #1
 801189e:	eb02 00c1 	add.w	r0, r2, r1, lsl #3
 80118a2:	1089      	asrs	r1, r1, #2
 80118a4:	fa08 f801 	lsl.w	r8, r8, r1
 80118a8:	6851      	ldr	r1, [r2, #4]
 80118aa:	6885      	ldr	r5, [r0, #8]
 80118ac:	60d8      	str	r0, [r3, #12]
 80118ae:	ea48 0901 	orr.w	r9, r8, r1
 80118b2:	f8c2 9004 	str.w	r9, [r2, #4]
 80118b6:	609d      	str	r5, [r3, #8]
 80118b8:	60eb      	str	r3, [r5, #12]
 80118ba:	6083      	str	r3, [r0, #8]
 80118bc:	2201      	movs	r2, #1
 80118be:	ea4f 03ac 	mov.w	r3, ip, asr #2
 80118c2:	fa02 f303 	lsl.w	r3, r2, r3
 80118c6:	454b      	cmp	r3, r9
 80118c8:	d854      	bhi.n	8011974 <_malloc_r+0x1d8>
 80118ca:	ea19 0f03 	tst.w	r9, r3
 80118ce:	d10d      	bne.n	80118ec <_malloc_r+0x150>
 80118d0:	4093      	lsls	r3, r2
 80118d2:	f02c 0c03 	bic.w	ip, ip, #3
 80118d6:	ea19 0f03 	tst.w	r9, r3
 80118da:	f10c 0c04 	add.w	ip, ip, #4
 80118de:	d105      	bne.n	80118ec <_malloc_r+0x150>
 80118e0:	005b      	lsls	r3, r3, #1
 80118e2:	f10c 0c04 	add.w	ip, ip, #4
 80118e6:	ea19 0f03 	tst.w	r9, r3
 80118ea:	d0f9      	beq.n	80118e0 <_malloc_r+0x144>
 80118ec:	eb07 09cc 	add.w	r9, r7, ip, lsl #3
 80118f0:	46e0      	mov	r8, ip
 80118f2:	4648      	mov	r0, r9
 80118f4:	68c2      	ldr	r2, [r0, #12]
 80118f6:	4290      	cmp	r0, r2
 80118f8:	d107      	bne.n	801190a <_malloc_r+0x16e>
 80118fa:	e150      	b.n	8011b9e <_malloc_r+0x402>
 80118fc:	2900      	cmp	r1, #0
 80118fe:	f280 8178 	bge.w	8011bf2 <_malloc_r+0x456>
 8011902:	68d2      	ldr	r2, [r2, #12]
 8011904:	4290      	cmp	r0, r2
 8011906:	f000 814a 	beq.w	8011b9e <_malloc_r+0x402>
 801190a:	6855      	ldr	r5, [r2, #4]
 801190c:	f025 0503 	bic.w	r5, r5, #3
 8011910:	1b29      	subs	r1, r5, r4
 8011912:	290f      	cmp	r1, #15
 8011914:	ddf2      	ble.n	80118fc <_malloc_r+0x160>
 8011916:	4690      	mov	r8, r2
 8011918:	1913      	adds	r3, r2, r4
 801191a:	68d5      	ldr	r5, [r2, #12]
 801191c:	f044 0001 	orr.w	r0, r4, #1
 8011920:	f858 4f08 	ldr.w	r4, [r8, #8]!
 8011924:	f041 0c01 	orr.w	ip, r1, #1
 8011928:	6050      	str	r0, [r2, #4]
 801192a:	4630      	mov	r0, r6
 801192c:	f8c3 c004 	str.w	ip, [r3, #4]
 8011930:	60e5      	str	r5, [r4, #12]
 8011932:	60ac      	str	r4, [r5, #8]
 8011934:	617b      	str	r3, [r7, #20]
 8011936:	613b      	str	r3, [r7, #16]
 8011938:	f8c3 e00c 	str.w	lr, [r3, #12]
 801193c:	f8c3 e008 	str.w	lr, [r3, #8]
 8011940:	5059      	str	r1, [r3, r1]
 8011942:	f000 fb55 	bl	8011ff0 <__malloc_unlock>
 8011946:	e75b      	b.n	8011800 <_malloc_r+0x64>
 8011948:	f1bc 0f04 	cmp.w	ip, #4
 801194c:	f200 80d5 	bhi.w	8011afa <_malloc_r+0x35e>
 8011950:	ea4f 1c94 	mov.w	ip, r4, lsr #6
 8011954:	f10c 0c38 	add.w	ip, ip, #56	; 0x38
 8011958:	ea4f 054c 	mov.w	r5, ip, lsl #1
 801195c:	e76b      	b.n	8011836 <_malloc_r+0x9a>
 801195e:	181a      	adds	r2, r3, r0
 8011960:	f103 0808 	add.w	r8, r3, #8
 8011964:	4630      	mov	r0, r6
 8011966:	6853      	ldr	r3, [r2, #4]
 8011968:	f043 0301 	orr.w	r3, r3, #1
 801196c:	6053      	str	r3, [r2, #4]
 801196e:	f000 fb3f 	bl	8011ff0 <__malloc_unlock>
 8011972:	e745      	b.n	8011800 <_malloc_r+0x64>
 8011974:	68bd      	ldr	r5, [r7, #8]
 8011976:	686b      	ldr	r3, [r5, #4]
 8011978:	f023 0903 	bic.w	r9, r3, #3
 801197c:	454c      	cmp	r4, r9
 801197e:	d804      	bhi.n	801198a <_malloc_r+0x1ee>
 8011980:	ebc4 0309 	rsb	r3, r4, r9
 8011984:	2b0f      	cmp	r3, #15
 8011986:	f300 809b 	bgt.w	8011ac0 <_malloc_r+0x324>
 801198a:	f8df a130 	ldr.w	sl, [pc, #304]	; 8011abc <_malloc_r+0x320>
 801198e:	eb05 0209 	add.w	r2, r5, r9
 8011992:	f8d7 1408 	ldr.w	r1, [r7, #1032]	; 0x408
 8011996:	f8da 3000 	ldr.w	r3, [sl]
 801199a:	3101      	adds	r1, #1
 801199c:	4423      	add	r3, r4
 801199e:	bf08      	it	eq
 80119a0:	f103 0b10 	addeq.w	fp, r3, #16
 80119a4:	d006      	beq.n	80119b4 <_malloc_r+0x218>
 80119a6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80119aa:	330f      	adds	r3, #15
 80119ac:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 80119b0:	f023 0b0f 	bic.w	fp, r3, #15
 80119b4:	4630      	mov	r0, r6
 80119b6:	4659      	mov	r1, fp
 80119b8:	9201      	str	r2, [sp, #4]
 80119ba:	f000 fe37 	bl	801262c <_sbrk_r>
 80119be:	9a01      	ldr	r2, [sp, #4]
 80119c0:	f1b0 3fff 	cmp.w	r0, #4294967295
 80119c4:	4680      	mov	r8, r0
 80119c6:	f000 815b 	beq.w	8011c80 <_malloc_r+0x4e4>
 80119ca:	4282      	cmp	r2, r0
 80119cc:	f200 8127 	bhi.w	8011c1e <_malloc_r+0x482>
 80119d0:	f8da 3004 	ldr.w	r3, [sl, #4]
 80119d4:	4542      	cmp	r2, r8
 80119d6:	445b      	add	r3, fp
 80119d8:	f8ca 3004 	str.w	r3, [sl, #4]
 80119dc:	f000 8159 	beq.w	8011c92 <_malloc_r+0x4f6>
 80119e0:	f8d7 1408 	ldr.w	r1, [r7, #1032]	; 0x408
 80119e4:	4630      	mov	r0, r6
 80119e6:	3101      	adds	r1, #1
 80119e8:	bf17      	itett	ne
 80119ea:	ebc2 0208 	rsbne	r2, r2, r8
 80119ee:	4b32      	ldreq	r3, [pc, #200]	; (8011ab8 <_malloc_r+0x31c>)
 80119f0:	189b      	addne	r3, r3, r2
 80119f2:	f8ca 3004 	strne.w	r3, [sl, #4]
 80119f6:	bf08      	it	eq
 80119f8:	f8c3 8408 	streq.w	r8, [r3, #1032]	; 0x408
 80119fc:	f018 0307 	ands.w	r3, r8, #7
 8011a00:	bf1f      	itttt	ne
 8011a02:	f1c3 0208 	rsbne	r2, r3, #8
 8011a06:	f5c3 5380 	rsbne	r3, r3, #4096	; 0x1000
 8011a0a:	4490      	addne	r8, r2
 8011a0c:	f103 0208 	addne.w	r2, r3, #8
 8011a10:	eb08 030b 	add.w	r3, r8, fp
 8011a14:	bf08      	it	eq
 8011a16:	f44f 5280 	moveq.w	r2, #4096	; 0x1000
 8011a1a:	051b      	lsls	r3, r3, #20
 8011a1c:	0d1b      	lsrs	r3, r3, #20
 8011a1e:	ebc3 0b02 	rsb	fp, r3, r2
 8011a22:	4659      	mov	r1, fp
 8011a24:	f000 fe02 	bl	801262c <_sbrk_r>
 8011a28:	1c43      	adds	r3, r0, #1
 8011a2a:	f000 813e 	beq.w	8011caa <_malloc_r+0x50e>
 8011a2e:	ebc8 0200 	rsb	r2, r8, r0
 8011a32:	445a      	add	r2, fp
 8011a34:	f042 0201 	orr.w	r2, r2, #1
 8011a38:	f8da 3004 	ldr.w	r3, [sl, #4]
 8011a3c:	42bd      	cmp	r5, r7
 8011a3e:	f8c7 8008 	str.w	r8, [r7, #8]
 8011a42:	445b      	add	r3, fp
 8011a44:	f8c8 2004 	str.w	r2, [r8, #4]
 8011a48:	f8ca 3004 	str.w	r3, [sl, #4]
 8011a4c:	d017      	beq.n	8011a7e <_malloc_r+0x2e2>
 8011a4e:	f1b9 0f0f 	cmp.w	r9, #15
 8011a52:	f240 8104 	bls.w	8011c5e <_malloc_r+0x4c2>
 8011a56:	f1a9 020c 	sub.w	r2, r9, #12
 8011a5a:	6869      	ldr	r1, [r5, #4]
 8011a5c:	f022 0207 	bic.w	r2, r2, #7
 8011a60:	f04f 0e05 	mov.w	lr, #5
 8011a64:	18a8      	adds	r0, r5, r2
 8011a66:	2a0f      	cmp	r2, #15
 8011a68:	f001 0101 	and.w	r1, r1, #1
 8011a6c:	ea42 0101 	orr.w	r1, r2, r1
 8011a70:	6069      	str	r1, [r5, #4]
 8011a72:	f8c0 e004 	str.w	lr, [r0, #4]
 8011a76:	f8c0 e008 	str.w	lr, [r0, #8]
 8011a7a:	f200 811a 	bhi.w	8011cb2 <_malloc_r+0x516>
 8011a7e:	f8da 202c 	ldr.w	r2, [sl, #44]	; 0x2c
 8011a82:	68bd      	ldr	r5, [r7, #8]
 8011a84:	4293      	cmp	r3, r2
 8011a86:	bf84      	itt	hi
 8011a88:	4a0c      	ldrhi	r2, [pc, #48]	; (8011abc <_malloc_r+0x320>)
 8011a8a:	62d3      	strhi	r3, [r2, #44]	; 0x2c
 8011a8c:	f8da 2030 	ldr.w	r2, [sl, #48]	; 0x30
 8011a90:	4293      	cmp	r3, r2
 8011a92:	bf84      	itt	hi
 8011a94:	4a09      	ldrhi	r2, [pc, #36]	; (8011abc <_malloc_r+0x320>)
 8011a96:	6313      	strhi	r3, [r2, #48]	; 0x30
 8011a98:	686a      	ldr	r2, [r5, #4]
 8011a9a:	f022 0203 	bic.w	r2, r2, #3
 8011a9e:	4294      	cmp	r4, r2
 8011aa0:	ebc4 0302 	rsb	r3, r4, r2
 8011aa4:	d801      	bhi.n	8011aaa <_malloc_r+0x30e>
 8011aa6:	2b0f      	cmp	r3, #15
 8011aa8:	dc0a      	bgt.n	8011ac0 <_malloc_r+0x324>
 8011aaa:	4630      	mov	r0, r6
 8011aac:	f04f 0800 	mov.w	r8, #0
 8011ab0:	f000 fa9e 	bl	8011ff0 <__malloc_unlock>
 8011ab4:	e6a4      	b.n	8011800 <_malloc_r+0x64>
 8011ab6:	bf00      	nop
 8011ab8:	200004e0 	.word	0x200004e0
 8011abc:	20000b50 	.word	0x20000b50
 8011ac0:	192a      	adds	r2, r5, r4
 8011ac2:	f043 0301 	orr.w	r3, r3, #1
 8011ac6:	f044 0401 	orr.w	r4, r4, #1
 8011aca:	4630      	mov	r0, r6
 8011acc:	606c      	str	r4, [r5, #4]
 8011ace:	f105 0808 	add.w	r8, r5, #8
 8011ad2:	6053      	str	r3, [r2, #4]
 8011ad4:	60ba      	str	r2, [r7, #8]
 8011ad6:	f000 fa8b 	bl	8011ff0 <__malloc_unlock>
 8011ada:	e691      	b.n	8011800 <_malloc_r+0x64>
 8011adc:	1859      	adds	r1, r3, r1
 8011ade:	68da      	ldr	r2, [r3, #12]
 8011ae0:	689c      	ldr	r4, [r3, #8]
 8011ae2:	4630      	mov	r0, r6
 8011ae4:	684d      	ldr	r5, [r1, #4]
 8011ae6:	f103 0808 	add.w	r8, r3, #8
 8011aea:	f045 0501 	orr.w	r5, r5, #1
 8011aee:	60e2      	str	r2, [r4, #12]
 8011af0:	6094      	str	r4, [r2, #8]
 8011af2:	604d      	str	r5, [r1, #4]
 8011af4:	f000 fa7c 	bl	8011ff0 <__malloc_unlock>
 8011af8:	e682      	b.n	8011800 <_malloc_r+0x64>
 8011afa:	f1bc 0f14 	cmp.w	ip, #20
 8011afe:	bf9c      	itt	ls
 8011b00:	f10c 0c5b 	addls.w	ip, ip, #91	; 0x5b
 8011b04:	ea4f 054c 	movls.w	r5, ip, lsl #1
 8011b08:	f67f ae95 	bls.w	8011836 <_malloc_r+0x9a>
 8011b0c:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
 8011b10:	f200 808e 	bhi.w	8011c30 <_malloc_r+0x494>
 8011b14:	ea4f 3c14 	mov.w	ip, r4, lsr #12
 8011b18:	f10c 0c6e 	add.w	ip, ip, #110	; 0x6e
 8011b1c:	ea4f 054c 	mov.w	r5, ip, lsl #1
 8011b20:	e689      	b.n	8011836 <_malloc_r+0x9a>
 8011b22:	0a42      	lsrs	r2, r0, #9
 8011b24:	2a04      	cmp	r2, #4
 8011b26:	d973      	bls.n	8011c10 <_malloc_r+0x474>
 8011b28:	2a14      	cmp	r2, #20
 8011b2a:	bf9c      	itt	ls
 8011b2c:	f102 095b 	addls.w	r9, r2, #91	; 0x5b
 8011b30:	ea4f 0549 	movls.w	r5, r9, lsl #1
 8011b34:	d908      	bls.n	8011b48 <_malloc_r+0x3ac>
 8011b36:	2a54      	cmp	r2, #84	; 0x54
 8011b38:	f200 80c3 	bhi.w	8011cc2 <_malloc_r+0x526>
 8011b3c:	ea4f 3910 	mov.w	r9, r0, lsr #12
 8011b40:	f109 096e 	add.w	r9, r9, #110	; 0x6e
 8011b44:	ea4f 0549 	mov.w	r5, r9, lsl #1
 8011b48:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 8011b4c:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 8011d04 <_malloc_r+0x568>
 8011b50:	68aa      	ldr	r2, [r5, #8]
 8011b52:	42aa      	cmp	r2, r5
 8011b54:	d076      	beq.n	8011c44 <_malloc_r+0x4a8>
 8011b56:	6851      	ldr	r1, [r2, #4]
 8011b58:	f021 0103 	bic.w	r1, r1, #3
 8011b5c:	4288      	cmp	r0, r1
 8011b5e:	d202      	bcs.n	8011b66 <_malloc_r+0x3ca>
 8011b60:	6892      	ldr	r2, [r2, #8]
 8011b62:	4295      	cmp	r5, r2
 8011b64:	d1f7      	bne.n	8011b56 <_malloc_r+0x3ba>
 8011b66:	68d0      	ldr	r0, [r2, #12]
 8011b68:	f8d7 9004 	ldr.w	r9, [r7, #4]
 8011b6c:	60d8      	str	r0, [r3, #12]
 8011b6e:	609a      	str	r2, [r3, #8]
 8011b70:	60d3      	str	r3, [r2, #12]
 8011b72:	6083      	str	r3, [r0, #8]
 8011b74:	e6a2      	b.n	80118bc <_malloc_r+0x120>
 8011b76:	191d      	adds	r5, r3, r4
 8011b78:	f041 0701 	orr.w	r7, r1, #1
 8011b7c:	6155      	str	r5, [r2, #20]
 8011b7e:	f044 0401 	orr.w	r4, r4, #1
 8011b82:	6115      	str	r5, [r2, #16]
 8011b84:	4630      	mov	r0, r6
 8011b86:	605c      	str	r4, [r3, #4]
 8011b88:	f103 0808 	add.w	r8, r3, #8
 8011b8c:	f8c5 e00c 	str.w	lr, [r5, #12]
 8011b90:	f8c5 e008 	str.w	lr, [r5, #8]
 8011b94:	606f      	str	r7, [r5, #4]
 8011b96:	5069      	str	r1, [r5, r1]
 8011b98:	f000 fa2a 	bl	8011ff0 <__malloc_unlock>
 8011b9c:	e630      	b.n	8011800 <_malloc_r+0x64>
 8011b9e:	f108 0801 	add.w	r8, r8, #1
 8011ba2:	3008      	adds	r0, #8
 8011ba4:	f018 0f03 	tst.w	r8, #3
 8011ba8:	f47f aea4 	bne.w	80118f4 <_malloc_r+0x158>
 8011bac:	464a      	mov	r2, r9
 8011bae:	f01c 0f03 	tst.w	ip, #3
 8011bb2:	f1a2 0108 	sub.w	r1, r2, #8
 8011bb6:	f10c 3cff 	add.w	ip, ip, #4294967295
 8011bba:	f000 809a 	beq.w	8011cf2 <_malloc_r+0x556>
 8011bbe:	6812      	ldr	r2, [r2, #0]
 8011bc0:	428a      	cmp	r2, r1
 8011bc2:	d0f4      	beq.n	8011bae <_malloc_r+0x412>
 8011bc4:	687a      	ldr	r2, [r7, #4]
 8011bc6:	005b      	lsls	r3, r3, #1
 8011bc8:	4293      	cmp	r3, r2
 8011bca:	f63f aed3 	bhi.w	8011974 <_malloc_r+0x1d8>
 8011bce:	2b00      	cmp	r3, #0
 8011bd0:	f43f aed0 	beq.w	8011974 <_malloc_r+0x1d8>
 8011bd4:	421a      	tst	r2, r3
 8011bd6:	f000 8091 	beq.w	8011cfc <_malloc_r+0x560>
 8011bda:	46c4      	mov	ip, r8
 8011bdc:	e686      	b.n	80118ec <_malloc_r+0x150>
 8011bde:	f103 0208 	add.w	r2, r3, #8
 8011be2:	695b      	ldr	r3, [r3, #20]
 8011be4:	429a      	cmp	r2, r3
 8011be6:	bf08      	it	eq
 8011be8:	f10c 0c02 	addeq.w	ip, ip, #2
 8011bec:	f43f ae3a 	beq.w	8011864 <_malloc_r+0xc8>
 8011bf0:	e5f5      	b.n	80117de <_malloc_r+0x42>
 8011bf2:	4690      	mov	r8, r2
 8011bf4:	1955      	adds	r5, r2, r5
 8011bf6:	68d3      	ldr	r3, [r2, #12]
 8011bf8:	4630      	mov	r0, r6
 8011bfa:	f858 2f08 	ldr.w	r2, [r8, #8]!
 8011bfe:	6869      	ldr	r1, [r5, #4]
 8011c00:	60d3      	str	r3, [r2, #12]
 8011c02:	f041 0101 	orr.w	r1, r1, #1
 8011c06:	609a      	str	r2, [r3, #8]
 8011c08:	6069      	str	r1, [r5, #4]
 8011c0a:	f000 f9f1 	bl	8011ff0 <__malloc_unlock>
 8011c0e:	e5f7      	b.n	8011800 <_malloc_r+0x64>
 8011c10:	ea4f 1990 	mov.w	r9, r0, lsr #6
 8011c14:	f109 0938 	add.w	r9, r9, #56	; 0x38
 8011c18:	ea4f 0549 	mov.w	r5, r9, lsl #1
 8011c1c:	e794      	b.n	8011b48 <_malloc_r+0x3ac>
 8011c1e:	42bd      	cmp	r5, r7
 8011c20:	f43f aed6 	beq.w	80119d0 <_malloc_r+0x234>
 8011c24:	4b37      	ldr	r3, [pc, #220]	; (8011d04 <_malloc_r+0x568>)
 8011c26:	689d      	ldr	r5, [r3, #8]
 8011c28:	686a      	ldr	r2, [r5, #4]
 8011c2a:	f022 0203 	bic.w	r2, r2, #3
 8011c2e:	e736      	b.n	8011a9e <_malloc_r+0x302>
 8011c30:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
 8011c34:	d819      	bhi.n	8011c6a <_malloc_r+0x4ce>
 8011c36:	ea4f 3cd4 	mov.w	ip, r4, lsr #15
 8011c3a:	f10c 0c77 	add.w	ip, ip, #119	; 0x77
 8011c3e:	ea4f 054c 	mov.w	r5, ip, lsl #1
 8011c42:	e5f8      	b.n	8011836 <_malloc_r+0x9a>
 8011c44:	2501      	movs	r5, #1
 8011c46:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8011c4a:	ea4f 09a9 	mov.w	r9, r9, asr #2
 8011c4e:	4610      	mov	r0, r2
 8011c50:	fa05 f509 	lsl.w	r5, r5, r9
 8011c54:	ea45 0901 	orr.w	r9, r5, r1
 8011c58:	f8c8 9004 	str.w	r9, [r8, #4]
 8011c5c:	e786      	b.n	8011b6c <_malloc_r+0x3d0>
 8011c5e:	2301      	movs	r3, #1
 8011c60:	4645      	mov	r5, r8
 8011c62:	f8c8 3004 	str.w	r3, [r8, #4]
 8011c66:	2200      	movs	r2, #0
 8011c68:	e719      	b.n	8011a9e <_malloc_r+0x302>
 8011c6a:	f240 5354 	movw	r3, #1364	; 0x554
 8011c6e:	459c      	cmp	ip, r3
 8011c70:	d80b      	bhi.n	8011c8a <_malloc_r+0x4ee>
 8011c72:	ea4f 4c94 	mov.w	ip, r4, lsr #18
 8011c76:	f10c 0c7c 	add.w	ip, ip, #124	; 0x7c
 8011c7a:	ea4f 054c 	mov.w	r5, ip, lsl #1
 8011c7e:	e5da      	b.n	8011836 <_malloc_r+0x9a>
 8011c80:	68bd      	ldr	r5, [r7, #8]
 8011c82:	686a      	ldr	r2, [r5, #4]
 8011c84:	f022 0203 	bic.w	r2, r2, #3
 8011c88:	e709      	b.n	8011a9e <_malloc_r+0x302>
 8011c8a:	25fc      	movs	r5, #252	; 0xfc
 8011c8c:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
 8011c90:	e5d1      	b.n	8011836 <_malloc_r+0x9a>
 8011c92:	0511      	lsls	r1, r2, #20
 8011c94:	0d09      	lsrs	r1, r1, #20
 8011c96:	2900      	cmp	r1, #0
 8011c98:	f47f aea2 	bne.w	80119e0 <_malloc_r+0x244>
 8011c9c:	68ba      	ldr	r2, [r7, #8]
 8011c9e:	eb0b 0109 	add.w	r1, fp, r9
 8011ca2:	f041 0101 	orr.w	r1, r1, #1
 8011ca6:	6051      	str	r1, [r2, #4]
 8011ca8:	e6e9      	b.n	8011a7e <_malloc_r+0x2e2>
 8011caa:	2201      	movs	r2, #1
 8011cac:	f04f 0b00 	mov.w	fp, #0
 8011cb0:	e6c2      	b.n	8011a38 <_malloc_r+0x29c>
 8011cb2:	4630      	mov	r0, r6
 8011cb4:	f105 0108 	add.w	r1, r5, #8
 8011cb8:	f001 fb78 	bl	80133ac <_free_r>
 8011cbc:	4b12      	ldr	r3, [pc, #72]	; (8011d08 <_malloc_r+0x56c>)
 8011cbe:	685b      	ldr	r3, [r3, #4]
 8011cc0:	e6dd      	b.n	8011a7e <_malloc_r+0x2e2>
 8011cc2:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8011cc6:	d806      	bhi.n	8011cd6 <_malloc_r+0x53a>
 8011cc8:	ea4f 39d0 	mov.w	r9, r0, lsr #15
 8011ccc:	f109 0977 	add.w	r9, r9, #119	; 0x77
 8011cd0:	ea4f 0549 	mov.w	r5, r9, lsl #1
 8011cd4:	e738      	b.n	8011b48 <_malloc_r+0x3ac>
 8011cd6:	f240 5154 	movw	r1, #1364	; 0x554
 8011cda:	25fc      	movs	r5, #252	; 0xfc
 8011cdc:	428a      	cmp	r2, r1
 8011cde:	f04f 097e 	mov.w	r9, #126	; 0x7e
 8011ce2:	bf9e      	ittt	ls
 8011ce4:	ea4f 4990 	movls.w	r9, r0, lsr #18
 8011ce8:	f109 097c 	addls.w	r9, r9, #124	; 0x7c
 8011cec:	ea4f 0549 	movls.w	r5, r9, lsl #1
 8011cf0:	e72a      	b.n	8011b48 <_malloc_r+0x3ac>
 8011cf2:	687a      	ldr	r2, [r7, #4]
 8011cf4:	ea22 0203 	bic.w	r2, r2, r3
 8011cf8:	607a      	str	r2, [r7, #4]
 8011cfa:	e764      	b.n	8011bc6 <_malloc_r+0x42a>
 8011cfc:	005b      	lsls	r3, r3, #1
 8011cfe:	f108 0804 	add.w	r8, r8, #4
 8011d02:	e767      	b.n	8011bd4 <_malloc_r+0x438>
 8011d04:	200004e0 	.word	0x200004e0
 8011d08:	20000b50 	.word	0x20000b50

08011d0c <memchr>:
 8011d0c:	0783      	lsls	r3, r0, #30
 8011d0e:	b2c9      	uxtb	r1, r1
 8011d10:	b470      	push	{r4, r5, r6}
 8011d12:	d040      	beq.n	8011d96 <memchr+0x8a>
 8011d14:	1e54      	subs	r4, r2, #1
 8011d16:	2a00      	cmp	r2, #0
 8011d18:	d03f      	beq.n	8011d9a <memchr+0x8e>
 8011d1a:	7803      	ldrb	r3, [r0, #0]
 8011d1c:	428b      	cmp	r3, r1
 8011d1e:	d021      	beq.n	8011d64 <memchr+0x58>
 8011d20:	1c43      	adds	r3, r0, #1
 8011d22:	e004      	b.n	8011d2e <memchr+0x22>
 8011d24:	b304      	cbz	r4, 8011d68 <memchr+0x5c>
 8011d26:	7802      	ldrb	r2, [r0, #0]
 8011d28:	3c01      	subs	r4, #1
 8011d2a:	428a      	cmp	r2, r1
 8011d2c:	d01a      	beq.n	8011d64 <memchr+0x58>
 8011d2e:	f013 0f03 	tst.w	r3, #3
 8011d32:	4618      	mov	r0, r3
 8011d34:	f103 0301 	add.w	r3, r3, #1
 8011d38:	d1f4      	bne.n	8011d24 <memchr+0x18>
 8011d3a:	2c03      	cmp	r4, #3
 8011d3c:	d816      	bhi.n	8011d6c <memchr+0x60>
 8011d3e:	1e65      	subs	r5, r4, #1
 8011d40:	b194      	cbz	r4, 8011d68 <memchr+0x5c>
 8011d42:	7803      	ldrb	r3, [r0, #0]
 8011d44:	428b      	cmp	r3, r1
 8011d46:	d00d      	beq.n	8011d64 <memchr+0x58>
 8011d48:	1c42      	adds	r2, r0, #1
 8011d4a:	2300      	movs	r3, #0
 8011d4c:	e002      	b.n	8011d54 <memchr+0x48>
 8011d4e:	7804      	ldrb	r4, [r0, #0]
 8011d50:	428c      	cmp	r4, r1
 8011d52:	d007      	beq.n	8011d64 <memchr+0x58>
 8011d54:	429d      	cmp	r5, r3
 8011d56:	4610      	mov	r0, r2
 8011d58:	f103 0301 	add.w	r3, r3, #1
 8011d5c:	f102 0201 	add.w	r2, r2, #1
 8011d60:	d1f5      	bne.n	8011d4e <memchr+0x42>
 8011d62:	2000      	movs	r0, #0
 8011d64:	bc70      	pop	{r4, r5, r6}
 8011d66:	4770      	bx	lr
 8011d68:	4620      	mov	r0, r4
 8011d6a:	e7fb      	b.n	8011d64 <memchr+0x58>
 8011d6c:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 8011d70:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 8011d74:	4602      	mov	r2, r0
 8011d76:	3004      	adds	r0, #4
 8011d78:	6813      	ldr	r3, [r2, #0]
 8011d7a:	4073      	eors	r3, r6
 8011d7c:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
 8011d80:	ea25 0303 	bic.w	r3, r5, r3
 8011d84:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8011d88:	d103      	bne.n	8011d92 <memchr+0x86>
 8011d8a:	3c04      	subs	r4, #4
 8011d8c:	2c03      	cmp	r4, #3
 8011d8e:	d8f1      	bhi.n	8011d74 <memchr+0x68>
 8011d90:	e7d5      	b.n	8011d3e <memchr+0x32>
 8011d92:	4610      	mov	r0, r2
 8011d94:	e7d3      	b.n	8011d3e <memchr+0x32>
 8011d96:	4614      	mov	r4, r2
 8011d98:	e7cf      	b.n	8011d3a <memchr+0x2e>
 8011d9a:	4610      	mov	r0, r2
 8011d9c:	e7e2      	b.n	8011d64 <memchr+0x58>
 8011d9e:	bf00      	nop

08011da0 <memcmp>:
 8011da0:	2a03      	cmp	r2, #3
 8011da2:	b470      	push	{r4, r5, r6}
 8011da4:	d922      	bls.n	8011dec <memcmp+0x4c>
 8011da6:	ea41 0300 	orr.w	r3, r1, r0
 8011daa:	079b      	lsls	r3, r3, #30
 8011dac:	d013      	beq.n	8011dd6 <memcmp+0x36>
 8011dae:	7805      	ldrb	r5, [r0, #0]
 8011db0:	3a01      	subs	r2, #1
 8011db2:	780c      	ldrb	r4, [r1, #0]
 8011db4:	2300      	movs	r3, #0
 8011db6:	42a5      	cmp	r5, r4
 8011db8:	d006      	beq.n	8011dc8 <memcmp+0x28>
 8011dba:	e01b      	b.n	8011df4 <memcmp+0x54>
 8011dbc:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 8011dc0:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8011dc4:	42a5      	cmp	r5, r4
 8011dc6:	d115      	bne.n	8011df4 <memcmp+0x54>
 8011dc8:	4293      	cmp	r3, r2
 8011dca:	f103 0301 	add.w	r3, r3, #1
 8011dce:	d1f5      	bne.n	8011dbc <memcmp+0x1c>
 8011dd0:	2000      	movs	r0, #0
 8011dd2:	bc70      	pop	{r4, r5, r6}
 8011dd4:	4770      	bx	lr
 8011dd6:	460c      	mov	r4, r1
 8011dd8:	4603      	mov	r3, r0
 8011dda:	3104      	adds	r1, #4
 8011ddc:	3004      	adds	r0, #4
 8011dde:	681e      	ldr	r6, [r3, #0]
 8011de0:	6825      	ldr	r5, [r4, #0]
 8011de2:	42ae      	cmp	r6, r5
 8011de4:	d108      	bne.n	8011df8 <memcmp+0x58>
 8011de6:	3a04      	subs	r2, #4
 8011de8:	2a03      	cmp	r2, #3
 8011dea:	d8f4      	bhi.n	8011dd6 <memcmp+0x36>
 8011dec:	2a00      	cmp	r2, #0
 8011dee:	d1de      	bne.n	8011dae <memcmp+0xe>
 8011df0:	4610      	mov	r0, r2
 8011df2:	e7ee      	b.n	8011dd2 <memcmp+0x32>
 8011df4:	1b28      	subs	r0, r5, r4
 8011df6:	e7ec      	b.n	8011dd2 <memcmp+0x32>
 8011df8:	4621      	mov	r1, r4
 8011dfa:	4618      	mov	r0, r3
 8011dfc:	2a00      	cmp	r2, #0
 8011dfe:	d1d6      	bne.n	8011dae <memcmp+0xe>
 8011e00:	e7f6      	b.n	8011df0 <memcmp+0x50>
 8011e02:	bf00      	nop

08011e04 <memcpy>:
 8011e04:	2a0f      	cmp	r2, #15
 8011e06:	b4f0      	push	{r4, r5, r6, r7}
 8011e08:	d940      	bls.n	8011e8c <memcpy+0x88>
 8011e0a:	ea41 0300 	orr.w	r3, r1, r0
 8011e0e:	079b      	lsls	r3, r3, #30
 8011e10:	d13e      	bne.n	8011e90 <memcpy+0x8c>
 8011e12:	460c      	mov	r4, r1
 8011e14:	4603      	mov	r3, r0
 8011e16:	4615      	mov	r5, r2
 8011e18:	6826      	ldr	r6, [r4, #0]
 8011e1a:	3d10      	subs	r5, #16
 8011e1c:	601e      	str	r6, [r3, #0]
 8011e1e:	6866      	ldr	r6, [r4, #4]
 8011e20:	605e      	str	r6, [r3, #4]
 8011e22:	68a6      	ldr	r6, [r4, #8]
 8011e24:	609e      	str	r6, [r3, #8]
 8011e26:	68e6      	ldr	r6, [r4, #12]
 8011e28:	3410      	adds	r4, #16
 8011e2a:	60de      	str	r6, [r3, #12]
 8011e2c:	3310      	adds	r3, #16
 8011e2e:	2d0f      	cmp	r5, #15
 8011e30:	d8f2      	bhi.n	8011e18 <memcpy+0x14>
 8011e32:	f1a2 0510 	sub.w	r5, r2, #16
 8011e36:	f002 040f 	and.w	r4, r2, #15
 8011e3a:	f025 050f 	bic.w	r5, r5, #15
 8011e3e:	3510      	adds	r5, #16
 8011e40:	2c03      	cmp	r4, #3
 8011e42:	eb00 0305 	add.w	r3, r0, r5
 8011e46:	4429      	add	r1, r5
 8011e48:	d924      	bls.n	8011e94 <memcpy+0x90>
 8011e4a:	f1a4 0c04 	sub.w	ip, r4, #4
 8011e4e:	461d      	mov	r5, r3
 8011e50:	460c      	mov	r4, r1
 8011e52:	ea4f 0c9c 	mov.w	ip, ip, lsr #2
 8011e56:	eb01 078c 	add.w	r7, r1, ip, lsl #2
 8011e5a:	3704      	adds	r7, #4
 8011e5c:	f854 6b04 	ldr.w	r6, [r4], #4
 8011e60:	42bc      	cmp	r4, r7
 8011e62:	f845 6b04 	str.w	r6, [r5], #4
 8011e66:	d1f9      	bne.n	8011e5c <memcpy+0x58>
 8011e68:	f10c 0401 	add.w	r4, ip, #1
 8011e6c:	f002 0203 	and.w	r2, r2, #3
 8011e70:	00a4      	lsls	r4, r4, #2
 8011e72:	1909      	adds	r1, r1, r4
 8011e74:	191b      	adds	r3, r3, r4
 8011e76:	b13a      	cbz	r2, 8011e88 <memcpy+0x84>
 8011e78:	3901      	subs	r1, #1
 8011e7a:	189a      	adds	r2, r3, r2
 8011e7c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8011e80:	f803 4b01 	strb.w	r4, [r3], #1
 8011e84:	4293      	cmp	r3, r2
 8011e86:	d1f9      	bne.n	8011e7c <memcpy+0x78>
 8011e88:	bcf0      	pop	{r4, r5, r6, r7}
 8011e8a:	4770      	bx	lr
 8011e8c:	4603      	mov	r3, r0
 8011e8e:	e7f2      	b.n	8011e76 <memcpy+0x72>
 8011e90:	4603      	mov	r3, r0
 8011e92:	e7f1      	b.n	8011e78 <memcpy+0x74>
 8011e94:	4622      	mov	r2, r4
 8011e96:	e7ee      	b.n	8011e76 <memcpy+0x72>

08011e98 <memmove>:
 8011e98:	4288      	cmp	r0, r1
 8011e9a:	b4f0      	push	{r4, r5, r6, r7}
 8011e9c:	d911      	bls.n	8011ec2 <memmove+0x2a>
 8011e9e:	188c      	adds	r4, r1, r2
 8011ea0:	42a0      	cmp	r0, r4
 8011ea2:	d20e      	bcs.n	8011ec2 <memmove+0x2a>
 8011ea4:	1885      	adds	r5, r0, r2
 8011ea6:	1e53      	subs	r3, r2, #1
 8011ea8:	b14a      	cbz	r2, 8011ebe <memmove+0x26>
 8011eaa:	4621      	mov	r1, r4
 8011eac:	462a      	mov	r2, r5
 8011eae:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
 8011eb2:	3b01      	subs	r3, #1
 8011eb4:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011eb8:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8011ebc:	d1f7      	bne.n	8011eae <memmove+0x16>
 8011ebe:	bcf0      	pop	{r4, r5, r6, r7}
 8011ec0:	4770      	bx	lr
 8011ec2:	2a0f      	cmp	r2, #15
 8011ec4:	d940      	bls.n	8011f48 <memmove+0xb0>
 8011ec6:	ea41 0300 	orr.w	r3, r1, r0
 8011eca:	079b      	lsls	r3, r3, #30
 8011ecc:	d13e      	bne.n	8011f4c <memmove+0xb4>
 8011ece:	460c      	mov	r4, r1
 8011ed0:	4603      	mov	r3, r0
 8011ed2:	4615      	mov	r5, r2
 8011ed4:	6826      	ldr	r6, [r4, #0]
 8011ed6:	3d10      	subs	r5, #16
 8011ed8:	601e      	str	r6, [r3, #0]
 8011eda:	6866      	ldr	r6, [r4, #4]
 8011edc:	605e      	str	r6, [r3, #4]
 8011ede:	68a6      	ldr	r6, [r4, #8]
 8011ee0:	609e      	str	r6, [r3, #8]
 8011ee2:	68e6      	ldr	r6, [r4, #12]
 8011ee4:	3410      	adds	r4, #16
 8011ee6:	60de      	str	r6, [r3, #12]
 8011ee8:	3310      	adds	r3, #16
 8011eea:	2d0f      	cmp	r5, #15
 8011eec:	d8f2      	bhi.n	8011ed4 <memmove+0x3c>
 8011eee:	f1a2 0510 	sub.w	r5, r2, #16
 8011ef2:	f002 040f 	and.w	r4, r2, #15
 8011ef6:	f025 050f 	bic.w	r5, r5, #15
 8011efa:	3510      	adds	r5, #16
 8011efc:	2c03      	cmp	r4, #3
 8011efe:	eb00 0305 	add.w	r3, r0, r5
 8011f02:	4429      	add	r1, r5
 8011f04:	d924      	bls.n	8011f50 <memmove+0xb8>
 8011f06:	f1a4 0c04 	sub.w	ip, r4, #4
 8011f0a:	461d      	mov	r5, r3
 8011f0c:	460c      	mov	r4, r1
 8011f0e:	ea4f 0c9c 	mov.w	ip, ip, lsr #2
 8011f12:	eb01 078c 	add.w	r7, r1, ip, lsl #2
 8011f16:	3704      	adds	r7, #4
 8011f18:	f854 6b04 	ldr.w	r6, [r4], #4
 8011f1c:	42bc      	cmp	r4, r7
 8011f1e:	f845 6b04 	str.w	r6, [r5], #4
 8011f22:	d1f9      	bne.n	8011f18 <memmove+0x80>
 8011f24:	f10c 0401 	add.w	r4, ip, #1
 8011f28:	f002 0203 	and.w	r2, r2, #3
 8011f2c:	00a4      	lsls	r4, r4, #2
 8011f2e:	1909      	adds	r1, r1, r4
 8011f30:	191b      	adds	r3, r3, r4
 8011f32:	2a00      	cmp	r2, #0
 8011f34:	d0c3      	beq.n	8011ebe <memmove+0x26>
 8011f36:	3901      	subs	r1, #1
 8011f38:	189a      	adds	r2, r3, r2
 8011f3a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8011f3e:	f803 4b01 	strb.w	r4, [r3], #1
 8011f42:	4293      	cmp	r3, r2
 8011f44:	d1f9      	bne.n	8011f3a <memmove+0xa2>
 8011f46:	e7ba      	b.n	8011ebe <memmove+0x26>
 8011f48:	4603      	mov	r3, r0
 8011f4a:	e7f2      	b.n	8011f32 <memmove+0x9a>
 8011f4c:	4603      	mov	r3, r0
 8011f4e:	e7f2      	b.n	8011f36 <memmove+0x9e>
 8011f50:	4622      	mov	r2, r4
 8011f52:	e7ee      	b.n	8011f32 <memmove+0x9a>

08011f54 <memset>:
 8011f54:	b470      	push	{r4, r5, r6}
 8011f56:	0784      	lsls	r4, r0, #30
 8011f58:	4603      	mov	r3, r0
 8011f5a:	d044      	beq.n	8011fe6 <memset+0x92>
 8011f5c:	1e54      	subs	r4, r2, #1
 8011f5e:	2a00      	cmp	r2, #0
 8011f60:	d03f      	beq.n	8011fe2 <memset+0x8e>
 8011f62:	b2ce      	uxtb	r6, r1
 8011f64:	e002      	b.n	8011f6c <memset+0x18>
 8011f66:	2c00      	cmp	r4, #0
 8011f68:	d03b      	beq.n	8011fe2 <memset+0x8e>
 8011f6a:	4614      	mov	r4, r2
 8011f6c:	f803 6b01 	strb.w	r6, [r3], #1
 8011f70:	f013 0f03 	tst.w	r3, #3
 8011f74:	461d      	mov	r5, r3
 8011f76:	f104 32ff 	add.w	r2, r4, #4294967295
 8011f7a:	d1f4      	bne.n	8011f66 <memset+0x12>
 8011f7c:	2c03      	cmp	r4, #3
 8011f7e:	d929      	bls.n	8011fd4 <memset+0x80>
 8011f80:	b2ca      	uxtb	r2, r1
 8011f82:	2c0f      	cmp	r4, #15
 8011f84:	bf84      	itt	hi
 8011f86:	462b      	movhi	r3, r5
 8011f88:	4626      	movhi	r6, r4
 8011f8a:	ea42 2202 	orr.w	r2, r2, r2, lsl #8
 8011f8e:	ea42 4202 	orr.w	r2, r2, r2, lsl #16
 8011f92:	d911      	bls.n	8011fb8 <memset+0x64>
 8011f94:	3e10      	subs	r6, #16
 8011f96:	601a      	str	r2, [r3, #0]
 8011f98:	605a      	str	r2, [r3, #4]
 8011f9a:	609a      	str	r2, [r3, #8]
 8011f9c:	60da      	str	r2, [r3, #12]
 8011f9e:	3310      	adds	r3, #16
 8011fa0:	2e0f      	cmp	r6, #15
 8011fa2:	d8f7      	bhi.n	8011f94 <memset+0x40>
 8011fa4:	f1a4 0310 	sub.w	r3, r4, #16
 8011fa8:	f004 040f 	and.w	r4, r4, #15
 8011fac:	f023 030f 	bic.w	r3, r3, #15
 8011fb0:	3310      	adds	r3, #16
 8011fb2:	2c03      	cmp	r4, #3
 8011fb4:	441d      	add	r5, r3
 8011fb6:	d90d      	bls.n	8011fd4 <memset+0x80>
 8011fb8:	462e      	mov	r6, r5
 8011fba:	4623      	mov	r3, r4
 8011fbc:	3b04      	subs	r3, #4
 8011fbe:	f846 2b04 	str.w	r2, [r6], #4
 8011fc2:	2b03      	cmp	r3, #3
 8011fc4:	d8fa      	bhi.n	8011fbc <memset+0x68>
 8011fc6:	1f23      	subs	r3, r4, #4
 8011fc8:	f004 0403 	and.w	r4, r4, #3
 8011fcc:	f023 0303 	bic.w	r3, r3, #3
 8011fd0:	3304      	adds	r3, #4
 8011fd2:	18ed      	adds	r5, r5, r3
 8011fd4:	b12c      	cbz	r4, 8011fe2 <memset+0x8e>
 8011fd6:	b2c9      	uxtb	r1, r1
 8011fd8:	192c      	adds	r4, r5, r4
 8011fda:	f805 1b01 	strb.w	r1, [r5], #1
 8011fde:	42a5      	cmp	r5, r4
 8011fe0:	d1fb      	bne.n	8011fda <memset+0x86>
 8011fe2:	bc70      	pop	{r4, r5, r6}
 8011fe4:	4770      	bx	lr
 8011fe6:	4605      	mov	r5, r0
 8011fe8:	4614      	mov	r4, r2
 8011fea:	e7c7      	b.n	8011f7c <memset+0x28>

08011fec <__malloc_lock>:
 8011fec:	4770      	bx	lr
 8011fee:	bf00      	nop

08011ff0 <__malloc_unlock>:
 8011ff0:	4770      	bx	lr
 8011ff2:	bf00      	nop

08011ff4 <_putc_r>:
 8011ff4:	b570      	push	{r4, r5, r6, lr}
 8011ff6:	460d      	mov	r5, r1
 8011ff8:	4614      	mov	r4, r2
 8011ffa:	4606      	mov	r6, r0
 8011ffc:	b108      	cbz	r0, 8012002 <_putc_r+0xe>
 8011ffe:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8012000:	b1c3      	cbz	r3, 8012034 <_putc_r+0x40>
 8012002:	68a3      	ldr	r3, [r4, #8]
 8012004:	3b01      	subs	r3, #1
 8012006:	60a3      	str	r3, [r4, #8]
 8012008:	2b00      	cmp	r3, #0
 801200a:	db06      	blt.n	801201a <_putc_r+0x26>
 801200c:	6823      	ldr	r3, [r4, #0]
 801200e:	701d      	strb	r5, [r3, #0]
 8012010:	6823      	ldr	r3, [r4, #0]
 8012012:	f813 0b01 	ldrb.w	r0, [r3], #1
 8012016:	6023      	str	r3, [r4, #0]
 8012018:	bd70      	pop	{r4, r5, r6, pc}
 801201a:	69a2      	ldr	r2, [r4, #24]
 801201c:	4293      	cmp	r3, r2
 801201e:	db0c      	blt.n	801203a <_putc_r+0x46>
 8012020:	6823      	ldr	r3, [r4, #0]
 8012022:	701d      	strb	r5, [r3, #0]
 8012024:	6823      	ldr	r3, [r4, #0]
 8012026:	7819      	ldrb	r1, [r3, #0]
 8012028:	290a      	cmp	r1, #10
 801202a:	d00d      	beq.n	8012048 <_putc_r+0x54>
 801202c:	3301      	adds	r3, #1
 801202e:	4608      	mov	r0, r1
 8012030:	6023      	str	r3, [r4, #0]
 8012032:	bd70      	pop	{r4, r5, r6, pc}
 8012034:	f001 f8e4 	bl	8013200 <__sinit>
 8012038:	e7e3      	b.n	8012002 <_putc_r+0xe>
 801203a:	4630      	mov	r0, r6
 801203c:	4629      	mov	r1, r5
 801203e:	4622      	mov	r2, r4
 8012040:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8012044:	f000 be1e 	b.w	8012c84 <__swbuf_r>
 8012048:	4630      	mov	r0, r6
 801204a:	4622      	mov	r2, r4
 801204c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8012050:	f000 be18 	b.w	8012c84 <__swbuf_r>

08012054 <putc>:
 8012054:	b570      	push	{r4, r5, r6, lr}
 8012056:	4606      	mov	r6, r0
 8012058:	4d17      	ldr	r5, [pc, #92]	; (80120b8 <putc+0x64>)
 801205a:	460c      	mov	r4, r1
 801205c:	6828      	ldr	r0, [r5, #0]
 801205e:	b108      	cbz	r0, 8012064 <putc+0x10>
 8012060:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8012062:	b1c2      	cbz	r2, 8012096 <putc+0x42>
 8012064:	68a3      	ldr	r3, [r4, #8]
 8012066:	3b01      	subs	r3, #1
 8012068:	60a3      	str	r3, [r4, #8]
 801206a:	2b00      	cmp	r3, #0
 801206c:	db06      	blt.n	801207c <putc+0x28>
 801206e:	6823      	ldr	r3, [r4, #0]
 8012070:	701e      	strb	r6, [r3, #0]
 8012072:	6823      	ldr	r3, [r4, #0]
 8012074:	f813 0b01 	ldrb.w	r0, [r3], #1
 8012078:	6023      	str	r3, [r4, #0]
 801207a:	bd70      	pop	{r4, r5, r6, pc}
 801207c:	69a2      	ldr	r2, [r4, #24]
 801207e:	4293      	cmp	r3, r2
 8012080:	db0c      	blt.n	801209c <putc+0x48>
 8012082:	6823      	ldr	r3, [r4, #0]
 8012084:	701e      	strb	r6, [r3, #0]
 8012086:	6823      	ldr	r3, [r4, #0]
 8012088:	7819      	ldrb	r1, [r3, #0]
 801208a:	290a      	cmp	r1, #10
 801208c:	d00d      	beq.n	80120aa <putc+0x56>
 801208e:	3301      	adds	r3, #1
 8012090:	4608      	mov	r0, r1
 8012092:	6023      	str	r3, [r4, #0]
 8012094:	bd70      	pop	{r4, r5, r6, pc}
 8012096:	f001 f8b3 	bl	8013200 <__sinit>
 801209a:	e7e3      	b.n	8012064 <putc+0x10>
 801209c:	6828      	ldr	r0, [r5, #0]
 801209e:	4631      	mov	r1, r6
 80120a0:	4622      	mov	r2, r4
 80120a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80120a6:	f000 bded 	b.w	8012c84 <__swbuf_r>
 80120aa:	6828      	ldr	r0, [r5, #0]
 80120ac:	4622      	mov	r2, r4
 80120ae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80120b2:	f000 bde7 	b.w	8012c84 <__swbuf_r>
 80120b6:	bf00      	nop
 80120b8:	200000b0 	.word	0x200000b0

080120bc <_puts_r>:
 80120bc:	b530      	push	{r4, r5, lr}
 80120be:	4605      	mov	r5, r0
 80120c0:	b089      	sub	sp, #36	; 0x24
 80120c2:	4608      	mov	r0, r1
 80120c4:	460c      	mov	r4, r1
 80120c6:	f000 fd57 	bl	8012b78 <strlen>
 80120ca:	4a13      	ldr	r2, [pc, #76]	; (8012118 <_puts_r+0x5c>)
 80120cc:	9404      	str	r4, [sp, #16]
 80120ce:	6812      	ldr	r2, [r2, #0]
 80120d0:	6893      	ldr	r3, [r2, #8]
 80120d2:	4a12      	ldr	r2, [pc, #72]	; (801211c <_puts_r+0x60>)
 80120d4:	9206      	str	r2, [sp, #24]
 80120d6:	2201      	movs	r2, #1
 80120d8:	9207      	str	r2, [sp, #28]
 80120da:	899a      	ldrh	r2, [r3, #12]
 80120dc:	1c41      	adds	r1, r0, #1
 80120de:	9103      	str	r1, [sp, #12]
 80120e0:	f402 5100 	and.w	r1, r2, #8192	; 0x2000
 80120e4:	9005      	str	r0, [sp, #20]
 80120e6:	a804      	add	r0, sp, #16
 80120e8:	9001      	str	r0, [sp, #4]
 80120ea:	b209      	sxth	r1, r1
 80120ec:	2002      	movs	r0, #2
 80120ee:	9002      	str	r0, [sp, #8]
 80120f0:	b931      	cbnz	r1, 8012100 <_puts_r+0x44>
 80120f2:	6e59      	ldr	r1, [r3, #100]	; 0x64
 80120f4:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80120f8:	819a      	strh	r2, [r3, #12]
 80120fa:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
 80120fe:	6659      	str	r1, [r3, #100]	; 0x64
 8012100:	4628      	mov	r0, r5
 8012102:	aa01      	add	r2, sp, #4
 8012104:	68a9      	ldr	r1, [r5, #8]
 8012106:	f7ff f93f 	bl	8011388 <__sfvwrite_r>
 801210a:	2800      	cmp	r0, #0
 801210c:	bf0c      	ite	eq
 801210e:	200a      	moveq	r0, #10
 8012110:	f04f 30ff 	movne.w	r0, #4294967295
 8012114:	b009      	add	sp, #36	; 0x24
 8012116:	bd30      	pop	{r4, r5, pc}
 8012118:	200000b0 	.word	0x200000b0
 801211c:	08020b9c 	.word	0x08020b9c

08012120 <puts>:
 8012120:	f240 03b0 	movw	r3, #176	; 0xb0
 8012124:	4601      	mov	r1, r0
 8012126:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801212a:	6818      	ldr	r0, [r3, #0]
 801212c:	f7ff bfc6 	b.w	80120bc <_puts_r>

08012130 <realloc>:
 8012130:	f240 03b0 	movw	r3, #176	; 0xb0
 8012134:	460a      	mov	r2, r1
 8012136:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801213a:	4601      	mov	r1, r0
 801213c:	6818      	ldr	r0, [r3, #0]
 801213e:	f000 b801 	b.w	8012144 <_realloc_r>
 8012142:	bf00      	nop

08012144 <_realloc_r>:
 8012144:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012148:	460c      	mov	r4, r1
 801214a:	b083      	sub	sp, #12
 801214c:	4681      	mov	r9, r0
 801214e:	4617      	mov	r7, r2
 8012150:	2900      	cmp	r1, #0
 8012152:	f000 812a 	beq.w	80123aa <_realloc_r+0x266>
 8012156:	f107 050b 	add.w	r5, r7, #11
 801215a:	f7ff ff47 	bl	8011fec <__malloc_lock>
 801215e:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8012162:	2d16      	cmp	r5, #22
 8012164:	f1a4 0a08 	sub.w	sl, r4, #8
 8012168:	f023 0603 	bic.w	r6, r3, #3
 801216c:	d87d      	bhi.n	801226a <_realloc_r+0x126>
 801216e:	2110      	movs	r1, #16
 8012170:	f04f 0800 	mov.w	r8, #0
 8012174:	460d      	mov	r5, r1
 8012176:	42bd      	cmp	r5, r7
 8012178:	bf38      	it	cc
 801217a:	f048 0801 	orrcc.w	r8, r8, #1
 801217e:	f1b8 0f00 	cmp.w	r8, #0
 8012182:	f040 8118 	bne.w	80123b6 <_realloc_r+0x272>
 8012186:	428e      	cmp	r6, r1
 8012188:	da75      	bge.n	8012276 <_realloc_r+0x132>
 801218a:	f8df c3b4 	ldr.w	ip, [pc, #948]	; 8012540 <_realloc_r+0x3fc>
 801218e:	eb0a 0206 	add.w	r2, sl, r6
 8012192:	f8dc 0008 	ldr.w	r0, [ip, #8]
 8012196:	4290      	cmp	r0, r2
 8012198:	f000 8112 	beq.w	80123c0 <_realloc_r+0x27c>
 801219c:	f8d2 e004 	ldr.w	lr, [r2, #4]
 80121a0:	f02e 0b01 	bic.w	fp, lr, #1
 80121a4:	4493      	add	fp, r2
 80121a6:	f8db b004 	ldr.w	fp, [fp, #4]
 80121aa:	f01b 0f01 	tst.w	fp, #1
 80121ae:	bf1c      	itt	ne
 80121b0:	46c6      	movne	lr, r8
 80121b2:	4672      	movne	r2, lr
 80121b4:	d078      	beq.n	80122a8 <_realloc_r+0x164>
 80121b6:	07db      	lsls	r3, r3, #31
 80121b8:	f100 80d1 	bmi.w	801235e <_realloc_r+0x21a>
 80121bc:	f854 3c08 	ldr.w	r3, [r4, #-8]
 80121c0:	ebc3 0b0a 	rsb	fp, r3, sl
 80121c4:	f8db 3004 	ldr.w	r3, [fp, #4]
 80121c8:	f023 0303 	bic.w	r3, r3, #3
 80121cc:	199b      	adds	r3, r3, r6
 80121ce:	2a00      	cmp	r2, #0
 80121d0:	d075      	beq.n	80122be <_realloc_r+0x17a>
 80121d2:	4282      	cmp	r2, r0
 80121d4:	f000 8145 	beq.w	8012462 <_realloc_r+0x31e>
 80121d8:	eb0e 0803 	add.w	r8, lr, r3
 80121dc:	4588      	cmp	r8, r1
 80121de:	db6e      	blt.n	80122be <_realloc_r+0x17a>
 80121e0:	68d1      	ldr	r1, [r2, #12]
 80121e2:	465b      	mov	r3, fp
 80121e4:	6890      	ldr	r0, [r2, #8]
 80121e6:	1f32      	subs	r2, r6, #4
 80121e8:	2a24      	cmp	r2, #36	; 0x24
 80121ea:	60c1      	str	r1, [r0, #12]
 80121ec:	6088      	str	r0, [r1, #8]
 80121ee:	f8db 100c 	ldr.w	r1, [fp, #12]
 80121f2:	f853 0f08 	ldr.w	r0, [r3, #8]!
 80121f6:	60c1      	str	r1, [r0, #12]
 80121f8:	6088      	str	r0, [r1, #8]
 80121fa:	f200 818e 	bhi.w	801251a <_realloc_r+0x3d6>
 80121fe:	2a13      	cmp	r2, #19
 8012200:	bf9c      	itt	ls
 8012202:	4619      	movls	r1, r3
 8012204:	4620      	movls	r0, r4
 8012206:	d925      	bls.n	8012254 <_realloc_r+0x110>
 8012208:	6821      	ldr	r1, [r4, #0]
 801220a:	2a1b      	cmp	r2, #27
 801220c:	bf98      	it	ls
 801220e:	f104 0008 	addls.w	r0, r4, #8
 8012212:	f8cb 1008 	str.w	r1, [fp, #8]
 8012216:	6861      	ldr	r1, [r4, #4]
 8012218:	f8cb 100c 	str.w	r1, [fp, #12]
 801221c:	bf98      	it	ls
 801221e:	f10b 0110 	addls.w	r1, fp, #16
 8012222:	d917      	bls.n	8012254 <_realloc_r+0x110>
 8012224:	68a1      	ldr	r1, [r4, #8]
 8012226:	2a24      	cmp	r2, #36	; 0x24
 8012228:	bf14      	ite	ne
 801222a:	f104 0010 	addne.w	r0, r4, #16
 801222e:	f104 0018 	addeq.w	r0, r4, #24
 8012232:	f8cb 1010 	str.w	r1, [fp, #16]
 8012236:	68e1      	ldr	r1, [r4, #12]
 8012238:	f8cb 1014 	str.w	r1, [fp, #20]
 801223c:	bf11      	iteee	ne
 801223e:	f10b 0118 	addne.w	r1, fp, #24
 8012242:	6922      	ldreq	r2, [r4, #16]
 8012244:	f10b 0120 	addeq.w	r1, fp, #32
 8012248:	f8cb 2018 	streq.w	r2, [fp, #24]
 801224c:	bf04      	itt	eq
 801224e:	6962      	ldreq	r2, [r4, #20]
 8012250:	f8cb 201c 	streq.w	r2, [fp, #28]
 8012254:	6802      	ldr	r2, [r0, #0]
 8012256:	461c      	mov	r4, r3
 8012258:	600a      	str	r2, [r1, #0]
 801225a:	46da      	mov	sl, fp
 801225c:	6843      	ldr	r3, [r0, #4]
 801225e:	604b      	str	r3, [r1, #4]
 8012260:	6883      	ldr	r3, [r0, #8]
 8012262:	608b      	str	r3, [r1, #8]
 8012264:	f8db 3004 	ldr.w	r3, [fp, #4]
 8012268:	e006      	b.n	8012278 <_realloc_r+0x134>
 801226a:	f025 0507 	bic.w	r5, r5, #7
 801226e:	4629      	mov	r1, r5
 8012270:	ea4f 78d5 	mov.w	r8, r5, lsr #31
 8012274:	e77f      	b.n	8012176 <_realloc_r+0x32>
 8012276:	46b0      	mov	r8, r6
 8012278:	ebc5 0208 	rsb	r2, r5, r8
 801227c:	2a0f      	cmp	r2, #15
 801227e:	d85a      	bhi.n	8012336 <_realloc_r+0x1f2>
 8012280:	eb0a 0208 	add.w	r2, sl, r8
 8012284:	f003 0301 	and.w	r3, r3, #1
 8012288:	ea43 0308 	orr.w	r3, r3, r8
 801228c:	f8ca 3004 	str.w	r3, [sl, #4]
 8012290:	6853      	ldr	r3, [r2, #4]
 8012292:	f043 0301 	orr.w	r3, r3, #1
 8012296:	6053      	str	r3, [r2, #4]
 8012298:	4648      	mov	r0, r9
 801229a:	4627      	mov	r7, r4
 801229c:	f7ff fea8 	bl	8011ff0 <__malloc_unlock>
 80122a0:	4638      	mov	r0, r7
 80122a2:	b003      	add	sp, #12
 80122a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80122a8:	f02e 0e03 	bic.w	lr, lr, #3
 80122ac:	eb0e 0806 	add.w	r8, lr, r6
 80122b0:	4588      	cmp	r8, r1
 80122b2:	db80      	blt.n	80121b6 <_realloc_r+0x72>
 80122b4:	68d1      	ldr	r1, [r2, #12]
 80122b6:	6892      	ldr	r2, [r2, #8]
 80122b8:	60d1      	str	r1, [r2, #12]
 80122ba:	608a      	str	r2, [r1, #8]
 80122bc:	e7dc      	b.n	8012278 <_realloc_r+0x134>
 80122be:	428b      	cmp	r3, r1
 80122c0:	db4d      	blt.n	801235e <_realloc_r+0x21a>
 80122c2:	465f      	mov	r7, fp
 80122c4:	f8db 100c 	ldr.w	r1, [fp, #12]
 80122c8:	1f32      	subs	r2, r6, #4
 80122ca:	f857 0f08 	ldr.w	r0, [r7, #8]!
 80122ce:	2a24      	cmp	r2, #36	; 0x24
 80122d0:	60c1      	str	r1, [r0, #12]
 80122d2:	6088      	str	r0, [r1, #8]
 80122d4:	f200 80b5 	bhi.w	8012442 <_realloc_r+0x2fe>
 80122d8:	2a13      	cmp	r2, #19
 80122da:	bf9c      	itt	ls
 80122dc:	4639      	movls	r1, r7
 80122de:	4620      	movls	r0, r4
 80122e0:	d925      	bls.n	801232e <_realloc_r+0x1ea>
 80122e2:	6821      	ldr	r1, [r4, #0]
 80122e4:	2a1b      	cmp	r2, #27
 80122e6:	bf98      	it	ls
 80122e8:	f104 0008 	addls.w	r0, r4, #8
 80122ec:	f8cb 1008 	str.w	r1, [fp, #8]
 80122f0:	6861      	ldr	r1, [r4, #4]
 80122f2:	f8cb 100c 	str.w	r1, [fp, #12]
 80122f6:	bf98      	it	ls
 80122f8:	f10b 0110 	addls.w	r1, fp, #16
 80122fc:	d917      	bls.n	801232e <_realloc_r+0x1ea>
 80122fe:	68a1      	ldr	r1, [r4, #8]
 8012300:	2a24      	cmp	r2, #36	; 0x24
 8012302:	bf14      	ite	ne
 8012304:	f104 0010 	addne.w	r0, r4, #16
 8012308:	f104 0018 	addeq.w	r0, r4, #24
 801230c:	f8cb 1010 	str.w	r1, [fp, #16]
 8012310:	68e1      	ldr	r1, [r4, #12]
 8012312:	f8cb 1014 	str.w	r1, [fp, #20]
 8012316:	bf11      	iteee	ne
 8012318:	f10b 0118 	addne.w	r1, fp, #24
 801231c:	6922      	ldreq	r2, [r4, #16]
 801231e:	f10b 0120 	addeq.w	r1, fp, #32
 8012322:	f8cb 2018 	streq.w	r2, [fp, #24]
 8012326:	bf04      	itt	eq
 8012328:	6962      	ldreq	r2, [r4, #20]
 801232a:	f8cb 201c 	streq.w	r2, [fp, #28]
 801232e:	6802      	ldr	r2, [r0, #0]
 8012330:	463c      	mov	r4, r7
 8012332:	4698      	mov	r8, r3
 8012334:	e790      	b.n	8012258 <_realloc_r+0x114>
 8012336:	eb0a 0105 	add.w	r1, sl, r5
 801233a:	f003 0301 	and.w	r3, r3, #1
 801233e:	188e      	adds	r6, r1, r2
 8012340:	431d      	orrs	r5, r3
 8012342:	f042 0201 	orr.w	r2, r2, #1
 8012346:	f8ca 5004 	str.w	r5, [sl, #4]
 801234a:	604a      	str	r2, [r1, #4]
 801234c:	4648      	mov	r0, r9
 801234e:	6873      	ldr	r3, [r6, #4]
 8012350:	3108      	adds	r1, #8
 8012352:	f043 0301 	orr.w	r3, r3, #1
 8012356:	6073      	str	r3, [r6, #4]
 8012358:	f001 f828 	bl	80133ac <_free_r>
 801235c:	e79c      	b.n	8012298 <_realloc_r+0x154>
 801235e:	4639      	mov	r1, r7
 8012360:	4648      	mov	r0, r9
 8012362:	f7ff fa1b 	bl	801179c <_malloc_r>
 8012366:	4607      	mov	r7, r0
 8012368:	b1d8      	cbz	r0, 80123a2 <_realloc_r+0x25e>
 801236a:	f854 3c04 	ldr.w	r3, [r4, #-4]
 801236e:	f1a0 0108 	sub.w	r1, r0, #8
 8012372:	f023 0201 	bic.w	r2, r3, #1
 8012376:	4452      	add	r2, sl
 8012378:	4291      	cmp	r1, r2
 801237a:	f000 80c8 	beq.w	801250e <_realloc_r+0x3ca>
 801237e:	1f32      	subs	r2, r6, #4
 8012380:	2a24      	cmp	r2, #36	; 0x24
 8012382:	d86a      	bhi.n	801245a <_realloc_r+0x316>
 8012384:	2a13      	cmp	r2, #19
 8012386:	bf9c      	itt	ls
 8012388:	4603      	movls	r3, r0
 801238a:	4622      	movls	r2, r4
 801238c:	d838      	bhi.n	8012400 <_realloc_r+0x2bc>
 801238e:	6811      	ldr	r1, [r2, #0]
 8012390:	6019      	str	r1, [r3, #0]
 8012392:	6851      	ldr	r1, [r2, #4]
 8012394:	6059      	str	r1, [r3, #4]
 8012396:	6892      	ldr	r2, [r2, #8]
 8012398:	609a      	str	r2, [r3, #8]
 801239a:	4648      	mov	r0, r9
 801239c:	4621      	mov	r1, r4
 801239e:	f001 f805 	bl	80133ac <_free_r>
 80123a2:	4648      	mov	r0, r9
 80123a4:	f7ff fe24 	bl	8011ff0 <__malloc_unlock>
 80123a8:	e77a      	b.n	80122a0 <_realloc_r+0x15c>
 80123aa:	4611      	mov	r1, r2
 80123ac:	b003      	add	sp, #12
 80123ae:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80123b2:	f7ff b9f3 	b.w	801179c <_malloc_r>
 80123b6:	230c      	movs	r3, #12
 80123b8:	2700      	movs	r7, #0
 80123ba:	f8c9 3000 	str.w	r3, [r9]
 80123be:	e76f      	b.n	80122a0 <_realloc_r+0x15c>
 80123c0:	6842      	ldr	r2, [r0, #4]
 80123c2:	f105 0810 	add.w	r8, r5, #16
 80123c6:	f022 0e03 	bic.w	lr, r2, #3
 80123ca:	eb0e 0206 	add.w	r2, lr, r6
 80123ce:	4542      	cmp	r2, r8
 80123d0:	bfb8      	it	lt
 80123d2:	4602      	movlt	r2, r0
 80123d4:	f6ff aeef 	blt.w	80121b6 <_realloc_r+0x72>
 80123d8:	eb0a 0305 	add.w	r3, sl, r5
 80123dc:	1b52      	subs	r2, r2, r5
 80123de:	f042 0201 	orr.w	r2, r2, #1
 80123e2:	4648      	mov	r0, r9
 80123e4:	605a      	str	r2, [r3, #4]
 80123e6:	4627      	mov	r7, r4
 80123e8:	f854 2c04 	ldr.w	r2, [r4, #-4]
 80123ec:	f8cc 3008 	str.w	r3, [ip, #8]
 80123f0:	f002 0201 	and.w	r2, r2, #1
 80123f4:	4315      	orrs	r5, r2
 80123f6:	f844 5c04 	str.w	r5, [r4, #-4]
 80123fa:	f7ff fdf9 	bl	8011ff0 <__malloc_unlock>
 80123fe:	e74f      	b.n	80122a0 <_realloc_r+0x15c>
 8012400:	6823      	ldr	r3, [r4, #0]
 8012402:	2a1b      	cmp	r2, #27
 8012404:	bf98      	it	ls
 8012406:	f104 0208 	addls.w	r2, r4, #8
 801240a:	6003      	str	r3, [r0, #0]
 801240c:	6863      	ldr	r3, [r4, #4]
 801240e:	6043      	str	r3, [r0, #4]
 8012410:	bf98      	it	ls
 8012412:	f100 0308 	addls.w	r3, r0, #8
 8012416:	d9ba      	bls.n	801238e <_realloc_r+0x24a>
 8012418:	68a3      	ldr	r3, [r4, #8]
 801241a:	2a24      	cmp	r2, #36	; 0x24
 801241c:	bf14      	ite	ne
 801241e:	f104 0210 	addne.w	r2, r4, #16
 8012422:	f104 0218 	addeq.w	r2, r4, #24
 8012426:	6083      	str	r3, [r0, #8]
 8012428:	68e3      	ldr	r3, [r4, #12]
 801242a:	60c3      	str	r3, [r0, #12]
 801242c:	bf11      	iteee	ne
 801242e:	f100 0310 	addne.w	r3, r0, #16
 8012432:	6921      	ldreq	r1, [r4, #16]
 8012434:	f100 0318 	addeq.w	r3, r0, #24
 8012438:	6101      	streq	r1, [r0, #16]
 801243a:	bf04      	itt	eq
 801243c:	6961      	ldreq	r1, [r4, #20]
 801243e:	6141      	streq	r1, [r0, #20]
 8012440:	e7a5      	b.n	801238e <_realloc_r+0x24a>
 8012442:	4621      	mov	r1, r4
 8012444:	4638      	mov	r0, r7
 8012446:	9301      	str	r3, [sp, #4]
 8012448:	f7ff fd26 	bl	8011e98 <memmove>
 801244c:	9b01      	ldr	r3, [sp, #4]
 801244e:	463c      	mov	r4, r7
 8012450:	46da      	mov	sl, fp
 8012452:	4698      	mov	r8, r3
 8012454:	f8db 3004 	ldr.w	r3, [fp, #4]
 8012458:	e70e      	b.n	8012278 <_realloc_r+0x134>
 801245a:	4621      	mov	r1, r4
 801245c:	f7ff fd1c 	bl	8011e98 <memmove>
 8012460:	e79b      	b.n	801239a <_realloc_r+0x256>
 8012462:	f105 0210 	add.w	r2, r5, #16
 8012466:	eb0e 0803 	add.w	r8, lr, r3
 801246a:	4590      	cmp	r8, r2
 801246c:	f6ff af27 	blt.w	80122be <_realloc_r+0x17a>
 8012470:	465f      	mov	r7, fp
 8012472:	f8db 300c 	ldr.w	r3, [fp, #12]
 8012476:	1f32      	subs	r2, r6, #4
 8012478:	f857 1f08 	ldr.w	r1, [r7, #8]!
 801247c:	2a24      	cmp	r2, #36	; 0x24
 801247e:	60cb      	str	r3, [r1, #12]
 8012480:	6099      	str	r1, [r3, #8]
 8012482:	d853      	bhi.n	801252c <_realloc_r+0x3e8>
 8012484:	2a13      	cmp	r2, #19
 8012486:	bf9c      	itt	ls
 8012488:	463b      	movls	r3, r7
 801248a:	4622      	movls	r2, r4
 801248c:	d925      	bls.n	80124da <_realloc_r+0x396>
 801248e:	6823      	ldr	r3, [r4, #0]
 8012490:	2a1b      	cmp	r2, #27
 8012492:	bf98      	it	ls
 8012494:	f104 0208 	addls.w	r2, r4, #8
 8012498:	f8cb 3008 	str.w	r3, [fp, #8]
 801249c:	6863      	ldr	r3, [r4, #4]
 801249e:	f8cb 300c 	str.w	r3, [fp, #12]
 80124a2:	bf98      	it	ls
 80124a4:	f10b 0310 	addls.w	r3, fp, #16
 80124a8:	d917      	bls.n	80124da <_realloc_r+0x396>
 80124aa:	68a3      	ldr	r3, [r4, #8]
 80124ac:	2a24      	cmp	r2, #36	; 0x24
 80124ae:	bf14      	ite	ne
 80124b0:	f104 0210 	addne.w	r2, r4, #16
 80124b4:	f104 0218 	addeq.w	r2, r4, #24
 80124b8:	f8cb 3010 	str.w	r3, [fp, #16]
 80124bc:	68e3      	ldr	r3, [r4, #12]
 80124be:	f8cb 3014 	str.w	r3, [fp, #20]
 80124c2:	bf11      	iteee	ne
 80124c4:	f10b 0318 	addne.w	r3, fp, #24
 80124c8:	6921      	ldreq	r1, [r4, #16]
 80124ca:	f10b 0320 	addeq.w	r3, fp, #32
 80124ce:	f8cb 1018 	streq.w	r1, [fp, #24]
 80124d2:	bf04      	itt	eq
 80124d4:	6961      	ldreq	r1, [r4, #20]
 80124d6:	f8cb 101c 	streq.w	r1, [fp, #28]
 80124da:	6811      	ldr	r1, [r2, #0]
 80124dc:	6019      	str	r1, [r3, #0]
 80124de:	6851      	ldr	r1, [r2, #4]
 80124e0:	6059      	str	r1, [r3, #4]
 80124e2:	6892      	ldr	r2, [r2, #8]
 80124e4:	609a      	str	r2, [r3, #8]
 80124e6:	eb0b 0305 	add.w	r3, fp, r5
 80124ea:	ebc5 0208 	rsb	r2, r5, r8
 80124ee:	f042 0201 	orr.w	r2, r2, #1
 80124f2:	4648      	mov	r0, r9
 80124f4:	605a      	str	r2, [r3, #4]
 80124f6:	f8db 2004 	ldr.w	r2, [fp, #4]
 80124fa:	f8cc 3008 	str.w	r3, [ip, #8]
 80124fe:	f002 0201 	and.w	r2, r2, #1
 8012502:	4315      	orrs	r5, r2
 8012504:	f8cb 5004 	str.w	r5, [fp, #4]
 8012508:	f7ff fd72 	bl	8011ff0 <__malloc_unlock>
 801250c:	e6c8      	b.n	80122a0 <_realloc_r+0x15c>
 801250e:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8012512:	f022 0803 	bic.w	r8, r2, #3
 8012516:	44b0      	add	r8, r6
 8012518:	e6ae      	b.n	8012278 <_realloc_r+0x134>
 801251a:	4621      	mov	r1, r4
 801251c:	4618      	mov	r0, r3
 801251e:	461c      	mov	r4, r3
 8012520:	46da      	mov	sl, fp
 8012522:	f7ff fcb9 	bl	8011e98 <memmove>
 8012526:	f8db 3004 	ldr.w	r3, [fp, #4]
 801252a:	e6a5      	b.n	8012278 <_realloc_r+0x134>
 801252c:	4638      	mov	r0, r7
 801252e:	4621      	mov	r1, r4
 8012530:	f8cd c004 	str.w	ip, [sp, #4]
 8012534:	f7ff fcb0 	bl	8011e98 <memmove>
 8012538:	f8dd c004 	ldr.w	ip, [sp, #4]
 801253c:	e7d3      	b.n	80124e6 <_realloc_r+0x3a2>
 801253e:	bf00      	nop
 8012540:	200004e0 	.word	0x200004e0

08012544 <cleanup_glue>:
 8012544:	b538      	push	{r3, r4, r5, lr}
 8012546:	460c      	mov	r4, r1
 8012548:	6809      	ldr	r1, [r1, #0]
 801254a:	4605      	mov	r5, r0
 801254c:	b109      	cbz	r1, 8012552 <cleanup_glue+0xe>
 801254e:	f7ff fff9 	bl	8012544 <cleanup_glue>
 8012552:	4628      	mov	r0, r5
 8012554:	4621      	mov	r1, r4
 8012556:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801255a:	f000 bf27 	b.w	80133ac <_free_r>
 801255e:	bf00      	nop

08012560 <_reclaim_reent>:
 8012560:	4b21      	ldr	r3, [pc, #132]	; (80125e8 <_reclaim_reent+0x88>)
 8012562:	b570      	push	{r4, r5, r6, lr}
 8012564:	4605      	mov	r5, r0
 8012566:	681b      	ldr	r3, [r3, #0]
 8012568:	4298      	cmp	r0, r3
 801256a:	d030      	beq.n	80125ce <_reclaim_reent+0x6e>
 801256c:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 801256e:	b1a2      	cbz	r2, 801259a <_reclaim_reent+0x3a>
 8012570:	2300      	movs	r3, #0
 8012572:	461e      	mov	r6, r3
 8012574:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 8012578:	b139      	cbz	r1, 801258a <_reclaim_reent+0x2a>
 801257a:	680c      	ldr	r4, [r1, #0]
 801257c:	4628      	mov	r0, r5
 801257e:	f000 ff15 	bl	80133ac <_free_r>
 8012582:	4621      	mov	r1, r4
 8012584:	2c00      	cmp	r4, #0
 8012586:	d1f8      	bne.n	801257a <_reclaim_reent+0x1a>
 8012588:	6cea      	ldr	r2, [r5, #76]	; 0x4c
 801258a:	3601      	adds	r6, #1
 801258c:	2e20      	cmp	r6, #32
 801258e:	4633      	mov	r3, r6
 8012590:	d1f0      	bne.n	8012574 <_reclaim_reent+0x14>
 8012592:	4628      	mov	r0, r5
 8012594:	4611      	mov	r1, r2
 8012596:	f000 ff09 	bl	80133ac <_free_r>
 801259a:	6c29      	ldr	r1, [r5, #64]	; 0x40
 801259c:	b111      	cbz	r1, 80125a4 <_reclaim_reent+0x44>
 801259e:	4628      	mov	r0, r5
 80125a0:	f000 ff04 	bl	80133ac <_free_r>
 80125a4:	f8d5 1148 	ldr.w	r1, [r5, #328]	; 0x148
 80125a8:	b151      	cbz	r1, 80125c0 <_reclaim_reent+0x60>
 80125aa:	f505 76a6 	add.w	r6, r5, #332	; 0x14c
 80125ae:	42b1      	cmp	r1, r6
 80125b0:	d006      	beq.n	80125c0 <_reclaim_reent+0x60>
 80125b2:	680c      	ldr	r4, [r1, #0]
 80125b4:	4628      	mov	r0, r5
 80125b6:	f000 fef9 	bl	80133ac <_free_r>
 80125ba:	42a6      	cmp	r6, r4
 80125bc:	4621      	mov	r1, r4
 80125be:	d1f8      	bne.n	80125b2 <_reclaim_reent+0x52>
 80125c0:	6d69      	ldr	r1, [r5, #84]	; 0x54
 80125c2:	b111      	cbz	r1, 80125ca <_reclaim_reent+0x6a>
 80125c4:	4628      	mov	r0, r5
 80125c6:	f000 fef1 	bl	80133ac <_free_r>
 80125ca:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80125cc:	b903      	cbnz	r3, 80125d0 <_reclaim_reent+0x70>
 80125ce:	bd70      	pop	{r4, r5, r6, pc}
 80125d0:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 80125d2:	4628      	mov	r0, r5
 80125d4:	4798      	blx	r3
 80125d6:	f8d5 12e0 	ldr.w	r1, [r5, #736]	; 0x2e0
 80125da:	2900      	cmp	r1, #0
 80125dc:	d0f7      	beq.n	80125ce <_reclaim_reent+0x6e>
 80125de:	4628      	mov	r0, r5
 80125e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80125e4:	f7ff bfae 	b.w	8012544 <cleanup_glue>
 80125e8:	200000b0 	.word	0x200000b0

080125ec <_wrapup_reent>:
 80125ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80125ee:	4607      	mov	r7, r0
 80125f0:	b1b8      	cbz	r0, 8012622 <_wrapup_reent+0x36>
 80125f2:	f8d7 6148 	ldr.w	r6, [r7, #328]	; 0x148
 80125f6:	b176      	cbz	r6, 8012616 <_wrapup_reent+0x2a>
 80125f8:	6875      	ldr	r5, [r6, #4]
 80125fa:	1e6c      	subs	r4, r5, #1
 80125fc:	d408      	bmi.n	8012610 <_wrapup_reent+0x24>
 80125fe:	3502      	adds	r5, #2
 8012600:	eb06 0585 	add.w	r5, r6, r5, lsl #2
 8012604:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 8012608:	3c01      	subs	r4, #1
 801260a:	4798      	blx	r3
 801260c:	1c63      	adds	r3, r4, #1
 801260e:	d1f9      	bne.n	8012604 <_wrapup_reent+0x18>
 8012610:	6836      	ldr	r6, [r6, #0]
 8012612:	2e00      	cmp	r6, #0
 8012614:	d1f0      	bne.n	80125f8 <_wrapup_reent+0xc>
 8012616:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012618:	b113      	cbz	r3, 8012620 <_wrapup_reent+0x34>
 801261a:	4638      	mov	r0, r7
 801261c:	4798      	blx	r3
 801261e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8012620:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8012622:	4b01      	ldr	r3, [pc, #4]	; (8012628 <_wrapup_reent+0x3c>)
 8012624:	681f      	ldr	r7, [r3, #0]
 8012626:	e7e4      	b.n	80125f2 <_wrapup_reent+0x6>
 8012628:	200000b0 	.word	0x200000b0

0801262c <_sbrk_r>:
 801262c:	b538      	push	{r3, r4, r5, lr}
 801262e:	4605      	mov	r5, r0
 8012630:	4c06      	ldr	r4, [pc, #24]	; (801264c <_sbrk_r+0x20>)
 8012632:	4608      	mov	r0, r1
 8012634:	2300      	movs	r3, #0
 8012636:	6023      	str	r3, [r4, #0]
 8012638:	f7f6 f804 	bl	8008644 <_sbrk>
 801263c:	1c43      	adds	r3, r0, #1
 801263e:	d000      	beq.n	8012642 <_sbrk_r+0x16>
 8012640:	bd38      	pop	{r3, r4, r5, pc}
 8012642:	6823      	ldr	r3, [r4, #0]
 8012644:	2b00      	cmp	r3, #0
 8012646:	d0fb      	beq.n	8012640 <_sbrk_r+0x14>
 8012648:	602b      	str	r3, [r5, #0]
 801264a:	bd38      	pop	{r3, r4, r5, pc}
 801264c:	20003618 	.word	0x20003618

08012650 <_init_signal_r>:
 8012650:	b538      	push	{r3, r4, r5, lr}
 8012652:	4604      	mov	r4, r0
 8012654:	f8d0 52dc 	ldr.w	r5, [r0, #732]	; 0x2dc
 8012658:	b10d      	cbz	r5, 801265e <_init_signal_r+0xe>
 801265a:	2000      	movs	r0, #0
 801265c:	bd38      	pop	{r3, r4, r5, pc}
 801265e:	2180      	movs	r1, #128	; 0x80
 8012660:	f7ff f89c 	bl	801179c <_malloc_r>
 8012664:	f8c4 02dc 	str.w	r0, [r4, #732]	; 0x2dc
 8012668:	b150      	cbz	r0, 8012680 <_init_signal_r+0x30>
 801266a:	462b      	mov	r3, r5
 801266c:	4629      	mov	r1, r5
 801266e:	e001      	b.n	8012674 <_init_signal_r+0x24>
 8012670:	f8d4 02dc 	ldr.w	r0, [r4, #732]	; 0x2dc
 8012674:	50c1      	str	r1, [r0, r3]
 8012676:	3304      	adds	r3, #4
 8012678:	2b80      	cmp	r3, #128	; 0x80
 801267a:	d1f9      	bne.n	8012670 <_init_signal_r+0x20>
 801267c:	2000      	movs	r0, #0
 801267e:	bd38      	pop	{r3, r4, r5, pc}
 8012680:	f04f 30ff 	mov.w	r0, #4294967295
 8012684:	bd38      	pop	{r3, r4, r5, pc}
 8012686:	bf00      	nop

08012688 <_signal_r>:
 8012688:	291f      	cmp	r1, #31
 801268a:	b510      	push	{r4, lr}
 801268c:	4604      	mov	r4, r0
 801268e:	b082      	sub	sp, #8
 8012690:	d808      	bhi.n	80126a4 <_signal_r+0x1c>
 8012692:	f8d0 32dc 	ldr.w	r3, [r0, #732]	; 0x2dc
 8012696:	b153      	cbz	r3, 80126ae <_signal_r+0x26>
 8012698:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
 801269c:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
 80126a0:	b002      	add	sp, #8
 80126a2:	bd10      	pop	{r4, pc}
 80126a4:	2316      	movs	r3, #22
 80126a6:	f04f 30ff 	mov.w	r0, #4294967295
 80126aa:	6023      	str	r3, [r4, #0]
 80126ac:	e7f8      	b.n	80126a0 <_signal_r+0x18>
 80126ae:	9101      	str	r1, [sp, #4]
 80126b0:	9200      	str	r2, [sp, #0]
 80126b2:	f7ff ffcd 	bl	8012650 <_init_signal_r>
 80126b6:	9901      	ldr	r1, [sp, #4]
 80126b8:	9a00      	ldr	r2, [sp, #0]
 80126ba:	b910      	cbnz	r0, 80126c2 <_signal_r+0x3a>
 80126bc:	f8d4 32dc 	ldr.w	r3, [r4, #732]	; 0x2dc
 80126c0:	e7ea      	b.n	8012698 <_signal_r+0x10>
 80126c2:	f04f 30ff 	mov.w	r0, #4294967295
 80126c6:	e7eb      	b.n	80126a0 <_signal_r+0x18>

080126c8 <_raise_r>:
 80126c8:	291f      	cmp	r1, #31
 80126ca:	b538      	push	{r3, r4, r5, lr}
 80126cc:	460c      	mov	r4, r1
 80126ce:	4605      	mov	r5, r0
 80126d0:	d820      	bhi.n	8012714 <_raise_r+0x4c>
 80126d2:	f8d0 22dc 	ldr.w	r2, [r0, #732]	; 0x2dc
 80126d6:	b19a      	cbz	r2, 8012700 <_raise_r+0x38>
 80126d8:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 80126dc:	b183      	cbz	r3, 8012700 <_raise_r+0x38>
 80126de:	2b01      	cmp	r3, #1
 80126e0:	d00c      	beq.n	80126fc <_raise_r+0x34>
 80126e2:	1c59      	adds	r1, r3, #1
 80126e4:	d006      	beq.n	80126f4 <_raise_r+0x2c>
 80126e6:	2500      	movs	r5, #0
 80126e8:	4620      	mov	r0, r4
 80126ea:	f842 5024 	str.w	r5, [r2, r4, lsl #2]
 80126ee:	4798      	blx	r3
 80126f0:	4628      	mov	r0, r5
 80126f2:	bd38      	pop	{r3, r4, r5, pc}
 80126f4:	2316      	movs	r3, #22
 80126f6:	2001      	movs	r0, #1
 80126f8:	602b      	str	r3, [r5, #0]
 80126fa:	bd38      	pop	{r3, r4, r5, pc}
 80126fc:	2000      	movs	r0, #0
 80126fe:	bd38      	pop	{r3, r4, r5, pc}
 8012700:	4628      	mov	r0, r5
 8012702:	f000 f86b 	bl	80127dc <_getpid_r>
 8012706:	4622      	mov	r2, r4
 8012708:	4601      	mov	r1, r0
 801270a:	4628      	mov	r0, r5
 801270c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8012710:	f000 b850 	b.w	80127b4 <_kill_r>
 8012714:	2316      	movs	r3, #22
 8012716:	f04f 30ff 	mov.w	r0, #4294967295
 801271a:	602b      	str	r3, [r5, #0]
 801271c:	bd38      	pop	{r3, r4, r5, pc}
 801271e:	bf00      	nop

08012720 <__sigtramp_r>:
 8012720:	291f      	cmp	r1, #31
 8012722:	b510      	push	{r4, lr}
 8012724:	4604      	mov	r4, r0
 8012726:	b082      	sub	sp, #8
 8012728:	d81f      	bhi.n	801276a <__sigtramp_r+0x4a>
 801272a:	f8d0 32dc 	ldr.w	r3, [r0, #732]	; 0x2dc
 801272e:	b1a3      	cbz	r3, 801275a <__sigtramp_r+0x3a>
 8012730:	f853 2021 	ldr.w	r2, [r3, r1, lsl #2]
 8012734:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8012738:	b16a      	cbz	r2, 8012756 <__sigtramp_r+0x36>
 801273a:	1c50      	adds	r0, r2, #1
 801273c:	d009      	beq.n	8012752 <__sigtramp_r+0x32>
 801273e:	2003      	movs	r0, #3
 8012740:	2a01      	cmp	r2, #1
 8012742:	d004      	beq.n	801274e <__sigtramp_r+0x2e>
 8012744:	2400      	movs	r4, #0
 8012746:	4608      	mov	r0, r1
 8012748:	601c      	str	r4, [r3, #0]
 801274a:	4790      	blx	r2
 801274c:	4620      	mov	r0, r4
 801274e:	b002      	add	sp, #8
 8012750:	bd10      	pop	{r4, pc}
 8012752:	2002      	movs	r0, #2
 8012754:	e7fb      	b.n	801274e <__sigtramp_r+0x2e>
 8012756:	2001      	movs	r0, #1
 8012758:	e7f9      	b.n	801274e <__sigtramp_r+0x2e>
 801275a:	9101      	str	r1, [sp, #4]
 801275c:	f7ff ff78 	bl	8012650 <_init_signal_r>
 8012760:	9901      	ldr	r1, [sp, #4]
 8012762:	b910      	cbnz	r0, 801276a <__sigtramp_r+0x4a>
 8012764:	f8d4 32dc 	ldr.w	r3, [r4, #732]	; 0x2dc
 8012768:	e7e2      	b.n	8012730 <__sigtramp_r+0x10>
 801276a:	f04f 30ff 	mov.w	r0, #4294967295
 801276e:	e7ee      	b.n	801274e <__sigtramp_r+0x2e>

08012770 <raise>:
 8012770:	f240 03b0 	movw	r3, #176	; 0xb0
 8012774:	4601      	mov	r1, r0
 8012776:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801277a:	6818      	ldr	r0, [r3, #0]
 801277c:	f7ff bfa4 	b.w	80126c8 <_raise_r>

08012780 <signal>:
 8012780:	f240 03b0 	movw	r3, #176	; 0xb0
 8012784:	460a      	mov	r2, r1
 8012786:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801278a:	4601      	mov	r1, r0
 801278c:	6818      	ldr	r0, [r3, #0]
 801278e:	f7ff bf7b 	b.w	8012688 <_signal_r>
 8012792:	bf00      	nop

08012794 <_init_signal>:
 8012794:	f240 03b0 	movw	r3, #176	; 0xb0
 8012798:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801279c:	6818      	ldr	r0, [r3, #0]
 801279e:	f7ff bf57 	b.w	8012650 <_init_signal_r>
 80127a2:	bf00      	nop

080127a4 <__sigtramp>:
 80127a4:	f240 03b0 	movw	r3, #176	; 0xb0
 80127a8:	4601      	mov	r1, r0
 80127aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80127ae:	6818      	ldr	r0, [r3, #0]
 80127b0:	f7ff bfb6 	b.w	8012720 <__sigtramp_r>

080127b4 <_kill_r>:
 80127b4:	b538      	push	{r3, r4, r5, lr}
 80127b6:	4605      	mov	r5, r0
 80127b8:	4c07      	ldr	r4, [pc, #28]	; (80127d8 <_kill_r+0x24>)
 80127ba:	4608      	mov	r0, r1
 80127bc:	4611      	mov	r1, r2
 80127be:	2300      	movs	r3, #0
 80127c0:	6023      	str	r3, [r4, #0]
 80127c2:	f7f5 ff68 	bl	8008696 <_kill>
 80127c6:	1c43      	adds	r3, r0, #1
 80127c8:	d000      	beq.n	80127cc <_kill_r+0x18>
 80127ca:	bd38      	pop	{r3, r4, r5, pc}
 80127cc:	6823      	ldr	r3, [r4, #0]
 80127ce:	2b00      	cmp	r3, #0
 80127d0:	d0fb      	beq.n	80127ca <_kill_r+0x16>
 80127d2:	602b      	str	r3, [r5, #0]
 80127d4:	bd38      	pop	{r3, r4, r5, pc}
 80127d6:	bf00      	nop
 80127d8:	20003618 	.word	0x20003618

080127dc <_getpid_r>:
 80127dc:	f7f5 bf59 	b.w	8008692 <_getpid>

080127e0 <strchr>:
 80127e0:	b2c9      	uxtb	r1, r1
 80127e2:	b4f0      	push	{r4, r5, r6, r7}
 80127e4:	2900      	cmp	r1, #0
 80127e6:	d04b      	beq.n	8012880 <strchr+0xa0>
 80127e8:	0783      	lsls	r3, r0, #30
 80127ea:	d00f      	beq.n	801280c <strchr+0x2c>
 80127ec:	7803      	ldrb	r3, [r0, #0]
 80127ee:	2b00      	cmp	r3, #0
 80127f0:	d073      	beq.n	80128da <strchr+0xfa>
 80127f2:	4299      	cmp	r1, r3
 80127f4:	d042      	beq.n	801287c <strchr+0x9c>
 80127f6:	1c43      	adds	r3, r0, #1
 80127f8:	e005      	b.n	8012806 <strchr+0x26>
 80127fa:	f813 2b01 	ldrb.w	r2, [r3], #1
 80127fe:	2a00      	cmp	r2, #0
 8012800:	d03b      	beq.n	801287a <strchr+0x9a>
 8012802:	4291      	cmp	r1, r2
 8012804:	d03a      	beq.n	801287c <strchr+0x9c>
 8012806:	079a      	lsls	r2, r3, #30
 8012808:	4618      	mov	r0, r3
 801280a:	d1f6      	bne.n	80127fa <strchr+0x1a>
 801280c:	6803      	ldr	r3, [r0, #0]
 801280e:	ea41 2701 	orr.w	r7, r1, r1, lsl #8
 8012812:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8012816:	ea47 4707 	orr.w	r7, r7, r7, lsl #16
 801281a:	ea22 0203 	bic.w	r2, r2, r3
 801281e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8012822:	d11c      	bne.n	801285e <strchr+0x7e>
 8012824:	407b      	eors	r3, r7
 8012826:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 801282a:	ea22 0303 	bic.w	r3, r2, r3
 801282e:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8012832:	d114      	bne.n	801285e <strchr+0x7e>
 8012834:	1d02      	adds	r2, r0, #4
 8012836:	e002      	b.n	801283e <strchr+0x5e>
 8012838:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 801283c:	d10f      	bne.n	801285e <strchr+0x7e>
 801283e:	4610      	mov	r0, r2
 8012840:	f852 3b04 	ldr.w	r3, [r2], #4
 8012844:	f1a3 3601 	sub.w	r6, r3, #16843009	; 0x1010101
 8012848:	ea87 0403 	eor.w	r4, r7, r3
 801284c:	ea26 0303 	bic.w	r3, r6, r3
 8012850:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 8012854:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8012858:	ea25 0404 	bic.w	r4, r5, r4
 801285c:	d0ec      	beq.n	8012838 <strchr+0x58>
 801285e:	7803      	ldrb	r3, [r0, #0]
 8012860:	2b00      	cmp	r3, #0
 8012862:	d03a      	beq.n	80128da <strchr+0xfa>
 8012864:	4299      	cmp	r1, r3
 8012866:	d009      	beq.n	801287c <strchr+0x9c>
 8012868:	1c43      	adds	r3, r0, #1
 801286a:	e001      	b.n	8012870 <strchr+0x90>
 801286c:	4291      	cmp	r1, r2
 801286e:	d005      	beq.n	801287c <strchr+0x9c>
 8012870:	4618      	mov	r0, r3
 8012872:	f813 2b01 	ldrb.w	r2, [r3], #1
 8012876:	2a00      	cmp	r2, #0
 8012878:	d1f8      	bne.n	801286c <strchr+0x8c>
 801287a:	4610      	mov	r0, r2
 801287c:	bcf0      	pop	{r4, r5, r6, r7}
 801287e:	4770      	bx	lr
 8012880:	0781      	lsls	r1, r0, #30
 8012882:	d00d      	beq.n	80128a0 <strchr+0xc0>
 8012884:	7803      	ldrb	r3, [r0, #0]
 8012886:	2b00      	cmp	r3, #0
 8012888:	d0f8      	beq.n	801287c <strchr+0x9c>
 801288a:	1c43      	adds	r3, r0, #1
 801288c:	e002      	b.n	8012894 <strchr+0xb4>
 801288e:	7802      	ldrb	r2, [r0, #0]
 8012890:	2a00      	cmp	r2, #0
 8012892:	d0f3      	beq.n	801287c <strchr+0x9c>
 8012894:	f013 0f03 	tst.w	r3, #3
 8012898:	4618      	mov	r0, r3
 801289a:	f103 0301 	add.w	r3, r3, #1
 801289e:	d1f6      	bne.n	801288e <strchr+0xae>
 80128a0:	6803      	ldr	r3, [r0, #0]
 80128a2:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 80128a6:	ea22 0303 	bic.w	r3, r2, r3
 80128aa:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 80128ae:	d10a      	bne.n	80128c6 <strchr+0xe6>
 80128b0:	1d02      	adds	r2, r0, #4
 80128b2:	4610      	mov	r0, r2
 80128b4:	f852 1b04 	ldr.w	r1, [r2], #4
 80128b8:	f1a1 3401 	sub.w	r4, r1, #16843009	; 0x1010101
 80128bc:	ea24 0101 	bic.w	r1, r4, r1
 80128c0:	f011 3f80 	tst.w	r1, #2155905152	; 0x80808080
 80128c4:	d0f5      	beq.n	80128b2 <strchr+0xd2>
 80128c6:	7803      	ldrb	r3, [r0, #0]
 80128c8:	2b00      	cmp	r3, #0
 80128ca:	d0d7      	beq.n	801287c <strchr+0x9c>
 80128cc:	1c43      	adds	r3, r0, #1
 80128ce:	4618      	mov	r0, r3
 80128d0:	3301      	adds	r3, #1
 80128d2:	7802      	ldrb	r2, [r0, #0]
 80128d4:	2a00      	cmp	r2, #0
 80128d6:	d1fa      	bne.n	80128ce <strchr+0xee>
 80128d8:	e7d0      	b.n	801287c <strchr+0x9c>
 80128da:	4618      	mov	r0, r3
 80128dc:	e7ce      	b.n	801287c <strchr+0x9c>
 80128de:	bf00      	nop

080128e0 <strcmp>:
 80128e0:	ea80 0201 	eor.w	r2, r0, r1
 80128e4:	f012 0f03 	tst.w	r2, #3
 80128e8:	f040 803a 	bne.w	8012960 <strcmp_unaligned>
 80128ec:	f010 0203 	ands.w	r2, r0, #3
 80128f0:	f020 0003 	bic.w	r0, r0, #3
 80128f4:	f021 0103 	bic.w	r1, r1, #3
 80128f8:	f850 cb04 	ldr.w	ip, [r0], #4
 80128fc:	bf08      	it	eq
 80128fe:	f851 3b04 	ldreq.w	r3, [r1], #4
 8012902:	d00d      	beq.n	8012920 <strcmp+0x40>
 8012904:	f082 0203 	eor.w	r2, r2, #3
 8012908:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 801290c:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8012910:	fa23 f202 	lsr.w	r2, r3, r2
 8012914:	f851 3b04 	ldr.w	r3, [r1], #4
 8012918:	ea4c 0c02 	orr.w	ip, ip, r2
 801291c:	ea43 0302 	orr.w	r3, r3, r2
 8012920:	f1ac 3201 	sub.w	r2, ip, #16843009	; 0x1010101
 8012924:	459c      	cmp	ip, r3
 8012926:	bf01      	itttt	eq
 8012928:	ea22 020c 	biceq.w	r2, r2, ip
 801292c:	f012 3f80 	tsteq.w	r2, #2155905152	; 0x80808080
 8012930:	f850 cb04 	ldreq.w	ip, [r0], #4
 8012934:	f851 3b04 	ldreq.w	r3, [r1], #4
 8012938:	d0f2      	beq.n	8012920 <strcmp+0x40>
 801293a:	ea4f 600c 	mov.w	r0, ip, lsl #24
 801293e:	ea4f 2c1c 	mov.w	ip, ip, lsr #8
 8012942:	2801      	cmp	r0, #1
 8012944:	bf28      	it	cs
 8012946:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
 801294a:	bf08      	it	eq
 801294c:	0a1b      	lsreq	r3, r3, #8
 801294e:	d0f4      	beq.n	801293a <strcmp+0x5a>
 8012950:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8012954:	ea4f 6010 	mov.w	r0, r0, lsr #24
 8012958:	eba0 0003 	sub.w	r0, r0, r3
 801295c:	4770      	bx	lr
 801295e:	bf00      	nop

08012960 <strcmp_unaligned>:
 8012960:	f010 0f03 	tst.w	r0, #3
 8012964:	d00a      	beq.n	801297c <strcmp_unaligned+0x1c>
 8012966:	f810 2b01 	ldrb.w	r2, [r0], #1
 801296a:	f811 3b01 	ldrb.w	r3, [r1], #1
 801296e:	2a01      	cmp	r2, #1
 8012970:	bf28      	it	cs
 8012972:	429a      	cmpcs	r2, r3
 8012974:	d0f4      	beq.n	8012960 <strcmp_unaligned>
 8012976:	eba2 0003 	sub.w	r0, r2, r3
 801297a:	4770      	bx	lr
 801297c:	f84d 5d04 	str.w	r5, [sp, #-4]!
 8012980:	f84d 4d04 	str.w	r4, [sp, #-4]!
 8012984:	f04f 0201 	mov.w	r2, #1
 8012988:	ea42 2202 	orr.w	r2, r2, r2, lsl #8
 801298c:	ea42 4202 	orr.w	r2, r2, r2, lsl #16
 8012990:	f001 0c03 	and.w	ip, r1, #3
 8012994:	f021 0103 	bic.w	r1, r1, #3
 8012998:	f850 4b04 	ldr.w	r4, [r0], #4
 801299c:	f851 5b04 	ldr.w	r5, [r1], #4
 80129a0:	f1bc 0f02 	cmp.w	ip, #2
 80129a4:	d026      	beq.n	80129f4 <strcmp_unaligned+0x94>
 80129a6:	d84b      	bhi.n	8012a40 <strcmp_unaligned+0xe0>
 80129a8:	f024 4c7f 	bic.w	ip, r4, #4278190080	; 0xff000000
 80129ac:	ebbc 2f15 	cmp.w	ip, r5, lsr #8
 80129b0:	eba4 0302 	sub.w	r3, r4, r2
 80129b4:	ea23 0304 	bic.w	r3, r3, r4
 80129b8:	d10d      	bne.n	80129d6 <strcmp_unaligned+0x76>
 80129ba:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 80129be:	bf08      	it	eq
 80129c0:	f851 5b04 	ldreq.w	r5, [r1], #4
 80129c4:	d10a      	bne.n	80129dc <strcmp_unaligned+0x7c>
 80129c6:	ea8c 0c04 	eor.w	ip, ip, r4
 80129ca:	ebbc 6f05 	cmp.w	ip, r5, lsl #24
 80129ce:	d10c      	bne.n	80129ea <strcmp_unaligned+0x8a>
 80129d0:	f850 4b04 	ldr.w	r4, [r0], #4
 80129d4:	e7e8      	b.n	80129a8 <strcmp_unaligned+0x48>
 80129d6:	ea4f 2515 	mov.w	r5, r5, lsr #8
 80129da:	e05c      	b.n	8012a96 <strcmp_unaligned+0x136>
 80129dc:	f033 437f 	bics.w	r3, r3, #4278190080	; 0xff000000
 80129e0:	d152      	bne.n	8012a88 <strcmp_unaligned+0x128>
 80129e2:	780d      	ldrb	r5, [r1, #0]
 80129e4:	ea4f 6c14 	mov.w	ip, r4, lsr #24
 80129e8:	e055      	b.n	8012a96 <strcmp_unaligned+0x136>
 80129ea:	ea4f 6c14 	mov.w	ip, r4, lsr #24
 80129ee:	f005 05ff 	and.w	r5, r5, #255	; 0xff
 80129f2:	e050      	b.n	8012a96 <strcmp_unaligned+0x136>
 80129f4:	ea4f 4c04 	mov.w	ip, r4, lsl #16
 80129f8:	eba4 0302 	sub.w	r3, r4, r2
 80129fc:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 8012a00:	ea23 0304 	bic.w	r3, r3, r4
 8012a04:	ebbc 4f15 	cmp.w	ip, r5, lsr #16
 8012a08:	d117      	bne.n	8012a3a <strcmp_unaligned+0xda>
 8012a0a:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 8012a0e:	bf08      	it	eq
 8012a10:	f851 5b04 	ldreq.w	r5, [r1], #4
 8012a14:	d107      	bne.n	8012a26 <strcmp_unaligned+0xc6>
 8012a16:	ea8c 0c04 	eor.w	ip, ip, r4
 8012a1a:	ebbc 4f05 	cmp.w	ip, r5, lsl #16
 8012a1e:	d108      	bne.n	8012a32 <strcmp_unaligned+0xd2>
 8012a20:	f850 4b04 	ldr.w	r4, [r0], #4
 8012a24:	e7e6      	b.n	80129f4 <strcmp_unaligned+0x94>
 8012a26:	041b      	lsls	r3, r3, #16
 8012a28:	d12e      	bne.n	8012a88 <strcmp_unaligned+0x128>
 8012a2a:	880d      	ldrh	r5, [r1, #0]
 8012a2c:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 8012a30:	e031      	b.n	8012a96 <strcmp_unaligned+0x136>
 8012a32:	ea4f 4505 	mov.w	r5, r5, lsl #16
 8012a36:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 8012a3a:	ea4f 4515 	mov.w	r5, r5, lsr #16
 8012a3e:	e02a      	b.n	8012a96 <strcmp_unaligned+0x136>
 8012a40:	f004 0cff 	and.w	ip, r4, #255	; 0xff
 8012a44:	ebbc 6f15 	cmp.w	ip, r5, lsr #24
 8012a48:	eba4 0302 	sub.w	r3, r4, r2
 8012a4c:	ea23 0304 	bic.w	r3, r3, r4
 8012a50:	d10d      	bne.n	8012a6e <strcmp_unaligned+0x10e>
 8012a52:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 8012a56:	bf08      	it	eq
 8012a58:	f851 5b04 	ldreq.w	r5, [r1], #4
 8012a5c:	d10a      	bne.n	8012a74 <strcmp_unaligned+0x114>
 8012a5e:	ea8c 0c04 	eor.w	ip, ip, r4
 8012a62:	ebbc 2f05 	cmp.w	ip, r5, lsl #8
 8012a66:	d10a      	bne.n	8012a7e <strcmp_unaligned+0x11e>
 8012a68:	f850 4b04 	ldr.w	r4, [r0], #4
 8012a6c:	e7e8      	b.n	8012a40 <strcmp_unaligned+0xe0>
 8012a6e:	ea4f 6515 	mov.w	r5, r5, lsr #24
 8012a72:	e010      	b.n	8012a96 <strcmp_unaligned+0x136>
 8012a74:	f014 0fff 	tst.w	r4, #255	; 0xff
 8012a78:	d006      	beq.n	8012a88 <strcmp_unaligned+0x128>
 8012a7a:	f851 5b04 	ldr.w	r5, [r1], #4
 8012a7e:	ea4f 2c14 	mov.w	ip, r4, lsr #8
 8012a82:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
 8012a86:	e006      	b.n	8012a96 <strcmp_unaligned+0x136>
 8012a88:	f04f 0000 	mov.w	r0, #0
 8012a8c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8012a90:	f85d 5b04 	ldr.w	r5, [sp], #4
 8012a94:	4770      	bx	lr
 8012a96:	f00c 02ff 	and.w	r2, ip, #255	; 0xff
 8012a9a:	f005 00ff 	and.w	r0, r5, #255	; 0xff
 8012a9e:	2801      	cmp	r0, #1
 8012aa0:	bf28      	it	cs
 8012aa2:	4290      	cmpcs	r0, r2
 8012aa4:	bf04      	itt	eq
 8012aa6:	ea4f 2c1c 	moveq.w	ip, ip, lsr #8
 8012aaa:	0a2d      	lsreq	r5, r5, #8
 8012aac:	d0f3      	beq.n	8012a96 <strcmp_unaligned+0x136>
 8012aae:	eba2 0000 	sub.w	r0, r2, r0
 8012ab2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8012ab6:	f85d 5b04 	ldr.w	r5, [sp], #4
 8012aba:	4770      	bx	lr

08012abc <strcpy>:
 8012abc:	ea80 0201 	eor.w	r2, r0, r1
 8012ac0:	4684      	mov	ip, r0
 8012ac2:	f012 0f03 	tst.w	r2, #3
 8012ac6:	d14f      	bne.n	8012b68 <strcpy+0xac>
 8012ac8:	f011 0f03 	tst.w	r1, #3
 8012acc:	d132      	bne.n	8012b34 <strcpy+0x78>
 8012ace:	f84d 4d04 	str.w	r4, [sp, #-4]!
 8012ad2:	f011 0f04 	tst.w	r1, #4
 8012ad6:	f851 3b04 	ldr.w	r3, [r1], #4
 8012ada:	d00b      	beq.n	8012af4 <strcpy+0x38>
 8012adc:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8012ae0:	439a      	bics	r2, r3
 8012ae2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8012ae6:	bf04      	itt	eq
 8012ae8:	f84c 3b04 	streq.w	r3, [ip], #4
 8012aec:	f851 3b04 	ldreq.w	r3, [r1], #4
 8012af0:	d116      	bne.n	8012b20 <strcpy+0x64>
 8012af2:	bf00      	nop
 8012af4:	f851 4b04 	ldr.w	r4, [r1], #4
 8012af8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8012afc:	439a      	bics	r2, r3
 8012afe:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8012b02:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 8012b06:	d10b      	bne.n	8012b20 <strcpy+0x64>
 8012b08:	f84c 3b04 	str.w	r3, [ip], #4
 8012b0c:	43a2      	bics	r2, r4
 8012b0e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8012b12:	bf04      	itt	eq
 8012b14:	f851 3b04 	ldreq.w	r3, [r1], #4
 8012b18:	f84c 4b04 	streq.w	r4, [ip], #4
 8012b1c:	d0ea      	beq.n	8012af4 <strcpy+0x38>
 8012b1e:	4623      	mov	r3, r4
 8012b20:	f80c 3b01 	strb.w	r3, [ip], #1
 8012b24:	f013 0fff 	tst.w	r3, #255	; 0xff
 8012b28:	ea4f 2333 	mov.w	r3, r3, ror #8
 8012b2c:	d1f8      	bne.n	8012b20 <strcpy+0x64>
 8012b2e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8012b32:	4770      	bx	lr
 8012b34:	f011 0f01 	tst.w	r1, #1
 8012b38:	d006      	beq.n	8012b48 <strcpy+0x8c>
 8012b3a:	f811 2b01 	ldrb.w	r2, [r1], #1
 8012b3e:	f80c 2b01 	strb.w	r2, [ip], #1
 8012b42:	2a00      	cmp	r2, #0
 8012b44:	bf08      	it	eq
 8012b46:	4770      	bxeq	lr
 8012b48:	f011 0f02 	tst.w	r1, #2
 8012b4c:	d0bf      	beq.n	8012ace <strcpy+0x12>
 8012b4e:	f831 2b02 	ldrh.w	r2, [r1], #2
 8012b52:	f012 0fff 	tst.w	r2, #255	; 0xff
 8012b56:	bf16      	itet	ne
 8012b58:	f82c 2b02 	strhne.w	r2, [ip], #2
 8012b5c:	f88c 2000 	strbeq.w	r2, [ip]
 8012b60:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
 8012b64:	d1b3      	bne.n	8012ace <strcpy+0x12>
 8012b66:	4770      	bx	lr
 8012b68:	f811 2b01 	ldrb.w	r2, [r1], #1
 8012b6c:	f80c 2b01 	strb.w	r2, [ip], #1
 8012b70:	2a00      	cmp	r2, #0
 8012b72:	d1f9      	bne.n	8012b68 <strcpy+0xac>
 8012b74:	4770      	bx	lr
 8012b76:	bf00      	nop

08012b78 <strlen>:
 8012b78:	f020 0103 	bic.w	r1, r0, #3
 8012b7c:	f010 0003 	ands.w	r0, r0, #3
 8012b80:	f1c0 0000 	rsb	r0, r0, #0
 8012b84:	f851 3b04 	ldr.w	r3, [r1], #4
 8012b88:	f100 0c04 	add.w	ip, r0, #4
 8012b8c:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8012b90:	f06f 0200 	mvn.w	r2, #0
 8012b94:	bf1c      	itt	ne
 8012b96:	fa22 f20c 	lsrne.w	r2, r2, ip
 8012b9a:	4313      	orrne	r3, r2
 8012b9c:	f04f 0c01 	mov.w	ip, #1
 8012ba0:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 8012ba4:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 8012ba8:	eba3 020c 	sub.w	r2, r3, ip
 8012bac:	ea22 0203 	bic.w	r2, r2, r3
 8012bb0:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 8012bb4:	bf04      	itt	eq
 8012bb6:	f851 3b04 	ldreq.w	r3, [r1], #4
 8012bba:	3004      	addeq	r0, #4
 8012bbc:	d0f4      	beq.n	8012ba8 <strlen+0x30>
 8012bbe:	f013 0fff 	tst.w	r3, #255	; 0xff
 8012bc2:	bf1f      	itttt	ne
 8012bc4:	3001      	addne	r0, #1
 8012bc6:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 8012bca:	3001      	addne	r0, #1
 8012bcc:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 8012bd0:	bf18      	it	ne
 8012bd2:	3001      	addne	r0, #1
 8012bd4:	4770      	bx	lr
 8012bd6:	bf00      	nop

08012bd8 <strncmp>:
 8012bd8:	b470      	push	{r4, r5, r6}
 8012bda:	2a00      	cmp	r2, #0
 8012bdc:	d045      	beq.n	8012c6a <strncmp+0x92>
 8012bde:	ea41 0300 	orr.w	r3, r1, r0
 8012be2:	f013 0303 	ands.w	r3, r3, #3
 8012be6:	d129      	bne.n	8012c3c <strncmp+0x64>
 8012be8:	2a03      	cmp	r2, #3
 8012bea:	d927      	bls.n	8012c3c <strncmp+0x64>
 8012bec:	6805      	ldr	r5, [r0, #0]
 8012bee:	680c      	ldr	r4, [r1, #0]
 8012bf0:	42a5      	cmp	r5, r4
 8012bf2:	d123      	bne.n	8012c3c <strncmp+0x64>
 8012bf4:	1f14      	subs	r4, r2, #4
 8012bf6:	d03a      	beq.n	8012c6e <strncmp+0x96>
 8012bf8:	f1a5 3201 	sub.w	r2, r5, #16843009	; 0x1010101
 8012bfc:	ea22 0505 	bic.w	r5, r2, r5
 8012c00:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
 8012c04:	d00d      	beq.n	8012c22 <strncmp+0x4a>
 8012c06:	e03a      	b.n	8012c7e <strncmp+0xa6>
 8012c08:	685b      	ldr	r3, [r3, #4]
 8012c0a:	686a      	ldr	r2, [r5, #4]
 8012c0c:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
 8012c10:	4293      	cmp	r3, r2
 8012c12:	ea25 0503 	bic.w	r5, r5, r3
 8012c16:	d12e      	bne.n	8012c76 <strncmp+0x9e>
 8012c18:	3c04      	subs	r4, #4
 8012c1a:	d028      	beq.n	8012c6e <strncmp+0x96>
 8012c1c:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
 8012c20:	d127      	bne.n	8012c72 <strncmp+0x9a>
 8012c22:	460d      	mov	r5, r1
 8012c24:	4603      	mov	r3, r0
 8012c26:	3104      	adds	r1, #4
 8012c28:	3004      	adds	r0, #4
 8012c2a:	2c03      	cmp	r4, #3
 8012c2c:	d8ec      	bhi.n	8012c08 <strncmp+0x30>
 8012c2e:	1e66      	subs	r6, r4, #1
 8012c30:	b92c      	cbnz	r4, 8012c3e <strncmp+0x66>
 8012c32:	791c      	ldrb	r4, [r3, #4]
 8012c34:	792a      	ldrb	r2, [r5, #4]
 8012c36:	1aa0      	subs	r0, r4, r2
 8012c38:	bc70      	pop	{r4, r5, r6}
 8012c3a:	4770      	bx	lr
 8012c3c:	1e56      	subs	r6, r2, #1
 8012c3e:	7804      	ldrb	r4, [r0, #0]
 8012c40:	780a      	ldrb	r2, [r1, #0]
 8012c42:	4294      	cmp	r4, r2
 8012c44:	d1f7      	bne.n	8012c36 <strncmp+0x5e>
 8012c46:	b1c6      	cbz	r6, 8012c7a <strncmp+0xa2>
 8012c48:	b18c      	cbz	r4, 8012c6e <strncmp+0x96>
 8012c4a:	3601      	adds	r6, #1
 8012c4c:	1c8b      	adds	r3, r1, #2
 8012c4e:	1989      	adds	r1, r1, r6
 8012c50:	e004      	b.n	8012c5c <strncmp+0x84>
 8012c52:	428b      	cmp	r3, r1
 8012c54:	f103 0301 	add.w	r3, r3, #1
 8012c58:	d00b      	beq.n	8012c72 <strncmp+0x9a>
 8012c5a:	b144      	cbz	r4, 8012c6e <strncmp+0x96>
 8012c5c:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 8012c60:	f813 2c01 	ldrb.w	r2, [r3, #-1]
 8012c64:	4294      	cmp	r4, r2
 8012c66:	d0f4      	beq.n	8012c52 <strncmp+0x7a>
 8012c68:	e7e5      	b.n	8012c36 <strncmp+0x5e>
 8012c6a:	4610      	mov	r0, r2
 8012c6c:	e7e4      	b.n	8012c38 <strncmp+0x60>
 8012c6e:	4620      	mov	r0, r4
 8012c70:	e7e2      	b.n	8012c38 <strncmp+0x60>
 8012c72:	2000      	movs	r0, #0
 8012c74:	e7e0      	b.n	8012c38 <strncmp+0x60>
 8012c76:	1e66      	subs	r6, r4, #1
 8012c78:	e7e1      	b.n	8012c3e <strncmp+0x66>
 8012c7a:	4630      	mov	r0, r6
 8012c7c:	e7dc      	b.n	8012c38 <strncmp+0x60>
 8012c7e:	4618      	mov	r0, r3
 8012c80:	e7da      	b.n	8012c38 <strncmp+0x60>
 8012c82:	bf00      	nop

08012c84 <__swbuf_r>:
 8012c84:	b570      	push	{r4, r5, r6, lr}
 8012c86:	460d      	mov	r5, r1
 8012c88:	4614      	mov	r4, r2
 8012c8a:	4606      	mov	r6, r0
 8012c8c:	b110      	cbz	r0, 8012c94 <__swbuf_r+0x10>
 8012c8e:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8012c90:	2b00      	cmp	r3, #0
 8012c92:	d04b      	beq.n	8012d2c <__swbuf_r+0xa8>
 8012c94:	89a3      	ldrh	r3, [r4, #12]
 8012c96:	69a2      	ldr	r2, [r4, #24]
 8012c98:	f003 0008 	and.w	r0, r3, #8
 8012c9c:	b200      	sxth	r0, r0
 8012c9e:	60a2      	str	r2, [r4, #8]
 8012ca0:	2800      	cmp	r0, #0
 8012ca2:	d03a      	beq.n	8012d1a <__swbuf_r+0x96>
 8012ca4:	6922      	ldr	r2, [r4, #16]
 8012ca6:	2a00      	cmp	r2, #0
 8012ca8:	d037      	beq.n	8012d1a <__swbuf_r+0x96>
 8012caa:	f403 5100 	and.w	r1, r3, #8192	; 0x2000
 8012cae:	b2ed      	uxtb	r5, r5
 8012cb0:	b209      	sxth	r1, r1
 8012cb2:	b1a9      	cbz	r1, 8012ce0 <__swbuf_r+0x5c>
 8012cb4:	6823      	ldr	r3, [r4, #0]
 8012cb6:	6961      	ldr	r1, [r4, #20]
 8012cb8:	1a9a      	subs	r2, r3, r2
 8012cba:	428a      	cmp	r2, r1
 8012cbc:	da1c      	bge.n	8012cf8 <__swbuf_r+0x74>
 8012cbe:	3201      	adds	r2, #1
 8012cc0:	68a1      	ldr	r1, [r4, #8]
 8012cc2:	3901      	subs	r1, #1
 8012cc4:	60a1      	str	r1, [r4, #8]
 8012cc6:	f803 5b01 	strb.w	r5, [r3], #1
 8012cca:	6961      	ldr	r1, [r4, #20]
 8012ccc:	6023      	str	r3, [r4, #0]
 8012cce:	4291      	cmp	r1, r2
 8012cd0:	d01a      	beq.n	8012d08 <__swbuf_r+0x84>
 8012cd2:	89a3      	ldrh	r3, [r4, #12]
 8012cd4:	07db      	lsls	r3, r3, #31
 8012cd6:	d501      	bpl.n	8012cdc <__swbuf_r+0x58>
 8012cd8:	2d0a      	cmp	r5, #10
 8012cda:	d015      	beq.n	8012d08 <__swbuf_r+0x84>
 8012cdc:	4628      	mov	r0, r5
 8012cde:	bd70      	pop	{r4, r5, r6, pc}
 8012ce0:	6e61      	ldr	r1, [r4, #100]	; 0x64
 8012ce2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8012ce6:	81a3      	strh	r3, [r4, #12]
 8012ce8:	6823      	ldr	r3, [r4, #0]
 8012cea:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
 8012cee:	6661      	str	r1, [r4, #100]	; 0x64
 8012cf0:	6961      	ldr	r1, [r4, #20]
 8012cf2:	1a9a      	subs	r2, r3, r2
 8012cf4:	428a      	cmp	r2, r1
 8012cf6:	dbe2      	blt.n	8012cbe <__swbuf_r+0x3a>
 8012cf8:	4630      	mov	r0, r6
 8012cfa:	4621      	mov	r1, r4
 8012cfc:	f000 fa06 	bl	801310c <_fflush_r>
 8012d00:	b940      	cbnz	r0, 8012d14 <__swbuf_r+0x90>
 8012d02:	6823      	ldr	r3, [r4, #0]
 8012d04:	2201      	movs	r2, #1
 8012d06:	e7db      	b.n	8012cc0 <__swbuf_r+0x3c>
 8012d08:	4630      	mov	r0, r6
 8012d0a:	4621      	mov	r1, r4
 8012d0c:	f000 f9fe 	bl	801310c <_fflush_r>
 8012d10:	2800      	cmp	r0, #0
 8012d12:	d0e3      	beq.n	8012cdc <__swbuf_r+0x58>
 8012d14:	f04f 35ff 	mov.w	r5, #4294967295
 8012d18:	e7e0      	b.n	8012cdc <__swbuf_r+0x58>
 8012d1a:	4630      	mov	r0, r6
 8012d1c:	4621      	mov	r1, r4
 8012d1e:	f000 f813 	bl	8012d48 <__swsetup_r>
 8012d22:	2800      	cmp	r0, #0
 8012d24:	d1f6      	bne.n	8012d14 <__swbuf_r+0x90>
 8012d26:	89a3      	ldrh	r3, [r4, #12]
 8012d28:	6922      	ldr	r2, [r4, #16]
 8012d2a:	e7be      	b.n	8012caa <__swbuf_r+0x26>
 8012d2c:	f000 fa68 	bl	8013200 <__sinit>
 8012d30:	e7b0      	b.n	8012c94 <__swbuf_r+0x10>
 8012d32:	bf00      	nop

08012d34 <__swbuf>:
 8012d34:	f240 03b0 	movw	r3, #176	; 0xb0
 8012d38:	460a      	mov	r2, r1
 8012d3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012d3e:	4601      	mov	r1, r0
 8012d40:	6818      	ldr	r0, [r3, #0]
 8012d42:	f7ff bf9f 	b.w	8012c84 <__swbuf_r>
 8012d46:	bf00      	nop

08012d48 <__swsetup_r>:
 8012d48:	b538      	push	{r3, r4, r5, lr}
 8012d4a:	4605      	mov	r5, r0
 8012d4c:	4b34      	ldr	r3, [pc, #208]	; (8012e20 <__swsetup_r+0xd8>)
 8012d4e:	460c      	mov	r4, r1
 8012d50:	6818      	ldr	r0, [r3, #0]
 8012d52:	b110      	cbz	r0, 8012d5a <__swsetup_r+0x12>
 8012d54:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8012d56:	2a00      	cmp	r2, #0
 8012d58:	d041      	beq.n	8012dde <__swsetup_r+0x96>
 8012d5a:	89a3      	ldrh	r3, [r4, #12]
 8012d5c:	f003 0208 	and.w	r2, r3, #8
 8012d60:	4619      	mov	r1, r3
 8012d62:	b212      	sxth	r2, r2
 8012d64:	b16a      	cbz	r2, 8012d82 <__swsetup_r+0x3a>
 8012d66:	6922      	ldr	r2, [r4, #16]
 8012d68:	b1d2      	cbz	r2, 8012da0 <__swsetup_r+0x58>
 8012d6a:	f013 0101 	ands.w	r1, r3, #1
 8012d6e:	d123      	bne.n	8012db8 <__swsetup_r+0x70>
 8012d70:	f003 0302 	and.w	r3, r3, #2
 8012d74:	b21b      	sxth	r3, r3
 8012d76:	b903      	cbnz	r3, 8012d7a <__swsetup_r+0x32>
 8012d78:	6961      	ldr	r1, [r4, #20]
 8012d7a:	60a1      	str	r1, [r4, #8]
 8012d7c:	b31a      	cbz	r2, 8012dc6 <__swsetup_r+0x7e>
 8012d7e:	2000      	movs	r0, #0
 8012d80:	bd38      	pop	{r3, r4, r5, pc}
 8012d82:	f003 0210 	and.w	r2, r3, #16
 8012d86:	b212      	sxth	r2, r2
 8012d88:	2a00      	cmp	r2, #0
 8012d8a:	d040      	beq.n	8012e0e <__swsetup_r+0xc6>
 8012d8c:	f001 0104 	and.w	r1, r1, #4
 8012d90:	b209      	sxth	r1, r1
 8012d92:	bb39      	cbnz	r1, 8012de4 <__swsetup_r+0x9c>
 8012d94:	6922      	ldr	r2, [r4, #16]
 8012d96:	f043 0308 	orr.w	r3, r3, #8
 8012d9a:	81a3      	strh	r3, [r4, #12]
 8012d9c:	2a00      	cmp	r2, #0
 8012d9e:	d1e4      	bne.n	8012d6a <__swsetup_r+0x22>
 8012da0:	f403 7120 	and.w	r1, r3, #640	; 0x280
 8012da4:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8012da8:	d0df      	beq.n	8012d6a <__swsetup_r+0x22>
 8012daa:	4628      	mov	r0, r5
 8012dac:	4621      	mov	r1, r4
 8012dae:	f000 fc0d 	bl	80135cc <__smakebuf_r>
 8012db2:	89a3      	ldrh	r3, [r4, #12]
 8012db4:	6922      	ldr	r2, [r4, #16]
 8012db6:	e7d8      	b.n	8012d6a <__swsetup_r+0x22>
 8012db8:	6963      	ldr	r3, [r4, #20]
 8012dba:	2100      	movs	r1, #0
 8012dbc:	60a1      	str	r1, [r4, #8]
 8012dbe:	425b      	negs	r3, r3
 8012dc0:	61a3      	str	r3, [r4, #24]
 8012dc2:	2a00      	cmp	r2, #0
 8012dc4:	d1db      	bne.n	8012d7e <__swsetup_r+0x36>
 8012dc6:	89a3      	ldrh	r3, [r4, #12]
 8012dc8:	f003 0180 	and.w	r1, r3, #128	; 0x80
 8012dcc:	b209      	sxth	r1, r1
 8012dce:	2900      	cmp	r1, #0
 8012dd0:	d0d5      	beq.n	8012d7e <__swsetup_r+0x36>
 8012dd2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8012dd6:	f04f 30ff 	mov.w	r0, #4294967295
 8012dda:	81a3      	strh	r3, [r4, #12]
 8012ddc:	bd38      	pop	{r3, r4, r5, pc}
 8012dde:	f000 fa0f 	bl	8013200 <__sinit>
 8012de2:	e7ba      	b.n	8012d5a <__swsetup_r+0x12>
 8012de4:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8012de6:	b149      	cbz	r1, 8012dfc <__swsetup_r+0xb4>
 8012de8:	f104 0240 	add.w	r2, r4, #64	; 0x40
 8012dec:	4291      	cmp	r1, r2
 8012dee:	d003      	beq.n	8012df8 <__swsetup_r+0xb0>
 8012df0:	4628      	mov	r0, r5
 8012df2:	f000 fadb 	bl	80133ac <_free_r>
 8012df6:	89a3      	ldrh	r3, [r4, #12]
 8012df8:	2200      	movs	r2, #0
 8012dfa:	6322      	str	r2, [r4, #48]	; 0x30
 8012dfc:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 8012e00:	6922      	ldr	r2, [r4, #16]
 8012e02:	2100      	movs	r1, #0
 8012e04:	6061      	str	r1, [r4, #4]
 8012e06:	041b      	lsls	r3, r3, #16
 8012e08:	6022      	str	r2, [r4, #0]
 8012e0a:	0c1b      	lsrs	r3, r3, #16
 8012e0c:	e7c3      	b.n	8012d96 <__swsetup_r+0x4e>
 8012e0e:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 8012e12:	2309      	movs	r3, #9
 8012e14:	f04f 30ff 	mov.w	r0, #4294967295
 8012e18:	602b      	str	r3, [r5, #0]
 8012e1a:	81a1      	strh	r1, [r4, #12]
 8012e1c:	bd38      	pop	{r3, r4, r5, pc}
 8012e1e:	bf00      	nop
 8012e20:	200000b0 	.word	0x200000b0

08012e24 <__register_exitproc>:
 8012e24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8012e28:	4607      	mov	r7, r0
 8012e2a:	4c28      	ldr	r4, [pc, #160]	; (8012ecc <__register_exitproc+0xa8>)
 8012e2c:	b084      	sub	sp, #16
 8012e2e:	6825      	ldr	r5, [r4, #0]
 8012e30:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
 8012e34:	2c00      	cmp	r4, #0
 8012e36:	d043      	beq.n	8012ec0 <__register_exitproc+0x9c>
 8012e38:	6866      	ldr	r6, [r4, #4]
 8012e3a:	2e1f      	cmp	r6, #31
 8012e3c:	dd1c      	ble.n	8012e78 <__register_exitproc+0x54>
 8012e3e:	4824      	ldr	r0, [pc, #144]	; (8012ed0 <__register_exitproc+0xac>)
 8012e40:	b910      	cbnz	r0, 8012e48 <__register_exitproc+0x24>
 8012e42:	f04f 30ff 	mov.w	r0, #4294967295
 8012e46:	e01f      	b.n	8012e88 <__register_exitproc+0x64>
 8012e48:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8012e4c:	9103      	str	r1, [sp, #12]
 8012e4e:	9202      	str	r2, [sp, #8]
 8012e50:	9301      	str	r3, [sp, #4]
 8012e52:	f7fe fc93 	bl	801177c <malloc>
 8012e56:	9903      	ldr	r1, [sp, #12]
 8012e58:	9a02      	ldr	r2, [sp, #8]
 8012e5a:	9b01      	ldr	r3, [sp, #4]
 8012e5c:	4604      	mov	r4, r0
 8012e5e:	2800      	cmp	r0, #0
 8012e60:	d0ef      	beq.n	8012e42 <__register_exitproc+0x1e>
 8012e62:	f8d5 6148 	ldr.w	r6, [r5, #328]	; 0x148
 8012e66:	2000      	movs	r0, #0
 8012e68:	6060      	str	r0, [r4, #4]
 8012e6a:	6026      	str	r6, [r4, #0]
 8012e6c:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 8012e70:	f8c4 0188 	str.w	r0, [r4, #392]	; 0x188
 8012e74:	f8c4 018c 	str.w	r0, [r4, #396]	; 0x18c
 8012e78:	6865      	ldr	r5, [r4, #4]
 8012e7a:	b947      	cbnz	r7, 8012e8e <__register_exitproc+0x6a>
 8012e7c:	1cab      	adds	r3, r5, #2
 8012e7e:	2000      	movs	r0, #0
 8012e80:	3501      	adds	r5, #1
 8012e82:	6065      	str	r5, [r4, #4]
 8012e84:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
 8012e88:	b004      	add	sp, #16
 8012e8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8012e8e:	2001      	movs	r0, #1
 8012e90:	eb04 0885 	add.w	r8, r4, r5, lsl #2
 8012e94:	2f02      	cmp	r7, #2
 8012e96:	f8d4 6188 	ldr.w	r6, [r4, #392]	; 0x188
 8012e9a:	f8c8 3108 	str.w	r3, [r8, #264]	; 0x108
 8012e9e:	fa00 f005 	lsl.w	r0, r0, r5
 8012ea2:	bf08      	it	eq
 8012ea4:	f8d4 318c 	ldreq.w	r3, [r4, #396]	; 0x18c
 8012ea8:	ea46 0600 	orr.w	r6, r6, r0
 8012eac:	f8c8 2088 	str.w	r2, [r8, #136]	; 0x88
 8012eb0:	bf08      	it	eq
 8012eb2:	4318      	orreq	r0, r3
 8012eb4:	f8c4 6188 	str.w	r6, [r4, #392]	; 0x188
 8012eb8:	bf08      	it	eq
 8012eba:	f8c4 018c 	streq.w	r0, [r4, #396]	; 0x18c
 8012ebe:	e7dd      	b.n	8012e7c <__register_exitproc+0x58>
 8012ec0:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
 8012ec4:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 8012ec8:	e7b6      	b.n	8012e38 <__register_exitproc+0x14>
 8012eca:	bf00      	nop
 8012ecc:	0801ffb0 	.word	0x0801ffb0
 8012ed0:	0801177d 	.word	0x0801177d

08012ed4 <__call_exitprocs>:
 8012ed4:	4b34      	ldr	r3, [pc, #208]	; (8012fa8 <__call_exitprocs+0xd4>)
 8012ed6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012eda:	460e      	mov	r6, r1
 8012edc:	681b      	ldr	r3, [r3, #0]
 8012ede:	b085      	sub	sp, #20
 8012ee0:	f04f 0901 	mov.w	r9, #1
 8012ee4:	9002      	str	r0, [sp, #8]
 8012ee6:	9301      	str	r3, [sp, #4]
 8012ee8:	f503 73a4 	add.w	r3, r3, #328	; 0x148
 8012eec:	9303      	str	r3, [sp, #12]
 8012eee:	9b01      	ldr	r3, [sp, #4]
 8012ef0:	f8dd b00c 	ldr.w	fp, [sp, #12]
 8012ef4:	f8d3 7148 	ldr.w	r7, [r3, #328]	; 0x148
 8012ef8:	b1af      	cbz	r7, 8012f26 <__call_exitprocs+0x52>
 8012efa:	687d      	ldr	r5, [r7, #4]
 8012efc:	1e6c      	subs	r4, r5, #1
 8012efe:	d40c      	bmi.n	8012f1a <__call_exitprocs+0x46>
 8012f00:	351f      	adds	r5, #31
 8012f02:	f107 0888 	add.w	r8, r7, #136	; 0x88
 8012f06:	eb08 0585 	add.w	r5, r8, r5, lsl #2
 8012f0a:	b17e      	cbz	r6, 8012f2c <__call_exitprocs+0x58>
 8012f0c:	682b      	ldr	r3, [r5, #0]
 8012f0e:	42b3      	cmp	r3, r6
 8012f10:	d00c      	beq.n	8012f2c <__call_exitprocs+0x58>
 8012f12:	3c01      	subs	r4, #1
 8012f14:	3d04      	subs	r5, #4
 8012f16:	1c63      	adds	r3, r4, #1
 8012f18:	d1f7      	bne.n	8012f0a <__call_exitprocs+0x36>
 8012f1a:	f241 738d 	movw	r3, #6029	; 0x178d
 8012f1e:	f6c0 0301 	movt	r3, #2049	; 0x801
 8012f22:	2b00      	cmp	r3, #0
 8012f24:	d130      	bne.n	8012f88 <__call_exitprocs+0xb4>
 8012f26:	b005      	add	sp, #20
 8012f28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8012f2c:	687b      	ldr	r3, [r7, #4]
 8012f2e:	ebc8 0205 	rsb	r2, r8, r5
 8012f32:	18ba      	adds	r2, r7, r2
 8012f34:	1e59      	subs	r1, r3, #1
 8012f36:	42a1      	cmp	r1, r4
 8012f38:	f852 3c78 	ldr.w	r3, [r2, #-120]
 8012f3c:	bf08      	it	eq
 8012f3e:	607c      	streq	r4, [r7, #4]
 8012f40:	d002      	beq.n	8012f48 <__call_exitprocs+0x74>
 8012f42:	2100      	movs	r1, #0
 8012f44:	f842 1c78 	str.w	r1, [r2, #-120]
 8012f48:	2b00      	cmp	r3, #0
 8012f4a:	d0e2      	beq.n	8012f12 <__call_exitprocs+0x3e>
 8012f4c:	f8d7 1188 	ldr.w	r1, [r7, #392]	; 0x188
 8012f50:	fa09 f204 	lsl.w	r2, r9, r4
 8012f54:	f8d7 a004 	ldr.w	sl, [r7, #4]
 8012f58:	420a      	tst	r2, r1
 8012f5a:	d00f      	beq.n	8012f7c <__call_exitprocs+0xa8>
 8012f5c:	f8d7 118c 	ldr.w	r1, [r7, #396]	; 0x18c
 8012f60:	420a      	tst	r2, r1
 8012f62:	d10d      	bne.n	8012f80 <__call_exitprocs+0xac>
 8012f64:	9802      	ldr	r0, [sp, #8]
 8012f66:	f855 1c80 	ldr.w	r1, [r5, #-128]
 8012f6a:	4798      	blx	r3
 8012f6c:	687b      	ldr	r3, [r7, #4]
 8012f6e:	4553      	cmp	r3, sl
 8012f70:	d1bd      	bne.n	8012eee <__call_exitprocs+0x1a>
 8012f72:	f8db 3000 	ldr.w	r3, [fp]
 8012f76:	42bb      	cmp	r3, r7
 8012f78:	d0cb      	beq.n	8012f12 <__call_exitprocs+0x3e>
 8012f7a:	e7b8      	b.n	8012eee <__call_exitprocs+0x1a>
 8012f7c:	4798      	blx	r3
 8012f7e:	e7f5      	b.n	8012f6c <__call_exitprocs+0x98>
 8012f80:	f855 0c80 	ldr.w	r0, [r5, #-128]
 8012f84:	4798      	blx	r3
 8012f86:	e7f1      	b.n	8012f6c <__call_exitprocs+0x98>
 8012f88:	687b      	ldr	r3, [r7, #4]
 8012f8a:	b94b      	cbnz	r3, 8012fa0 <__call_exitprocs+0xcc>
 8012f8c:	683b      	ldr	r3, [r7, #0]
 8012f8e:	b143      	cbz	r3, 8012fa2 <__call_exitprocs+0xce>
 8012f90:	4638      	mov	r0, r7
 8012f92:	f8cb 3000 	str.w	r3, [fp]
 8012f96:	f7fe fbf9 	bl	801178c <free>
 8012f9a:	f8db 7000 	ldr.w	r7, [fp]
 8012f9e:	e7ab      	b.n	8012ef8 <__call_exitprocs+0x24>
 8012fa0:	683b      	ldr	r3, [r7, #0]
 8012fa2:	46bb      	mov	fp, r7
 8012fa4:	461f      	mov	r7, r3
 8012fa6:	e7a7      	b.n	8012ef8 <__call_exitprocs+0x24>
 8012fa8:	0801ffb0 	.word	0x0801ffb0

08012fac <__sflush_r>:
 8012fac:	898b      	ldrh	r3, [r1, #12]
 8012fae:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8012fb2:	f003 0208 	and.w	r2, r3, #8
 8012fb6:	460d      	mov	r5, r1
 8012fb8:	4680      	mov	r8, r0
 8012fba:	b212      	sxth	r2, r2
 8012fbc:	2a00      	cmp	r2, #0
 8012fbe:	d13f      	bne.n	8013040 <__sflush_r+0x94>
 8012fc0:	684a      	ldr	r2, [r1, #4]
 8012fc2:	f443 6100 	orr.w	r1, r3, #2048	; 0x800
 8012fc6:	81a9      	strh	r1, [r5, #12]
 8012fc8:	2a00      	cmp	r2, #0
 8012fca:	dd5e      	ble.n	801308a <__sflush_r+0xde>
 8012fcc:	6aac      	ldr	r4, [r5, #40]	; 0x28
 8012fce:	2c00      	cmp	r4, #0
 8012fd0:	d050      	beq.n	8013074 <__sflush_r+0xc8>
 8012fd2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8012fd6:	f8d8 7000 	ldr.w	r7, [r8]
 8012fda:	2200      	movs	r2, #0
 8012fdc:	f8c8 2000 	str.w	r2, [r8]
 8012fe0:	b21e      	sxth	r6, r3
 8012fe2:	2e00      	cmp	r6, #0
 8012fe4:	d055      	beq.n	8013092 <__sflush_r+0xe6>
 8012fe6:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 8012fe8:	f001 0104 	and.w	r1, r1, #4
 8012fec:	b209      	sxth	r1, r1
 8012fee:	b129      	cbz	r1, 8012ffc <__sflush_r+0x50>
 8012ff0:	6869      	ldr	r1, [r5, #4]
 8012ff2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8012ff4:	1a52      	subs	r2, r2, r1
 8012ff6:	b10b      	cbz	r3, 8012ffc <__sflush_r+0x50>
 8012ff8:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8012ffa:	1ad2      	subs	r2, r2, r3
 8012ffc:	2300      	movs	r3, #0
 8012ffe:	4640      	mov	r0, r8
 8013000:	69e9      	ldr	r1, [r5, #28]
 8013002:	47a0      	blx	r4
 8013004:	1c42      	adds	r2, r0, #1
 8013006:	d04f      	beq.n	80130a8 <__sflush_r+0xfc>
 8013008:	89ab      	ldrh	r3, [r5, #12]
 801300a:	2400      	movs	r4, #0
 801300c:	692a      	ldr	r2, [r5, #16]
 801300e:	f403 5180 	and.w	r1, r3, #4096	; 0x1000
 8013012:	606c      	str	r4, [r5, #4]
 8013014:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8013018:	81ab      	strh	r3, [r5, #12]
 801301a:	b209      	sxth	r1, r1
 801301c:	602a      	str	r2, [r5, #0]
 801301e:	2900      	cmp	r1, #0
 8013020:	d151      	bne.n	80130c6 <__sflush_r+0x11a>
 8013022:	6b29      	ldr	r1, [r5, #48]	; 0x30
 8013024:	f8c8 7000 	str.w	r7, [r8]
 8013028:	b321      	cbz	r1, 8013074 <__sflush_r+0xc8>
 801302a:	f105 0340 	add.w	r3, r5, #64	; 0x40
 801302e:	4299      	cmp	r1, r3
 8013030:	d002      	beq.n	8013038 <__sflush_r+0x8c>
 8013032:	4640      	mov	r0, r8
 8013034:	f000 f9ba 	bl	80133ac <_free_r>
 8013038:	2000      	movs	r0, #0
 801303a:	6328      	str	r0, [r5, #48]	; 0x30
 801303c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8013040:	690e      	ldr	r6, [r1, #16]
 8013042:	b1be      	cbz	r6, 8013074 <__sflush_r+0xc8>
 8013044:	079b      	lsls	r3, r3, #30
 8013046:	680c      	ldr	r4, [r1, #0]
 8013048:	600e      	str	r6, [r1, #0]
 801304a:	bf08      	it	eq
 801304c:	694b      	ldreq	r3, [r1, #20]
 801304e:	ebc6 0404 	rsb	r4, r6, r4
 8013052:	bf18      	it	ne
 8013054:	2300      	movne	r3, #0
 8013056:	608b      	str	r3, [r1, #8]
 8013058:	e00a      	b.n	8013070 <__sflush_r+0xc4>
 801305a:	4632      	mov	r2, r6
 801305c:	4623      	mov	r3, r4
 801305e:	6a6f      	ldr	r7, [r5, #36]	; 0x24
 8013060:	4640      	mov	r0, r8
 8013062:	69e9      	ldr	r1, [r5, #28]
 8013064:	47b8      	blx	r7
 8013066:	2800      	cmp	r0, #0
 8013068:	ebc0 0404 	rsb	r4, r0, r4
 801306c:	4406      	add	r6, r0
 801306e:	dd04      	ble.n	801307a <__sflush_r+0xce>
 8013070:	2c00      	cmp	r4, #0
 8013072:	dcf2      	bgt.n	801305a <__sflush_r+0xae>
 8013074:	2000      	movs	r0, #0
 8013076:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801307a:	89ab      	ldrh	r3, [r5, #12]
 801307c:	f04f 30ff 	mov.w	r0, #4294967295
 8013080:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8013084:	81ab      	strh	r3, [r5, #12]
 8013086:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801308a:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 801308c:	2a00      	cmp	r2, #0
 801308e:	dc9d      	bgt.n	8012fcc <__sflush_r+0x20>
 8013090:	e7f0      	b.n	8013074 <__sflush_r+0xc8>
 8013092:	69e9      	ldr	r1, [r5, #28]
 8013094:	4632      	mov	r2, r6
 8013096:	2301      	movs	r3, #1
 8013098:	4640      	mov	r0, r8
 801309a:	47a0      	blx	r4
 801309c:	1c41      	adds	r1, r0, #1
 801309e:	4602      	mov	r2, r0
 80130a0:	d020      	beq.n	80130e4 <__sflush_r+0x138>
 80130a2:	89a9      	ldrh	r1, [r5, #12]
 80130a4:	6aac      	ldr	r4, [r5, #40]	; 0x28
 80130a6:	e79f      	b.n	8012fe8 <__sflush_r+0x3c>
 80130a8:	f8d8 3000 	ldr.w	r3, [r8]
 80130ac:	b96b      	cbnz	r3, 80130ca <__sflush_r+0x11e>
 80130ae:	89aa      	ldrh	r2, [r5, #12]
 80130b0:	6929      	ldr	r1, [r5, #16]
 80130b2:	f402 5480 	and.w	r4, r2, #4096	; 0x1000
 80130b6:	606b      	str	r3, [r5, #4]
 80130b8:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80130bc:	81aa      	strh	r2, [r5, #12]
 80130be:	b223      	sxth	r3, r4
 80130c0:	6029      	str	r1, [r5, #0]
 80130c2:	2b00      	cmp	r3, #0
 80130c4:	d0ad      	beq.n	8013022 <__sflush_r+0x76>
 80130c6:	6528      	str	r0, [r5, #80]	; 0x50
 80130c8:	e7ab      	b.n	8013022 <__sflush_r+0x76>
 80130ca:	2b1d      	cmp	r3, #29
 80130cc:	d001      	beq.n	80130d2 <__sflush_r+0x126>
 80130ce:	2b16      	cmp	r3, #22
 80130d0:	d115      	bne.n	80130fe <__sflush_r+0x152>
 80130d2:	692b      	ldr	r3, [r5, #16]
 80130d4:	2100      	movs	r1, #0
 80130d6:	89aa      	ldrh	r2, [r5, #12]
 80130d8:	6069      	str	r1, [r5, #4]
 80130da:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80130de:	602b      	str	r3, [r5, #0]
 80130e0:	81aa      	strh	r2, [r5, #12]
 80130e2:	e79e      	b.n	8013022 <__sflush_r+0x76>
 80130e4:	f8d8 3000 	ldr.w	r3, [r8]
 80130e8:	2b00      	cmp	r3, #0
 80130ea:	d0da      	beq.n	80130a2 <__sflush_r+0xf6>
 80130ec:	2b1d      	cmp	r3, #29
 80130ee:	bf18      	it	ne
 80130f0:	2b16      	cmpne	r3, #22
 80130f2:	d1c2      	bne.n	801307a <__sflush_r+0xce>
 80130f4:	f8c8 7000 	str.w	r7, [r8]
 80130f8:	4630      	mov	r0, r6
 80130fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80130fe:	89ab      	ldrh	r3, [r5, #12]
 8013100:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8013104:	81ab      	strh	r3, [r5, #12]
 8013106:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801310a:	bf00      	nop

0801310c <_fflush_r>:
 801310c:	b510      	push	{r4, lr}
 801310e:	4604      	mov	r4, r0
 8013110:	b082      	sub	sp, #8
 8013112:	b108      	cbz	r0, 8013118 <_fflush_r+0xc>
 8013114:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8013116:	b153      	cbz	r3, 801312e <_fflush_r+0x22>
 8013118:	f9b1 000c 	ldrsh.w	r0, [r1, #12]
 801311c:	b908      	cbnz	r0, 8013122 <_fflush_r+0x16>
 801311e:	b002      	add	sp, #8
 8013120:	bd10      	pop	{r4, pc}
 8013122:	4620      	mov	r0, r4
 8013124:	b002      	add	sp, #8
 8013126:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801312a:	f7ff bf3f 	b.w	8012fac <__sflush_r>
 801312e:	9101      	str	r1, [sp, #4]
 8013130:	f000 f866 	bl	8013200 <__sinit>
 8013134:	9901      	ldr	r1, [sp, #4]
 8013136:	e7ef      	b.n	8013118 <_fflush_r+0xc>

08013138 <fflush>:
 8013138:	b120      	cbz	r0, 8013144 <fflush+0xc>
 801313a:	4b05      	ldr	r3, [pc, #20]	; (8013150 <fflush+0x18>)
 801313c:	4601      	mov	r1, r0
 801313e:	6818      	ldr	r0, [r3, #0]
 8013140:	f7ff bfe4 	b.w	801310c <_fflush_r>
 8013144:	4b03      	ldr	r3, [pc, #12]	; (8013154 <fflush+0x1c>)
 8013146:	4904      	ldr	r1, [pc, #16]	; (8013158 <fflush+0x20>)
 8013148:	6818      	ldr	r0, [r3, #0]
 801314a:	f000 ba19 	b.w	8013580 <_fwalk_reent>
 801314e:	bf00      	nop
 8013150:	200000b0 	.word	0x200000b0
 8013154:	0801ffb0 	.word	0x0801ffb0
 8013158:	0801310d 	.word	0x0801310d

0801315c <__fp_lock>:
 801315c:	2000      	movs	r0, #0
 801315e:	4770      	bx	lr

08013160 <__fp_unlock>:
 8013160:	2000      	movs	r0, #0
 8013162:	4770      	bx	lr

08013164 <_cleanup_r>:
 8013164:	f643 0119 	movw	r1, #14361	; 0x3819
 8013168:	f6c0 0101 	movt	r1, #2049	; 0x801
 801316c:	f000 b9e4 	b.w	8013538 <_fwalk>

08013170 <std.isra.0>:
 8013170:	b510      	push	{r4, lr}
 8013172:	4604      	mov	r4, r0
 8013174:	2300      	movs	r3, #0
 8013176:	f100 005c 	add.w	r0, r0, #92	; 0x5c
 801317a:	81a1      	strh	r1, [r4, #12]
 801317c:	4619      	mov	r1, r3
 801317e:	81e2      	strh	r2, [r4, #14]
 8013180:	2208      	movs	r2, #8
 8013182:	6023      	str	r3, [r4, #0]
 8013184:	6063      	str	r3, [r4, #4]
 8013186:	60a3      	str	r3, [r4, #8]
 8013188:	6663      	str	r3, [r4, #100]	; 0x64
 801318a:	6123      	str	r3, [r4, #16]
 801318c:	6163      	str	r3, [r4, #20]
 801318e:	61a3      	str	r3, [r4, #24]
 8013190:	f7fe fee0 	bl	8011f54 <memset>
 8013194:	f243 63b9 	movw	r3, #14009	; 0x36b9
 8013198:	f6c0 0301 	movt	r3, #2049	; 0x801
 801319c:	6223      	str	r3, [r4, #32]
 801319e:	f243 63e1 	movw	r3, #14049	; 0x36e1
 80131a2:	61e4      	str	r4, [r4, #28]
 80131a4:	f6c0 0301 	movt	r3, #2049	; 0x801
 80131a8:	6263      	str	r3, [r4, #36]	; 0x24
 80131aa:	f243 731d 	movw	r3, #14109	; 0x371d
 80131ae:	f6c0 0301 	movt	r3, #2049	; 0x801
 80131b2:	62a3      	str	r3, [r4, #40]	; 0x28
 80131b4:	f243 733d 	movw	r3, #14141	; 0x373d
 80131b8:	f6c0 0301 	movt	r3, #2049	; 0x801
 80131bc:	62e3      	str	r3, [r4, #44]	; 0x2c
 80131be:	bd10      	pop	{r4, pc}

080131c0 <__sfmoreglue>:
 80131c0:	b570      	push	{r4, r5, r6, lr}
 80131c2:	2568      	movs	r5, #104	; 0x68
 80131c4:	460e      	mov	r6, r1
 80131c6:	fb05 f501 	mul.w	r5, r5, r1
 80131ca:	f105 010c 	add.w	r1, r5, #12
 80131ce:	f7fe fae5 	bl	801179c <_malloc_r>
 80131d2:	4604      	mov	r4, r0
 80131d4:	b148      	cbz	r0, 80131ea <__sfmoreglue+0x2a>
 80131d6:	f100 030c 	add.w	r3, r0, #12
 80131da:	2100      	movs	r1, #0
 80131dc:	6046      	str	r6, [r0, #4]
 80131de:	462a      	mov	r2, r5
 80131e0:	4618      	mov	r0, r3
 80131e2:	6021      	str	r1, [r4, #0]
 80131e4:	60a3      	str	r3, [r4, #8]
 80131e6:	f7fe feb5 	bl	8011f54 <memset>
 80131ea:	4620      	mov	r0, r4
 80131ec:	bd70      	pop	{r4, r5, r6, pc}
 80131ee:	bf00      	nop

080131f0 <_cleanup>:
 80131f0:	f64f 73b0 	movw	r3, #65456	; 0xffb0
 80131f4:	f6c0 0301 	movt	r3, #2049	; 0x801
 80131f8:	6818      	ldr	r0, [r3, #0]
 80131fa:	f7ff bfb3 	b.w	8013164 <_cleanup_r>
 80131fe:	bf00      	nop

08013200 <__sinit>:
 8013200:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8013202:	b570      	push	{r4, r5, r6, lr}
 8013204:	4604      	mov	r4, r0
 8013206:	b103      	cbz	r3, 801320a <__sinit+0xa>
 8013208:	bd70      	pop	{r4, r5, r6, pc}
 801320a:	4e0f      	ldr	r6, [pc, #60]	; (8013248 <__sinit+0x48>)
 801320c:	2501      	movs	r5, #1
 801320e:	2104      	movs	r1, #4
 8013210:	461a      	mov	r2, r3
 8013212:	f8c4 32e0 	str.w	r3, [r4, #736]	; 0x2e0
 8013216:	f504 733b 	add.w	r3, r4, #748	; 0x2ec
 801321a:	63e6      	str	r6, [r4, #60]	; 0x3c
 801321c:	2603      	movs	r6, #3
 801321e:	f8c4 32e8 	str.w	r3, [r4, #744]	; 0x2e8
 8013222:	6840      	ldr	r0, [r0, #4]
 8013224:	63a5      	str	r5, [r4, #56]	; 0x38
 8013226:	f8c4 62e4 	str.w	r6, [r4, #740]	; 0x2e4
 801322a:	f7ff ffa1 	bl	8013170 <std.isra.0>
 801322e:	68a0      	ldr	r0, [r4, #8]
 8013230:	2109      	movs	r1, #9
 8013232:	462a      	mov	r2, r5
 8013234:	f7ff ff9c 	bl	8013170 <std.isra.0>
 8013238:	68e0      	ldr	r0, [r4, #12]
 801323a:	2112      	movs	r1, #18
 801323c:	2202      	movs	r2, #2
 801323e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8013242:	f7ff bf95 	b.w	8013170 <std.isra.0>
 8013246:	bf00      	nop
 8013248:	08013165 	.word	0x08013165

0801324c <__sfp>:
 801324c:	4b20      	ldr	r3, [pc, #128]	; (80132d0 <__sfp+0x84>)
 801324e:	b570      	push	{r4, r5, r6, lr}
 8013250:	4606      	mov	r6, r0
 8013252:	681d      	ldr	r5, [r3, #0]
 8013254:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8013256:	2b00      	cmp	r3, #0
 8013258:	d02b      	beq.n	80132b2 <__sfp+0x66>
 801325a:	f505 7538 	add.w	r5, r5, #736	; 0x2e0
 801325e:	686b      	ldr	r3, [r5, #4]
 8013260:	68ac      	ldr	r4, [r5, #8]
 8013262:	3b01      	subs	r3, #1
 8013264:	d504      	bpl.n	8013270 <__sfp+0x24>
 8013266:	e020      	b.n	80132aa <__sfp+0x5e>
 8013268:	3b01      	subs	r3, #1
 801326a:	3468      	adds	r4, #104	; 0x68
 801326c:	1c5a      	adds	r2, r3, #1
 801326e:	d01c      	beq.n	80132aa <__sfp+0x5e>
 8013270:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8013274:	2a00      	cmp	r2, #0
 8013276:	d1f7      	bne.n	8013268 <__sfp+0x1c>
 8013278:	2500      	movs	r5, #0
 801327a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801327e:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8013282:	81e3      	strh	r3, [r4, #14]
 8013284:	6665      	str	r5, [r4, #100]	; 0x64
 8013286:	2301      	movs	r3, #1
 8013288:	4629      	mov	r1, r5
 801328a:	81a3      	strh	r3, [r4, #12]
 801328c:	6025      	str	r5, [r4, #0]
 801328e:	2208      	movs	r2, #8
 8013290:	60a5      	str	r5, [r4, #8]
 8013292:	6065      	str	r5, [r4, #4]
 8013294:	6125      	str	r5, [r4, #16]
 8013296:	6165      	str	r5, [r4, #20]
 8013298:	61a5      	str	r5, [r4, #24]
 801329a:	f7fe fe5b 	bl	8011f54 <memset>
 801329e:	6325      	str	r5, [r4, #48]	; 0x30
 80132a0:	6365      	str	r5, [r4, #52]	; 0x34
 80132a2:	6465      	str	r5, [r4, #68]	; 0x44
 80132a4:	64a5      	str	r5, [r4, #72]	; 0x48
 80132a6:	4620      	mov	r0, r4
 80132a8:	bd70      	pop	{r4, r5, r6, pc}
 80132aa:	6828      	ldr	r0, [r5, #0]
 80132ac:	b128      	cbz	r0, 80132ba <__sfp+0x6e>
 80132ae:	4605      	mov	r5, r0
 80132b0:	e7d5      	b.n	801325e <__sfp+0x12>
 80132b2:	4628      	mov	r0, r5
 80132b4:	f7ff ffa4 	bl	8013200 <__sinit>
 80132b8:	e7cf      	b.n	801325a <__sfp+0xe>
 80132ba:	4630      	mov	r0, r6
 80132bc:	2104      	movs	r1, #4
 80132be:	f7ff ff7f 	bl	80131c0 <__sfmoreglue>
 80132c2:	6028      	str	r0, [r5, #0]
 80132c4:	2800      	cmp	r0, #0
 80132c6:	d1f2      	bne.n	80132ae <__sfp+0x62>
 80132c8:	230c      	movs	r3, #12
 80132ca:	4604      	mov	r4, r0
 80132cc:	6033      	str	r3, [r6, #0]
 80132ce:	e7ea      	b.n	80132a6 <__sfp+0x5a>
 80132d0:	0801ffb0 	.word	0x0801ffb0

080132d4 <__sfp_lock_acquire>:
 80132d4:	4770      	bx	lr
 80132d6:	bf00      	nop

080132d8 <__sfp_lock_release>:
 80132d8:	4770      	bx	lr
 80132da:	bf00      	nop

080132dc <__sinit_lock_acquire>:
 80132dc:	4770      	bx	lr
 80132de:	bf00      	nop

080132e0 <__sinit_lock_release>:
 80132e0:	4770      	bx	lr
 80132e2:	bf00      	nop

080132e4 <__fp_lock_all>:
 80132e4:	f240 03b0 	movw	r3, #176	; 0xb0
 80132e8:	f243 115d 	movw	r1, #12637	; 0x315d
 80132ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80132f0:	f6c0 0101 	movt	r1, #2049	; 0x801
 80132f4:	6818      	ldr	r0, [r3, #0]
 80132f6:	f000 b91f 	b.w	8013538 <_fwalk>
 80132fa:	bf00      	nop

080132fc <__fp_unlock_all>:
 80132fc:	f240 03b0 	movw	r3, #176	; 0xb0
 8013300:	f243 1161 	movw	r1, #12641	; 0x3161
 8013304:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013308:	f6c0 0101 	movt	r1, #2049	; 0x801
 801330c:	6818      	ldr	r0, [r3, #0]
 801330e:	f000 b913 	b.w	8013538 <_fwalk>
 8013312:	bf00      	nop

08013314 <_malloc_trim_r>:
 8013314:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8013316:	460f      	mov	r7, r1
 8013318:	4d21      	ldr	r5, [pc, #132]	; (80133a0 <_malloc_trim_r+0x8c>)
 801331a:	4604      	mov	r4, r0
 801331c:	f7fe fe66 	bl	8011fec <__malloc_lock>
 8013320:	68ab      	ldr	r3, [r5, #8]
 8013322:	685e      	ldr	r6, [r3, #4]
 8013324:	f026 0603 	bic.w	r6, r6, #3
 8013328:	f606 73ef 	addw	r3, r6, #4079	; 0xfef
 801332c:	1bdf      	subs	r7, r3, r7
 801332e:	0b3f      	lsrs	r7, r7, #12
 8013330:	3f01      	subs	r7, #1
 8013332:	033f      	lsls	r7, r7, #12
 8013334:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
 8013338:	db07      	blt.n	801334a <_malloc_trim_r+0x36>
 801333a:	2100      	movs	r1, #0
 801333c:	4620      	mov	r0, r4
 801333e:	f7ff f975 	bl	801262c <_sbrk_r>
 8013342:	68ab      	ldr	r3, [r5, #8]
 8013344:	199b      	adds	r3, r3, r6
 8013346:	4298      	cmp	r0, r3
 8013348:	d004      	beq.n	8013354 <_malloc_trim_r+0x40>
 801334a:	4620      	mov	r0, r4
 801334c:	f7fe fe50 	bl	8011ff0 <__malloc_unlock>
 8013350:	2000      	movs	r0, #0
 8013352:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8013354:	4279      	negs	r1, r7
 8013356:	4620      	mov	r0, r4
 8013358:	f7ff f968 	bl	801262c <_sbrk_r>
 801335c:	3001      	adds	r0, #1
 801335e:	d00d      	beq.n	801337c <_malloc_trim_r+0x68>
 8013360:	4b10      	ldr	r3, [pc, #64]	; (80133a4 <_malloc_trim_r+0x90>)
 8013362:	1bf6      	subs	r6, r6, r7
 8013364:	68a9      	ldr	r1, [r5, #8]
 8013366:	4620      	mov	r0, r4
 8013368:	f046 0601 	orr.w	r6, r6, #1
 801336c:	681a      	ldr	r2, [r3, #0]
 801336e:	604e      	str	r6, [r1, #4]
 8013370:	1bd7      	subs	r7, r2, r7
 8013372:	601f      	str	r7, [r3, #0]
 8013374:	f7fe fe3c 	bl	8011ff0 <__malloc_unlock>
 8013378:	2001      	movs	r0, #1
 801337a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801337c:	2100      	movs	r1, #0
 801337e:	4620      	mov	r0, r4
 8013380:	f7ff f954 	bl	801262c <_sbrk_r>
 8013384:	68ab      	ldr	r3, [r5, #8]
 8013386:	1ac2      	subs	r2, r0, r3
 8013388:	2a0f      	cmp	r2, #15
 801338a:	ddde      	ble.n	801334a <_malloc_trim_r+0x36>
 801338c:	f042 0201 	orr.w	r2, r2, #1
 8013390:	605a      	str	r2, [r3, #4]
 8013392:	4b05      	ldr	r3, [pc, #20]	; (80133a8 <_malloc_trim_r+0x94>)
 8013394:	681b      	ldr	r3, [r3, #0]
 8013396:	1ac0      	subs	r0, r0, r3
 8013398:	4b02      	ldr	r3, [pc, #8]	; (80133a4 <_malloc_trim_r+0x90>)
 801339a:	6018      	str	r0, [r3, #0]
 801339c:	e7d5      	b.n	801334a <_malloc_trim_r+0x36>
 801339e:	bf00      	nop
 80133a0:	200004e0 	.word	0x200004e0
 80133a4:	20000b54 	.word	0x20000b54
 80133a8:	200008e8 	.word	0x200008e8

080133ac <_free_r>:
 80133ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80133ae:	460d      	mov	r5, r1
 80133b0:	4606      	mov	r6, r0
 80133b2:	2900      	cmp	r1, #0
 80133b4:	d055      	beq.n	8013462 <_free_r+0xb6>
 80133b6:	f7fe fe19 	bl	8011fec <__malloc_lock>
 80133ba:	f855 1c04 	ldr.w	r1, [r5, #-4]
 80133be:	f8df c168 	ldr.w	ip, [pc, #360]	; 8013528 <_free_r+0x17c>
 80133c2:	f1a5 0408 	sub.w	r4, r5, #8
 80133c6:	f021 0301 	bic.w	r3, r1, #1
 80133ca:	18e2      	adds	r2, r4, r3
 80133cc:	f8dc 0008 	ldr.w	r0, [ip, #8]
 80133d0:	6857      	ldr	r7, [r2, #4]
 80133d2:	4290      	cmp	r0, r2
 80133d4:	f027 0703 	bic.w	r7, r7, #3
 80133d8:	d064      	beq.n	80134a4 <_free_r+0xf8>
 80133da:	f011 0101 	ands.w	r1, r1, #1
 80133de:	6057      	str	r7, [r2, #4]
 80133e0:	d032      	beq.n	8013448 <_free_r+0x9c>
 80133e2:	2100      	movs	r1, #0
 80133e4:	19d0      	adds	r0, r2, r7
 80133e6:	6840      	ldr	r0, [r0, #4]
 80133e8:	07c0      	lsls	r0, r0, #31
 80133ea:	d406      	bmi.n	80133fa <_free_r+0x4e>
 80133ec:	19db      	adds	r3, r3, r7
 80133ee:	6890      	ldr	r0, [r2, #8]
 80133f0:	2900      	cmp	r1, #0
 80133f2:	d049      	beq.n	8013488 <_free_r+0xdc>
 80133f4:	68d2      	ldr	r2, [r2, #12]
 80133f6:	60c2      	str	r2, [r0, #12]
 80133f8:	6090      	str	r0, [r2, #8]
 80133fa:	f043 0201 	orr.w	r2, r3, #1
 80133fe:	50e3      	str	r3, [r4, r3]
 8013400:	6062      	str	r2, [r4, #4]
 8013402:	b9e1      	cbnz	r1, 801343e <_free_r+0x92>
 8013404:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8013408:	d32c      	bcc.n	8013464 <_free_r+0xb8>
 801340a:	0a5a      	lsrs	r2, r3, #9
 801340c:	2a04      	cmp	r2, #4
 801340e:	d865      	bhi.n	80134dc <_free_r+0x130>
 8013410:	0998      	lsrs	r0, r3, #6
 8013412:	3038      	adds	r0, #56	; 0x38
 8013414:	0041      	lsls	r1, r0, #1
 8013416:	eb0c 0c81 	add.w	ip, ip, r1, lsl #2
 801341a:	4943      	ldr	r1, [pc, #268]	; (8013528 <_free_r+0x17c>)
 801341c:	f8dc 2008 	ldr.w	r2, [ip, #8]
 8013420:	4562      	cmp	r2, ip
 8013422:	d066      	beq.n	80134f2 <_free_r+0x146>
 8013424:	6851      	ldr	r1, [r2, #4]
 8013426:	f021 0103 	bic.w	r1, r1, #3
 801342a:	428b      	cmp	r3, r1
 801342c:	d202      	bcs.n	8013434 <_free_r+0x88>
 801342e:	6892      	ldr	r2, [r2, #8]
 8013430:	4594      	cmp	ip, r2
 8013432:	d1f7      	bne.n	8013424 <_free_r+0x78>
 8013434:	68d3      	ldr	r3, [r2, #12]
 8013436:	60e3      	str	r3, [r4, #12]
 8013438:	60a2      	str	r2, [r4, #8]
 801343a:	60d4      	str	r4, [r2, #12]
 801343c:	609c      	str	r4, [r3, #8]
 801343e:	4630      	mov	r0, r6
 8013440:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8013444:	f7fe bdd4 	b.w	8011ff0 <__malloc_unlock>
 8013448:	f855 0c08 	ldr.w	r0, [r5, #-8]
 801344c:	f10c 0508 	add.w	r5, ip, #8
 8013450:	1a24      	subs	r4, r4, r0
 8013452:	181b      	adds	r3, r3, r0
 8013454:	68a0      	ldr	r0, [r4, #8]
 8013456:	42a8      	cmp	r0, r5
 8013458:	d03e      	beq.n	80134d8 <_free_r+0x12c>
 801345a:	68e5      	ldr	r5, [r4, #12]
 801345c:	60c5      	str	r5, [r0, #12]
 801345e:	60a8      	str	r0, [r5, #8]
 8013460:	e7c0      	b.n	80133e4 <_free_r+0x38>
 8013462:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8013464:	08db      	lsrs	r3, r3, #3
 8013466:	2101      	movs	r1, #1
 8013468:	f8dc 0004 	ldr.w	r0, [ip, #4]
 801346c:	eb0c 02c3 	add.w	r2, ip, r3, lsl #3
 8013470:	109b      	asrs	r3, r3, #2
 8013472:	fa01 f303 	lsl.w	r3, r1, r3
 8013476:	60e2      	str	r2, [r4, #12]
 8013478:	6891      	ldr	r1, [r2, #8]
 801347a:	4318      	orrs	r0, r3
 801347c:	f8cc 0004 	str.w	r0, [ip, #4]
 8013480:	60a1      	str	r1, [r4, #8]
 8013482:	60cc      	str	r4, [r1, #12]
 8013484:	6094      	str	r4, [r2, #8]
 8013486:	e7da      	b.n	801343e <_free_r+0x92>
 8013488:	4d28      	ldr	r5, [pc, #160]	; (801352c <_free_r+0x180>)
 801348a:	42a8      	cmp	r0, r5
 801348c:	d1b2      	bne.n	80133f4 <_free_r+0x48>
 801348e:	f8cc 4014 	str.w	r4, [ip, #20]
 8013492:	f043 0201 	orr.w	r2, r3, #1
 8013496:	f8cc 4010 	str.w	r4, [ip, #16]
 801349a:	60e0      	str	r0, [r4, #12]
 801349c:	60a0      	str	r0, [r4, #8]
 801349e:	6062      	str	r2, [r4, #4]
 80134a0:	50e3      	str	r3, [r4, r3]
 80134a2:	e7cc      	b.n	801343e <_free_r+0x92>
 80134a4:	18ff      	adds	r7, r7, r3
 80134a6:	07cb      	lsls	r3, r1, #31
 80134a8:	d407      	bmi.n	80134ba <_free_r+0x10e>
 80134aa:	f855 3c08 	ldr.w	r3, [r5, #-8]
 80134ae:	1ae4      	subs	r4, r4, r3
 80134b0:	18ff      	adds	r7, r7, r3
 80134b2:	68a2      	ldr	r2, [r4, #8]
 80134b4:	68e3      	ldr	r3, [r4, #12]
 80134b6:	60d3      	str	r3, [r2, #12]
 80134b8:	609a      	str	r2, [r3, #8]
 80134ba:	f047 0301 	orr.w	r3, r7, #1
 80134be:	6063      	str	r3, [r4, #4]
 80134c0:	4b1b      	ldr	r3, [pc, #108]	; (8013530 <_free_r+0x184>)
 80134c2:	f8cc 4008 	str.w	r4, [ip, #8]
 80134c6:	681b      	ldr	r3, [r3, #0]
 80134c8:	429f      	cmp	r7, r3
 80134ca:	d3b8      	bcc.n	801343e <_free_r+0x92>
 80134cc:	4b19      	ldr	r3, [pc, #100]	; (8013534 <_free_r+0x188>)
 80134ce:	4630      	mov	r0, r6
 80134d0:	6819      	ldr	r1, [r3, #0]
 80134d2:	f7ff ff1f 	bl	8013314 <_malloc_trim_r>
 80134d6:	e7b2      	b.n	801343e <_free_r+0x92>
 80134d8:	2101      	movs	r1, #1
 80134da:	e783      	b.n	80133e4 <_free_r+0x38>
 80134dc:	f102 005b 	add.w	r0, r2, #91	; 0x5b
 80134e0:	0041      	lsls	r1, r0, #1
 80134e2:	2a14      	cmp	r2, #20
 80134e4:	d997      	bls.n	8013416 <_free_r+0x6a>
 80134e6:	2a54      	cmp	r2, #84	; 0x54
 80134e8:	d80c      	bhi.n	8013504 <_free_r+0x158>
 80134ea:	0b18      	lsrs	r0, r3, #12
 80134ec:	306e      	adds	r0, #110	; 0x6e
 80134ee:	0041      	lsls	r1, r0, #1
 80134f0:	e791      	b.n	8013416 <_free_r+0x6a>
 80134f2:	2701      	movs	r7, #1
 80134f4:	684d      	ldr	r5, [r1, #4]
 80134f6:	1080      	asrs	r0, r0, #2
 80134f8:	4613      	mov	r3, r2
 80134fa:	fa07 f000 	lsl.w	r0, r7, r0
 80134fe:	4305      	orrs	r5, r0
 8013500:	604d      	str	r5, [r1, #4]
 8013502:	e798      	b.n	8013436 <_free_r+0x8a>
 8013504:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8013508:	d803      	bhi.n	8013512 <_free_r+0x166>
 801350a:	0bd8      	lsrs	r0, r3, #15
 801350c:	3077      	adds	r0, #119	; 0x77
 801350e:	0041      	lsls	r1, r0, #1
 8013510:	e781      	b.n	8013416 <_free_r+0x6a>
 8013512:	f240 5154 	movw	r1, #1364	; 0x554
 8013516:	428a      	cmp	r2, r1
 8013518:	d803      	bhi.n	8013522 <_free_r+0x176>
 801351a:	0c98      	lsrs	r0, r3, #18
 801351c:	307c      	adds	r0, #124	; 0x7c
 801351e:	0041      	lsls	r1, r0, #1
 8013520:	e779      	b.n	8013416 <_free_r+0x6a>
 8013522:	21fc      	movs	r1, #252	; 0xfc
 8013524:	207e      	movs	r0, #126	; 0x7e
 8013526:	e776      	b.n	8013416 <_free_r+0x6a>
 8013528:	200004e0 	.word	0x200004e0
 801352c:	200004e8 	.word	0x200004e8
 8013530:	200008ec 	.word	0x200008ec
 8013534:	20000b50 	.word	0x20000b50

08013538 <_fwalk>:
 8013538:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801353c:	f510 7638 	adds.w	r6, r0, #736	; 0x2e0
 8013540:	4688      	mov	r8, r1
 8013542:	d019      	beq.n	8013578 <_fwalk+0x40>
 8013544:	2700      	movs	r7, #0
 8013546:	6875      	ldr	r5, [r6, #4]
 8013548:	68b4      	ldr	r4, [r6, #8]
 801354a:	3d01      	subs	r5, #1
 801354c:	d40e      	bmi.n	801356c <_fwalk+0x34>
 801354e:	89a3      	ldrh	r3, [r4, #12]
 8013550:	3d01      	subs	r5, #1
 8013552:	b143      	cbz	r3, 8013566 <_fwalk+0x2e>
 8013554:	2b01      	cmp	r3, #1
 8013556:	d906      	bls.n	8013566 <_fwalk+0x2e>
 8013558:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 801355c:	4620      	mov	r0, r4
 801355e:	3301      	adds	r3, #1
 8013560:	d001      	beq.n	8013566 <_fwalk+0x2e>
 8013562:	47c0      	blx	r8
 8013564:	4307      	orrs	r7, r0
 8013566:	3468      	adds	r4, #104	; 0x68
 8013568:	1c6b      	adds	r3, r5, #1
 801356a:	d1f0      	bne.n	801354e <_fwalk+0x16>
 801356c:	6836      	ldr	r6, [r6, #0]
 801356e:	2e00      	cmp	r6, #0
 8013570:	d1e9      	bne.n	8013546 <_fwalk+0xe>
 8013572:	4638      	mov	r0, r7
 8013574:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8013578:	4637      	mov	r7, r6
 801357a:	4638      	mov	r0, r7
 801357c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08013580 <_fwalk_reent>:
 8013580:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8013584:	f510 7638 	adds.w	r6, r0, #736	; 0x2e0
 8013588:	4680      	mov	r8, r0
 801358a:	4689      	mov	r9, r1
 801358c:	d01a      	beq.n	80135c4 <_fwalk_reent+0x44>
 801358e:	2700      	movs	r7, #0
 8013590:	6875      	ldr	r5, [r6, #4]
 8013592:	68b4      	ldr	r4, [r6, #8]
 8013594:	3d01      	subs	r5, #1
 8013596:	d40f      	bmi.n	80135b8 <_fwalk_reent+0x38>
 8013598:	89a3      	ldrh	r3, [r4, #12]
 801359a:	3d01      	subs	r5, #1
 801359c:	b14b      	cbz	r3, 80135b2 <_fwalk_reent+0x32>
 801359e:	2b01      	cmp	r3, #1
 80135a0:	d907      	bls.n	80135b2 <_fwalk_reent+0x32>
 80135a2:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 80135a6:	4621      	mov	r1, r4
 80135a8:	4640      	mov	r0, r8
 80135aa:	3301      	adds	r3, #1
 80135ac:	d001      	beq.n	80135b2 <_fwalk_reent+0x32>
 80135ae:	47c8      	blx	r9
 80135b0:	4307      	orrs	r7, r0
 80135b2:	3468      	adds	r4, #104	; 0x68
 80135b4:	1c6a      	adds	r2, r5, #1
 80135b6:	d1ef      	bne.n	8013598 <_fwalk_reent+0x18>
 80135b8:	6836      	ldr	r6, [r6, #0]
 80135ba:	2e00      	cmp	r6, #0
 80135bc:	d1e8      	bne.n	8013590 <_fwalk_reent+0x10>
 80135be:	4638      	mov	r0, r7
 80135c0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80135c4:	4637      	mov	r7, r6
 80135c6:	4638      	mov	r0, r7
 80135c8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080135cc <__smakebuf_r>:
 80135cc:	898b      	ldrh	r3, [r1, #12]
 80135ce:	b5f0      	push	{r4, r5, r6, r7, lr}
 80135d0:	f003 0202 	and.w	r2, r3, #2
 80135d4:	b091      	sub	sp, #68	; 0x44
 80135d6:	460c      	mov	r4, r1
 80135d8:	b212      	sxth	r2, r2
 80135da:	4605      	mov	r5, r0
 80135dc:	2a00      	cmp	r2, #0
 80135de:	d138      	bne.n	8013652 <__smakebuf_r+0x86>
 80135e0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80135e4:	2900      	cmp	r1, #0
 80135e6:	db16      	blt.n	8013616 <__smakebuf_r+0x4a>
 80135e8:	aa01      	add	r2, sp, #4
 80135ea:	f000 f91d 	bl	8013828 <_fstat_r>
 80135ee:	2800      	cmp	r0, #0
 80135f0:	db10      	blt.n	8013614 <__smakebuf_r+0x48>
 80135f2:	9b02      	ldr	r3, [sp, #8]
 80135f4:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
 80135f8:	f5b3 5200 	subs.w	r2, r3, #8192	; 0x2000
 80135fc:	4257      	negs	r7, r2
 80135fe:	4157      	adcs	r7, r2
 8013600:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8013604:	d02c      	beq.n	8013660 <__smakebuf_r+0x94>
 8013606:	89a3      	ldrh	r3, [r4, #12]
 8013608:	f44f 6680 	mov.w	r6, #1024	; 0x400
 801360c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8013610:	81a3      	strh	r3, [r4, #12]
 8013612:	e00c      	b.n	801362e <__smakebuf_r+0x62>
 8013614:	89a3      	ldrh	r3, [r4, #12]
 8013616:	f003 0680 	and.w	r6, r3, #128	; 0x80
 801361a:	2700      	movs	r7, #0
 801361c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8013620:	81a3      	strh	r3, [r4, #12]
 8013622:	b236      	sxth	r6, r6
 8013624:	42be      	cmp	r6, r7
 8013626:	bf0c      	ite	eq
 8013628:	f44f 6680 	moveq.w	r6, #1024	; 0x400
 801362c:	2640      	movne	r6, #64	; 0x40
 801362e:	4628      	mov	r0, r5
 8013630:	4631      	mov	r1, r6
 8013632:	f7fe f8b3 	bl	801179c <_malloc_r>
 8013636:	89a3      	ldrh	r3, [r4, #12]
 8013638:	2800      	cmp	r0, #0
 801363a:	d029      	beq.n	8013690 <__smakebuf_r+0xc4>
 801363c:	4a1c      	ldr	r2, [pc, #112]	; (80136b0 <__smakebuf_r+0xe4>)
 801363e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8013642:	63ea      	str	r2, [r5, #60]	; 0x3c
 8013644:	6020      	str	r0, [r4, #0]
 8013646:	81a3      	strh	r3, [r4, #12]
 8013648:	6120      	str	r0, [r4, #16]
 801364a:	6166      	str	r6, [r4, #20]
 801364c:	b9a7      	cbnz	r7, 8013678 <__smakebuf_r+0xac>
 801364e:	b011      	add	sp, #68	; 0x44
 8013650:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013652:	f101 0343 	add.w	r3, r1, #67	; 0x43
 8013656:	600b      	str	r3, [r1, #0]
 8013658:	610b      	str	r3, [r1, #16]
 801365a:	2301      	movs	r3, #1
 801365c:	614b      	str	r3, [r1, #20]
 801365e:	e7f6      	b.n	801364e <__smakebuf_r+0x82>
 8013660:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8013662:	4a14      	ldr	r2, [pc, #80]	; (80136b4 <__smakebuf_r+0xe8>)
 8013664:	4293      	cmp	r3, r2
 8013666:	d1ce      	bne.n	8013606 <__smakebuf_r+0x3a>
 8013668:	89a2      	ldrh	r2, [r4, #12]
 801366a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801366e:	461e      	mov	r6, r3
 8013670:	64e3      	str	r3, [r4, #76]	; 0x4c
 8013672:	4313      	orrs	r3, r2
 8013674:	81a3      	strh	r3, [r4, #12]
 8013676:	e7da      	b.n	801362e <__smakebuf_r+0x62>
 8013678:	4628      	mov	r0, r5
 801367a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 801367e:	f000 f8e7 	bl	8013850 <_isatty_r>
 8013682:	2800      	cmp	r0, #0
 8013684:	d0e3      	beq.n	801364e <__smakebuf_r+0x82>
 8013686:	89a3      	ldrh	r3, [r4, #12]
 8013688:	f043 0301 	orr.w	r3, r3, #1
 801368c:	81a3      	strh	r3, [r4, #12]
 801368e:	e7de      	b.n	801364e <__smakebuf_r+0x82>
 8013690:	f403 7200 	and.w	r2, r3, #512	; 0x200
 8013694:	b212      	sxth	r2, r2
 8013696:	2a00      	cmp	r2, #0
 8013698:	d1d9      	bne.n	801364e <__smakebuf_r+0x82>
 801369a:	f104 0243 	add.w	r2, r4, #67	; 0x43
 801369e:	f043 0302 	orr.w	r3, r3, #2
 80136a2:	6022      	str	r2, [r4, #0]
 80136a4:	81a3      	strh	r3, [r4, #12]
 80136a6:	2301      	movs	r3, #1
 80136a8:	6122      	str	r2, [r4, #16]
 80136aa:	6163      	str	r3, [r4, #20]
 80136ac:	e7cf      	b.n	801364e <__smakebuf_r+0x82>
 80136ae:	bf00      	nop
 80136b0:	08013165 	.word	0x08013165
 80136b4:	0801371d 	.word	0x0801371d

080136b8 <__sread>:
 80136b8:	b510      	push	{r4, lr}
 80136ba:	460c      	mov	r4, r1
 80136bc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80136c0:	f000 f8ec 	bl	801389c <_read_r>
 80136c4:	2800      	cmp	r0, #0
 80136c6:	bfab      	itete	ge
 80136c8:	6d23      	ldrge	r3, [r4, #80]	; 0x50
 80136ca:	89a3      	ldrhlt	r3, [r4, #12]
 80136cc:	181b      	addge	r3, r3, r0
 80136ce:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 80136d2:	bfac      	ite	ge
 80136d4:	6523      	strge	r3, [r4, #80]	; 0x50
 80136d6:	81a3      	strhlt	r3, [r4, #12]
 80136d8:	bd10      	pop	{r4, pc}
 80136da:	bf00      	nop

080136dc <__seofread>:
 80136dc:	2000      	movs	r0, #0
 80136de:	4770      	bx	lr

080136e0 <__swrite>:
 80136e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80136e4:	460c      	mov	r4, r1
 80136e6:	8989      	ldrh	r1, [r1, #12]
 80136e8:	461d      	mov	r5, r3
 80136ea:	4607      	mov	r7, r0
 80136ec:	4616      	mov	r6, r2
 80136ee:	f401 7380 	and.w	r3, r1, #256	; 0x100
 80136f2:	b21b      	sxth	r3, r3
 80136f4:	b133      	cbz	r3, 8013704 <__swrite+0x24>
 80136f6:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80136fa:	2200      	movs	r2, #0
 80136fc:	2302      	movs	r3, #2
 80136fe:	f000 f8b9 	bl	8013874 <_lseek_r>
 8013702:	89a1      	ldrh	r1, [r4, #12]
 8013704:	f421 5180 	bic.w	r1, r1, #4096	; 0x1000
 8013708:	4638      	mov	r0, r7
 801370a:	81a1      	strh	r1, [r4, #12]
 801370c:	4632      	mov	r2, r6
 801370e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8013712:	462b      	mov	r3, r5
 8013714:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8013718:	f000 b814 	b.w	8013744 <_write_r>

0801371c <__sseek>:
 801371c:	b510      	push	{r4, lr}
 801371e:	460c      	mov	r4, r1
 8013720:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8013724:	f000 f8a6 	bl	8013874 <_lseek_r>
 8013728:	89a3      	ldrh	r3, [r4, #12]
 801372a:	1c42      	adds	r2, r0, #1
 801372c:	bf16      	itet	ne
 801372e:	6520      	strne	r0, [r4, #80]	; 0x50
 8013730:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8013734:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8013738:	81a3      	strh	r3, [r4, #12]
 801373a:	bd10      	pop	{r4, pc}

0801373c <__sclose>:
 801373c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8013740:	f000 b814 	b.w	801376c <_close_r>

08013744 <_write_r>:
 8013744:	b538      	push	{r3, r4, r5, lr}
 8013746:	4605      	mov	r5, r0
 8013748:	4c07      	ldr	r4, [pc, #28]	; (8013768 <_write_r+0x24>)
 801374a:	4608      	mov	r0, r1
 801374c:	4611      	mov	r1, r2
 801374e:	461a      	mov	r2, r3
 8013750:	2300      	movs	r3, #0
 8013752:	6023      	str	r3, [r4, #0]
 8013754:	f7f4 ffae 	bl	80086b4 <_write>
 8013758:	1c43      	adds	r3, r0, #1
 801375a:	d000      	beq.n	801375e <_write_r+0x1a>
 801375c:	bd38      	pop	{r3, r4, r5, pc}
 801375e:	6823      	ldr	r3, [r4, #0]
 8013760:	2b00      	cmp	r3, #0
 8013762:	d0fb      	beq.n	801375c <_write_r+0x18>
 8013764:	602b      	str	r3, [r5, #0]
 8013766:	bd38      	pop	{r3, r4, r5, pc}
 8013768:	20003618 	.word	0x20003618

0801376c <_close_r>:
 801376c:	b538      	push	{r3, r4, r5, lr}
 801376e:	4605      	mov	r5, r0
 8013770:	4c06      	ldr	r4, [pc, #24]	; (801378c <_close_r+0x20>)
 8013772:	4608      	mov	r0, r1
 8013774:	2300      	movs	r3, #0
 8013776:	6023      	str	r3, [r4, #0]
 8013778:	f7f4 ffa9 	bl	80086ce <_close>
 801377c:	1c43      	adds	r3, r0, #1
 801377e:	d000      	beq.n	8013782 <_close_r+0x16>
 8013780:	bd38      	pop	{r3, r4, r5, pc}
 8013782:	6823      	ldr	r3, [r4, #0]
 8013784:	2b00      	cmp	r3, #0
 8013786:	d0fb      	beq.n	8013780 <_close_r+0x14>
 8013788:	602b      	str	r3, [r5, #0]
 801378a:	bd38      	pop	{r3, r4, r5, pc}
 801378c:	20003618 	.word	0x20003618

08013790 <_fclose_r>:
 8013790:	b570      	push	{r4, r5, r6, lr}
 8013792:	460c      	mov	r4, r1
 8013794:	4605      	mov	r5, r0
 8013796:	b131      	cbz	r1, 80137a6 <_fclose_r+0x16>
 8013798:	b110      	cbz	r0, 80137a0 <_fclose_r+0x10>
 801379a:	6b83      	ldr	r3, [r0, #56]	; 0x38
 801379c:	2b00      	cmp	r3, #0
 801379e:	d033      	beq.n	8013808 <_fclose_r+0x78>
 80137a0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80137a4:	b913      	cbnz	r3, 80137ac <_fclose_r+0x1c>
 80137a6:	2600      	movs	r6, #0
 80137a8:	4630      	mov	r0, r6
 80137aa:	bd70      	pop	{r4, r5, r6, pc}
 80137ac:	4628      	mov	r0, r5
 80137ae:	4621      	mov	r1, r4
 80137b0:	f7ff fcac 	bl	801310c <_fflush_r>
 80137b4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80137b6:	4606      	mov	r6, r0
 80137b8:	b13b      	cbz	r3, 80137ca <_fclose_r+0x3a>
 80137ba:	4628      	mov	r0, r5
 80137bc:	69e1      	ldr	r1, [r4, #28]
 80137be:	4798      	blx	r3
 80137c0:	ea36 0620 	bics.w	r6, r6, r0, asr #32
 80137c4:	bf28      	it	cs
 80137c6:	f04f 36ff 	movcs.w	r6, #4294967295
 80137ca:	89a3      	ldrh	r3, [r4, #12]
 80137cc:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80137d0:	b21b      	sxth	r3, r3
 80137d2:	b9e3      	cbnz	r3, 801380e <_fclose_r+0x7e>
 80137d4:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80137d6:	b141      	cbz	r1, 80137ea <_fclose_r+0x5a>
 80137d8:	f104 0340 	add.w	r3, r4, #64	; 0x40
 80137dc:	4299      	cmp	r1, r3
 80137de:	d002      	beq.n	80137e6 <_fclose_r+0x56>
 80137e0:	4628      	mov	r0, r5
 80137e2:	f7ff fde3 	bl	80133ac <_free_r>
 80137e6:	2300      	movs	r3, #0
 80137e8:	6323      	str	r3, [r4, #48]	; 0x30
 80137ea:	6c61      	ldr	r1, [r4, #68]	; 0x44
 80137ec:	b121      	cbz	r1, 80137f8 <_fclose_r+0x68>
 80137ee:	4628      	mov	r0, r5
 80137f0:	f7ff fddc 	bl	80133ac <_free_r>
 80137f4:	2300      	movs	r3, #0
 80137f6:	6463      	str	r3, [r4, #68]	; 0x44
 80137f8:	f7ff fd6c 	bl	80132d4 <__sfp_lock_acquire>
 80137fc:	2300      	movs	r3, #0
 80137fe:	81a3      	strh	r3, [r4, #12]
 8013800:	f7ff fd6a 	bl	80132d8 <__sfp_lock_release>
 8013804:	4630      	mov	r0, r6
 8013806:	bd70      	pop	{r4, r5, r6, pc}
 8013808:	f7ff fcfa 	bl	8013200 <__sinit>
 801380c:	e7c8      	b.n	80137a0 <_fclose_r+0x10>
 801380e:	4628      	mov	r0, r5
 8013810:	6921      	ldr	r1, [r4, #16]
 8013812:	f7ff fdcb 	bl	80133ac <_free_r>
 8013816:	e7dd      	b.n	80137d4 <_fclose_r+0x44>

08013818 <fclose>:
 8013818:	f240 03b0 	movw	r3, #176	; 0xb0
 801381c:	4601      	mov	r1, r0
 801381e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013822:	6818      	ldr	r0, [r3, #0]
 8013824:	f7ff bfb4 	b.w	8013790 <_fclose_r>

08013828 <_fstat_r>:
 8013828:	b538      	push	{r3, r4, r5, lr}
 801382a:	4605      	mov	r5, r0
 801382c:	4c07      	ldr	r4, [pc, #28]	; (801384c <_fstat_r+0x24>)
 801382e:	4608      	mov	r0, r1
 8013830:	4611      	mov	r1, r2
 8013832:	2300      	movs	r3, #0
 8013834:	6023      	str	r3, [r4, #0]
 8013836:	f7f4 ff4d 	bl	80086d4 <_fstat>
 801383a:	1c43      	adds	r3, r0, #1
 801383c:	d000      	beq.n	8013840 <_fstat_r+0x18>
 801383e:	bd38      	pop	{r3, r4, r5, pc}
 8013840:	6823      	ldr	r3, [r4, #0]
 8013842:	2b00      	cmp	r3, #0
 8013844:	d0fb      	beq.n	801383e <_fstat_r+0x16>
 8013846:	602b      	str	r3, [r5, #0]
 8013848:	bd38      	pop	{r3, r4, r5, pc}
 801384a:	bf00      	nop
 801384c:	20003618 	.word	0x20003618

08013850 <_isatty_r>:
 8013850:	b538      	push	{r3, r4, r5, lr}
 8013852:	4605      	mov	r5, r0
 8013854:	4c06      	ldr	r4, [pc, #24]	; (8013870 <_isatty_r+0x20>)
 8013856:	4608      	mov	r0, r1
 8013858:	2300      	movs	r3, #0
 801385a:	6023      	str	r3, [r4, #0]
 801385c:	f7f4 ff3f 	bl	80086de <_isatty>
 8013860:	1c43      	adds	r3, r0, #1
 8013862:	d000      	beq.n	8013866 <_isatty_r+0x16>
 8013864:	bd38      	pop	{r3, r4, r5, pc}
 8013866:	6823      	ldr	r3, [r4, #0]
 8013868:	2b00      	cmp	r3, #0
 801386a:	d0fb      	beq.n	8013864 <_isatty_r+0x14>
 801386c:	602b      	str	r3, [r5, #0]
 801386e:	bd38      	pop	{r3, r4, r5, pc}
 8013870:	20003618 	.word	0x20003618

08013874 <_lseek_r>:
 8013874:	b538      	push	{r3, r4, r5, lr}
 8013876:	4605      	mov	r5, r0
 8013878:	4c07      	ldr	r4, [pc, #28]	; (8013898 <_lseek_r+0x24>)
 801387a:	4608      	mov	r0, r1
 801387c:	4611      	mov	r1, r2
 801387e:	461a      	mov	r2, r3
 8013880:	2300      	movs	r3, #0
 8013882:	6023      	str	r3, [r4, #0]
 8013884:	f7f4 ff2d 	bl	80086e2 <_lseek>
 8013888:	1c43      	adds	r3, r0, #1
 801388a:	d000      	beq.n	801388e <_lseek_r+0x1a>
 801388c:	bd38      	pop	{r3, r4, r5, pc}
 801388e:	6823      	ldr	r3, [r4, #0]
 8013890:	2b00      	cmp	r3, #0
 8013892:	d0fb      	beq.n	801388c <_lseek_r+0x18>
 8013894:	602b      	str	r3, [r5, #0]
 8013896:	bd38      	pop	{r3, r4, r5, pc}
 8013898:	20003618 	.word	0x20003618

0801389c <_read_r>:
 801389c:	b538      	push	{r3, r4, r5, lr}
 801389e:	4605      	mov	r5, r0
 80138a0:	4c07      	ldr	r4, [pc, #28]	; (80138c0 <_read_r+0x24>)
 80138a2:	4608      	mov	r0, r1
 80138a4:	4611      	mov	r1, r2
 80138a6:	461a      	mov	r2, r3
 80138a8:	2300      	movs	r3, #0
 80138aa:	6023      	str	r3, [r4, #0]
 80138ac:	f7f4 ff1b 	bl	80086e6 <_read>
 80138b0:	1c43      	adds	r3, r0, #1
 80138b2:	d000      	beq.n	80138b6 <_read_r+0x1a>
 80138b4:	bd38      	pop	{r3, r4, r5, pc}
 80138b6:	6823      	ldr	r3, [r4, #0]
 80138b8:	2b00      	cmp	r3, #0
 80138ba:	d0fb      	beq.n	80138b4 <_read_r+0x18>
 80138bc:	602b      	str	r3, [r5, #0]
 80138be:	bd38      	pop	{r3, r4, r5, pc}
 80138c0:	20003618 	.word	0x20003618
 80138c4:	00000000 	.word	0x00000000

080138c8 <__aeabi_uidiv>:
 80138c8:	1e4a      	subs	r2, r1, #1
 80138ca:	bf08      	it	eq
 80138cc:	4770      	bxeq	lr
 80138ce:	f0c0 8124 	bcc.w	8013b1a <__aeabi_uidiv+0x252>
 80138d2:	4288      	cmp	r0, r1
 80138d4:	f240 8116 	bls.w	8013b04 <__aeabi_uidiv+0x23c>
 80138d8:	4211      	tst	r1, r2
 80138da:	f000 8117 	beq.w	8013b0c <__aeabi_uidiv+0x244>
 80138de:	fab0 f380 	clz	r3, r0
 80138e2:	fab1 f281 	clz	r2, r1
 80138e6:	eba2 0303 	sub.w	r3, r2, r3
 80138ea:	f1c3 031f 	rsb	r3, r3, #31
 80138ee:	a204      	add	r2, pc, #16	; (adr r2, 8013900 <__aeabi_uidiv+0x38>)
 80138f0:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 80138f4:	f04f 0200 	mov.w	r2, #0
 80138f8:	469f      	mov	pc, r3
 80138fa:	bf00      	nop
 80138fc:	f3af 8000 	nop.w
 8013900:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
 8013904:	bf00      	nop
 8013906:	eb42 0202 	adc.w	r2, r2, r2
 801390a:	bf28      	it	cs
 801390c:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
 8013910:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
 8013914:	bf00      	nop
 8013916:	eb42 0202 	adc.w	r2, r2, r2
 801391a:	bf28      	it	cs
 801391c:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
 8013920:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
 8013924:	bf00      	nop
 8013926:	eb42 0202 	adc.w	r2, r2, r2
 801392a:	bf28      	it	cs
 801392c:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
 8013930:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
 8013934:	bf00      	nop
 8013936:	eb42 0202 	adc.w	r2, r2, r2
 801393a:	bf28      	it	cs
 801393c:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
 8013940:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
 8013944:	bf00      	nop
 8013946:	eb42 0202 	adc.w	r2, r2, r2
 801394a:	bf28      	it	cs
 801394c:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
 8013950:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
 8013954:	bf00      	nop
 8013956:	eb42 0202 	adc.w	r2, r2, r2
 801395a:	bf28      	it	cs
 801395c:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
 8013960:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
 8013964:	bf00      	nop
 8013966:	eb42 0202 	adc.w	r2, r2, r2
 801396a:	bf28      	it	cs
 801396c:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
 8013970:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
 8013974:	bf00      	nop
 8013976:	eb42 0202 	adc.w	r2, r2, r2
 801397a:	bf28      	it	cs
 801397c:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
 8013980:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
 8013984:	bf00      	nop
 8013986:	eb42 0202 	adc.w	r2, r2, r2
 801398a:	bf28      	it	cs
 801398c:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
 8013990:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
 8013994:	bf00      	nop
 8013996:	eb42 0202 	adc.w	r2, r2, r2
 801399a:	bf28      	it	cs
 801399c:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
 80139a0:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
 80139a4:	bf00      	nop
 80139a6:	eb42 0202 	adc.w	r2, r2, r2
 80139aa:	bf28      	it	cs
 80139ac:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
 80139b0:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
 80139b4:	bf00      	nop
 80139b6:	eb42 0202 	adc.w	r2, r2, r2
 80139ba:	bf28      	it	cs
 80139bc:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
 80139c0:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
 80139c4:	bf00      	nop
 80139c6:	eb42 0202 	adc.w	r2, r2, r2
 80139ca:	bf28      	it	cs
 80139cc:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
 80139d0:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
 80139d4:	bf00      	nop
 80139d6:	eb42 0202 	adc.w	r2, r2, r2
 80139da:	bf28      	it	cs
 80139dc:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
 80139e0:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
 80139e4:	bf00      	nop
 80139e6:	eb42 0202 	adc.w	r2, r2, r2
 80139ea:	bf28      	it	cs
 80139ec:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
 80139f0:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
 80139f4:	bf00      	nop
 80139f6:	eb42 0202 	adc.w	r2, r2, r2
 80139fa:	bf28      	it	cs
 80139fc:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
 8013a00:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
 8013a04:	bf00      	nop
 8013a06:	eb42 0202 	adc.w	r2, r2, r2
 8013a0a:	bf28      	it	cs
 8013a0c:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
 8013a10:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
 8013a14:	bf00      	nop
 8013a16:	eb42 0202 	adc.w	r2, r2, r2
 8013a1a:	bf28      	it	cs
 8013a1c:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
 8013a20:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
 8013a24:	bf00      	nop
 8013a26:	eb42 0202 	adc.w	r2, r2, r2
 8013a2a:	bf28      	it	cs
 8013a2c:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
 8013a30:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
 8013a34:	bf00      	nop
 8013a36:	eb42 0202 	adc.w	r2, r2, r2
 8013a3a:	bf28      	it	cs
 8013a3c:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
 8013a40:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
 8013a44:	bf00      	nop
 8013a46:	eb42 0202 	adc.w	r2, r2, r2
 8013a4a:	bf28      	it	cs
 8013a4c:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
 8013a50:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
 8013a54:	bf00      	nop
 8013a56:	eb42 0202 	adc.w	r2, r2, r2
 8013a5a:	bf28      	it	cs
 8013a5c:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
 8013a60:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
 8013a64:	bf00      	nop
 8013a66:	eb42 0202 	adc.w	r2, r2, r2
 8013a6a:	bf28      	it	cs
 8013a6c:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
 8013a70:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
 8013a74:	bf00      	nop
 8013a76:	eb42 0202 	adc.w	r2, r2, r2
 8013a7a:	bf28      	it	cs
 8013a7c:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
 8013a80:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
 8013a84:	bf00      	nop
 8013a86:	eb42 0202 	adc.w	r2, r2, r2
 8013a8a:	bf28      	it	cs
 8013a8c:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
 8013a90:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
 8013a94:	bf00      	nop
 8013a96:	eb42 0202 	adc.w	r2, r2, r2
 8013a9a:	bf28      	it	cs
 8013a9c:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
 8013aa0:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
 8013aa4:	bf00      	nop
 8013aa6:	eb42 0202 	adc.w	r2, r2, r2
 8013aaa:	bf28      	it	cs
 8013aac:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
 8013ab0:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
 8013ab4:	bf00      	nop
 8013ab6:	eb42 0202 	adc.w	r2, r2, r2
 8013aba:	bf28      	it	cs
 8013abc:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
 8013ac0:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
 8013ac4:	bf00      	nop
 8013ac6:	eb42 0202 	adc.w	r2, r2, r2
 8013aca:	bf28      	it	cs
 8013acc:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
 8013ad0:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
 8013ad4:	bf00      	nop
 8013ad6:	eb42 0202 	adc.w	r2, r2, r2
 8013ada:	bf28      	it	cs
 8013adc:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
 8013ae0:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
 8013ae4:	bf00      	nop
 8013ae6:	eb42 0202 	adc.w	r2, r2, r2
 8013aea:	bf28      	it	cs
 8013aec:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
 8013af0:	ebb0 0f01 	cmp.w	r0, r1
 8013af4:	bf00      	nop
 8013af6:	eb42 0202 	adc.w	r2, r2, r2
 8013afa:	bf28      	it	cs
 8013afc:	eba0 0001 	subcs.w	r0, r0, r1
 8013b00:	4610      	mov	r0, r2
 8013b02:	4770      	bx	lr
 8013b04:	bf0c      	ite	eq
 8013b06:	2001      	moveq	r0, #1
 8013b08:	2000      	movne	r0, #0
 8013b0a:	4770      	bx	lr
 8013b0c:	fab1 f281 	clz	r2, r1
 8013b10:	f1c2 021f 	rsb	r2, r2, #31
 8013b14:	fa20 f002 	lsr.w	r0, r0, r2
 8013b18:	4770      	bx	lr
 8013b1a:	b108      	cbz	r0, 8013b20 <__aeabi_uidiv+0x258>
 8013b1c:	f04f 30ff 	mov.w	r0, #4294967295
 8013b20:	f000 b80e 	b.w	8013b40 <__aeabi_idiv0>

08013b24 <__aeabi_uidivmod>:
 8013b24:	2900      	cmp	r1, #0
 8013b26:	d0f8      	beq.n	8013b1a <__aeabi_uidiv+0x252>
 8013b28:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
 8013b2c:	f7ff fecc 	bl	80138c8 <__aeabi_uidiv>
 8013b30:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
 8013b34:	fb02 f300 	mul.w	r3, r2, r0
 8013b38:	eba1 0103 	sub.w	r1, r1, r3
 8013b3c:	4770      	bx	lr
 8013b3e:	bf00      	nop

08013b40 <__aeabi_idiv0>:
 8013b40:	4770      	bx	lr
 8013b42:	bf00      	nop

08013b44 <Reset_Handler>:
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8013b44:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8013b46:	f000 b804 	b.w	8013b52 <LoopCopyDataInit>

08013b4a <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8013b4a:	4b0d      	ldr	r3, [pc, #52]	; (8013b80 <LoopFillZerobss+0x16>)
	ldr	r3, [r3, r1]
 8013b4c:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8013b4e:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8013b50:	3104      	adds	r1, #4

08013b52 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 8013b52:	480c      	ldr	r0, [pc, #48]	; (8013b84 <LoopFillZerobss+0x1a>)
	ldr	r3, =_edata
 8013b54:	4b0c      	ldr	r3, [pc, #48]	; (8013b88 <LoopFillZerobss+0x1e>)
	adds	r2, r0, r1
 8013b56:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8013b58:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8013b5a:	f4ff aff6 	bcc.w	8013b4a <CopyDataInit>
	ldr	r2, =_sbss
 8013b5e:	4a0b      	ldr	r2, [pc, #44]	; (8013b8c <LoopFillZerobss+0x22>)
	b	LoopFillZerobss
 8013b60:	f000 b803 	b.w	8013b6a <LoopFillZerobss>

08013b64 <FillZerobss>:

/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 8013b64:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8013b66:	f842 3b04 	str.w	r3, [r2], #4

08013b6a <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8013b6a:	4b09      	ldr	r3, [pc, #36]	; (8013b90 <LoopFillZerobss+0x26>)
	cmp	r2, r3
 8013b6c:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8013b6e:	f4ff aff9 	bcc.w	8013b64 <FillZerobss>

/* Call the clock system intitialization function.*/
  	bl  SystemInit
 8013b72:	f7ef fcef 	bl	8003554 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8013b76:	f7fd fdd9 	bl	801172c <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8013b7a:	f000 f814 	bl	8013ba6 <main>
	bx	lr
 8013b7e:	4770      	bx	lr
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
 8013b80:	08021c80 	.word	0x08021c80
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
 8013b84:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8013b88:	20000900 	.word	0x20000900
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
 8013b8c:	20000908 	.word	0x20000908
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
 8013b90:	2000361c 	.word	0x2000361c

08013b94 <ADC1_2_IRQHandler>:
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
//	b	Infinite_Loop
	TST LR, #4
 8013b94:	f01e 0f04 	tst.w	lr, #4
  	ITE EQ
 8013b98:	bf0c      	ite	eq
  	MRSEQ R0, MSP
 8013b9a:	f3ef 8008 	mrseq	r0, MSP
  	MRSNE R0, PSP
 8013b9e:	f3ef 8009 	mrsne	r0, PSP
  	b Default_Handler_c
 8013ba2:	f7f5 bd79 	b.w	8009698 <Default_Handler_c>

08013ba6 <main>:

#endif
}

int main(void)
{
 8013ba6:	b510      	push	{r4, lr}
		APPSTATE_TESTMENU,
		APPSTATE_USBHOST
	} AppState;
	AppState appState = APPSTATE_FF_TERM;
#endif
	setup();
 8013ba8:	f7f5 fd32 	bl	8009610 <setup>
	typedef enum {
		APPSTATE_FF_TERM,
		APPSTATE_TESTMENU,
		APPSTATE_USBHOST
	} AppState;
	AppState appState = APPSTATE_FF_TERM;
 8013bac:	2400      	movs	r4, #0
	for(;;) {
#ifdef USE_UHS20

		//libuhs_task();

		delay_ms(20);	//delay(10);
 8013bae:	2014      	movs	r0, #20
 8013bb0:	f7f4 faf4 	bl	800819c <delay_ms>
		printf("\ntime:%d", millis());
#endif

#ifdef USE_SDCARD

		switch ( appState ) {
 8013bb4:	2c00      	cmp	r4, #0
 8013bb6:	d1fa      	bne.n	8013bae <main+0x8>
		case APPSTATE_FF_TERM:
			/* ff_test_term is not reentrant, blocks until exit */
			if ( !ff_test_term() ) {
 8013bb8:	f7f4 ff38 	bl	8008a2c <ff_test_term>
				appState = APPSTATE_TESTMENU;
 8013bbc:	f1d0 0401 	rsbs	r4, r0, #1
 8013bc0:	bf38      	it	cc
 8013bc2:	2400      	movcc	r4, #0
 8013bc4:	e7f3      	b.n	8013bae <main+0x8>
	...

08013bc8 <register_usb_kernel_callback>:
LibuhsUsbHostCallbacks *usbhost_cb;
LibuhsSystemCallbacks *system_cb;
LibuhsUsbClassCallbacks *class_cb;

unsigned char register_usb_kernel_callback(LibuhsUsbHostCallbacks *callbacks, void *callback_context)
{
 8013bc8:	b480      	push	{r7}
 8013bca:	b085      	sub	sp, #20
 8013bcc:	af00      	add	r7, sp, #0
 8013bce:	6078      	str	r0, [r7, #4]
 8013bd0:	6039      	str	r1, [r7, #0]
	uint32_t *cb = (uint32_t *)callbacks;
 8013bd2:	687b      	ldr	r3, [r7, #4]
 8013bd4:	60fb      	str	r3, [r7, #12]
	for(int i = 0; i < sizeof(LibuhsUsbHostCallbacks) / sizeof(unsigned int); i++, cb++)
 8013bd6:	f04f 0300 	mov.w	r3, #0
 8013bda:	60bb      	str	r3, [r7, #8]
 8013bdc:	e00d      	b.n	8013bfa <register_usb_kernel_callback+0x32>
	{
		if(cb == 0) return eLibuhsErrorInvalidParam;
 8013bde:	68fb      	ldr	r3, [r7, #12]
 8013be0:	2b00      	cmp	r3, #0
 8013be2:	d102      	bne.n	8013bea <register_usb_kernel_callback+0x22>
 8013be4:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8013be8:	e012      	b.n	8013c10 <register_usb_kernel_callback+0x48>
LibuhsUsbClassCallbacks *class_cb;

unsigned char register_usb_kernel_callback(LibuhsUsbHostCallbacks *callbacks, void *callback_context)
{
	uint32_t *cb = (uint32_t *)callbacks;
	for(int i = 0; i < sizeof(LibuhsUsbHostCallbacks) / sizeof(unsigned int); i++, cb++)
 8013bea:	68bb      	ldr	r3, [r7, #8]
 8013bec:	f103 0301 	add.w	r3, r3, #1
 8013bf0:	60bb      	str	r3, [r7, #8]
 8013bf2:	68fb      	ldr	r3, [r7, #12]
 8013bf4:	f103 0304 	add.w	r3, r3, #4
 8013bf8:	60fb      	str	r3, [r7, #12]
 8013bfa:	68bb      	ldr	r3, [r7, #8]
 8013bfc:	2b12      	cmp	r3, #18
 8013bfe:	d9ee      	bls.n	8013bde <register_usb_kernel_callback+0x16>
	{
		if(cb == 0) return eLibuhsErrorInvalidParam;
	}
	usbhost_cb = callbacks;
 8013c00:	f243 6310 	movw	r3, #13840	; 0x3610
 8013c04:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013c08:	687a      	ldr	r2, [r7, #4]
 8013c0a:	601a      	str	r2, [r3, #0]
	return eLibuhsSuccess;
 8013c0c:	f04f 0300 	mov.w	r3, #0
}
 8013c10:	4618      	mov	r0, r3
 8013c12:	f107 0714 	add.w	r7, r7, #20
 8013c16:	46bd      	mov	sp, r7
 8013c18:	bc80      	pop	{r7}
 8013c1a:	4770      	bx	lr

08013c1c <register_system_callback>:

unsigned char register_system_callback(LibuhsSystemCallbacks *callbacks, void *callback_context)
{
 8013c1c:	b480      	push	{r7}
 8013c1e:	b085      	sub	sp, #20
 8013c20:	af00      	add	r7, sp, #0
 8013c22:	6078      	str	r0, [r7, #4]
 8013c24:	6039      	str	r1, [r7, #0]
	uint32_t *cb = (uint32_t *)callbacks;
 8013c26:	687b      	ldr	r3, [r7, #4]
 8013c28:	60fb      	str	r3, [r7, #12]
	for(int i = 0; i < sizeof(LibuhsSystemCallbacks) / sizeof(unsigned int); i++, cb++)
 8013c2a:	f04f 0300 	mov.w	r3, #0
 8013c2e:	60bb      	str	r3, [r7, #8]
 8013c30:	e00d      	b.n	8013c4e <register_system_callback+0x32>
	{
		if(cb == 0) return eLibuhsErrorInvalidParam;
 8013c32:	68fb      	ldr	r3, [r7, #12]
 8013c34:	2b00      	cmp	r3, #0
 8013c36:	d102      	bne.n	8013c3e <register_system_callback+0x22>
 8013c38:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8013c3c:	e012      	b.n	8013c64 <register_system_callback+0x48>
}

unsigned char register_system_callback(LibuhsSystemCallbacks *callbacks, void *callback_context)
{
	uint32_t *cb = (uint32_t *)callbacks;
	for(int i = 0; i < sizeof(LibuhsSystemCallbacks) / sizeof(unsigned int); i++, cb++)
 8013c3e:	68bb      	ldr	r3, [r7, #8]
 8013c40:	f103 0301 	add.w	r3, r3, #1
 8013c44:	60bb      	str	r3, [r7, #8]
 8013c46:	68fb      	ldr	r3, [r7, #12]
 8013c48:	f103 0304 	add.w	r3, r3, #4
 8013c4c:	60fb      	str	r3, [r7, #12]
 8013c4e:	68bb      	ldr	r3, [r7, #8]
 8013c50:	2b04      	cmp	r3, #4
 8013c52:	d9ee      	bls.n	8013c32 <register_system_callback+0x16>
	{
		if(cb == 0) return eLibuhsErrorInvalidParam;
	}
	system_cb = callbacks;
 8013c54:	f243 630c 	movw	r3, #13836	; 0x360c
 8013c58:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013c5c:	687a      	ldr	r2, [r7, #4]
 8013c5e:	601a      	str	r2, [r3, #0]
	return eLibuhsSuccess;
 8013c60:	f04f 0300 	mov.w	r3, #0
}
 8013c64:	4618      	mov	r0, r3
 8013c66:	f107 0714 	add.w	r7, r7, #20
 8013c6a:	46bd      	mov	sp, r7
 8013c6c:	bc80      	pop	{r7}
 8013c6e:	4770      	bx	lr

08013c70 <register_usb_class_callback>:

unsigned char register_usb_class_callback(LibuhsUsbClassCallbacks *callbacks, void *callback_context)
{
 8013c70:	b480      	push	{r7}
 8013c72:	b085      	sub	sp, #20
 8013c74:	af00      	add	r7, sp, #0
 8013c76:	6078      	str	r0, [r7, #4]
 8013c78:	6039      	str	r1, [r7, #0]
	uint32_t *cb = (uint32_t *)callbacks;
 8013c7a:	687b      	ldr	r3, [r7, #4]
 8013c7c:	60fb      	str	r3, [r7, #12]
	for(int i = 0; i < sizeof(LibuhsUsbClassCallbacks) / sizeof(unsigned int); i++, cb++)
 8013c7e:	f04f 0300 	mov.w	r3, #0
 8013c82:	60bb      	str	r3, [r7, #8]
 8013c84:	e00d      	b.n	8013ca2 <register_usb_class_callback+0x32>
	{
		if(cb == 0) return eLibuhsErrorInvalidParam;
 8013c86:	68fb      	ldr	r3, [r7, #12]
 8013c88:	2b00      	cmp	r3, #0
 8013c8a:	d102      	bne.n	8013c92 <register_usb_class_callback+0x22>
 8013c8c:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8013c90:	e012      	b.n	8013cb8 <register_usb_class_callback+0x48>
}

unsigned char register_usb_class_callback(LibuhsUsbClassCallbacks *callbacks, void *callback_context)
{
	uint32_t *cb = (uint32_t *)callbacks;
	for(int i = 0; i < sizeof(LibuhsUsbClassCallbacks) / sizeof(unsigned int); i++, cb++)
 8013c92:	68bb      	ldr	r3, [r7, #8]
 8013c94:	f103 0301 	add.w	r3, r3, #1
 8013c98:	60bb      	str	r3, [r7, #8]
 8013c9a:	68fb      	ldr	r3, [r7, #12]
 8013c9c:	f103 0304 	add.w	r3, r3, #4
 8013ca0:	60fb      	str	r3, [r7, #12]
 8013ca2:	68bb      	ldr	r3, [r7, #8]
 8013ca4:	2b01      	cmp	r3, #1
 8013ca6:	d9ee      	bls.n	8013c86 <register_usb_class_callback+0x16>
	{
		if(cb == 0) return eLibuhsErrorInvalidParam;
	}
	class_cb = callbacks;
 8013ca8:	f243 6314 	movw	r3, #13844	; 0x3614
 8013cac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013cb0:	687a      	ldr	r2, [r7, #4]
 8013cb2:	601a      	str	r2, [r3, #0]
	return eLibuhsSuccess;
 8013cb4:	f04f 0300 	mov.w	r3, #0
}
 8013cb8:	4618      	mov	r0, r3
 8013cba:	f107 0714 	add.w	r7, r7, #20
 8013cbe:	46bd      	mov	sp, r7
 8013cc0:	bc80      	pop	{r7}
 8013cc2:	4770      	bx	lr

08013cc4 <libuhs_kernel_init>:
extern void cdc_check_state(uint8_t state);
extern void msc_check_state(uint8_t state, uint8_t drive);
extern void printer_check_state(uint8_t state);

int libuhs_kernel_init(void)
{
 8013cc4:	b580      	push	{r7, lr}
 8013cc6:	af00      	add	r7, sp, #0
	return Usb.Init();
 8013cc8:	f640 3084 	movw	r0, #2948	; 0xb84
 8013ccc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8013cd0:	f000 f862 	bl	8013d98 <_ZN7STM32F2I1a1bE4InitEv>
 8013cd4:	4603      	mov	r3, r0
 8013cd6:	b2db      	uxtb	r3, r3
 8013cd8:	b25b      	sxtb	r3, r3
}
 8013cda:	4618      	mov	r0, r3
 8013cdc:	bd80      	pop	{r7, pc}
 8013cde:	bf00      	nop

08013ce0 <libuhs_class_hub_init>:

void libuhs_class_hub_init(void)
{
 8013ce0:	b598      	push	{r3, r4, r7, lr}
 8013ce2:	af00      	add	r7, sp, #0
	/* --- Hub class --- */
	mpHub = new USBHub(&Usb);
 8013ce4:	f04f 001c 	mov.w	r0, #28
 8013ce8:	f009 fafa 	bl	801d2e0 <_Znwj>
 8013cec:	4603      	mov	r3, r0
 8013cee:	461c      	mov	r4, r3
 8013cf0:	4620      	mov	r0, r4
 8013cf2:	f640 3184 	movw	r1, #2948	; 0xb84
 8013cf6:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8013cfa:	f005 fecf 	bl	8019a9c <_ZN6USBHubC1EP3USB>
 8013cfe:	f640 4344 	movw	r3, #3140	; 0xc44
 8013d02:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013d06:	601c      	str	r4, [r3, #0]
 8013d08:	e004      	b.n	8013d14 <libuhs_class_hub_init+0x34>
 8013d0a:	4620      	mov	r0, r4
 8013d0c:	f008 feb4 	bl	801ca78 <_ZdlPv>
 8013d10:	f008 feb6 	bl	801ca80 <__cxa_end_cleanup>
}
 8013d14:	bd98      	pop	{r3, r4, r7, pc}
 8013d16:	bf00      	nop

08013d18 <libuhs_task>:

/*
 * @brief	: This is a blocking task and never return
 */
void libuhs_task(void)
{
 8013d18:	b580      	push	{r7, lr}
 8013d1a:	b082      	sub	sp, #8
 8013d1c:	af00      	add	r7, sp, #0
	//for(;;)
	{
		Usb.Task();
 8013d1e:	f640 3084 	movw	r0, #2948	; 0xb84
 8013d22:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8013d26:	f001 f987 	bl	8015038 <_ZN3USB4TaskEv>

		for(int i = 0; i < FS_MAX_USB_MS_DRIVERS; i++)
 8013d2a:	f04f 0300 	mov.w	r3, #0
 8013d2e:	607b      	str	r3, [r7, #4]
 8013d30:	e011      	b.n	8013d56 <libuhs_task+0x3e>
			msc_check_state(Usb.getUsbTaskState(), i);
 8013d32:	f640 3084 	movw	r0, #2948	; 0xb84
 8013d36:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8013d3a:	f000 fbc7 	bl	80144cc <_ZN3USB15getUsbTaskStateEv>
 8013d3e:	4603      	mov	r3, r0
 8013d40:	461a      	mov	r2, r3
 8013d42:	687b      	ldr	r3, [r7, #4]
 8013d44:	b2db      	uxtb	r3, r3
 8013d46:	4610      	mov	r0, r2
 8013d48:	4619      	mov	r1, r3
 8013d4a:	f000 f8e9 	bl	8013f20 <_Z15msc_check_statehh>
{
	//for(;;)
	{
		Usb.Task();

		for(int i = 0; i < FS_MAX_USB_MS_DRIVERS; i++)
 8013d4e:	687b      	ldr	r3, [r7, #4]
 8013d50:	f103 0301 	add.w	r3, r3, #1
 8013d54:	607b      	str	r3, [r7, #4]
 8013d56:	687b      	ldr	r3, [r7, #4]
 8013d58:	2b00      	cmp	r3, #0
 8013d5a:	bfcc      	ite	gt
 8013d5c:	2300      	movgt	r3, #0
 8013d5e:	2301      	movle	r3, #1
 8013d60:	b2db      	uxtb	r3, r3
 8013d62:	2b00      	cmp	r3, #0
 8013d64:	d1e5      	bne.n	8013d32 <libuhs_task+0x1a>
			msc_check_state(Usb.getUsbTaskState(), i);

		printer_check_state(Usb.getUsbTaskState());
 8013d66:	f640 3084 	movw	r0, #2948	; 0xb84
 8013d6a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8013d6e:	f000 fbad 	bl	80144cc <_ZN3USB15getUsbTaskStateEv>
 8013d72:	4603      	mov	r3, r0
 8013d74:	4618      	mov	r0, r3
 8013d76:	f000 fa9d 	bl	80142b4 <_Z19printer_check_stateh>

		cdc_check_state(Usb.getUsbTaskState());
 8013d7a:	f640 3084 	movw	r0, #2948	; 0xb84
 8013d7e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8013d82:	f000 fba3 	bl	80144cc <_ZN3USB15getUsbTaskStateEv>
 8013d86:	4603      	mov	r3, r0
 8013d88:	4618      	mov	r0, r3
 8013d8a:	f007 fc1d 	bl	801b5c8 <_Z15cdc_check_stateh>

		//system_cb->delay_milli_second_cb(20);
	}
}
 8013d8e:	f107 0708 	add.w	r7, r7, #8
 8013d92:	46bd      	mov	sp, r7
 8013d94:	bd80      	pop	{r7, pc}
 8013d96:	bf00      	nop

08013d98 <_ZN7STM32F2I1a1bE4InitEv>:
}

/* initialize STM32F2. Set Host mode, pullups, and stuff. Returns 0 if success, -1 if not */
// it seems we have already done this init function in HCD_Init in USB::STM32F2
template< typename SS, typename INTR >
int8_t STM32F2< SS, INTR >::Init() {
 8013d98:	b580      	push	{r7, lr}
 8013d9a:	b082      	sub	sp, #8
 8013d9c:	af00      	add	r7, sp, #0
 8013d9e:	6078      	str	r0, [r7, #4]
	if(reset() == 0) { //OSCOKIRQ hasn't asserted in time
 8013da0:	6878      	ldr	r0, [r7, #4]
 8013da2:	f000 f817 	bl	8013dd4 <_ZN7STM32F2I1a1bE5resetEv>
 8013da6:	4603      	mov	r3, r0
 8013da8:	2b00      	cmp	r3, #0
 8013daa:	bf14      	ite	ne
 8013dac:	2300      	movne	r3, #0
 8013dae:	2301      	moveq	r3, #1
 8013db0:	b2db      	uxtb	r3, r3
 8013db2:	2b00      	cmp	r3, #0
 8013db4:	d002      	beq.n	8013dbc <_ZN7STM32F2I1a1bE4InitEv+0x24>
		return( -1);
 8013db6:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8013dba:	e004      	b.n	8013dc6 <_ZN7STM32F2I1a1bE4InitEv+0x2e>

	// check if device is connected
	//regWr(rHCTL, bmSAMPLEBUS); // sample USB bus
	//while(!(regRd(rHCTL) & bmSAMPLEBUS)); //wait for sample operation to finish

	busprobe(); //check if anything is connected
 8013dbc:	6878      	ldr	r0, [r7, #4]
 8013dbe:	f000 f815 	bl	8013dec <_ZN7STM32F2I1a1bE8busprobeEv>

	//regWr(rHIRQ, bmCONDETIRQ); //clear connection detect interrupt
	//regWr(rCPUCTL, 0x01); //enable interrupt pin

	return( 0);
 8013dc2:	f04f 0300 	mov.w	r3, #0
 8013dc6:	b25b      	sxtb	r3, r3
}
 8013dc8:	4618      	mov	r0, r3
 8013dca:	f107 0708 	add.w	r7, r7, #8
 8013dce:	46bd      	mov	sp, r7
 8013dd0:	bd80      	pop	{r7, pc}
 8013dd2:	bf00      	nop

08013dd4 <_ZN7STM32F2I1a1bE5resetEv>:


/* reset ???. Returns number of cycles it took for PLL to stabilize after reset
  or zero if PLL haven't stabilized in 65535 cycles */
template< typename SS, typename INTR >
uint16_t STM32F2< SS, INTR >::reset() {
 8013dd4:	b480      	push	{r7}
 8013dd6:	b083      	sub	sp, #12
 8013dd8:	af00      	add	r7, sp, #0
 8013dda:	6078      	str	r0, [r7, #4]
//                        break;
//                }
//        }
//        return( i);
	// reset usb phy? is that necessary? just keep the code (above) here...
	return 1;
 8013ddc:	f04f 0301 	mov.w	r3, #1
}
 8013de0:	4618      	mov	r0, r3
 8013de2:	f107 070c 	add.w	r7, r7, #12
 8013de6:	46bd      	mov	sp, r7
 8013de8:	bc80      	pop	{r7}
 8013dea:	4770      	bx	lr

08013dec <_ZN7STM32F2I1a1bE8busprobeEv>:
}

/* probe bus to determine device presence and speed and switch host to this speed */
// currently, I haven't make any host switching here.
template< typename SS, typename INTR >
void STM32F2< SS, INTR >::busprobe() {
 8013dec:	b580      	push	{r7, lr}
 8013dee:	b084      	sub	sp, #16
 8013df0:	af00      	add	r7, sp, #0
 8013df2:	6078      	str	r0, [r7, #4]
	uint32_t bus_sample;    //uint8_t bus_sample;

	if(usbhost_cb->is_attached_cb()) {	// pdev->host.ConnSts) {
 8013df4:	f243 6310 	movw	r3, #13840	; 0x3610
 8013df8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013dfc:	681b      	ldr	r3, [r3, #0]
 8013dfe:	685b      	ldr	r3, [r3, #4]
 8013e00:	4798      	blx	r3
 8013e02:	4603      	mov	r3, r0
 8013e04:	2b00      	cmp	r3, #0
 8013e06:	bf0c      	ite	eq
 8013e08:	2300      	moveq	r3, #0
 8013e0a:	2301      	movne	r3, #1
 8013e0c:	b2db      	uxtb	r3, r3
 8013e0e:	2b00      	cmp	r3, #0
 8013e10:	d009      	beq.n	8013e26 <_ZN7STM32F2I1a1bE8busprobeEv+0x3a>
		bus_sample = usbhost_cb->get_speed_mode_cb();	//hprt0.b.prtspd;
 8013e12:	f243 6310 	movw	r3, #13840	; 0x3610
 8013e16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013e1a:	681b      	ldr	r3, [r3, #0]
 8013e1c:	691b      	ldr	r3, [r3, #16]
 8013e1e:	4798      	blx	r3
 8013e20:	4603      	mov	r3, r0
 8013e22:	60fb      	str	r3, [r7, #12]
 8013e24:	e002      	b.n	8013e2c <_ZN7STM32F2I1a1bE8busprobeEv+0x40>
	} else {
		bus_sample = bmSE0;
 8013e26:	f04f 03f0 	mov.w	r3, #240	; 0xf0
 8013e2a:	60fb      	str	r3, [r7, #12]
	}
    //bus_sample = regRd(rHRSL); //Get J,K status STM32F2: J/K means Pos/Neg for D+/D-
    //bus_sample &= (bmJSTATUS | bmKSTATUS); //zero the rest of the byte
	// ok, I haven't found any information about D+/D- alternation detect.
	// so, here we assume the correct d+/d- are connected.
	switch(bus_sample) { //start full-speed or low-speed host
 8013e2c:	68fb      	ldr	r3, [r7, #12]
 8013e2e:	2b02      	cmp	r3, #2
 8013e30:	d00b      	beq.n	8013e4a <_ZN7STM32F2I1a1bE8busprobeEv+0x5e>
 8013e32:	2bf0      	cmp	r3, #240	; 0xf0
 8013e34:	d011      	beq.n	8013e5a <_ZN7STM32F2I1a1bE8busprobeEv+0x6e>
 8013e36:	2b01      	cmp	r3, #1
 8013e38:	d117      	bne.n	8013e6a <_ZN7STM32F2I1a1bE8busprobeEv+0x7e>
		case(bmFULLSPEED):
			vbusState = FSHOST;
 8013e3a:	f640 4348 	movw	r3, #3144	; 0xc48
 8013e3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013e42:	f04f 0202 	mov.w	r2, #2
 8013e46:	701a      	strb	r2, [r3, #0]
			break;
 8013e48:	e016      	b.n	8013e78 <_ZN7STM32F2I1a1bE8busprobeEv+0x8c>
		case(bmLOWSPEED):
			vbusState = LSHOST;
 8013e4a:	f640 4348 	movw	r3, #3144	; 0xc48
 8013e4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013e52:	f04f 0203 	mov.w	r2, #3
 8013e56:	701a      	strb	r2, [r3, #0]
			break;
 8013e58:	e00e      	b.n	8013e78 <_ZN7STM32F2I1a1bE8busprobeEv+0x8c>
				vbusState = SE1;
				break; */
		case( bmSE0): //disconnected state
			//	regWr(rMODE, bmDPPULLDN | bmDMPULLDN | bmHOST | bmSEPIRQ);
			// we should already tidy up in disconnected isr.
			vbusState = SE0;
 8013e5a:	f640 4348 	movw	r3, #3144	; 0xc48
 8013e5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013e62:	f04f 0200 	mov.w	r2, #0
 8013e66:	701a      	strb	r2, [r3, #0]
			break;
 8013e68:	e006      	b.n	8013e78 <_ZN7STM32F2I1a1bE8busprobeEv+0x8c>
		default:
			vbusState = SE1;
 8013e6a:	f640 4348 	movw	r3, #3144	; 0xc48
 8013e6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013e72:	f04f 0201 	mov.w	r2, #1
 8013e76:	701a      	strb	r2, [r3, #0]

	}//end switch( bus_sample )

}
 8013e78:	f107 0710 	add.w	r7, r7, #16
 8013e7c:	46bd      	mov	sp, r7
 8013e7e:	bd80      	pop	{r7, pc}

08013e80 <_Z41__static_initialization_and_destruction_0ii>:
 8013e80:	b580      	push	{r7, lr}
 8013e82:	b082      	sub	sp, #8
 8013e84:	af00      	add	r7, sp, #0
 8013e86:	6078      	str	r0, [r7, #4]
 8013e88:	6039      	str	r1, [r7, #0]
 8013e8a:	687b      	ldr	r3, [r7, #4]
 8013e8c:	2b01      	cmp	r3, #1
 8013e8e:	d10a      	bne.n	8013ea6 <_Z41__static_initialization_and_destruction_0ii+0x26>
 8013e90:	683a      	ldr	r2, [r7, #0]
 8013e92:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8013e96:	429a      	cmp	r2, r3
 8013e98:	d105      	bne.n	8013ea6 <_Z41__static_initialization_and_destruction_0ii+0x26>
 *      Author: Hz
 */

#include "usbhost/usbhub.h"

USB Usb;
 8013e9a:	f640 3084 	movw	r0, #2948	; 0xb84
 8013e9e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8013ea2:	f000 fac5 	bl	8014430 <_ZN3USBC1Ev>

		cdc_check_state(Usb.getUsbTaskState());

		//system_cb->delay_milli_second_cb(20);
	}
}
 8013ea6:	f107 0708 	add.w	r7, r7, #8
 8013eaa:	46bd      	mov	sp, r7
 8013eac:	bd80      	pop	{r7, pc}
 8013eae:	bf00      	nop

08013eb0 <_GLOBAL__sub_I_Usb>:
 8013eb0:	b580      	push	{r7, lr}
 8013eb2:	af00      	add	r7, sp, #0
 8013eb4:	f04f 0001 	mov.w	r0, #1
 8013eb8:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8013ebc:	f7ff ffe0 	bl	8013e80 <_Z41__static_initialization_and_destruction_0ii>
 8013ec0:	bd80      	pop	{r7, pc}
 8013ec2:	bf00      	nop

08013ec4 <_ZN8BulkOnly10GetbMaxLUNEv>:

        uint8_t GetLastUsbError() {
                return bLastUsbError;
        };

        uint8_t GetbMaxLUN() {
 8013ec4:	b480      	push	{r7}
 8013ec6:	b083      	sub	sp, #12
 8013ec8:	af00      	add	r7, sp, #0
 8013eca:	6078      	str	r0, [r7, #4]
                return bMaxLUN; // Max LUN
 8013ecc:	687b      	ldr	r3, [r7, #4]
 8013ece:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
        }
 8013ed2:	4618      	mov	r0, r3
 8013ed4:	f107 070c 	add.w	r7, r7, #12
 8013ed8:	46bd      	mov	sp, r7
 8013eda:	bc80      	pop	{r7}
 8013edc:	4770      	bx	lr
 8013ede:	bf00      	nop

08013ee0 <_ZN8BulkOnly14DisablePollingEv>:
        virtual uint8_t Init(uint8_t parent, uint8_t port, bool lowspeed);
        virtual uint8_t ConfigureDevice(uint8_t parent, uint8_t port, bool lowspeed);

        virtual uint8_t Release();
        virtual uint8_t Poll();
        void DisablePolling() {
 8013ee0:	b480      	push	{r7}
 8013ee2:	b083      	sub	sp, #12
 8013ee4:	af00      	add	r7, sp, #0
 8013ee6:	6078      	str	r0, [r7, #4]
        	//bPollEnable = false;
        	pUsb->bGlobalPollEnable = false;
 8013ee8:	687b      	ldr	r3, [r7, #4]
 8013eea:	689b      	ldr	r3, [r3, #8]
 8013eec:	f04f 0200 	mov.w	r2, #0
 8013ef0:	f883 20bd 	strb.w	r2, [r3, #189]	; 0xbd
        };
 8013ef4:	f107 070c 	add.w	r7, r7, #12
 8013ef8:	46bd      	mov	sp, r7
 8013efa:	bc80      	pop	{r7}
 8013efc:	4770      	bx	lr
 8013efe:	bf00      	nop

08013f00 <_ZN8BulkOnly13EnablePollingEv>:
        void EnablePolling() {
 8013f00:	b480      	push	{r7}
 8013f02:	b083      	sub	sp, #12
 8013f04:	af00      	add	r7, sp, #0
 8013f06:	6078      	str	r0, [r7, #4]
        	//bPollEnable = true;
        	pUsb->bGlobalPollEnable = true;
 8013f08:	687b      	ldr	r3, [r7, #4]
 8013f0a:	689b      	ldr	r3, [r3, #8]
 8013f0c:	f04f 0201 	mov.w	r2, #1
 8013f10:	f883 20bd 	strb.w	r2, [r3, #189]	; 0xbd
        };
 8013f14:	f107 070c 	add.w	r7, r7, #12
 8013f18:	46bd      	mov	sp, r7
 8013f1a:	bc80      	pop	{r7}
 8013f1c:	4770      	bx	lr
 8013f1e:	bf00      	nop

08013f20 <_Z15msc_check_statehh>:
BulkOnly *Bulk[FS_MAX_USB_MS_DRIVERS] = {NULL};

static uint8_t isOnline[FS_MAX_USB_MS_DRIVERS] = {0};

void msc_check_state(uint8_t state, uint8_t drive)
{
 8013f20:	b580      	push	{r7, lr}
 8013f22:	b082      	sub	sp, #8
 8013f24:	af00      	add	r7, sp, #0
 8013f26:	4602      	mov	r2, r0
 8013f28:	460b      	mov	r3, r1
 8013f2a:	71fa      	strb	r2, [r7, #7]
 8013f2c:	71bb      	strb	r3, [r7, #6]
	static uint8_t current_state = 1;
	static uint8_t last_state = 0;

	current_state = state;
 8013f2e:	f640 03f0 	movw	r3, #2288	; 0x8f0
 8013f32:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013f36:	79fa      	ldrb	r2, [r7, #7]
 8013f38:	701a      	strb	r2, [r3, #0]
	if(current_state != last_state)
 8013f3a:	f640 03f0 	movw	r3, #2288	; 0x8f0
 8013f3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013f42:	781a      	ldrb	r2, [r3, #0]
 8013f44:	f640 4354 	movw	r3, #3156	; 0xc54
 8013f48:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013f4c:	781b      	ldrb	r3, [r3, #0]
 8013f4e:	429a      	cmp	r2, r3
 8013f50:	d018      	beq.n	8013f84 <_Z15msc_check_statehh+0x64>
	{
		if(current_state == USB_STATE_DETACHED)
 8013f52:	f640 03f0 	movw	r3, #2288	; 0x8f0
 8013f56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013f5a:	781b      	ldrb	r3, [r3, #0]
 8013f5c:	2b10      	cmp	r3, #16
 8013f5e:	d107      	bne.n	8013f70 <_Z15msc_check_statehh+0x50>
		{
			isOnline[drive] = 0;
 8013f60:	79ba      	ldrb	r2, [r7, #6]
 8013f62:	f640 4350 	movw	r3, #3152	; 0xc50
 8013f66:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013f6a:	f04f 0100 	mov.w	r1, #0
 8013f6e:	5499      	strb	r1, [r3, r2]
		}

		last_state = current_state;
 8013f70:	f640 03f0 	movw	r3, #2288	; 0x8f0
 8013f74:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013f78:	781a      	ldrb	r2, [r3, #0]
 8013f7a:	f640 4354 	movw	r3, #3156	; 0xc54
 8013f7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013f82:	701a      	strb	r2, [r3, #0]
	}

	if(!isOnline[drive] && Bulk[drive] != NULL && Bulk[drive]->GetAddress() != 0)
 8013f84:	79ba      	ldrb	r2, [r7, #6]
 8013f86:	f640 4350 	movw	r3, #3152	; 0xc50
 8013f8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013f8e:	5c9b      	ldrb	r3, [r3, r2]
 8013f90:	2b00      	cmp	r3, #0
 8013f92:	d122      	bne.n	8013fda <_Z15msc_check_statehh+0xba>
 8013f94:	79ba      	ldrb	r2, [r7, #6]
 8013f96:	f640 434c 	movw	r3, #3148	; 0xc4c
 8013f9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013f9e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8013fa2:	2b00      	cmp	r3, #0
 8013fa4:	d019      	beq.n	8013fda <_Z15msc_check_statehh+0xba>
 8013fa6:	79ba      	ldrb	r2, [r7, #6]
 8013fa8:	f640 434c 	movw	r3, #3148	; 0xc4c
 8013fac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013fb0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8013fb4:	681b      	ldr	r3, [r3, #0]
 8013fb6:	f103 0310 	add.w	r3, r3, #16
 8013fba:	681a      	ldr	r2, [r3, #0]
 8013fbc:	79b9      	ldrb	r1, [r7, #6]
 8013fbe:	f640 434c 	movw	r3, #3148	; 0xc4c
 8013fc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013fc6:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8013fca:	4618      	mov	r0, r3
 8013fcc:	4790      	blx	r2
 8013fce:	4603      	mov	r3, r0
 8013fd0:	2b00      	cmp	r3, #0
 8013fd2:	d002      	beq.n	8013fda <_Z15msc_check_statehh+0xba>
 8013fd4:	f04f 0301 	mov.w	r3, #1
 8013fd8:	e001      	b.n	8013fde <_Z15msc_check_statehh+0xbe>
 8013fda:	f04f 0300 	mov.w	r3, #0
 8013fde:	2b00      	cmp	r3, #0
 8013fe0:	d007      	beq.n	8013ff2 <_Z15msc_check_statehh+0xd2>
	{
		isOnline[drive] = 1;
 8013fe2:	79ba      	ldrb	r2, [r7, #6]
 8013fe4:	f640 4350 	movw	r3, #3152	; 0xc50
 8013fe8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013fec:	f04f 0101 	mov.w	r1, #1
 8013ff0:	5499      	strb	r1, [r3, r2]
		// usb printer is ready to serve.
	}

}
 8013ff2:	f107 0708 	add.w	r7, r7, #8
 8013ff6:	46bd      	mov	sp, r7
 8013ff8:	bd80      	pop	{r7, pc}
 8013ffa:	bf00      	nop

08013ffc <_Z16InitClassStoragev>:
/**
 * This must be called before using generic_storage. This works around a G++ bug.
 * Thanks to Lei Shi for the heads up.
 */
void InitClassStorage(void)
{
 8013ffc:	b590      	push	{r4, r7, lr}
 8013ffe:	b083      	sub	sp, #12
 8014000:	af00      	add	r7, sp, #0
	for(int i=0; i< FS_MAX_USB_MS_DRIVERS; i++)
 8014002:	f04f 0300 	mov.w	r3, #0
 8014006:	607b      	str	r3, [r7, #4]
 8014008:	e017      	b.n	801403a <_Z16InitClassStoragev+0x3e>
	{
		Bulk[i]= new BulkOnly(&Usb);
 801400a:	f04f 0070 	mov.w	r0, #112	; 0x70
 801400e:	f009 f967 	bl	801d2e0 <_Znwj>
 8014012:	4603      	mov	r3, r0
 8014014:	461c      	mov	r4, r3
 8014016:	4620      	mov	r0, r4
 8014018:	f640 3184 	movw	r1, #2948	; 0xb84
 801401c:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8014020:	f002 feba 	bl	8016d98 <_ZN8BulkOnlyC1EP3USB>
 8014024:	f640 434c 	movw	r3, #3148	; 0xc4c
 8014028:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801402c:	687a      	ldr	r2, [r7, #4]
 801402e:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
 * This must be called before using generic_storage. This works around a G++ bug.
 * Thanks to Lei Shi for the heads up.
 */
void InitClassStorage(void)
{
	for(int i=0; i< FS_MAX_USB_MS_DRIVERS; i++)
 8014032:	687b      	ldr	r3, [r7, #4]
 8014034:	f103 0301 	add.w	r3, r3, #1
 8014038:	607b      	str	r3, [r7, #4]
 801403a:	687b      	ldr	r3, [r7, #4]
 801403c:	2b00      	cmp	r3, #0
 801403e:	bfcc      	ite	gt
 8014040:	2300      	movgt	r3, #0
 8014042:	2301      	movle	r3, #1
 8014044:	b2db      	uxtb	r3, r3
 8014046:	2b00      	cmp	r3, #0
 8014048:	d1df      	bne.n	801400a <_Z16InitClassStoragev+0xe>
	{
		Bulk[i]= new BulkOnly(&Usb);
	}

	system_cb->printf("\r\nMSC Library Started");
 801404a:	f243 630c 	movw	r3, #13836	; 0x360c
 801404e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014052:	681b      	ldr	r3, [r3, #0]
 8014054:	68db      	ldr	r3, [r3, #12]
 8014056:	f24e 60f8 	movw	r0, #59128	; 0xe6f8
 801405a:	f6c0 0001 	movt	r0, #2049	; 0x801
 801405e:	4798      	blx	r3
 8014060:	e004      	b.n	801406c <_Z16InitClassStoragev+0x70>
 */
void InitClassStorage(void)
{
	for(int i=0; i< FS_MAX_USB_MS_DRIVERS; i++)
	{
		Bulk[i]= new BulkOnly(&Usb);
 8014062:	4620      	mov	r0, r4
 8014064:	f008 fd08 	bl	801ca78 <_ZdlPv>
 8014068:	f008 fd0a 	bl	801ca80 <__cxa_end_cleanup>
	}

	system_cb->printf("\r\nMSC Library Started");
}
 801406c:	f107 070c 	add.w	r7, r7, #12
 8014070:	46bd      	mov	sp, r7
 8014072:	bd90      	pop	{r4, r7, pc}

08014074 <libuhs_class_msc_init>:


extern "C" {	// msc class api

void libuhs_class_msc_init(void)
{
 8014074:	b580      	push	{r7, lr}
 8014076:	af00      	add	r7, sp, #0
	InitClassStorage();
 8014078:	f7ff ffc0 	bl	8013ffc <_Z16InitClassStoragev>
	//mpUsbFsPlugin = new UsbFs(&Bulk[0], FS_MAX_USB_MS_DRIVERS);

}
 801407c:	bd80      	pop	{r7, pc}
 801407e:	bf00      	nop

08014080 <libuhs_class_msc_is_ready>:

uint8_t libuhs_class_msc_is_ready(uint8_t drive)
{
 8014080:	b480      	push	{r7}
 8014082:	b083      	sub	sp, #12
 8014084:	af00      	add	r7, sp, #0
 8014086:	4603      	mov	r3, r0
 8014088:	71fb      	strb	r3, [r7, #7]
	if(drive < FS_MAX_USB_MS_DRIVERS)
 801408a:	79fb      	ldrb	r3, [r7, #7]
 801408c:	2b00      	cmp	r3, #0
 801408e:	d106      	bne.n	801409e <libuhs_class_msc_is_ready+0x1e>
		return isOnline[drive];
 8014090:	79fa      	ldrb	r2, [r7, #7]
 8014092:	f640 4350 	movw	r3, #3152	; 0xc50
 8014096:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801409a:	5c9b      	ldrb	r3, [r3, r2]
 801409c:	e001      	b.n	80140a2 <libuhs_class_msc_is_ready+0x22>
	return eLibuhsErrorInvalidParam;
 801409e:	f04f 03ff 	mov.w	r3, #255	; 0xff
}
 80140a2:	4618      	mov	r0, r3
 80140a4:	f107 070c 	add.w	r7, r7, #12
 80140a8:	46bd      	mov	sp, r7
 80140aa:	bc80      	pop	{r7}
 80140ac:	4770      	bx	lr
 80140ae:	bf00      	nop

080140b0 <libuhs_class_msc_get_max_lun>:

uint8_t libuhs_class_msc_get_max_lun(uint8_t drive)
{
 80140b0:	b580      	push	{r7, lr}
 80140b2:	b082      	sub	sp, #8
 80140b4:	af00      	add	r7, sp, #0
 80140b6:	4603      	mov	r3, r0
 80140b8:	71fb      	strb	r3, [r7, #7]
	if(drive < FS_MAX_USB_MS_DRIVERS)
 80140ba:	79fb      	ldrb	r3, [r7, #7]
 80140bc:	2b00      	cmp	r3, #0
 80140be:	d10b      	bne.n	80140d8 <libuhs_class_msc_get_max_lun+0x28>
		return Bulk[drive]->GetbMaxLUN();
 80140c0:	79fa      	ldrb	r2, [r7, #7]
 80140c2:	f640 434c 	movw	r3, #3148	; 0xc4c
 80140c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80140ca:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80140ce:	4618      	mov	r0, r3
 80140d0:	f7ff fef8 	bl	8013ec4 <_ZN8BulkOnly10GetbMaxLUNEv>
 80140d4:	4603      	mov	r3, r0
 80140d6:	e001      	b.n	80140dc <libuhs_class_msc_get_max_lun+0x2c>
	return eLibuhsErrorInvalidParam;
 80140d8:	f04f 03ff 	mov.w	r3, #255	; 0xff
}
 80140dc:	4618      	mov	r0, r3
 80140de:	f107 0708 	add.w	r7, r7, #8
 80140e2:	46bd      	mov	sp, r7
 80140e4:	bd80      	pop	{r7, pc}
 80140e6:	bf00      	nop

080140e8 <libuhs_class_msc_lun_is_good>:

uint8_t libuhs_class_msc_lun_is_good(uint8_t drive, uint8_t lun)
{
 80140e8:	b580      	push	{r7, lr}
 80140ea:	b082      	sub	sp, #8
 80140ec:	af00      	add	r7, sp, #0
 80140ee:	4602      	mov	r2, r0
 80140f0:	460b      	mov	r3, r1
 80140f2:	71fa      	strb	r2, [r7, #7]
 80140f4:	71bb      	strb	r3, [r7, #6]
	if(drive < FS_MAX_USB_MS_DRIVERS)
 80140f6:	79fb      	ldrb	r3, [r7, #7]
 80140f8:	2b00      	cmp	r3, #0
 80140fa:	d10d      	bne.n	8014118 <libuhs_class_msc_lun_is_good+0x30>
		return Bulk[drive]->LUNIsGood(lun);
 80140fc:	79fa      	ldrb	r2, [r7, #7]
 80140fe:	f640 434c 	movw	r3, #3148	; 0xc4c
 8014102:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014106:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801410a:	79bb      	ldrb	r3, [r7, #6]
 801410c:	4610      	mov	r0, r2
 801410e:	4619      	mov	r1, r3
 8014110:	f002 fad6 	bl	80166c0 <_ZN8BulkOnly9LUNIsGoodEh>
 8014114:	4603      	mov	r3, r0
 8014116:	e001      	b.n	801411c <libuhs_class_msc_lun_is_good+0x34>
	return eLibuhsErrorInvalidParam;
 8014118:	f04f 03ff 	mov.w	r3, #255	; 0xff
}
 801411c:	4618      	mov	r0, r3
 801411e:	f107 0708 	add.w	r7, r7, #8
 8014122:	46bd      	mov	sp, r7
 8014124:	bd80      	pop	{r7, pc}
 8014126:	bf00      	nop

08014128 <libuhs_class_msc_get_capacity>:

uint32_t libuhs_class_msc_get_capacity(uint8_t drive, uint8_t lun)
{
 8014128:	b580      	push	{r7, lr}
 801412a:	b082      	sub	sp, #8
 801412c:	af00      	add	r7, sp, #0
 801412e:	4602      	mov	r2, r0
 8014130:	460b      	mov	r3, r1
 8014132:	71fa      	strb	r2, [r7, #7]
 8014134:	71bb      	strb	r3, [r7, #6]
	if(drive < FS_MAX_USB_MS_DRIVERS)
 8014136:	79fb      	ldrb	r3, [r7, #7]
 8014138:	2b00      	cmp	r3, #0
 801413a:	d10d      	bne.n	8014158 <libuhs_class_msc_get_capacity+0x30>
		return Bulk[drive]->GetCapacity(lun);
 801413c:	79fa      	ldrb	r2, [r7, #7]
 801413e:	f640 434c 	movw	r3, #3148	; 0xc4c
 8014142:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014146:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801414a:	79bb      	ldrb	r3, [r7, #6]
 801414c:	4610      	mov	r0, r2
 801414e:	4619      	mov	r1, r3
 8014150:	f002 fa7e 	bl	8016650 <_ZN8BulkOnly11GetCapacityEh>
 8014154:	4603      	mov	r3, r0
 8014156:	e001      	b.n	801415c <libuhs_class_msc_get_capacity+0x34>
	return eLibuhsErrorInvalidParam;
 8014158:	f04f 33ff 	mov.w	r3, #4294967295
}
 801415c:	4618      	mov	r0, r3
 801415e:	f107 0708 	add.w	r7, r7, #8
 8014162:	46bd      	mov	sp, r7
 8014164:	bd80      	pop	{r7, pc}
 8014166:	bf00      	nop

08014168 <libuhs_class_msc_get_sector_size>:

uint16_t libuhs_class_msc_get_sector_size(uint8_t drive, uint8_t lun)
{
 8014168:	b580      	push	{r7, lr}
 801416a:	b082      	sub	sp, #8
 801416c:	af00      	add	r7, sp, #0
 801416e:	4602      	mov	r2, r0
 8014170:	460b      	mov	r3, r1
 8014172:	71fa      	strb	r2, [r7, #7]
 8014174:	71bb      	strb	r3, [r7, #6]
	if(drive < FS_MAX_USB_MS_DRIVERS)
 8014176:	79fb      	ldrb	r3, [r7, #7]
 8014178:	2b00      	cmp	r3, #0
 801417a:	d10d      	bne.n	8014198 <libuhs_class_msc_get_sector_size+0x30>
		return Bulk[drive]->GetSectorSize(lun);
 801417c:	79fa      	ldrb	r2, [r7, #7]
 801417e:	f640 434c 	movw	r3, #3148	; 0xc4c
 8014182:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014186:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801418a:	79bb      	ldrb	r3, [r7, #6]
 801418c:	4610      	mov	r0, r2
 801418e:	4619      	mov	r1, r3
 8014190:	f002 fa7a 	bl	8016688 <_ZN8BulkOnly13GetSectorSizeEh>
 8014194:	4603      	mov	r3, r0
 8014196:	e001      	b.n	801419c <libuhs_class_msc_get_sector_size+0x34>
	return eLibuhsErrorInvalidParam;
 8014198:	f64f 73ff 	movw	r3, #65535	; 0xffff
}
 801419c:	4618      	mov	r0, r3
 801419e:	f107 0708 	add.w	r7, r7, #8
 80141a2:	46bd      	mov	sp, r7
 80141a4:	bd80      	pop	{r7, pc}
 80141a6:	bf00      	nop

080141a8 <libuhs_class_msc_write_protected>:

uint8_t libuhs_class_msc_write_protected(uint8_t drive, uint8_t lun)
{
 80141a8:	b580      	push	{r7, lr}
 80141aa:	b082      	sub	sp, #8
 80141ac:	af00      	add	r7, sp, #0
 80141ae:	4602      	mov	r2, r0
 80141b0:	460b      	mov	r3, r1
 80141b2:	71fa      	strb	r2, [r7, #7]
 80141b4:	71bb      	strb	r3, [r7, #6]
	return Bulk[drive]->WriteProtected(lun);
 80141b6:	79fa      	ldrb	r2, [r7, #7]
 80141b8:	f640 434c 	movw	r3, #3148	; 0xc4c
 80141bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80141c0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80141c4:	79bb      	ldrb	r3, [r7, #6]
 80141c6:	4610      	mov	r0, r2
 80141c8:	4619      	mov	r1, r3
 80141ca:	f002 fa8b 	bl	80166e4 <_ZN8BulkOnly14WriteProtectedEh>
 80141ce:	4603      	mov	r3, r0
}
 80141d0:	4618      	mov	r0, r3
 80141d2:	f107 0708 	add.w	r7, r7, #8
 80141d6:	46bd      	mov	sp, r7
 80141d8:	bd80      	pop	{r7, pc}
 80141da:	bf00      	nop

080141dc <libuhs_class_msc_read_data>:
uint8_t libuhs_class_msc_read_data(uint8_t drive, uint8_t lun, uint32_t addr, uint16_t bsize, uint8_t blocks, uint8_t *buf)
{
 80141dc:	b580      	push	{r7, lr}
 80141de:	b084      	sub	sp, #16
 80141e0:	af02      	add	r7, sp, #8
 80141e2:	603a      	str	r2, [r7, #0]
 80141e4:	4602      	mov	r2, r0
 80141e6:	71fa      	strb	r2, [r7, #7]
 80141e8:	460a      	mov	r2, r1
 80141ea:	71ba      	strb	r2, [r7, #6]
 80141ec:	80bb      	strh	r3, [r7, #4]
	return Bulk[drive]->Read(lun, addr, bsize, blocks, buf);
 80141ee:	79fa      	ldrb	r2, [r7, #7]
 80141f0:	f640 434c 	movw	r3, #3148	; 0xc4c
 80141f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80141f8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80141fc:	79ba      	ldrb	r2, [r7, #6]
 80141fe:	88bb      	ldrh	r3, [r7, #4]
 8014200:	7c38      	ldrb	r0, [r7, #16]
 8014202:	9000      	str	r0, [sp, #0]
 8014204:	6978      	ldr	r0, [r7, #20]
 8014206:	9001      	str	r0, [sp, #4]
 8014208:	4608      	mov	r0, r1
 801420a:	4611      	mov	r1, r2
 801420c:	683a      	ldr	r2, [r7, #0]
 801420e:	f002 fb87 	bl	8016920 <_ZN8BulkOnly4ReadEhmthPh>
 8014212:	4603      	mov	r3, r0
}
 8014214:	4618      	mov	r0, r3
 8014216:	f107 0708 	add.w	r7, r7, #8
 801421a:	46bd      	mov	sp, r7
 801421c:	bd80      	pop	{r7, pc}
 801421e:	bf00      	nop

08014220 <libuhs_class_msc_write_data>:
uint8_t libuhs_class_msc_write_data(uint8_t drive, uint8_t lun, uint32_t addr, uint16_t bsize, uint8_t blocks, uint8_t * buf)
{
 8014220:	b580      	push	{r7, lr}
 8014222:	b084      	sub	sp, #16
 8014224:	af02      	add	r7, sp, #8
 8014226:	603a      	str	r2, [r7, #0]
 8014228:	4602      	mov	r2, r0
 801422a:	71fa      	strb	r2, [r7, #7]
 801422c:	460a      	mov	r2, r1
 801422e:	71ba      	strb	r2, [r7, #6]
 8014230:	80bb      	strh	r3, [r7, #4]
	return Bulk[drive]->Write(lun, addr, bsize, blocks, buf);
 8014232:	79fa      	ldrb	r2, [r7, #7]
 8014234:	f640 434c 	movw	r3, #3148	; 0xc4c
 8014238:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801423c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8014240:	79ba      	ldrb	r2, [r7, #6]
 8014242:	88bb      	ldrh	r3, [r7, #4]
 8014244:	7c38      	ldrb	r0, [r7, #16]
 8014246:	9000      	str	r0, [sp, #0]
 8014248:	6978      	ldr	r0, [r7, #20]
 801424a:	9001      	str	r0, [sp, #4]
 801424c:	4608      	mov	r0, r1
 801424e:	4611      	mov	r1, r2
 8014250:	683a      	ldr	r2, [r7, #0]
 8014252:	f002 fc6d 	bl	8016b30 <_ZN8BulkOnly5WriteEhmthPh>
 8014256:	4603      	mov	r3, r0
}
 8014258:	4618      	mov	r0, r3
 801425a:	f107 0708 	add.w	r7, r7, #8
 801425e:	46bd      	mov	sp, r7
 8014260:	bd80      	pop	{r7, pc}
 8014262:	bf00      	nop

08014264 <libuhs_class_msc_disable_polling>:
void libuhs_class_msc_disable_polling(uint8_t drive)
{
 8014264:	b580      	push	{r7, lr}
 8014266:	b082      	sub	sp, #8
 8014268:	af00      	add	r7, sp, #0
 801426a:	4603      	mov	r3, r0
 801426c:	71fb      	strb	r3, [r7, #7]
	Bulk[drive]->DisablePolling();
 801426e:	79fa      	ldrb	r2, [r7, #7]
 8014270:	f640 434c 	movw	r3, #3148	; 0xc4c
 8014274:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014278:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801427c:	4618      	mov	r0, r3
 801427e:	f7ff fe2f 	bl	8013ee0 <_ZN8BulkOnly14DisablePollingEv>
}
 8014282:	f107 0708 	add.w	r7, r7, #8
 8014286:	46bd      	mov	sp, r7
 8014288:	bd80      	pop	{r7, pc}
 801428a:	bf00      	nop

0801428c <libuhs_class_msc_enable_polling>:
void libuhs_class_msc_enable_polling(uint8_t drive)
{
 801428c:	b580      	push	{r7, lr}
 801428e:	b082      	sub	sp, #8
 8014290:	af00      	add	r7, sp, #0
 8014292:	4603      	mov	r3, r0
 8014294:	71fb      	strb	r3, [r7, #7]
	Bulk[drive]->EnablePolling();
 8014296:	79fa      	ldrb	r2, [r7, #7]
 8014298:	f640 434c 	movw	r3, #3148	; 0xc4c
 801429c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80142a0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80142a4:	4618      	mov	r0, r3
 80142a6:	f7ff fe2b 	bl	8013f00 <_ZN8BulkOnly13EnablePollingEv>
}
 80142aa:	f107 0708 	add.w	r7, r7, #8
 80142ae:	46bd      	mov	sp, r7
 80142b0:	bd80      	pop	{r7, pc}
 80142b2:	bf00      	nop

080142b4 <_Z19printer_check_stateh>:
extern USB Usb;
static USBPrinter *mpUsbPrinter = NULL;
static uint8_t isOnline = 0;

void printer_check_state(uint8_t state)
{
 80142b4:	b580      	push	{r7, lr}
 80142b6:	b082      	sub	sp, #8
 80142b8:	af00      	add	r7, sp, #0
 80142ba:	4603      	mov	r3, r0
 80142bc:	71fb      	strb	r3, [r7, #7]
	static uint8_t current_state = 0;
	static uint8_t last_state = 0;

	current_state = state;
 80142be:	f640 435d 	movw	r3, #3165	; 0xc5d
 80142c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80142c6:	79fa      	ldrb	r2, [r7, #7]
 80142c8:	701a      	strb	r2, [r3, #0]
	if(current_state != last_state)
 80142ca:	f640 435d 	movw	r3, #3165	; 0xc5d
 80142ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80142d2:	781a      	ldrb	r2, [r3, #0]
 80142d4:	f640 435e 	movw	r3, #3166	; 0xc5e
 80142d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80142dc:	781b      	ldrb	r3, [r3, #0]
 80142de:	429a      	cmp	r2, r3
 80142e0:	d017      	beq.n	8014312 <_Z19printer_check_stateh+0x5e>
	{
		if(current_state == USB_STATE_DETACHED)
 80142e2:	f640 435d 	movw	r3, #3165	; 0xc5d
 80142e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80142ea:	781b      	ldrb	r3, [r3, #0]
 80142ec:	2b10      	cmp	r3, #16
 80142ee:	d106      	bne.n	80142fe <_Z19printer_check_stateh+0x4a>
		{
			isOnline = 0;
 80142f0:	f640 435c 	movw	r3, #3164	; 0xc5c
 80142f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80142f8:	f04f 0200 	mov.w	r2, #0
 80142fc:	701a      	strb	r2, [r3, #0]
		}

		last_state = current_state;
 80142fe:	f640 435d 	movw	r3, #3165	; 0xc5d
 8014302:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014306:	781a      	ldrb	r2, [r3, #0]
 8014308:	f640 435e 	movw	r3, #3166	; 0xc5e
 801430c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014310:	701a      	strb	r2, [r3, #0]
	}
	if(!isOnline && mpUsbPrinter != NULL && mpUsbPrinter->GetAddress() != 0)
 8014312:	f640 435c 	movw	r3, #3164	; 0xc5c
 8014316:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801431a:	781b      	ldrb	r3, [r3, #0]
 801431c:	2b00      	cmp	r3, #0
 801431e:	d11c      	bne.n	801435a <_Z19printer_check_stateh+0xa6>
 8014320:	f640 4358 	movw	r3, #3160	; 0xc58
 8014324:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014328:	681b      	ldr	r3, [r3, #0]
 801432a:	2b00      	cmp	r3, #0
 801432c:	d015      	beq.n	801435a <_Z19printer_check_stateh+0xa6>
 801432e:	f640 4358 	movw	r3, #3160	; 0xc58
 8014332:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014336:	681b      	ldr	r3, [r3, #0]
 8014338:	681b      	ldr	r3, [r3, #0]
 801433a:	f103 0310 	add.w	r3, r3, #16
 801433e:	681a      	ldr	r2, [r3, #0]
 8014340:	f640 4358 	movw	r3, #3160	; 0xc58
 8014344:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014348:	681b      	ldr	r3, [r3, #0]
 801434a:	4618      	mov	r0, r3
 801434c:	4790      	blx	r2
 801434e:	4603      	mov	r3, r0
 8014350:	2b00      	cmp	r3, #0
 8014352:	d002      	beq.n	801435a <_Z19printer_check_stateh+0xa6>
 8014354:	f04f 0301 	mov.w	r3, #1
 8014358:	e001      	b.n	801435e <_Z19printer_check_stateh+0xaa>
 801435a:	f04f 0300 	mov.w	r3, #0
 801435e:	2b00      	cmp	r3, #0
 8014360:	d006      	beq.n	8014370 <_Z19printer_check_stateh+0xbc>
	{
		isOnline = 1;
 8014362:	f640 435c 	movw	r3, #3164	; 0xc5c
 8014366:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801436a:	f04f 0201 	mov.w	r2, #1
 801436e:	701a      	strb	r2, [r3, #0]
		// usb printer is ready to serve.
	}
}
 8014370:	f107 0708 	add.w	r7, r7, #8
 8014374:	46bd      	mov	sp, r7
 8014376:	bd80      	pop	{r7, pc}

08014378 <libuhs_class_printer_init>:

extern "C" {	// printer class api

void libuhs_class_printer_init(void)
{
 8014378:	b598      	push	{r3, r4, r7, lr}
 801437a:	af00      	add	r7, sp, #0
	if(mpUsbPrinter == NULL)
 801437c:	f640 4358 	movw	r3, #3160	; 0xc58
 8014380:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014384:	681b      	ldr	r3, [r3, #0]
 8014386:	2b00      	cmp	r3, #0
 8014388:	d117      	bne.n	80143ba <libuhs_class_printer_init+0x42>
	{
		mpUsbPrinter = new USBPrinter(&Usb);
 801438a:	f04f 0028 	mov.w	r0, #40	; 0x28
 801438e:	f008 ffa7 	bl	801d2e0 <_Znwj>
 8014392:	4603      	mov	r3, r0
 8014394:	461c      	mov	r4, r3
 8014396:	4620      	mov	r0, r4
 8014398:	f640 3184 	movw	r1, #2948	; 0xb84
 801439c:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80143a0:	f006 f918 	bl	801a5d4 <_ZN10USBPrinterC1EP3USB>
 80143a4:	f640 4358 	movw	r3, #3160	; 0xc58
 80143a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80143ac:	601c      	str	r4, [r3, #0]
 80143ae:	e005      	b.n	80143bc <libuhs_class_printer_init+0x44>
 80143b0:	4620      	mov	r0, r4
 80143b2:	f008 fb61 	bl	801ca78 <_ZdlPv>
 80143b6:	f008 fb63 	bl	801ca80 <__cxa_end_cleanup>
	}
}
 80143ba:	bf00      	nop
 80143bc:	bd98      	pop	{r3, r4, r7, pc}
 80143be:	bf00      	nop

080143c0 <libuhs_class_printer_is_ready>:

uint8_t libuhs_class_printer_is_ready(void)
{
 80143c0:	b480      	push	{r7}
 80143c2:	af00      	add	r7, sp, #0
	return isOnline;
 80143c4:	f640 435c 	movw	r3, #3164	; 0xc5c
 80143c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80143cc:	781b      	ldrb	r3, [r3, #0]
}
 80143ce:	4618      	mov	r0, r3
 80143d0:	46bd      	mov	sp, r7
 80143d2:	bc80      	pop	{r7}
 80143d4:	4770      	bx	lr
 80143d6:	bf00      	nop

080143d8 <libuhs_class_printer_send_data>:

uint8_t libuhs_class_printer_send_data(uint8_t *buf, uint16_t nbytes)
{
 80143d8:	b580      	push	{r7, lr}
 80143da:	b082      	sub	sp, #8
 80143dc:	af00      	add	r7, sp, #0
 80143de:	6078      	str	r0, [r7, #4]
 80143e0:	460b      	mov	r3, r1
 80143e2:	807b      	strh	r3, [r7, #2]
	if(mpUsbPrinter != NULL)
 80143e4:	f640 4358 	movw	r3, #3160	; 0xc58
 80143e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80143ec:	681b      	ldr	r3, [r3, #0]
 80143ee:	2b00      	cmp	r3, #0
 80143f0:	d00c      	beq.n	801440c <libuhs_class_printer_send_data+0x34>
		return mpUsbPrinter->BulkWrite((uint8_t *)buf, nbytes);
 80143f2:	f640 4358 	movw	r3, #3160	; 0xc58
 80143f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80143fa:	681a      	ldr	r2, [r3, #0]
 80143fc:	887b      	ldrh	r3, [r7, #2]
 80143fe:	4610      	mov	r0, r2
 8014400:	6879      	ldr	r1, [r7, #4]
 8014402:	461a      	mov	r2, r3
 8014404:	f006 f95a 	bl	801a6bc <_ZN10USBPrinter9BulkWriteEPht>
 8014408:	4603      	mov	r3, r0
 801440a:	e7ff      	b.n	801440c <libuhs_class_printer_send_data+0x34>
}
 801440c:	4618      	mov	r0, r3
 801440e:	f107 0708 	add.w	r7, r7, #8
 8014412:	46bd      	mov	sp, r7
 8014414:	bd80      	pop	{r7, pc}
 8014416:	bf00      	nop

08014418 <_ZN3USB14GetAddressPoolEv>:

        void ResetHubPreMask() {
                bmHubPre &= (~bmHUBPRE);
        };

        AddressPool& GetAddressPool() {
 8014418:	b480      	push	{r7}
 801441a:	b083      	sub	sp, #12
 801441c:	af00      	add	r7, sp, #0
 801441e:	6078      	str	r0, [r7, #4]
			return(AddressPool&) addrPool;
 8014420:	687b      	ldr	r3, [r7, #4]
        };
 8014422:	4618      	mov	r0, r3
 8014424:	f107 070c 	add.w	r7, r7, #12
 8014428:	46bd      	mov	sp, r7
 801442a:	bc80      	pop	{r7}
 801442c:	4770      	bx	lr
 801442e:	bf00      	nop

08014430 <_ZN3USBC1Ev>:

static uint8_t usb_error = 0;
static uint8_t usb_task_state;

/* constructor */
USB::USB() :	//USB_OTG_CORE_HANDLE *pDev) :
 8014430:	b580      	push	{r7, lr}
 8014432:	b084      	sub	sp, #16
 8014434:	af00      	add	r7, sp, #0
 8014436:	6078      	str	r0, [r7, #4]
STM32F207(),	//pDev),
bmHubPre(0),
bGlobalPollEnable(true)
 8014438:	6878      	ldr	r0, [r7, #4]
 801443a:	f001 fca3 	bl	8015d84 <_ZN7STM32F2I1a1bEC1Ev>
 801443e:	687b      	ldr	r3, [r7, #4]
 8014440:	4618      	mov	r0, r3
 8014442:	f001 fcbb 	bl	8015dbc <_ZN15AddressPoolImplILh16EEC1Ev>
 8014446:	687b      	ldr	r3, [r7, #4]
 8014448:	f04f 0200 	mov.w	r2, #0
 801444c:	f883 20bc 	strb.w	r2, [r3, #188]	; 0xbc
 8014450:	687b      	ldr	r3, [r7, #4]
 8014452:	f04f 0201 	mov.w	r2, #1
 8014456:	f883 20bd 	strb.w	r2, [r3, #189]	; 0xbd
{
	usb_task_state = USB_DETACHED_SUBSTATE_INITIALIZE; //set up state machine
 801445a:	f640 4360 	movw	r3, #3168	; 0xc60
 801445e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014462:	f04f 0211 	mov.w	r2, #17
 8014466:	701a      	strb	r2, [r3, #0]
	for(uint8_t i = 0; i < USB_NUMDEVICES; i++) {
 8014468:	f04f 0300 	mov.w	r3, #0
 801446c:	73fb      	strb	r3, [r7, #15]
 801446e:	e00d      	b.n	801448c <_ZN3USBC1Ev+0x5c>
		devConfig[i] = 0;
 8014470:	7bfb      	ldrb	r3, [r7, #15]
 8014472:	687a      	ldr	r2, [r7, #4]
 8014474:	f103 031e 	add.w	r3, r3, #30
 8014478:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801447c:	18d3      	adds	r3, r2, r3
 801447e:	f04f 0200 	mov.w	r2, #0
 8014482:	605a      	str	r2, [r3, #4]
STM32F207(),	//pDev),
bmHubPre(0),
bGlobalPollEnable(true)
{
	usb_task_state = USB_DETACHED_SUBSTATE_INITIALIZE; //set up state machine
	for(uint8_t i = 0; i < USB_NUMDEVICES; i++) {
 8014484:	7bfb      	ldrb	r3, [r7, #15]
 8014486:	f103 0301 	add.w	r3, r3, #1
 801448a:	73fb      	strb	r3, [r7, #15]
 801448c:	7bfb      	ldrb	r3, [r7, #15]
 801448e:	2b0f      	cmp	r3, #15
 8014490:	bf8c      	ite	hi
 8014492:	2300      	movhi	r3, #0
 8014494:	2301      	movls	r3, #1
 8014496:	b2db      	uxtb	r3, r3
 8014498:	2b00      	cmp	r3, #0
 801449a:	d1e9      	bne.n	8014470 <_ZN3USBC1Ev+0x40>
		devConfig[i] = 0;
	}
	init();
 801449c:	6878      	ldr	r0, [r7, #4]
 801449e:	f000 f807 	bl	80144b0 <_ZN3USB4initEv>
}
 80144a2:	687b      	ldr	r3, [r7, #4]
 80144a4:	4618      	mov	r0, r3
 80144a6:	f107 0710 	add.w	r7, r7, #16
 80144aa:	46bd      	mov	sp, r7
 80144ac:	bd80      	pop	{r7, pc}
 80144ae:	bf00      	nop

080144b0 <_ZN3USB4initEv>:

/* Initialize data structures */
void USB::init() {
 80144b0:	b480      	push	{r7}
 80144b2:	b083      	sub	sp, #12
 80144b4:	af00      	add	r7, sp, #0
 80144b6:	6078      	str	r0, [r7, #4]
    //devConfigIndex = 0;
    bmHubPre = 0;
 80144b8:	687b      	ldr	r3, [r7, #4]
 80144ba:	f04f 0200 	mov.w	r2, #0
 80144be:	f883 20bc 	strb.w	r2, [r3, #188]	; 0xbc
}
 80144c2:	f107 070c 	add.w	r7, r7, #12
 80144c6:	46bd      	mov	sp, r7
 80144c8:	bc80      	pop	{r7}
 80144ca:	4770      	bx	lr

080144cc <_ZN3USB15getUsbTaskStateEv>:

uint8_t USB::getUsbTaskState(void) {
 80144cc:	b480      	push	{r7}
 80144ce:	b083      	sub	sp, #12
 80144d0:	af00      	add	r7, sp, #0
 80144d2:	6078      	str	r0, [r7, #4]
        return ( usb_task_state);
 80144d4:	f640 4360 	movw	r3, #3168	; 0xc60
 80144d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80144dc:	781b      	ldrb	r3, [r3, #0]
}
 80144de:	4618      	mov	r0, r3
 80144e0:	f107 070c 	add.w	r7, r7, #12
 80144e4:	46bd      	mov	sp, r7
 80144e6:	bc80      	pop	{r7}
 80144e8:	4770      	bx	lr
 80144ea:	bf00      	nop

080144ec <_ZN3USB15setUsbTaskStateEh>:

void USB::setUsbTaskState(uint8_t state) {
 80144ec:	b480      	push	{r7}
 80144ee:	b083      	sub	sp, #12
 80144f0:	af00      	add	r7, sp, #0
 80144f2:	6078      	str	r0, [r7, #4]
 80144f4:	460b      	mov	r3, r1
 80144f6:	70fb      	strb	r3, [r7, #3]
        usb_task_state = state;
 80144f8:	f640 4360 	movw	r3, #3168	; 0xc60
 80144fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014500:	78fa      	ldrb	r2, [r7, #3]
 8014502:	701a      	strb	r2, [r3, #0]
}
 8014504:	f107 070c 	add.w	r7, r7, #12
 8014508:	46bd      	mov	sp, r7
 801450a:	bc80      	pop	{r7}
 801450c:	4770      	bx	lr
 801450e:	bf00      	nop

08014510 <_ZN3USB14getEpInfoEntryEhh>:

EpInfo* USB::getEpInfoEntry(uint8_t addr, uint8_t ep) {
 8014510:	b580      	push	{r7, lr}
 8014512:	b086      	sub	sp, #24
 8014514:	af00      	add	r7, sp, #0
 8014516:	6078      	str	r0, [r7, #4]
 8014518:	4613      	mov	r3, r2
 801451a:	460a      	mov	r2, r1
 801451c:	70fa      	strb	r2, [r7, #3]
 801451e:	70bb      	strb	r3, [r7, #2]
        UsbDevice *p = addrPool.GetUsbDevicePtr(addr);
 8014520:	687a      	ldr	r2, [r7, #4]
 8014522:	78fb      	ldrb	r3, [r7, #3]
 8014524:	4610      	mov	r0, r2
 8014526:	4619      	mov	r1, r3
 8014528:	f001 fc84 	bl	8015e34 <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh>
 801452c:	4603      	mov	r3, r0
 801452e:	60fb      	str	r3, [r7, #12]

        if (!p || !p->epinfo)
 8014530:	68fb      	ldr	r3, [r7, #12]
 8014532:	2b00      	cmp	r3, #0
 8014534:	d003      	beq.n	801453e <_ZN3USB14getEpInfoEntryEhh+0x2e>
 8014536:	68fb      	ldr	r3, [r7, #12]
 8014538:	681b      	ldr	r3, [r3, #0]
 801453a:	2b00      	cmp	r3, #0
 801453c:	d102      	bne.n	8014544 <_ZN3USB14getEpInfoEntryEhh+0x34>
			return NULL;
 801453e:	f04f 0300 	mov.w	r3, #0
 8014542:	e021      	b.n	8014588 <_ZN3USB14getEpInfoEntryEhh+0x78>

        EpInfo *pep = p->epinfo;
 8014544:	68fb      	ldr	r3, [r7, #12]
 8014546:	681b      	ldr	r3, [r3, #0]
 8014548:	617b      	str	r3, [r7, #20]

        for (uint8_t i = 0; i < p->epcount; i++) {
 801454a:	f04f 0300 	mov.w	r3, #0
 801454e:	74fb      	strb	r3, [r7, #19]
 8014550:	e00e      	b.n	8014570 <_ZN3USB14getEpInfoEntryEhh+0x60>
			if ((pep)->epAddr == ep)
 8014552:	697b      	ldr	r3, [r7, #20]
 8014554:	781b      	ldrb	r3, [r3, #0]
 8014556:	78ba      	ldrb	r2, [r7, #2]
 8014558:	429a      	cmp	r2, r3
 801455a:	d101      	bne.n	8014560 <_ZN3USB14getEpInfoEntryEhh+0x50>
				return pep;
 801455c:	697b      	ldr	r3, [r7, #20]
 801455e:	e013      	b.n	8014588 <_ZN3USB14getEpInfoEntryEhh+0x78>

			pep++;
 8014560:	697b      	ldr	r3, [r7, #20]
 8014562:	f103 0305 	add.w	r3, r3, #5
 8014566:	617b      	str	r3, [r7, #20]
        if (!p || !p->epinfo)
			return NULL;

        EpInfo *pep = p->epinfo;

        for (uint8_t i = 0; i < p->epcount; i++) {
 8014568:	7cfb      	ldrb	r3, [r7, #19]
 801456a:	f103 0301 	add.w	r3, r3, #1
 801456e:	74fb      	strb	r3, [r7, #19]
 8014570:	68fb      	ldr	r3, [r7, #12]
 8014572:	795b      	ldrb	r3, [r3, #5]
 8014574:	7cfa      	ldrb	r2, [r7, #19]
 8014576:	429a      	cmp	r2, r3
 8014578:	bf2c      	ite	cs
 801457a:	2300      	movcs	r3, #0
 801457c:	2301      	movcc	r3, #1
 801457e:	b2db      	uxtb	r3, r3
 8014580:	2b00      	cmp	r3, #0
 8014582:	d1e6      	bne.n	8014552 <_ZN3USB14getEpInfoEntryEhh+0x42>
			if ((pep)->epAddr == ep)
				return pep;

			pep++;
        }
        return NULL;
 8014584:	f04f 0300 	mov.w	r3, #0
}
 8014588:	4618      	mov	r0, r3
 801458a:	f107 0718 	add.w	r7, r7, #24
 801458e:	46bd      	mov	sp, r7
 8014590:	bd80      	pop	{r7, pc}
 8014592:	bf00      	nop

08014594 <_ZN3USB14setEpInfoEntryEhhP6EpInfo>:

/* set device table entry */

/* each device is different and has different number of endpoints. This function plugs endpoint record structure, defined in application, to devtable */
uint8_t USB::setEpInfoEntry(uint8_t addr, uint8_t epcount, EpInfo* eprecord_ptr) {
 8014594:	b580      	push	{r7, lr}
 8014596:	b086      	sub	sp, #24
 8014598:	af00      	add	r7, sp, #0
 801459a:	60f8      	str	r0, [r7, #12]
 801459c:	607b      	str	r3, [r7, #4]
 801459e:	460b      	mov	r3, r1
 80145a0:	72fb      	strb	r3, [r7, #11]
 80145a2:	4613      	mov	r3, r2
 80145a4:	72bb      	strb	r3, [r7, #10]
        if (!eprecord_ptr)
 80145a6:	687b      	ldr	r3, [r7, #4]
 80145a8:	2b00      	cmp	r3, #0
 80145aa:	d102      	bne.n	80145b2 <_ZN3USB14setEpInfoEntryEhhP6EpInfo+0x1e>
			return USB_ERROR_INVALID_ARGUMENT;
 80145ac:	f04f 03d8 	mov.w	r3, #216	; 0xd8
 80145b0:	e018      	b.n	80145e4 <_ZN3USB14setEpInfoEntryEhhP6EpInfo+0x50>

        UsbDevice *p = addrPool.GetUsbDevicePtr(addr);
 80145b2:	68fa      	ldr	r2, [r7, #12]
 80145b4:	7afb      	ldrb	r3, [r7, #11]
 80145b6:	4610      	mov	r0, r2
 80145b8:	4619      	mov	r1, r3
 80145ba:	f001 fc3b 	bl	8015e34 <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh>
 80145be:	4603      	mov	r3, r0
 80145c0:	617b      	str	r3, [r7, #20]

        if (!p)
 80145c2:	697b      	ldr	r3, [r7, #20]
 80145c4:	2b00      	cmp	r3, #0
 80145c6:	d102      	bne.n	80145ce <_ZN3USB14setEpInfoEntryEhhP6EpInfo+0x3a>
			return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
 80145c8:	f04f 03d6 	mov.w	r3, #214	; 0xd6
 80145cc:	e00a      	b.n	80145e4 <_ZN3USB14setEpInfoEntryEhhP6EpInfo+0x50>

        p->address = addr;
 80145ce:	697b      	ldr	r3, [r7, #20]
 80145d0:	7afa      	ldrb	r2, [r7, #11]
 80145d2:	711a      	strb	r2, [r3, #4]
        p->epinfo = eprecord_ptr;
 80145d4:	697b      	ldr	r3, [r7, #20]
 80145d6:	687a      	ldr	r2, [r7, #4]
 80145d8:	601a      	str	r2, [r3, #0]
        p->epcount = epcount;
 80145da:	697b      	ldr	r3, [r7, #20]
 80145dc:	7aba      	ldrb	r2, [r7, #10]
 80145de:	715a      	strb	r2, [r3, #5]

        return 0;
 80145e0:	f04f 0300 	mov.w	r3, #0
}
 80145e4:	4618      	mov	r0, r3
 80145e6:	f107 0718 	add.w	r7, r7, #24
 80145ea:	46bd      	mov	sp, r7
 80145ec:	bd80      	pop	{r7, pc}
 80145ee:	bf00      	nop

080145f0 <_ZN3USB10SetAddressEhhPP6EpInfoRt>:

uint8_t USB::SetAddress(uint8_t addr, uint8_t ep, EpInfo **ppep, uint16_t &nak_limit) {
 80145f0:	b580      	push	{r7, lr}
 80145f2:	b086      	sub	sp, #24
 80145f4:	af00      	add	r7, sp, #0
 80145f6:	60f8      	str	r0, [r7, #12]
 80145f8:	607b      	str	r3, [r7, #4]
 80145fa:	460b      	mov	r3, r1
 80145fc:	72fb      	strb	r3, [r7, #11]
 80145fe:	4613      	mov	r3, r2
 8014600:	72bb      	strb	r3, [r7, #10]
        UsbDevice *p = addrPool.GetUsbDevicePtr(addr);
 8014602:	68fa      	ldr	r2, [r7, #12]
 8014604:	7afb      	ldrb	r3, [r7, #11]
 8014606:	4610      	mov	r0, r2
 8014608:	4619      	mov	r1, r3
 801460a:	f001 fc13 	bl	8015e34 <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh>
 801460e:	4603      	mov	r3, r0
 8014610:	617b      	str	r3, [r7, #20]

        if (!p)
 8014612:	697b      	ldr	r3, [r7, #20]
 8014614:	2b00      	cmp	r3, #0
 8014616:	d102      	bne.n	801461e <_ZN3USB10SetAddressEhhPP6EpInfoRt+0x2e>
			return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
 8014618:	f04f 03d6 	mov.w	r3, #214	; 0xd6
 801461c:	e03d      	b.n	801469a <_ZN3USB10SetAddressEhhPP6EpInfoRt+0xaa>

        if (!p->epinfo)
 801461e:	697b      	ldr	r3, [r7, #20]
 8014620:	681b      	ldr	r3, [r3, #0]
 8014622:	2b00      	cmp	r3, #0
 8014624:	d102      	bne.n	801462c <_ZN3USB10SetAddressEhhPP6EpInfoRt+0x3c>
			return USB_ERROR_EPINFO_IS_NULL;
 8014626:	f04f 03d7 	mov.w	r3, #215	; 0xd7
 801462a:	e036      	b.n	801469a <_ZN3USB10SetAddressEhhPP6EpInfoRt+0xaa>

        *ppep = getEpInfoEntry(addr, ep);
 801462c:	7afa      	ldrb	r2, [r7, #11]
 801462e:	7abb      	ldrb	r3, [r7, #10]
 8014630:	68f8      	ldr	r0, [r7, #12]
 8014632:	4611      	mov	r1, r2
 8014634:	461a      	mov	r2, r3
 8014636:	f7ff ff6b 	bl	8014510 <_ZN3USB14getEpInfoEntryEhh>
 801463a:	4603      	mov	r3, r0
 801463c:	461a      	mov	r2, r3
 801463e:	687b      	ldr	r3, [r7, #4]
 8014640:	601a      	str	r2, [r3, #0]

        if (!*ppep)
 8014642:	687b      	ldr	r3, [r7, #4]
 8014644:	681b      	ldr	r3, [r3, #0]
 8014646:	2b00      	cmp	r3, #0
 8014648:	d102      	bne.n	8014650 <_ZN3USB10SetAddressEhhPP6EpInfoRt+0x60>
			return USB_ERROR_EP_NOT_FOUND_IN_TBL;
 801464a:	f04f 03db 	mov.w	r3, #219	; 0xdb
 801464e:	e024      	b.n	801469a <_ZN3USB10SetAddressEhhPP6EpInfoRt+0xaa>

        nak_limit = (0x0001UL << (((*ppep)->bmNakPower > USB_NAK_MAX_POWER) ? USB_NAK_MAX_POWER : (*ppep)->bmNakPower));
 8014650:	687b      	ldr	r3, [r7, #4]
 8014652:	681b      	ldr	r3, [r3, #0]
 8014654:	791b      	ldrb	r3, [r3, #4]
 8014656:	f3c3 0385 	ubfx	r3, r3, #2, #6
 801465a:	b2db      	uxtb	r3, r3
 801465c:	2b0f      	cmp	r3, #15
 801465e:	dc0b      	bgt.n	8014678 <_ZN3USB10SetAddressEhhPP6EpInfoRt+0x88>
 8014660:	687b      	ldr	r3, [r7, #4]
 8014662:	681b      	ldr	r3, [r3, #0]
 8014664:	791b      	ldrb	r3, [r3, #4]
 8014666:	f3c3 0385 	ubfx	r3, r3, #2, #6
 801466a:	b2db      	uxtb	r3, r3
 801466c:	f04f 0201 	mov.w	r2, #1
 8014670:	fa02 f303 	lsl.w	r3, r2, r3
 8014674:	b29b      	uxth	r3, r3
 8014676:	e001      	b.n	801467c <_ZN3USB10SetAddressEhhPP6EpInfoRt+0x8c>
 8014678:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 801467c:	6a3a      	ldr	r2, [r7, #32]
 801467e:	8013      	strh	r3, [r2, #0]
        nak_limit--;
 8014680:	6a3b      	ldr	r3, [r7, #32]
 8014682:	881b      	ldrh	r3, [r3, #0]
 8014684:	f103 33ff 	add.w	r3, r3, #4294967295
 8014688:	b29a      	uxth	r2, r3
 801468a:	6a3b      	ldr	r3, [r7, #32]
 801468c:	801a      	strh	r2, [r3, #0]
          USBTRACE2(" NAK Power: ",(*ppep)->bmNakPower);
          USBTRACE2(" NAK Limit: ", nak_limit);
          USBTRACE("\r\n");
         */
        //regWr(rPERADDR, addr); //set peripheral address
        (*ppep)->hcDevAddr = addr;
 801468e:	687b      	ldr	r3, [r7, #4]
 8014690:	681b      	ldr	r3, [r3, #0]
 8014692:	7afa      	ldrb	r2, [r7, #11]
 8014694:	709a      	strb	r2, [r3, #2]


        // Set bmLOWSPEED and bmHUBPRE in case of low-speed device, reset them otherwise
//        regWr(rMODE, (p->lowspeed) ? mode | bmLOWSPEED | bmHubPre : mode & ~(bmHUBPRE | bmLOWSPEED));

        return 0;
 8014696:	f04f 0300 	mov.w	r3, #0
}
 801469a:	4618      	mov	r0, r3
 801469c:	f107 0718 	add.w	r7, r7, #24
 80146a0:	46bd      	mov	sp, r7
 80146a2:	bd80      	pop	{r7, pc}

080146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>:
 * 00       =   success
 * 01-0f    =   non-zero HRSLT
 *
 */
uint8_t USB::ctrlReq(uint8_t addr, uint8_t ep, uint8_t bmReqType, uint8_t bRequest, uint8_t wValLo, uint8_t wValHi,
        uint16_t wInd, uint16_t total, uint16_t nbytes, uint8_t* dataptr, USBReadParser *p) {
 80146a4:	b5b0      	push	{r4, r5, r7, lr}
 80146a6:	b08e      	sub	sp, #56	; 0x38
 80146a8:	af06      	add	r7, sp, #24
 80146aa:	6078      	str	r0, [r7, #4]
 80146ac:	70f9      	strb	r1, [r7, #3]
 80146ae:	70ba      	strb	r2, [r7, #2]
 80146b0:	707b      	strb	r3, [r7, #1]
        bool direction = false; //request direction, IN or OUT
 80146b2:	f04f 0300 	mov.w	r3, #0
 80146b6:	77bb      	strb	r3, [r7, #30]
        uint8_t rcode;
        SETUP_PKT setup_pkt;
        //USB_OTG_CORE_HANDLE *pdev = coreConfig;

        EpInfo *pep = NULL;
 80146b8:	f04f 0300 	mov.w	r3, #0
 80146bc:	60fb      	str	r3, [r7, #12]
        uint16_t nak_limit = 0;
 80146be:	f04f 0300 	mov.w	r3, #0
 80146c2:	817b      	strh	r3, [r7, #10]
/* the address are set by HC functions as 0*/
        rcode = SetAddress(addr, ep, &pep, nak_limit);
 80146c4:	78f9      	ldrb	r1, [r7, #3]
 80146c6:	78ba      	ldrb	r2, [r7, #2]
 80146c8:	f107 030c 	add.w	r3, r7, #12
 80146cc:	f107 000a 	add.w	r0, r7, #10
 80146d0:	9000      	str	r0, [sp, #0]
 80146d2:	6878      	ldr	r0, [r7, #4]
 80146d4:	f7ff ff8c 	bl	80145f0 <_ZN3USB10SetAddressEhhPP6EpInfoRt>
 80146d8:	4603      	mov	r3, r0
 80146da:	77fb      	strb	r3, [r7, #31]

        if (rcode)
 80146dc:	7ffb      	ldrb	r3, [r7, #31]
 80146de:	2b00      	cmp	r3, #0
 80146e0:	d001      	beq.n	80146e6 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x42>
			return rcode;
 80146e2:	7ffb      	ldrb	r3, [r7, #31]
 80146e4:	e0aa      	b.n	801483c <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x198>

        direction = ((bmReqType & 0x80) > 0);
 80146e6:	787b      	ldrb	r3, [r7, #1]
 80146e8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80146ec:	2b00      	cmp	r3, #0
 80146ee:	bfd4      	ite	le
 80146f0:	2300      	movle	r3, #0
 80146f2:	2301      	movgt	r3, #1
 80146f4:	77bb      	strb	r3, [r7, #30]

        /* fill in setup packet */
        setup_pkt.ReqType_u.bmRequestType = bmReqType;
 80146f6:	787b      	ldrb	r3, [r7, #1]
 80146f8:	743b      	strb	r3, [r7, #16]
        setup_pkt.bRequest = bRequest;
 80146fa:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 80146fe:	747b      	strb	r3, [r7, #17]
        setup_pkt.wVal_u.wValueLo = wValLo;
 8014700:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 8014704:	74bb      	strb	r3, [r7, #18]
        setup_pkt.wVal_u.wValueHi = wValHi;
 8014706:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 801470a:	74fb      	strb	r3, [r7, #19]
        setup_pkt.wIndex = wInd;
 801470c:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 801470e:	82bb      	strh	r3, [r7, #20]
        setup_pkt.wLength = total;
 8014710:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 8014714:	82fb      	strh	r3, [r7, #22]
		//		pdev->host.hc[pep->hcNumOut].dev_addr = addr;
		//	if(pdev->host.hc[pep->hcNumIn].dev_addr != addr)
		//		pdev->host.hc[pep->hcNumIn].dev_addr = addr;
        //}

        rcode = dispatchPkt(tokSETUP, ep, nak_limit, (uint8_t *)&setup_pkt, sizeof(setup_pkt), pep->hcNumOut, addr, pep->maxPktSize); //dispatch packet
 8014716:	897b      	ldrh	r3, [r7, #10]
 8014718:	68fa      	ldr	r2, [r7, #12]
 801471a:	78d2      	ldrb	r2, [r2, #3]
 801471c:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8014720:	b2d2      	uxtb	r2, r2
 8014722:	4610      	mov	r0, r2
 8014724:	68fa      	ldr	r2, [r7, #12]
 8014726:	7851      	ldrb	r1, [r2, #1]
 8014728:	78ba      	ldrb	r2, [r7, #2]
 801472a:	f107 0410 	add.w	r4, r7, #16
 801472e:	9400      	str	r4, [sp, #0]
 8014730:	f04f 0408 	mov.w	r4, #8
 8014734:	9401      	str	r4, [sp, #4]
 8014736:	9002      	str	r0, [sp, #8]
 8014738:	78f8      	ldrb	r0, [r7, #3]
 801473a:	9003      	str	r0, [sp, #12]
 801473c:	9104      	str	r1, [sp, #16]
 801473e:	6878      	ldr	r0, [r7, #4]
 8014740:	f04f 0110 	mov.w	r1, #16
 8014744:	f000 fb5c 	bl	8014e00 <_ZN3USB11dispatchPktEhhtPhthhh>
 8014748:	4603      	mov	r3, r0
 801474a:	77fb      	strb	r3, [r7, #31]

        if (rcode) //return HRSLT if not zero
 801474c:	7ffb      	ldrb	r3, [r7, #31]
 801474e:	2b00      	cmp	r3, #0
 8014750:	d001      	beq.n	8014756 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0xb2>
			return ( rcode);
 8014752:	7ffb      	ldrb	r3, [r7, #31]
 8014754:	e072      	b.n	801483c <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x198>

        if (dataptr != NULL) //data stage, if present
 8014756:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8014758:	2b00      	cmp	r3, #0
 801475a:	d044      	beq.n	80147e6 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x142>
        {
			if (direction) //IN transfer
 801475c:	7fbb      	ldrb	r3, [r7, #30]
 801475e:	2b00      	cmp	r3, #0
 8014760:	d02c      	beq.n	80147bc <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x118>
			{
				uint16_t left = total;
 8014762:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 8014766:	83bb      	strh	r3, [r7, #28]
#if 1
				pep->bmRcvToggle = 1; //bmRCVTOG1;
 8014768:	68fa      	ldr	r2, [r7, #12]
 801476a:	7913      	ldrb	r3, [r2, #4]
 801476c:	f043 0302 	orr.w	r3, r3, #2
 8014770:	7113      	strb	r3, [r2, #4]
				// instead by set in InTransfer
				//pdev->host.hc[pep->hcNumIn].toggle_in = 0x1;
				//pep->bmRcvToggle = pdev->host.hc[pep->hcNumIn].toggle_in;
				uint16_t read = total;	//nbytes;
 8014772:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 8014776:	813b      	strh	r3, [r7, #8]
				rcode = InTransfer(pep, nak_limit, &read, dataptr);
 8014778:	68f9      	ldr	r1, [r7, #12]
 801477a:	897a      	ldrh	r2, [r7, #10]
 801477c:	f107 0308 	add.w	r3, r7, #8
 8014780:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8014782:	9000      	str	r0, [sp, #0]
 8014784:	6878      	ldr	r0, [r7, #4]
 8014786:	f000 f897 	bl	80148b8 <_ZN3USB10InTransferEP6EpInfotPtPh>
 801478a:	4603      	mov	r3, r0
 801478c:	77fb      	strb	r3, [r7, #31]

				// Invoke callback function if inTransfer completed successfully and callback function pointer is specified
				if (!rcode && p)
 801478e:	7ffb      	ldrb	r3, [r7, #31]
 8014790:	2b00      	cmp	r3, #0
 8014792:	d123      	bne.n	80147dc <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x138>
 8014794:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8014796:	2b00      	cmp	r3, #0
 8014798:	d020      	beq.n	80147dc <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x138>
					((USBReadParser*)p)->Parse(read, dataptr, total - left);
 801479a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801479c:	681b      	ldr	r3, [r3, #0]
 801479e:	681c      	ldr	r4, [r3, #0]
 80147a0:	893a      	ldrh	r2, [r7, #8]
 80147a2:	f8b7 1040 	ldrh.w	r1, [r7, #64]	; 0x40
 80147a6:	8bbb      	ldrh	r3, [r7, #28]
 80147a8:	1acb      	subs	r3, r1, r3
 80147aa:	b29b      	uxth	r3, r3
 80147ac:	837b      	strh	r3, [r7, #26]
 80147ae:	f107 031a 	add.w	r3, r7, #26
 80147b2:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 80147b4:	4611      	mov	r1, r2
 80147b6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80147b8:	47a0      	blx	r4
 80147ba:	e00f      	b.n	80147dc <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x138>
						break;
				}
#endif
			} else //OUT transfer
			{
				pep->bmSndToggle = 1; //bmSNDTOG1;
 80147bc:	68fa      	ldr	r2, [r7, #12]
 80147be:	7913      	ldrb	r3, [r2, #4]
 80147c0:	f043 0301 	orr.w	r3, r3, #1
 80147c4:	7113      	strb	r3, [r2, #4]
				// instead by set in OutTransfer
				//pdev->host.hc[pep->hcNumOut].toggle_out = 0x1;
				//pep->bmSndToggle = pdev->host.hc[pep->hcNumOut].toggle_out;
				rcode = OutTransfer(pep, nak_limit, nbytes, dataptr);
 80147c6:	68f9      	ldr	r1, [r7, #12]
 80147c8:	897a      	ldrh	r2, [r7, #10]
 80147ca:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 80147ce:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 80147d0:	9000      	str	r0, [sp, #0]
 80147d2:	6878      	ldr	r0, [r7, #4]
 80147d4:	f000 f95a 	bl	8014a8c <_ZN3USB11OutTransferEP6EpInfottPKh>
 80147d8:	4603      	mov	r3, r0
 80147da:	77fb      	strb	r3, [r7, #31]
			}
			if (rcode) //return error
 80147dc:	7ffb      	ldrb	r3, [r7, #31]
 80147de:	2b00      	cmp	r3, #0
 80147e0:	d001      	beq.n	80147e6 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x142>
				return ( rcode);
 80147e2:	7ffb      	ldrb	r3, [r7, #31]
 80147e4:	e02a      	b.n	801483c <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x198>
        }
        // Status stage
        return dispatchPkt((direction) ? tokOUTHS : tokINHS, ep, nak_limit, NULL, 0, (direction) ? pep->hcNumOut : pep->hcNumIn, addr, pep->maxPktSize);	//GET if direction
 80147e6:	7fbb      	ldrb	r3, [r7, #30]
 80147e8:	2b00      	cmp	r3, #0
 80147ea:	d002      	beq.n	80147f2 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x14e>
 80147ec:	f04f 03a0 	mov.w	r3, #160	; 0xa0
 80147f0:	e001      	b.n	80147f6 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x152>
 80147f2:	f04f 0380 	mov.w	r3, #128	; 0x80
 80147f6:	897c      	ldrh	r4, [r7, #10]
 80147f8:	7fba      	ldrb	r2, [r7, #30]
 80147fa:	2a00      	cmp	r2, #0
 80147fc:	d005      	beq.n	801480a <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x166>
 80147fe:	68fa      	ldr	r2, [r7, #12]
 8014800:	78d2      	ldrb	r2, [r2, #3]
 8014802:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8014806:	b2d2      	uxtb	r2, r2
 8014808:	e004      	b.n	8014814 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x170>
 801480a:	68fa      	ldr	r2, [r7, #12]
 801480c:	78d2      	ldrb	r2, [r2, #3]
 801480e:	f3c2 0203 	ubfx	r2, r2, #0, #4
 8014812:	b2d2      	uxtb	r2, r2
 8014814:	68f9      	ldr	r1, [r7, #12]
 8014816:	7849      	ldrb	r1, [r1, #1]
 8014818:	78bd      	ldrb	r5, [r7, #2]
 801481a:	f04f 0000 	mov.w	r0, #0
 801481e:	9000      	str	r0, [sp, #0]
 8014820:	f04f 0000 	mov.w	r0, #0
 8014824:	9001      	str	r0, [sp, #4]
 8014826:	9202      	str	r2, [sp, #8]
 8014828:	78fa      	ldrb	r2, [r7, #3]
 801482a:	9203      	str	r2, [sp, #12]
 801482c:	9104      	str	r1, [sp, #16]
 801482e:	6878      	ldr	r0, [r7, #4]
 8014830:	4619      	mov	r1, r3
 8014832:	462a      	mov	r2, r5
 8014834:	4623      	mov	r3, r4
 8014836:	f000 fae3 	bl	8014e00 <_ZN3USB11dispatchPktEhhtPhthhh>
 801483a:	4603      	mov	r3, r0
 801483c:	e003      	b.n	8014846 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x1a2>
 801483e:	e000      	b.n	8014842 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x19e>
 8014840:	e7ff      	b.n	8014842 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser+0x19e>
 8014842:	f008 f91d 	bl	801ca80 <__cxa_end_cleanup>
}
 8014846:	4618      	mov	r0, r3
 8014848:	f107 0720 	add.w	r7, r7, #32
 801484c:	46bd      	mov	sp, r7
 801484e:	bdb0      	pop	{r4, r5, r7, pc}

08014850 <_ZN3USB10inTransferEhhPtPh>:
/* IN transfer to arbitrary endpoint. Assumes PERADDR is set. Handles multiple packets if necessary. Transfers 'nbytes' bytes. */
/* Keep sending INs and writes data to memory area pointed by 'data'                                                           */

/* rcode 0 if no errors. rcode 01-0f is relayed from dispatchPkt(). Rcode f0 means RCVDAVIRQ error,
            fe USB xfer timeout */
uint8_t USB::inTransfer(uint8_t addr, uint8_t ep, uint16_t *nbytesptr, uint8_t* data) {
 8014850:	b580      	push	{r7, lr}
 8014852:	b08a      	sub	sp, #40	; 0x28
 8014854:	af02      	add	r7, sp, #8
 8014856:	60f8      	str	r0, [r7, #12]
 8014858:	607b      	str	r3, [r7, #4]
 801485a:	460b      	mov	r3, r1
 801485c:	72fb      	strb	r3, [r7, #11]
 801485e:	4613      	mov	r3, r2
 8014860:	72bb      	strb	r3, [r7, #10]
	EpInfo *pep = NULL;
 8014862:	f04f 0300 	mov.w	r3, #0
 8014866:	61bb      	str	r3, [r7, #24]
	uint16_t nak_limit = 0;
 8014868:	f04f 0300 	mov.w	r3, #0
 801486c:	82fb      	strh	r3, [r7, #22]
	uint8_t rcode = SetAddress(addr, ep, &pep, nak_limit);
 801486e:	7af9      	ldrb	r1, [r7, #11]
 8014870:	7aba      	ldrb	r2, [r7, #10]
 8014872:	f107 0318 	add.w	r3, r7, #24
 8014876:	f107 0016 	add.w	r0, r7, #22
 801487a:	9000      	str	r0, [sp, #0]
 801487c:	68f8      	ldr	r0, [r7, #12]
 801487e:	f7ff feb7 	bl	80145f0 <_ZN3USB10SetAddressEhhPP6EpInfoRt>
 8014882:	4603      	mov	r3, r0
 8014884:	77fb      	strb	r3, [r7, #31]

	if (rcode) {
 8014886:	7ffb      	ldrb	r3, [r7, #31]
 8014888:	2b00      	cmp	r3, #0
 801488a:	d001      	beq.n	8014890 <_ZN3USB10inTransferEhhPtPh+0x40>
		//xprintf("SetAddress Failed");
		return rcode;
 801488c:	7ffb      	ldrb	r3, [r7, #31]
 801488e:	e00a      	b.n	80148a6 <_ZN3USB10inTransferEhhPtPh+0x56>
	}

	return InTransfer(pep, nak_limit, nbytesptr, data);
 8014890:	69ba      	ldr	r2, [r7, #24]
 8014892:	8afb      	ldrh	r3, [r7, #22]
 8014894:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8014896:	9100      	str	r1, [sp, #0]
 8014898:	68f8      	ldr	r0, [r7, #12]
 801489a:	4611      	mov	r1, r2
 801489c:	461a      	mov	r2, r3
 801489e:	687b      	ldr	r3, [r7, #4]
 80148a0:	f000 f80a 	bl	80148b8 <_ZN3USB10InTransferEP6EpInfotPtPh>
 80148a4:	4603      	mov	r3, r0
 80148a6:	e001      	b.n	80148ac <_ZN3USB10inTransferEhhPtPh+0x5c>
 80148a8:	f008 f8ea 	bl	801ca80 <__cxa_end_cleanup>
}
 80148ac:	4618      	mov	r0, r3
 80148ae:	f107 0720 	add.w	r7, r7, #32
 80148b2:	46bd      	mov	sp, r7
 80148b4:	bd80      	pop	{r7, pc}
 80148b6:	bf00      	nop

080148b8 <_ZN3USB10InTransferEP6EpInfotPtPh>:

uint8_t USB::InTransfer(EpInfo *pep, uint16_t nak_limit, uint16_t *nbytesptr, uint8_t* data) {
 80148b8:	b5b0      	push	{r4, r5, r7, lr}
 80148ba:	b08e      	sub	sp, #56	; 0x38
 80148bc:	af06      	add	r7, sp, #24
 80148be:	60f8      	str	r0, [r7, #12]
 80148c0:	60b9      	str	r1, [r7, #8]
 80148c2:	603b      	str	r3, [r7, #0]
 80148c4:	4613      	mov	r3, r2
 80148c6:	80fb      	strh	r3, [r7, #6]
	uint8_t rcode = 0;
 80148c8:	f04f 0300 	mov.w	r3, #0
 80148cc:	77fb      	strb	r3, [r7, #31]
	//uint8_t pktsize;

	uint16_t nbytes = *nbytesptr;
 80148ce:	683b      	ldr	r3, [r7, #0]
 80148d0:	881b      	ldrh	r3, [r3, #0]
 80148d2:	83bb      	strh	r3, [r7, #28]
	//xprintf("Requesting %i bytes ", nbytes);
	uint16_t maxpktsize = pep->maxPktSize;
 80148d4:	68bb      	ldr	r3, [r7, #8]
 80148d6:	785b      	ldrb	r3, [r3, #1]
 80148d8:	837b      	strh	r3, [r7, #26]
	//USB_OTG_CORE_HANDLE *pdev = coreConfig;
	uint32_t hcnum = pep->hcNumIn;	//pdev->host.hc_num_in;
 80148da:	68bb      	ldr	r3, [r7, #8]
 80148dc:	78db      	ldrb	r3, [r3, #3]
 80148de:	f3c3 0303 	ubfx	r3, r3, #0, #4
 80148e2:	b2db      	uxtb	r3, r3
 80148e4:	617b      	str	r3, [r7, #20]
	pdev->host.hc[hcnum].xfer_buff = data;
	pdev->host.hc[hcnum].xfer_len = nbytes;

	HCD_SubmitRequest(pdev, hcnum);
#else	// get one packet per transfer.
	*nbytesptr = 0;	// 1. means how many bytes was received.
 80148e6:	683b      	ldr	r3, [r7, #0]
 80148e8:	f04f 0200 	mov.w	r2, #0
 80148ec:	801a      	strh	r2, [r3, #0]
	//if(ep_addr != pdev->host.hc[hcnum].ep_num)
	//	pdev->host.hc[hcnum].ep_num = ep_addr;
	// todo : i insist these state variables, like toggle flag, should be maintained at bsp side.
	//if(pep->bmRcvToggle != pdev->host.hc[hcnum].toggle_in)	// for hid composite
	//	pdev->host.hc[hcnum].toggle_in = pep->bmRcvToggle;
	usbhost_cb->set_toggle_cb(hcnum, tokIN, pep->bmRcvToggle);
 80148ee:	f243 6310 	movw	r3, #13840	; 0x3610
 80148f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80148f6:	681b      	ldr	r3, [r3, #0]
 80148f8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80148fa:	697a      	ldr	r2, [r7, #20]
 80148fc:	b2d1      	uxtb	r1, r2
 80148fe:	68ba      	ldr	r2, [r7, #8]
 8014900:	7912      	ldrb	r2, [r2, #4]
 8014902:	f3c2 0240 	ubfx	r2, r2, #1, #1
 8014906:	b2d2      	uxtb	r2, r2
 8014908:	4608      	mov	r0, r1
 801490a:	f04f 0100 	mov.w	r1, #0
 801490e:	4798      	blx	r3


	while (1) // use a 'return' to exit this loop
	{
		rcode = dispatchPkt(tokIN, pep->epAddr, nak_limit, data, nbytes, hcnum, pep->hcDevAddr, pep->maxPktSize); //IN packet to EP-'endpoint'. Function takes care of NAKS.
 8014910:	68bb      	ldr	r3, [r7, #8]
 8014912:	781a      	ldrb	r2, [r3, #0]
 8014914:	697b      	ldr	r3, [r7, #20]
 8014916:	b2dc      	uxtb	r4, r3
 8014918:	68bb      	ldr	r3, [r7, #8]
 801491a:	7898      	ldrb	r0, [r3, #2]
 801491c:	68bb      	ldr	r3, [r7, #8]
 801491e:	7859      	ldrb	r1, [r3, #1]
 8014920:	88fb      	ldrh	r3, [r7, #6]
 8014922:	6b3d      	ldr	r5, [r7, #48]	; 0x30
 8014924:	9500      	str	r5, [sp, #0]
 8014926:	8bbd      	ldrh	r5, [r7, #28]
 8014928:	9501      	str	r5, [sp, #4]
 801492a:	9402      	str	r4, [sp, #8]
 801492c:	9003      	str	r0, [sp, #12]
 801492e:	9104      	str	r1, [sp, #16]
 8014930:	68f8      	ldr	r0, [r7, #12]
 8014932:	f04f 0100 	mov.w	r1, #0
 8014936:	f000 fa63 	bl	8014e00 <_ZN3USB11dispatchPktEhhtPhthhh>
 801493a:	4603      	mov	r3, r0
 801493c:	77fb      	strb	r3, [r7, #31]
		if (rcode == hrTOGERR) {
 801493e:	7ffb      	ldrb	r3, [r7, #31]
 8014940:	2b06      	cmp	r3, #6
 8014942:	d13e      	bne.n	80149c2 <_ZN3USB10InTransferEP6EpInfotPtPh+0x10a>
			// yes, we flip it wrong here so that next time it is actually correct!
//			pep->bmRcvToggle = (regRd(rHRSL) & bmSNDTOGRD) ? 0 : 1;
//			regWr(rHCTL, (pep->bmRcvToggle) ? bmRCVTOG1 : bmRCVTOG0); //set toggle value
			//pdev->host.hc[hcnum].toggle_in ^= 0x1;	//btd hci case
			pep->bmRcvToggle = (usbhost_cb->get_toggle_cb(hcnum, tokIN)) ? 0 : 1;
 8014944:	f243 6310 	movw	r3, #13840	; 0x3610
 8014948:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801494c:	681b      	ldr	r3, [r3, #0]
 801494e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014950:	697a      	ldr	r2, [r7, #20]
 8014952:	b2d2      	uxtb	r2, r2
 8014954:	4610      	mov	r0, r2
 8014956:	f04f 0100 	mov.w	r1, #0
 801495a:	4798      	blx	r3
 801495c:	4603      	mov	r3, r0
 801495e:	2b00      	cmp	r3, #0
 8014960:	bf14      	ite	ne
 8014962:	2300      	movne	r3, #0
 8014964:	2301      	moveq	r3, #1
 8014966:	b2d9      	uxtb	r1, r3
 8014968:	68ba      	ldr	r2, [r7, #8]
 801496a:	7913      	ldrb	r3, [r2, #4]
 801496c:	f361 0341 	bfi	r3, r1, #1, #1
 8014970:	7113      	strb	r3, [r2, #4]
			usbhost_cb->set_toggle_cb(hcnum, tokIN, pep->bmRcvToggle);
 8014972:	f243 6310 	movw	r3, #13840	; 0x3610
 8014976:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801497a:	681b      	ldr	r3, [r3, #0]
 801497c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801497e:	697a      	ldr	r2, [r7, #20]
 8014980:	b2d1      	uxtb	r1, r2
 8014982:	68ba      	ldr	r2, [r7, #8]
 8014984:	7912      	ldrb	r2, [r2, #4]
 8014986:	f3c2 0240 	ubfx	r2, r2, #1, #1
 801498a:	b2d2      	uxtb	r2, r2
 801498c:	4608      	mov	r0, r1
 801498e:	f04f 0100 	mov.w	r1, #0
 8014992:	4798      	blx	r3
			USBTRACE2("\nInXfer - toggle err, hc num=%d", hcnum);	// will meet toggle error here? todo: sometimes once unplugged device, there is small chance that Poll still works here.
 8014994:	f24e 7010 	movw	r0, #59152	; 0xe710
 8014998:	f6c0 0001 	movt	r0, #2049	; 0x801
 801499c:	f04f 0180 	mov.w	r1, #128	; 0x80
 80149a0:	f004 fd08 	bl	80193b4 <_Z8E_NotifyPKci>
 80149a4:	697b      	ldr	r3, [r7, #20]
 80149a6:	b2db      	uxtb	r3, r3
 80149a8:	4618      	mov	r0, r3
 80149aa:	f04f 0180 	mov.w	r1, #128	; 0x80
 80149ae:	f001 fa6b 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 80149b2:	f24e 7030 	movw	r0, #59184	; 0xe730
 80149b6:	f6c0 0001 	movt	r0, #2049	; 0x801
 80149ba:	f04f 0180 	mov.w	r1, #128	; 0x80
 80149be:	f004 fcf9 	bl	80193b4 <_Z8E_NotifyPKci>
			//continue;
		}
		if (rcode) {
 80149c2:	7ffb      	ldrb	r3, [r7, #31]
 80149c4:	2b00      	cmp	r3, #0
 80149c6:	d12a      	bne.n	8014a1e <_ZN3USB10InTransferEP6EpInfotPtPh+0x166>
//			mem_left = 0;

//		data = bytesRd(rRCVFIFO, ((pktsize > mem_left) ? mem_left : pktsize), data);

//		regWr(rHIRQ, bmRCVDAVIRQ); // Clear the IRQ & free the buffer
		*nbytesptr += usbhost_cb->get_received_bytes_cb(hcnum);	//pdev->host.XferCnt[hcnum];	//pktsize; // add this packet's byte count to total transfer length
 80149c8:	f243 6310 	movw	r3, #13840	; 0x3610
 80149cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80149d0:	681b      	ldr	r3, [r3, #0]
 80149d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80149d4:	697a      	ldr	r2, [r7, #20]
 80149d6:	b2d2      	uxtb	r2, r2
 80149d8:	4610      	mov	r0, r2
 80149da:	4798      	blx	r3
 80149dc:	4603      	mov	r3, r0
 80149de:	683a      	ldr	r2, [r7, #0]
 80149e0:	8812      	ldrh	r2, [r2, #0]
 80149e2:	18d3      	adds	r3, r2, r3
 80149e4:	b29a      	uxth	r2, r3
 80149e6:	683b      	ldr	r3, [r7, #0]
 80149e8:	801a      	strh	r2, [r3, #0]
		//if ((pktsize < maxpktsize) || (*nbytesptr >= nbytes)) // have we transferred 'nbytes' bytes?
		{	// thanks to large fifo on stm32, we don't need packet by packet handling.
			// Save toggle value
			// the toggle is flipped at interrupt handler.
			//pep->bmRcvToggle = ((regRd(rHRSL) & bmRCVTOGRD)) ? 1 : 0;
			pep->bmRcvToggle = usbhost_cb->get_toggle_cb(hcnum, tokIN);	//pdev->host.hc[hcnum].toggle_in;	//save last toggle
 80149ea:	f243 6310 	movw	r3, #13840	; 0x3610
 80149ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80149f2:	681b      	ldr	r3, [r3, #0]
 80149f4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80149f6:	697a      	ldr	r2, [r7, #20]
 80149f8:	b2d2      	uxtb	r2, r2
 80149fa:	4610      	mov	r0, r2
 80149fc:	f04f 0100 	mov.w	r1, #0
 8014a00:	4798      	blx	r3
 8014a02:	4603      	mov	r3, r0
 8014a04:	b2db      	uxtb	r3, r3
 8014a06:	f003 0301 	and.w	r3, r3, #1
 8014a0a:	b2d9      	uxtb	r1, r3
 8014a0c:	68ba      	ldr	r2, [r7, #8]
 8014a0e:	7913      	ldrb	r3, [r2, #4]
 8014a10:	f361 0341 	bfi	r3, r1, #1, #1
 8014a14:	7113      	strb	r3, [r2, #4]
			//xprintf("\r\n");

			rcode = 0;
 8014a16:	f04f 0300 	mov.w	r3, #0
 8014a1a:	77fb      	strb	r3, [r7, #31]
			break;
 8014a1c:	e000      	b.n	8014a20 <_ZN3USB10InTransferEP6EpInfotPtPh+0x168>
			USBTRACE2("\nInXfer - toggle err, hc num=%d", hcnum);	// will meet toggle error here? todo: sometimes once unplugged device, there is small chance that Poll still works here.
			//continue;
		}
		if (rcode) {
			//xprintf("\r\n>>>>>>>> Problem! dispatchPkt %d", rcode);
			break; //should be 0, indicating ACK. Else return error code.
 8014a1e:	bf00      	nop
			rcode = 0;
			break;
		} // if
	} //while( 1 )
#endif		
	return ( rcode);
 8014a20:	7ffb      	ldrb	r3, [r7, #31]
}
 8014a22:	4618      	mov	r0, r3
 8014a24:	f107 0720 	add.w	r7, r7, #32
 8014a28:	46bd      	mov	sp, r7
 8014a2a:	bdb0      	pop	{r4, r5, r7, pc}

08014a2c <_ZN3USB11outTransferEhhtPKh>:

/* OUT transfer to arbitrary endpoint. Handles multiple packets if necessary. Transfers 'nbytes' bytes. */
/* Handles NAK bug per Maxim Application Note 4000 for single buffer transfer   */

/* rcode 0 if no errors. rcode 01-0f is relayed from HRSL                       */
uint8_t USB::outTransfer(uint8_t addr, uint8_t ep, uint16_t nbytes, const uint8_t* data) {
 8014a2c:	b580      	push	{r7, lr}
 8014a2e:	b088      	sub	sp, #32
 8014a30:	af02      	add	r7, sp, #8
 8014a32:	6078      	str	r0, [r7, #4]
 8014a34:	70f9      	strb	r1, [r7, #3]
 8014a36:	70ba      	strb	r2, [r7, #2]
 8014a38:	803b      	strh	r3, [r7, #0]
        EpInfo *pep = NULL;
 8014a3a:	f04f 0300 	mov.w	r3, #0
 8014a3e:	613b      	str	r3, [r7, #16]
        uint16_t nak_limit = 0;
 8014a40:	f04f 0300 	mov.w	r3, #0
 8014a44:	81fb      	strh	r3, [r7, #14]

        uint8_t rcode = SetAddress(addr, ep, &pep, nak_limit);
 8014a46:	78f9      	ldrb	r1, [r7, #3]
 8014a48:	78ba      	ldrb	r2, [r7, #2]
 8014a4a:	f107 0310 	add.w	r3, r7, #16
 8014a4e:	f107 000e 	add.w	r0, r7, #14
 8014a52:	9000      	str	r0, [sp, #0]
 8014a54:	6878      	ldr	r0, [r7, #4]
 8014a56:	f7ff fdcb 	bl	80145f0 <_ZN3USB10SetAddressEhhPP6EpInfoRt>
 8014a5a:	4603      	mov	r3, r0
 8014a5c:	75fb      	strb	r3, [r7, #23]

        if (rcode)
 8014a5e:	7dfb      	ldrb	r3, [r7, #23]
 8014a60:	2b00      	cmp	r3, #0
 8014a62:	d001      	beq.n	8014a68 <_ZN3USB11outTransferEhhtPKh+0x3c>
			return rcode;
 8014a64:	7dfb      	ldrb	r3, [r7, #23]
 8014a66:	e008      	b.n	8014a7a <_ZN3USB11outTransferEhhtPKh+0x4e>

        return OutTransfer(pep, nak_limit, nbytes, data);
 8014a68:	6939      	ldr	r1, [r7, #16]
 8014a6a:	89fa      	ldrh	r2, [r7, #14]
 8014a6c:	883b      	ldrh	r3, [r7, #0]
 8014a6e:	6a38      	ldr	r0, [r7, #32]
 8014a70:	9000      	str	r0, [sp, #0]
 8014a72:	6878      	ldr	r0, [r7, #4]
 8014a74:	f000 f80a 	bl	8014a8c <_ZN3USB11OutTransferEP6EpInfottPKh>
 8014a78:	4603      	mov	r3, r0
 8014a7a:	e001      	b.n	8014a80 <_ZN3USB11outTransferEhhtPKh+0x54>
 8014a7c:	f008 f800 	bl	801ca80 <__cxa_end_cleanup>
}
 8014a80:	4618      	mov	r0, r3
 8014a82:	f107 0718 	add.w	r7, r7, #24
 8014a86:	46bd      	mov	sp, r7
 8014a88:	bd80      	pop	{r7, pc}
 8014a8a:	bf00      	nop

08014a8c <_ZN3USB11OutTransferEP6EpInfottPKh>:

uint8_t USB::OutTransfer(EpInfo *pep, uint16_t nak_limit, const uint16_t nbytes, const uint8_t *data) {
 8014a8c:	b590      	push	{r4, r7, lr}
 8014a8e:	b08f      	sub	sp, #60	; 0x3c
 8014a90:	af02      	add	r7, sp, #8
 8014a92:	60f8      	str	r0, [r7, #12]
 8014a94:	60b9      	str	r1, [r7, #8]
 8014a96:	80fa      	strh	r2, [r7, #6]
 8014a98:	80bb      	strh	r3, [r7, #4]
	uint8_t rcode = hrSUCCESS, retry_count;
 8014a9a:	f04f 0300 	mov.w	r3, #0
 8014a9e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	const uint8_t *data_p = data; //local copy of the data pointer
 8014aa2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014aa4:	62bb      	str	r3, [r7, #40]	; 0x28
	uint16_t bytes_tosend, nak_count;
	uint16_t bytes_left = nbytes;	//, last_bytesleft = nbytes;
 8014aa6:	88bb      	ldrh	r3, [r7, #4]
 8014aa8:	84bb      	strh	r3, [r7, #36]	; 0x24
	//USB_OTG_CORE_HANDLE *pdev = coreConfig;
	uint32_t hcnum = pep->hcNumOut;
 8014aaa:	68bb      	ldr	r3, [r7, #8]
 8014aac:	78db      	ldrb	r3, [r3, #3]
 8014aae:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8014ab2:	b2db      	uxtb	r3, r3
 8014ab4:	623b      	str	r3, [r7, #32]

	uint8_t maxpktsize = pep->maxPktSize;
 8014ab6:	68bb      	ldr	r3, [r7, #8]
 8014ab8:	785b      	ldrb	r3, [r3, #1]
 8014aba:	77fb      	strb	r3, [r7, #31]

	if (maxpktsize < 1 || maxpktsize > 64)
 8014abc:	7ffb      	ldrb	r3, [r7, #31]
 8014abe:	2b00      	cmp	r3, #0
 8014ac0:	d002      	beq.n	8014ac8 <_ZN3USB11OutTransferEP6EpInfottPKh+0x3c>
 8014ac2:	7ffb      	ldrb	r3, [r7, #31]
 8014ac4:	2b40      	cmp	r3, #64	; 0x40
 8014ac6:	d902      	bls.n	8014ace <_ZN3USB11OutTransferEP6EpInfottPKh+0x42>
		return USB_ERROR_INVALID_MAX_PKT_SIZE;
 8014ac8:	f04f 03da 	mov.w	r3, #218	; 0xda
 8014acc:	e193      	b.n	8014df6 <_ZN3USB11OutTransferEP6EpInfottPKh+0x36a>
	// should already be updated when do enum, and call open_channel.
	//if(maxpktsize != pdev->host.hc[hcnum].max_packet)
	//	pdev->host.hc[hcnum].max_packet = maxpktsize;

	unsigned long timeout = millis() + USB_XFER_TIMEOUT;
 8014ace:	f243 630c 	movw	r3, #13836	; 0x360c
 8014ad2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014ad6:	681b      	ldr	r3, [r3, #0]
 8014ad8:	689b      	ldr	r3, [r3, #8]
 8014ada:	4798      	blx	r3
 8014adc:	4603      	mov	r3, r0
 8014ade:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 8014ae2:	f103 0310 	add.w	r3, r3, #16
 8014ae6:	61bb      	str	r3, [r7, #24]

	//regWr(rHCTL, (pep->bmSndToggle) ? bmSNDTOG1 : bmSNDTOG0); //set toggle value
	usbhost_cb->set_toggle_cb(hcnum, tokOUT, pep->bmSndToggle);
 8014ae8:	f243 6310 	movw	r3, #13840	; 0x3610
 8014aec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014af0:	681b      	ldr	r3, [r3, #0]
 8014af2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014af4:	6a3a      	ldr	r2, [r7, #32]
 8014af6:	b2d1      	uxtb	r1, r2
 8014af8:	68ba      	ldr	r2, [r7, #8]
 8014afa:	7912      	ldrb	r2, [r2, #4]
 8014afc:	f3c2 0200 	ubfx	r2, r2, #0, #1
 8014b00:	b2d2      	uxtb	r2, r2
 8014b02:	4608      	mov	r0, r1
 8014b04:	f04f 0120 	mov.w	r1, #32
 8014b08:	4798      	blx	r3

	while (bytes_left) {
 8014b0a:	e153      	b.n	8014db4 <_ZN3USB11OutTransferEP6EpInfottPKh+0x328>
		retry_count = 0;
 8014b0c:	f04f 0300 	mov.w	r3, #0
 8014b10:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
		nak_count = 0;
 8014b14:	f04f 0300 	mov.w	r3, #0
 8014b18:	84fb      	strh	r3, [r7, #38]	; 0x26
		bytes_tosend = (bytes_left >= maxpktsize) ? maxpktsize : bytes_left;
 8014b1a:	7ffb      	ldrb	r3, [r7, #31]
 8014b1c:	b29a      	uxth	r2, r3
 8014b1e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8014b20:	429a      	cmp	r2, r3
 8014b22:	bf38      	it	cc
 8014b24:	4613      	movcc	r3, r2
 8014b26:	82fb      	strh	r3, [r7, #22]

		//bytesWr(rSNDFIFO, bytes_tosend, data_p); //filling output FIFO
		//regWr(rSNDBC, bytes_tosend); //set number of bytes
		//regWr(rHXFR, (tokOUT | pep->epAddr)); //dispatch packet
		//USBH_BulkSendData(pdev, data_p, bytes_tosend, hcnum);
		usbhost_cb->out_transfer_cb(data_p, bytes_tosend, hcnum, pep->epAddr, pep->maxPktSize);
 8014b28:	f243 6310 	movw	r3, #13840	; 0x3610
 8014b2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014b30:	681b      	ldr	r3, [r3, #0]
 8014b32:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 8014b34:	6a3b      	ldr	r3, [r7, #32]
 8014b36:	b2da      	uxtb	r2, r3
 8014b38:	68bb      	ldr	r3, [r7, #8]
 8014b3a:	781b      	ldrb	r3, [r3, #0]
 8014b3c:	68b9      	ldr	r1, [r7, #8]
 8014b3e:	7848      	ldrb	r0, [r1, #1]
 8014b40:	8af9      	ldrh	r1, [r7, #22]
 8014b42:	9000      	str	r0, [sp, #0]
 8014b44:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8014b46:	47a0      	blx	r4
		//while (!(regRd(rHIRQ) & bmHXFRDNIRQ)); //wait for the completion IRQ
		//regWr(rHIRQ, bmHXFRDNIRQ); //clear IRQ
		while ((long)(millis() - timeout) < 0L) {
 8014b48:	e015      	b.n	8014b76 <_ZN3USB11OutTransferEP6EpInfottPKh+0xea>
			rcode = usbhost_cb->get_urb_status_cb(hcnum);	//HCD_GetURB_State(pdev, hcnum);
 8014b4a:	f243 6310 	movw	r3, #13840	; 0x3610
 8014b4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014b52:	681b      	ldr	r3, [r3, #0]
 8014b54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014b56:	6a3a      	ldr	r2, [r7, #32]
 8014b58:	b2d2      	uxtb	r2, r2
 8014b5a:	4610      	mov	r0, r2
 8014b5c:	4798      	blx	r3
 8014b5e:	4603      	mov	r3, r0
 8014b60:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
			if (rcode != eUrbIdle) {
 8014b64:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8014b68:	2b00      	cmp	r3, #0
 8014b6a:	d004      	beq.n	8014b76 <_ZN3USB11OutTransferEP6EpInfottPKh+0xea>
				rcode = 0x00;
 8014b6c:	f04f 0300 	mov.w	r3, #0
 8014b70:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
				break;
 8014b74:	e00f      	b.n	8014b96 <_ZN3USB11OutTransferEP6EpInfottPKh+0x10a>
		//regWr(rHXFR, (tokOUT | pep->epAddr)); //dispatch packet
		//USBH_BulkSendData(pdev, data_p, bytes_tosend, hcnum);
		usbhost_cb->out_transfer_cb(data_p, bytes_tosend, hcnum, pep->epAddr, pep->maxPktSize);
		//while (!(regRd(rHIRQ) & bmHXFRDNIRQ)); //wait for the completion IRQ
		//regWr(rHIRQ, bmHXFRDNIRQ); //clear IRQ
		while ((long)(millis() - timeout) < 0L) {
 8014b76:	f243 630c 	movw	r3, #13836	; 0x360c
 8014b7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014b7e:	681b      	ldr	r3, [r3, #0]
 8014b80:	689b      	ldr	r3, [r3, #8]
 8014b82:	4798      	blx	r3
 8014b84:	4603      	mov	r3, r0
 8014b86:	461a      	mov	r2, r3
 8014b88:	69bb      	ldr	r3, [r7, #24]
 8014b8a:	1ad3      	subs	r3, r2, r3
 8014b8c:	ea4f 73d3 	mov.w	r3, r3, lsr #31
 8014b90:	b2db      	uxtb	r3, r3
 8014b92:	2b00      	cmp	r3, #0
 8014b94:	d1d9      	bne.n	8014b4a <_ZN3USB11OutTransferEP6EpInfottPKh+0xbe>
				break;
			}
		}

		//rcode = (regRd(rHRSL) & 0x0f);
		rcode = usbhost_cb->get_pipe_status_cb(hcnum);	//HCD_GetHCState(pdev, hcnum);
 8014b96:	f243 6310 	movw	r3, #13840	; 0x3610
 8014b9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014b9e:	681b      	ldr	r3, [r3, #0]
 8014ba0:	6a1b      	ldr	r3, [r3, #32]
 8014ba2:	6a3a      	ldr	r2, [r7, #32]
 8014ba4:	b2d2      	uxtb	r2, r2
 8014ba6:	4610      	mov	r0, r2
 8014ba8:	4798      	blx	r3
 8014baa:	4603      	mov	r3, r0
 8014bac:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		while (rcode && ((long)(millis() - timeout) < 0L)) {
 8014bb0:	e0df      	b.n	8014d72 <_ZN3USB11OutTransferEP6EpInfottPKh+0x2e6>
			switch (rcode) {
 8014bb2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8014bb6:	2b06      	cmp	r3, #6
 8014bb8:	d062      	beq.n	8014c80 <_ZN3USB11OutTransferEP6EpInfottPKh+0x1f4>
 8014bba:	2b0e      	cmp	r3, #14
 8014bbc:	d03e      	beq.n	8014c3c <_ZN3USB11OutTransferEP6EpInfottPKh+0x1b0>
 8014bbe:	2b04      	cmp	r3, #4
 8014bc0:	f040 808f 	bne.w	8014ce2 <_ZN3USB11OutTransferEP6EpInfottPKh+0x256>
				case hrNAK:
					nak_count++;	//maybe a NOT_READY happens
 8014bc4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8014bc6:	f103 0301 	add.w	r3, r3, #1
 8014bca:	84fb      	strh	r3, [r7, #38]	; 0x26
					if (nak_limit && (nak_count == nak_limit)) {
 8014bcc:	88fb      	ldrh	r3, [r7, #6]
 8014bce:	2b00      	cmp	r3, #0
 8014bd0:	f000 8088 	beq.w	8014ce4 <_ZN3USB11OutTransferEP6EpInfottPKh+0x258>
 8014bd4:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8014bd6:	88fb      	ldrh	r3, [r7, #6]
 8014bd8:	429a      	cmp	r2, r3
 8014bda:	f040 8083 	bne.w	8014ce4 <_ZN3USB11OutTransferEP6EpInfottPKh+0x258>
						USBTRACE2("\nOutTransfer - nak:%d", nak_count);
 8014bde:	f24e 7034 	movw	r0, #59188	; 0xe734
 8014be2:	f6c0 0001 	movt	r0, #2049	; 0x801
 8014be6:	f04f 0180 	mov.w	r1, #128	; 0x80
 8014bea:	f004 fbe3 	bl	80193b4 <_Z8E_NotifyPKci>
 8014bee:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8014bf0:	b2db      	uxtb	r3, r3
 8014bf2:	4618      	mov	r0, r3
 8014bf4:	f04f 0180 	mov.w	r1, #128	; 0x80
 8014bf8:	f001 f946 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 8014bfc:	f24e 7030 	movw	r0, #59184	; 0xe730
 8014c00:	f6c0 0001 	movt	r0, #2049	; 0x801
 8014c04:	f04f 0180 	mov.w	r1, #128	; 0x80
 8014c08:	f004 fbd4 	bl	80193b4 <_Z8E_NotifyPKci>
						USBTRACE2("nak-limit:%d", nak_limit);
 8014c0c:	f24e 704c 	movw	r0, #59212	; 0xe74c
 8014c10:	f6c0 0001 	movt	r0, #2049	; 0x801
 8014c14:	f04f 0180 	mov.w	r1, #128	; 0x80
 8014c18:	f004 fbcc 	bl	80193b4 <_Z8E_NotifyPKci>
 8014c1c:	88fb      	ldrh	r3, [r7, #6]
 8014c1e:	b2db      	uxtb	r3, r3
 8014c20:	4618      	mov	r0, r3
 8014c22:	f04f 0180 	mov.w	r1, #128	; 0x80
 8014c26:	f001 f92f 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 8014c2a:	f24e 7030 	movw	r0, #59184	; 0xe730
 8014c2e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8014c32:	f04f 0180 	mov.w	r1, #128	; 0x80
 8014c36:	f004 fbbd 	bl	80193b4 <_Z8E_NotifyPKci>
						goto breakout;
 8014c3a:	e0c4      	b.n	8014dc6 <_ZN3USB11OutTransferEP6EpInfottPKh+0x33a>
					}
					break;
				case hrTIMEOUT:
					retry_count++;
 8014c3c:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8014c40:	f103 0301 	add.w	r3, r3, #1
 8014c44:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
					USBTRACE2("\nOutTransfer - hrTimeout & act err (%d)", retry_count);
 8014c48:	f24e 705c 	movw	r0, #59228	; 0xe75c
 8014c4c:	f6c0 0001 	movt	r0, #2049	; 0x801
 8014c50:	f04f 0180 	mov.w	r1, #128	; 0x80
 8014c54:	f004 fbae 	bl	80193b4 <_Z8E_NotifyPKci>
 8014c58:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8014c5c:	4618      	mov	r0, r3
 8014c5e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8014c62:	f001 f911 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 8014c66:	f24e 7030 	movw	r0, #59184	; 0xe730
 8014c6a:	f6c0 0001 	movt	r0, #2049	; 0x801
 8014c6e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8014c72:	f004 fb9f 	bl	80193b4 <_Z8E_NotifyPKci>
					if (retry_count == USB_RETRY_LIMIT)
 8014c76:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8014c7a:	2b06      	cmp	r3, #6
 8014c7c:	d134      	bne.n	8014ce8 <_ZN3USB11OutTransferEP6EpInfottPKh+0x25c>
						goto breakout;
 8014c7e:	e0a2      	b.n	8014dc6 <_ZN3USB11OutTransferEP6EpInfottPKh+0x33a>
					// yes, we flip it wrong here so that next time it is actually correct!
					//pep->bmSndToggle = (regRd(rHRSL) & bmSNDTOGRD) ? 0 : 1;
					//regWr(rHCTL, (pep->bmSndToggle) ? bmSNDTOG1 : bmSNDTOG0); //set toggle value
					//pdev->host.hc[hcnum].toggle_out ^= 0x1;
					//pdev->host.hc[hcnum].data_pid = (pdev->host.hc[hcnum].toggle_out) ? HC_PID_DATA1 : HC_PID_DATA0;
					pep->bmSndToggle = (usbhost_cb->get_toggle_cb(hcnum, tokOUT)) ? 0 : 1;
 8014c80:	f243 6310 	movw	r3, #13840	; 0x3610
 8014c84:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014c88:	681b      	ldr	r3, [r3, #0]
 8014c8a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014c8c:	6a3a      	ldr	r2, [r7, #32]
 8014c8e:	b2d2      	uxtb	r2, r2
 8014c90:	4610      	mov	r0, r2
 8014c92:	f04f 0120 	mov.w	r1, #32
 8014c96:	4798      	blx	r3
 8014c98:	4603      	mov	r3, r0
 8014c9a:	2b00      	cmp	r3, #0
 8014c9c:	bf14      	ite	ne
 8014c9e:	2300      	movne	r3, #0
 8014ca0:	2301      	moveq	r3, #1
 8014ca2:	b2d9      	uxtb	r1, r3
 8014ca4:	68ba      	ldr	r2, [r7, #8]
 8014ca6:	7913      	ldrb	r3, [r2, #4]
 8014ca8:	f361 0300 	bfi	r3, r1, #0, #1
 8014cac:	7113      	strb	r3, [r2, #4]
					usbhost_cb->set_toggle_cb(hcnum, tokOUT, pep->bmSndToggle);
 8014cae:	f243 6310 	movw	r3, #13840	; 0x3610
 8014cb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014cb6:	681b      	ldr	r3, [r3, #0]
 8014cb8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014cba:	6a3a      	ldr	r2, [r7, #32]
 8014cbc:	b2d1      	uxtb	r1, r2
 8014cbe:	68ba      	ldr	r2, [r7, #8]
 8014cc0:	7912      	ldrb	r2, [r2, #4]
 8014cc2:	f3c2 0200 	ubfx	r2, r2, #0, #1
 8014cc6:	b2d2      	uxtb	r2, r2
 8014cc8:	4608      	mov	r0, r1
 8014cca:	f04f 0120 	mov.w	r1, #32
 8014cce:	4798      	blx	r3
					USBTRACE("\nOutTransfer - togerr");
 8014cd0:	f24e 7084 	movw	r0, #59268	; 0xe784
 8014cd4:	f6c0 0001 	movt	r0, #2049	; 0x801
 8014cd8:	f04f 0180 	mov.w	r1, #128	; 0x80
 8014cdc:	f004 fb6a 	bl	80193b4 <_Z8E_NotifyPKci>
					break;
 8014ce0:	e003      	b.n	8014cea <_ZN3USB11OutTransferEP6EpInfottPKh+0x25e>
				default:
					goto breakout;
 8014ce2:	e070      	b.n	8014dc6 <_ZN3USB11OutTransferEP6EpInfottPKh+0x33a>
					if (nak_limit && (nak_count == nak_limit)) {
						USBTRACE2("\nOutTransfer - nak:%d", nak_count);
						USBTRACE2("nak-limit:%d", nak_limit);
						goto breakout;
					}
					break;
 8014ce4:	bf00      	nop
 8014ce6:	e000      	b.n	8014cea <_ZN3USB11OutTransferEP6EpInfottPKh+0x25e>
					retry_count++;
					USBTRACE2("\nOutTransfer - hrTimeout & act err (%d)", retry_count);
					if (retry_count == USB_RETRY_LIMIT)
						goto breakout;
					//return ( rcode);
					break;
 8014ce8:	bf00      	nop

			//regWr(rSNDFIFO, *data_p);
			//regWr(rSNDBC, bytes_tosend);
			//regWr(rHXFR, (tokOUT | pep->epAddr)); //dispatch packet
			//USBH_BulkSendData(pdev, data_p, bytes_tosend, hcnum);
			usbhost_cb->out_transfer_cb(data_p, bytes_tosend, hcnum, pep->epAddr, pep->maxPktSize);
 8014cea:	f243 6310 	movw	r3, #13840	; 0x3610
 8014cee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014cf2:	681b      	ldr	r3, [r3, #0]
 8014cf4:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 8014cf6:	6a3b      	ldr	r3, [r7, #32]
 8014cf8:	b2da      	uxtb	r2, r3
 8014cfa:	68bb      	ldr	r3, [r7, #8]
 8014cfc:	781b      	ldrb	r3, [r3, #0]
 8014cfe:	68b9      	ldr	r1, [r7, #8]
 8014d00:	7848      	ldrb	r0, [r1, #1]
 8014d02:	8af9      	ldrh	r1, [r7, #22]
 8014d04:	9000      	str	r0, [sp, #0]
 8014d06:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8014d08:	47a0      	blx	r4

			//while (!(regRd(rHIRQ) & bmHXFRDNIRQ)); //wait for the completion IRQ
			//regWr(rHIRQ, bmHXFRDNIRQ); //clear IRQ
			while ((long)(millis() - timeout) < 0L) {
 8014d0a:	e015      	b.n	8014d38 <_ZN3USB11OutTransferEP6EpInfottPKh+0x2ac>
				rcode = usbhost_cb->get_urb_status_cb(hcnum);	//HCD_GetURB_State(pdev, hcnum);
 8014d0c:	f243 6310 	movw	r3, #13840	; 0x3610
 8014d10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014d14:	681b      	ldr	r3, [r3, #0]
 8014d16:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014d18:	6a3a      	ldr	r2, [r7, #32]
 8014d1a:	b2d2      	uxtb	r2, r2
 8014d1c:	4610      	mov	r0, r2
 8014d1e:	4798      	blx	r3
 8014d20:	4603      	mov	r3, r0
 8014d22:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
				if (rcode != eUrbIdle) {
 8014d26:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8014d2a:	2b00      	cmp	r3, #0
 8014d2c:	d004      	beq.n	8014d38 <_ZN3USB11OutTransferEP6EpInfottPKh+0x2ac>
					rcode = 0x00;
 8014d2e:	f04f 0300 	mov.w	r3, #0
 8014d32:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
					break;
 8014d36:	e00f      	b.n	8014d58 <_ZN3USB11OutTransferEP6EpInfottPKh+0x2cc>
			//USBH_BulkSendData(pdev, data_p, bytes_tosend, hcnum);
			usbhost_cb->out_transfer_cb(data_p, bytes_tosend, hcnum, pep->epAddr, pep->maxPktSize);

			//while (!(regRd(rHIRQ) & bmHXFRDNIRQ)); //wait for the completion IRQ
			//regWr(rHIRQ, bmHXFRDNIRQ); //clear IRQ
			while ((long)(millis() - timeout) < 0L) {
 8014d38:	f243 630c 	movw	r3, #13836	; 0x360c
 8014d3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014d40:	681b      	ldr	r3, [r3, #0]
 8014d42:	689b      	ldr	r3, [r3, #8]
 8014d44:	4798      	blx	r3
 8014d46:	4603      	mov	r3, r0
 8014d48:	461a      	mov	r2, r3
 8014d4a:	69bb      	ldr	r3, [r7, #24]
 8014d4c:	1ad3      	subs	r3, r2, r3
 8014d4e:	ea4f 73d3 	mov.w	r3, r3, lsr #31
 8014d52:	b2db      	uxtb	r3, r3
 8014d54:	2b00      	cmp	r3, #0
 8014d56:	d1d9      	bne.n	8014d0c <_ZN3USB11OutTransferEP6EpInfottPKh+0x280>
					rcode = 0x00;
					break;
				}
			}
			//rcode = (regRd(rHRSL) & 0x0f);
			rcode = usbhost_cb->get_pipe_status_cb(hcnum);	//HCD_GetHCState(pdev, hcnum);
 8014d58:	f243 6310 	movw	r3, #13840	; 0x3610
 8014d5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014d60:	681b      	ldr	r3, [r3, #0]
 8014d62:	6a1b      	ldr	r3, [r3, #32]
 8014d64:	6a3a      	ldr	r2, [r7, #32]
 8014d66:	b2d2      	uxtb	r2, r2
 8014d68:	4610      	mov	r0, r2
 8014d6a:	4798      	blx	r3
 8014d6c:	4603      	mov	r3, r0
 8014d6e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
			}
		}

		//rcode = (regRd(rHRSL) & 0x0f);
		rcode = usbhost_cb->get_pipe_status_cb(hcnum);	//HCD_GetHCState(pdev, hcnum);
		while (rcode && ((long)(millis() - timeout) < 0L)) {
 8014d72:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8014d76:	2b00      	cmp	r3, #0
 8014d78:	d00f      	beq.n	8014d9a <_ZN3USB11OutTransferEP6EpInfottPKh+0x30e>
 8014d7a:	f243 630c 	movw	r3, #13836	; 0x360c
 8014d7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014d82:	681b      	ldr	r3, [r3, #0]
 8014d84:	689b      	ldr	r3, [r3, #8]
 8014d86:	4798      	blx	r3
 8014d88:	4603      	mov	r3, r0
 8014d8a:	461a      	mov	r2, r3
 8014d8c:	69bb      	ldr	r3, [r7, #24]
 8014d8e:	1ad3      	subs	r3, r2, r3
 8014d90:	2b00      	cmp	r3, #0
 8014d92:	da02      	bge.n	8014d9a <_ZN3USB11OutTransferEP6EpInfottPKh+0x30e>
 8014d94:	f04f 0301 	mov.w	r3, #1
 8014d98:	e001      	b.n	8014d9e <_ZN3USB11OutTransferEP6EpInfottPKh+0x312>
 8014d9a:	f04f 0300 	mov.w	r3, #0
 8014d9e:	2b00      	cmp	r3, #0
 8014da0:	f47f af07 	bne.w	8014bb2 <_ZN3USB11OutTransferEP6EpInfottPKh+0x126>
				pdev->host.hc[hcnum].data_pid = (pdev->host.hc[hcnum].toggle_out) ? HC_PID_DATA1 : HC_PID_DATA0;
			}
			pdev->host.hc[hcnum].isEvenTimesToggle = 0;	// will be re-calculate in HCD_SubmitRequest
#endif
		}//while( rcode && ....
		bytes_left -= bytes_tosend;
 8014da4:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8014da6:	8afb      	ldrh	r3, [r7, #22]
 8014da8:	1ad3      	subs	r3, r2, r3
 8014daa:	84bb      	strh	r3, [r7, #36]	; 0x24
		data_p += bytes_tosend;
 8014dac:	8afb      	ldrh	r3, [r7, #22]
 8014dae:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014db0:	18d3      	adds	r3, r2, r3
 8014db2:	62bb      	str	r3, [r7, #40]	; 0x28
	unsigned long timeout = millis() + USB_XFER_TIMEOUT;

	//regWr(rHCTL, (pep->bmSndToggle) ? bmSNDTOG1 : bmSNDTOG0); //set toggle value
	usbhost_cb->set_toggle_cb(hcnum, tokOUT, pep->bmSndToggle);

	while (bytes_left) {
 8014db4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8014db6:	2b00      	cmp	r3, #0
 8014db8:	bf0c      	ite	eq
 8014dba:	2300      	moveq	r3, #0
 8014dbc:	2301      	movne	r3, #1
 8014dbe:	b2db      	uxtb	r3, r3
 8014dc0:	2b00      	cmp	r3, #0
 8014dc2:	f47f aea3 	bne.w	8014b0c <_ZN3USB11OutTransferEP6EpInfottPKh+0x80>
		data_p += bytes_tosend;
	}//while( bytes_left...
breakout:

	//pep->bmSndToggle = (regRd(rHRSL) & bmSNDTOGRD) ? 1 : 0; //bmSNDTOG1 : bmSNDTOG0;  //update toggle
	pep->bmSndToggle = usbhost_cb->get_toggle_cb(hcnum, tokOUT);
 8014dc6:	f243 6310 	movw	r3, #13840	; 0x3610
 8014dca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014dce:	681b      	ldr	r3, [r3, #0]
 8014dd0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014dd2:	6a3a      	ldr	r2, [r7, #32]
 8014dd4:	b2d2      	uxtb	r2, r2
 8014dd6:	4610      	mov	r0, r2
 8014dd8:	f04f 0120 	mov.w	r1, #32
 8014ddc:	4798      	blx	r3
 8014dde:	4603      	mov	r3, r0
 8014de0:	b2db      	uxtb	r3, r3
 8014de2:	f003 0301 	and.w	r3, r3, #1
 8014de6:	b2d9      	uxtb	r1, r3
 8014de8:	68ba      	ldr	r2, [r7, #8]
 8014dea:	7913      	ldrb	r3, [r2, #4]
 8014dec:	f361 0300 	bfi	r3, r1, #0, #1
 8014df0:	7113      	strb	r3, [r2, #4]
	return ( rcode); //should be 0 in all cases
 8014df2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
}
 8014df6:	4618      	mov	r0, r3
 8014df8:	f107 0734 	add.w	r7, r7, #52	; 0x34
 8014dfc:	46bd      	mov	sp, r7
 8014dfe:	bd90      	pop	{r4, r7, pc}

08014e00 <_ZN3USB11dispatchPktEhhtPhthhh>:
/* If NAK, tries to re-send up to nak_limit times                                                   */
/* If nak_limit == 0, do not count NAKs, exit after timeout                                         */
/* If bus timeout, re-sends up to USB_RETRY_LIMIT times                                             */

/* return codes 0x00-0x0f are HRSLT( 0x00 being success ), 0xff means timeout                       */
uint8_t USB::dispatchPkt(uint8_t token, uint8_t ep, uint16_t nak_limit, uint8_t *data_p = NULL, uint16_t nbytes = 0, uint8_t hcnum = 0, uint8_t devAddr = 0, uint8_t mps = 8) {
 8014e00:	b590      	push	{r4, r7, lr}
 8014e02:	b089      	sub	sp, #36	; 0x24
 8014e04:	af02      	add	r7, sp, #8
 8014e06:	6078      	str	r0, [r7, #4]
 8014e08:	70f9      	strb	r1, [r7, #3]
 8014e0a:	70ba      	strb	r2, [r7, #2]
 8014e0c:	803b      	strh	r3, [r7, #0]
        unsigned long timeout = millis() + USB_XFER_TIMEOUT;
 8014e0e:	f243 630c 	movw	r3, #13836	; 0x360c
 8014e12:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014e16:	681b      	ldr	r3, [r3, #0]
 8014e18:	689b      	ldr	r3, [r3, #8]
 8014e1a:	4798      	blx	r3
 8014e1c:	4603      	mov	r3, r0
 8014e1e:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 8014e22:	f103 0310 	add.w	r3, r3, #16
 8014e26:	613b      	str	r3, [r7, #16]
        //unsigned long timeout2 = timeout;
        uint8_t tmpdata;
        uint8_t rcode = hrSUCCESS;
 8014e28:	f04f 0300 	mov.w	r3, #0
 8014e2c:	75fb      	strb	r3, [r7, #23]
        uint8_t retry_count = 0;
 8014e2e:	f04f 0300 	mov.w	r3, #0
 8014e32:	75bb      	strb	r3, [r7, #22]
        uint16_t nak_count = 0;
 8014e34:	f04f 0300 	mov.w	r3, #0
 8014e38:	81fb      	strh	r3, [r7, #14]
        //USB_OTG_CORE_HANDLE *pdev = coreConfig;
        uint8_t pid = 0;
 8014e3a:	f04f 0300 	mov.w	r3, #0
 8014e3e:	737b      	strb	r3, [r7, #13]
        // todo : need to reconsider the usage of nak
		//pdev->host.hc[hcnum].nak_count = 0;
		//pdev->host.hc[hcnum].nak_limit = nak_limit;

        while ((long)(millis() - timeout) < 0L)	{	//(timeout > millis()) {
 8014e40:	e0e2      	b.n	8015008 <_ZN3USB11dispatchPktEhhtPhthhh+0x208>
			//regWr(rHXFR, (token | ep)); //launch the transfer
        	if(token == tokSETUP || token == tokOUTHS)
 8014e42:	78fb      	ldrb	r3, [r7, #3]
 8014e44:	2b10      	cmp	r3, #16
 8014e46:	d002      	beq.n	8014e4e <_ZN3USB11dispatchPktEhhtPhthhh+0x4e>
 8014e48:	78fb      	ldrb	r3, [r7, #3]
 8014e4a:	2ba0      	cmp	r3, #160	; 0xa0
 8014e4c:	d113      	bne.n	8014e76 <_ZN3USB11dispatchPktEhhtPhthhh+0x76>
        	{
				//USBH_CtlSendSetup(pdev, data_p, hcnum);
				usbhost_cb->control_out_transfer_cb(token, data_p, hcnum, devAddr, ep, mps);
 8014e4e:	f243 6310 	movw	r3, #13840	; 0x3610
 8014e52:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014e56:	681b      	ldr	r3, [r3, #0]
 8014e58:	6c5c      	ldr	r4, [r3, #68]	; 0x44
 8014e5a:	78f9      	ldrb	r1, [r7, #3]
 8014e5c:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 8014e60:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 8014e64:	78b8      	ldrb	r0, [r7, #2]
 8014e66:	9000      	str	r0, [sp, #0]
 8014e68:	f897 0038 	ldrb.w	r0, [r7, #56]	; 0x38
 8014e6c:	9001      	str	r0, [sp, #4]
 8014e6e:	4608      	mov	r0, r1
 8014e70:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8014e72:	47a0      	blx	r4
 8014e74:	e03a      	b.n	8014eec <_ZN3USB11dispatchPktEhhtPhthhh+0xec>
        		//if(token == tokOUTHS) {
        			//pdev->host.hc[hcnum].toggle_out = 0x1;
        			//pdev->host.hc[hcnum].ep_is_in = 0;
        			//pid = HC_PID_DATA1;
        		//} else
        		if (token == tokINHS) {
 8014e76:	78fb      	ldrb	r3, [r7, #3]
 8014e78:	2b80      	cmp	r3, #128	; 0x80
 8014e7a:	d112      	bne.n	8014ea2 <_ZN3USB11dispatchPktEhhtPhthhh+0xa2>
        			//pdev->host.hc[hcnum].toggle_in = 0x1;
        			//pdev->host.hc[hcnum].ep_is_in = 1;
        			//pid = HC_PID_DATA1;
        			usbhost_cb->control_in_transfer_cb(data_p, nbytes, hcnum, devAddr, ep, mps);
 8014e7c:	f243 6310 	movw	r3, #13840	; 0x3610
 8014e80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014e84:	681b      	ldr	r3, [r3, #0]
 8014e86:	6c9c      	ldr	r4, [r3, #72]	; 0x48
 8014e88:	8db9      	ldrh	r1, [r7, #44]	; 0x2c
 8014e8a:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 8014e8e:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 8014e92:	78b8      	ldrb	r0, [r7, #2]
 8014e94:	9000      	str	r0, [sp, #0]
 8014e96:	f897 0038 	ldrb.w	r0, [r7, #56]	; 0x38
 8014e9a:	9001      	str	r0, [sp, #4]
 8014e9c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8014e9e:	47a0      	blx	r4
 8014ea0:	e024      	b.n	8014eec <_ZN3USB11dispatchPktEhhtPhthhh+0xec>
        		} else if (token == tokIN) {
 8014ea2:	78fb      	ldrb	r3, [r7, #3]
 8014ea4:	2b00      	cmp	r3, #0
 8014ea6:	d112      	bne.n	8014ece <_ZN3USB11dispatchPktEhhtPhthhh+0xce>
        			//pdev->host.hc[hcnum].ep_is_in = 1;
        			//pid = (pdev->host.hc[hcnum].toggle_in)? HC_PID_DATA1 : HC_PID_DATA0;
        			usbhost_cb->in_transfer_cb(data_p, nbytes, hcnum, devAddr, ep, mps);
 8014ea8:	f243 6310 	movw	r3, #13840	; 0x3610
 8014eac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014eb0:	681b      	ldr	r3, [r3, #0]
 8014eb2:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 8014eb4:	8db9      	ldrh	r1, [r7, #44]	; 0x2c
 8014eb6:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 8014eba:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 8014ebe:	78b8      	ldrb	r0, [r7, #2]
 8014ec0:	9000      	str	r0, [sp, #0]
 8014ec2:	f897 0038 	ldrb.w	r0, [r7, #56]	; 0x38
 8014ec6:	9001      	str	r0, [sp, #4]
 8014ec8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8014eca:	47a0      	blx	r4
 8014ecc:	e00e      	b.n	8014eec <_ZN3USB11dispatchPktEhhtPhthhh+0xec>
        		} else {
        			//pdev->host.hc[hcnum].ep_is_in = 0;
        			//pid = (pdev->host.hc[hcnum].toggle_out)? HC_PID_DATA1 : HC_PID_DATA0;
        			usbhost_cb->out_transfer_cb(data_p, nbytes, hcnum, ep, mps);	// todo : never come?
 8014ece:	f243 6310 	movw	r3, #13840	; 0x3610
 8014ed2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014ed6:	681b      	ldr	r3, [r3, #0]
 8014ed8:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 8014eda:	8db9      	ldrh	r1, [r7, #44]	; 0x2c
 8014edc:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 8014ee0:	78bb      	ldrb	r3, [r7, #2]
 8014ee2:	f897 0038 	ldrb.w	r0, [r7, #56]	; 0x38
 8014ee6:	9000      	str	r0, [sp, #0]
 8014ee8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8014eea:	47a0      	blx	r4
    			//pdev->host.hc[hcnum].xfer_len = nbytes;

    			//HCD_SubmitRequest(pdev, hcnum);
        	}

			rcode = USB_ERROR_TRANSFER_TIMEOUT;
 8014eec:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8014ef0:	75fb      	strb	r3, [r7, #23]
			while ((long)(millis() - timeout) < 0L)	//(timeout > millis()) //wait for transfer completion
 8014ef2:	e044      	b.n	8014f7e <_ZN3USB11dispatchPktEhhtPhthhh+0x17e>
			{
				tmpdata = usbhost_cb->get_urb_status_cb(hcnum);	//HCD_GetURB_State(pdev, hcnum);	//regRd(rHIRQ);
 8014ef4:	f243 6310 	movw	r3, #13840	; 0x3610
 8014ef8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014efc:	681b      	ldr	r3, [r3, #0]
 8014efe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014f00:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 8014f04:	4610      	mov	r0, r2
 8014f06:	4798      	blx	r3
 8014f08:	4603      	mov	r3, r0
 8014f0a:	733b      	strb	r3, [r7, #12]
				if (tmpdata != eUrbIdle) {	//& bmHXFRDNIRQ) {
 8014f0c:	7b3b      	ldrb	r3, [r7, #12]
 8014f0e:	2b00      	cmp	r3, #0
 8014f10:	d021      	beq.n	8014f56 <_ZN3USB11dispatchPktEhhtPhthhh+0x156>
					//regWr(rHIRQ, bmHXFRDNIRQ); //clear the interrupt
					if(tmpdata != eUrbDone && tmpdata != eUrbNotReady)
 8014f12:	7b3b      	ldrb	r3, [r7, #12]
 8014f14:	2b01      	cmp	r3, #1
 8014f16:	d01a      	beq.n	8014f4e <_ZN3USB11dispatchPktEhhtPhthhh+0x14e>
 8014f18:	7b3b      	ldrb	r3, [r7, #12]
 8014f1a:	2b02      	cmp	r3, #2
 8014f1c:	d017      	beq.n	8014f4e <_ZN3USB11dispatchPktEhhtPhthhh+0x14e>
					{
						toggle_led3();
 8014f1e:	f000 ffc3 	bl	8015ea8 <_ZN7STM32F2I1a1bE11toggle_led3Ev>
						USBTRACE2("cu:", tmpdata);
 8014f22:	f24e 709c 	movw	r0, #59292	; 0xe79c
 8014f26:	f6c0 0001 	movt	r0, #2049	; 0x801
 8014f2a:	f04f 0180 	mov.w	r1, #128	; 0x80
 8014f2e:	f004 fa41 	bl	80193b4 <_Z8E_NotifyPKci>
 8014f32:	7b3b      	ldrb	r3, [r7, #12]
 8014f34:	4618      	mov	r0, r3
 8014f36:	f04f 0180 	mov.w	r1, #128	; 0x80
 8014f3a:	f000 ffa5 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 8014f3e:	f24e 7030 	movw	r0, #59184	; 0xe730
 8014f42:	f6c0 0001 	movt	r0, #2049	; 0x801
 8014f46:	f04f 0180 	mov.w	r1, #128	; 0x80
 8014f4a:	f004 fa33 	bl	80193b4 <_Z8E_NotifyPKci>
					}
					rcode = 0x00;
 8014f4e:	f04f 0300 	mov.w	r3, #0
 8014f52:	75fb      	strb	r3, [r7, #23]
					break;
 8014f54:	e023      	b.n	8014f9e <_ZN3USB11dispatchPktEhhtPhthhh+0x19e>
				} 
				if (usbhost_cb->is_attached_cb() == 0)	//pdev->host.ConnSts == 0)
 8014f56:	f243 6310 	movw	r3, #13840	; 0x3610
 8014f5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014f5e:	681b      	ldr	r3, [r3, #0]
 8014f60:	685b      	ldr	r3, [r3, #4]
 8014f62:	4798      	blx	r3
 8014f64:	4603      	mov	r3, r0
 8014f66:	2b00      	cmp	r3, #0
 8014f68:	bf14      	ite	ne
 8014f6a:	2300      	movne	r3, #0
 8014f6c:	2301      	moveq	r3, #1
 8014f6e:	b2db      	uxtb	r3, r3
 8014f70:	2b00      	cmp	r3, #0
 8014f72:	d004      	beq.n	8014f7e <_ZN3USB11dispatchPktEhhtPhthhh+0x17e>
				{
					rcode = hrJERR;
 8014f74:	f04f 030d 	mov.w	r3, #13
 8014f78:	75fb      	strb	r3, [r7, #23]
					return rcode;
 8014f7a:	7dfb      	ldrb	r3, [r7, #23]
 8014f7c:	e056      	b.n	801502c <_ZN3USB11dispatchPktEhhtPhthhh+0x22c>

    			//HCD_SubmitRequest(pdev, hcnum);
        	}

			rcode = USB_ERROR_TRANSFER_TIMEOUT;
			while ((long)(millis() - timeout) < 0L)	//(timeout > millis()) //wait for transfer completion
 8014f7e:	f243 630c 	movw	r3, #13836	; 0x360c
 8014f82:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014f86:	681b      	ldr	r3, [r3, #0]
 8014f88:	689b      	ldr	r3, [r3, #8]
 8014f8a:	4798      	blx	r3
 8014f8c:	4603      	mov	r3, r0
 8014f8e:	461a      	mov	r2, r3
 8014f90:	693b      	ldr	r3, [r7, #16]
 8014f92:	1ad3      	subs	r3, r2, r3
 8014f94:	ea4f 73d3 	mov.w	r3, r3, lsr #31
 8014f98:	b2db      	uxtb	r3, r3
 8014f9a:	2b00      	cmp	r3, #0
 8014f9c:	d1aa      	bne.n	8014ef4 <_ZN3USB11dispatchPktEhhtPhthhh+0xf4>
			}

			//if (rcode != 0x00) //exit if timeout
			//        return ( rcode);

            rcode = usbhost_cb->get_pipe_status_cb(hcnum);	//HCD_GetHCState(pdev, hcnum);	//(regRd(rHRSL) & 0x0f); //analyze transfer result
 8014f9e:	f243 6310 	movw	r3, #13840	; 0x3610
 8014fa2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014fa6:	681b      	ldr	r3, [r3, #0]
 8014fa8:	6a1b      	ldr	r3, [r3, #32]
 8014faa:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 8014fae:	4610      	mov	r0, r2
 8014fb0:	4798      	blx	r3
 8014fb2:	4603      	mov	r3, r0
 8014fb4:	75fb      	strb	r3, [r7, #23]
			switch (rcode) {
 8014fb6:	7dfb      	ldrb	r3, [r7, #23]
 8014fb8:	2b04      	cmp	r3, #4
 8014fba:	d002      	beq.n	8014fc2 <_ZN3USB11dispatchPktEhhtPhthhh+0x1c2>
 8014fbc:	2b0e      	cmp	r3, #14
 8014fbe:	d015      	beq.n	8014fec <_ZN3USB11dispatchPktEhhtPhthhh+0x1ec>
 8014fc0:	e01d      	b.n	8014ffe <_ZN3USB11dispatchPktEhhtPhthhh+0x1fe>
				case hrNAK: 	//todo: if timeout above with nak, we need to consider the next xfer.
					nak_count = usbhost_cb->get_nak_count_cb(hcnum);	//pdev->host.hc[hcnum].nak_count;
 8014fc2:	f243 6310 	movw	r3, #13840	; 0x3610
 8014fc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014fca:	681b      	ldr	r3, [r3, #0]
 8014fcc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014fce:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
 8014fd2:	4610      	mov	r0, r2
 8014fd4:	4798      	blx	r3
 8014fd6:	4603      	mov	r3, r0
 8014fd8:	81fb      	strh	r3, [r7, #14]
					if (nak_limit && (nak_count == nak_limit))
 8014fda:	883b      	ldrh	r3, [r7, #0]
 8014fdc:	2b00      	cmp	r3, #0
 8014fde:	d010      	beq.n	8015002 <_ZN3USB11dispatchPktEhhtPhthhh+0x202>
 8014fe0:	89fa      	ldrh	r2, [r7, #14]
 8014fe2:	883b      	ldrh	r3, [r7, #0]
 8014fe4:	429a      	cmp	r2, r3
 8014fe6:	d10c      	bne.n	8015002 <_ZN3USB11dispatchPktEhhtPhthhh+0x202>
						return (rcode);
 8014fe8:	7dfb      	ldrb	r3, [r7, #23]
 8014fea:	e01f      	b.n	801502c <_ZN3USB11dispatchPktEhhtPhthhh+0x22c>
					break;
				case hrTIMEOUT:
					retry_count++;
 8014fec:	7dbb      	ldrb	r3, [r7, #22]
 8014fee:	f103 0301 	add.w	r3, r3, #1
 8014ff2:	75bb      	strb	r3, [r7, #22]
					if (retry_count == USB_RETRY_LIMIT)
 8014ff4:	7dbb      	ldrb	r3, [r7, #22]
 8014ff6:	2b06      	cmp	r3, #6
 8014ff8:	d105      	bne.n	8015006 <_ZN3USB11dispatchPktEhhtPhthhh+0x206>
						return (rcode);
 8014ffa:	7dfb      	ldrb	r3, [r7, #23]
 8014ffc:	e016      	b.n	801502c <_ZN3USB11dispatchPktEhhtPhthhh+0x22c>
					break;
				default:
					return (rcode);
 8014ffe:	7dfb      	ldrb	r3, [r7, #23]
 8015000:	e014      	b.n	801502c <_ZN3USB11dispatchPktEhhtPhthhh+0x22c>
			switch (rcode) {
				case hrNAK: 	//todo: if timeout above with nak, we need to consider the next xfer.
					nak_count = usbhost_cb->get_nak_count_cb(hcnum);	//pdev->host.hc[hcnum].nak_count;
					if (nak_limit && (nak_count == nak_limit))
						return (rcode);
					break;
 8015002:	bf00      	nop
 8015004:	e000      	b.n	8015008 <_ZN3USB11dispatchPktEhhtPhthhh+0x208>
				case hrTIMEOUT:
					retry_count++;
					if (retry_count == USB_RETRY_LIMIT)
						return (rcode);
					break;
 8015006:	bf00      	nop
        uint8_t pid = 0;
        // todo : need to reconsider the usage of nak
		//pdev->host.hc[hcnum].nak_count = 0;
		//pdev->host.hc[hcnum].nak_limit = nak_limit;

        while ((long)(millis() - timeout) < 0L)	{	//(timeout > millis()) {
 8015008:	f243 630c 	movw	r3, #13836	; 0x360c
 801500c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015010:	681b      	ldr	r3, [r3, #0]
 8015012:	689b      	ldr	r3, [r3, #8]
 8015014:	4798      	blx	r3
 8015016:	4603      	mov	r3, r0
 8015018:	461a      	mov	r2, r3
 801501a:	693b      	ldr	r3, [r7, #16]
 801501c:	1ad3      	subs	r3, r2, r3
 801501e:	ea4f 73d3 	mov.w	r3, r3, lsr #31
 8015022:	b2db      	uxtb	r3, r3
 8015024:	2b00      	cmp	r3, #0
 8015026:	f47f af0c 	bne.w	8014e42 <_ZN3USB11dispatchPktEhhtPhthhh+0x42>
					return (rcode);
			}

        }//while( timeout > millis()

        return ( rcode);
 801502a:	7dfb      	ldrb	r3, [r7, #23]
}
 801502c:	4618      	mov	r0, r3
 801502e:	f107 071c 	add.w	r7, r7, #28
 8015032:	46bd      	mov	sp, r7
 8015034:	bd90      	pop	{r4, r7, pc}
 8015036:	bf00      	nop

08015038 <_ZN3USB4TaskEv>:

/* USB main task. Performs enumeration/cleanup */
void USB::Task(void)	//USB_OTG_CORE_HANDLE *pdev) //USB state machine
{
 8015038:	b580      	push	{r7, lr}
 801503a:	b086      	sub	sp, #24
 801503c:	af00      	add	r7, sp, #0
 801503e:	6078      	str	r0, [r7, #4]
	uint8_t rcode;
	uint8_t tmpdata;
	static unsigned long timeout = 0;
	bool lowspeed = false;
 8015040:	f04f 0300 	mov.w	r3, #0
 8015044:	75fb      	strb	r3, [r7, #23]

	STM32F2::Task();
 8015046:	6878      	ldr	r0, [r7, #4]
 8015048:	f000 ff3a 	bl	8015ec0 <_ZN7STM32F2I1a1bE4TaskEv>

	tmpdata = getVbusState();
 801504c:	6878      	ldr	r0, [r7, #4]
 801504e:	f000 ff47 	bl	8015ee0 <_ZN7STM32F2I1a1bE12getVbusStateEv>
 8015052:	4603      	mov	r3, r0
 8015054:	753b      	strb	r3, [r7, #20]

	/* modify USB task state if Vbus changed */
	switch (tmpdata) {
 8015056:	7d3b      	ldrb	r3, [r7, #20]
 8015058:	2b03      	cmp	r3, #3
 801505a:	d84f      	bhi.n	80150fc <_ZN3USB4TaskEv+0xc4>
 801505c:	a201      	add	r2, pc, #4	; (adr r2, 8015064 <_ZN3USB4TaskEv+0x2c>)
 801505e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8015062:	bf00      	nop
 8015064:	0801508b 	.word	0x0801508b
 8015068:	08015075 	.word	0x08015075
 801506c:	080150b9 	.word	0x080150b9
 8015070:	080150b3 	.word	0x080150b3
		case SE1: //illegal state
			usb_task_state = USB_DETACHED_SUBSTATE_ILLEGAL;
 8015074:	f640 4360 	movw	r3, #3168	; 0xc60
 8015078:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801507c:	f04f 0213 	mov.w	r2, #19
 8015080:	701a      	strb	r2, [r3, #0]
			lowspeed = false;
 8015082:	f04f 0300 	mov.w	r3, #0
 8015086:	75fb      	strb	r3, [r7, #23]
			break;
 8015088:	e038      	b.n	80150fc <_ZN3USB4TaskEv+0xc4>
		case SE0: //disconnected
			if ((usb_task_state & USB_STATE_MASK) != USB_STATE_DETACHED)
 801508a:	f640 4360 	movw	r3, #3168	; 0xc60
 801508e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015092:	781b      	ldrb	r3, [r3, #0]
 8015094:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8015098:	2b10      	cmp	r3, #16
 801509a:	d006      	beq.n	80150aa <_ZN3USB4TaskEv+0x72>
					usb_task_state = USB_DETACHED_SUBSTATE_INITIALIZE;
 801509c:	f640 4360 	movw	r3, #3168	; 0xc60
 80150a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80150a4:	f04f 0211 	mov.w	r2, #17
 80150a8:	701a      	strb	r2, [r3, #0]
			lowspeed = false;
 80150aa:	f04f 0300 	mov.w	r3, #0
 80150ae:	75fb      	strb	r3, [r7, #23]
			break;
 80150b0:	e024      	b.n	80150fc <_ZN3USB4TaskEv+0xc4>
		case LSHOST:
//        if ((usb_task_state & USB_STATE_MASK) == USB_STATE_DETACHED) {
			lowspeed = true;
 80150b2:	f04f 0301 	mov.w	r3, #1
 80150b6:	75fb      	strb	r3, [r7, #23]
//        }
		case FSHOST: //attached
			if ((usb_task_state & USB_STATE_MASK) == USB_STATE_DETACHED) {
 80150b8:	f640 4360 	movw	r3, #3168	; 0xc60
 80150bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80150c0:	781b      	ldrb	r3, [r3, #0]
 80150c2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80150c6:	2b10      	cmp	r3, #16
 80150c8:	d117      	bne.n	80150fa <_ZN3USB4TaskEv+0xc2>
				timeout = millis() + USB_SETTLE_DELAY;
 80150ca:	f243 630c 	movw	r3, #13836	; 0x360c
 80150ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80150d2:	681b      	ldr	r3, [r3, #0]
 80150d4:	689b      	ldr	r3, [r3, #8]
 80150d6:	4798      	blx	r3
 80150d8:	4603      	mov	r3, r0
 80150da:	f103 02c8 	add.w	r2, r3, #200	; 0xc8
 80150de:	f640 4364 	movw	r3, #3172	; 0xc64
 80150e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80150e6:	601a      	str	r2, [r3, #0]
				usb_task_state = USB_ATTACHED_SUBSTATE_SETTLE;
 80150e8:	f640 4360 	movw	r3, #3168	; 0xc60
 80150ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80150f0:	f04f 0220 	mov.w	r2, #32
 80150f4:	701a      	strb	r2, [r3, #0]
				toggle_led3();
 80150f6:	f000 fed7 	bl	8015ea8 <_ZN7STM32F2I1a1bE11toggle_led3Ev>
			}
			break;
 80150fa:	bf00      	nop
	}// switch( tmpdata

	if(bGlobalPollEnable) {	// to avoid interrupting the bulk transaction.
 80150fc:	687b      	ldr	r3, [r7, #4]
 80150fe:	f893 30bd 	ldrb.w	r3, [r3, #189]	; 0xbd
 8015102:	2b00      	cmp	r3, #0
 8015104:	d031      	beq.n	801516a <_ZN3USB4TaskEv+0x132>
		for (uint8_t i = 0; i < USB_NUMDEVICES; i++)
 8015106:	f04f 0300 	mov.w	r3, #0
 801510a:	75bb      	strb	r3, [r7, #22]
 801510c:	e025      	b.n	801515a <_ZN3USB4TaskEv+0x122>
			if (devConfig[i])
 801510e:	7dbb      	ldrb	r3, [r7, #22]
 8015110:	687a      	ldr	r2, [r7, #4]
 8015112:	f103 031e 	add.w	r3, r3, #30
 8015116:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801511a:	18d3      	adds	r3, r2, r3
 801511c:	685b      	ldr	r3, [r3, #4]
 801511e:	2b00      	cmp	r3, #0
 8015120:	d017      	beq.n	8015152 <_ZN3USB4TaskEv+0x11a>
				rcode = devConfig[i]->Poll();
 8015122:	7dbb      	ldrb	r3, [r7, #22]
 8015124:	687a      	ldr	r2, [r7, #4]
 8015126:	f103 031e 	add.w	r3, r3, #30
 801512a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801512e:	18d3      	adds	r3, r2, r3
 8015130:	685b      	ldr	r3, [r3, #4]
 8015132:	681b      	ldr	r3, [r3, #0]
 8015134:	f103 030c 	add.w	r3, r3, #12
 8015138:	681a      	ldr	r2, [r3, #0]
 801513a:	7dbb      	ldrb	r3, [r7, #22]
 801513c:	6879      	ldr	r1, [r7, #4]
 801513e:	f103 031e 	add.w	r3, r3, #30
 8015142:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8015146:	18cb      	adds	r3, r1, r3
 8015148:	685b      	ldr	r3, [r3, #4]
 801514a:	4618      	mov	r0, r3
 801514c:	4790      	blx	r2
 801514e:	4603      	mov	r3, r0
 8015150:	74fb      	strb	r3, [r7, #19]
			}
			break;
	}// switch( tmpdata

	if(bGlobalPollEnable) {	// to avoid interrupting the bulk transaction.
		for (uint8_t i = 0; i < USB_NUMDEVICES; i++)
 8015152:	7dbb      	ldrb	r3, [r7, #22]
 8015154:	f103 0301 	add.w	r3, r3, #1
 8015158:	75bb      	strb	r3, [r7, #22]
 801515a:	7dbb      	ldrb	r3, [r7, #22]
 801515c:	2b0f      	cmp	r3, #15
 801515e:	bf8c      	ite	hi
 8015160:	2300      	movhi	r3, #0
 8015162:	2301      	movls	r3, #1
 8015164:	b2db      	uxtb	r3, r3
 8015166:	2b00      	cmp	r3, #0
 8015168:	d1d1      	bne.n	801510e <_ZN3USB4TaskEv+0xd6>
			if (devConfig[i])
				rcode = devConfig[i]->Poll();
	}

	switch (usb_task_state) {
 801516a:	f640 4360 	movw	r3, #3168	; 0xc60
 801516e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015172:	781b      	ldrb	r3, [r3, #0]
 8015174:	2b30      	cmp	r3, #48	; 0x30
 8015176:	d072      	beq.n	801525e <_ZN3USB4TaskEv+0x226>
 8015178:	2b30      	cmp	r3, #48	; 0x30
 801517a:	dc0d      	bgt.n	8015198 <_ZN3USB4TaskEv+0x160>
 801517c:	2b12      	cmp	r3, #18
 801517e:	f000 813f 	beq.w	8015400 <_ZN3USB4TaskEv+0x3c8>
 8015182:	2b12      	cmp	r3, #18
 8015184:	dc02      	bgt.n	801518c <_ZN3USB4TaskEv+0x154>
 8015186:	2b11      	cmp	r3, #17
 8015188:	d018      	beq.n	80151bc <_ZN3USB4TaskEv+0x184>
 801518a:	e146      	b.n	801541a <_ZN3USB4TaskEv+0x3e2>
 801518c:	2b13      	cmp	r3, #19
 801518e:	f000 8139 	beq.w	8015404 <_ZN3USB4TaskEv+0x3cc>
 8015192:	2b20      	cmp	r3, #32
 8015194:	d04f      	beq.n	8015236 <_ZN3USB4TaskEv+0x1fe>
 8015196:	e140      	b.n	801541a <_ZN3USB4TaskEv+0x3e2>
 8015198:	2b80      	cmp	r3, #128	; 0x80
 801519a:	f000 80d6 	beq.w	801534a <_ZN3USB4TaskEv+0x312>
 801519e:	2b80      	cmp	r3, #128	; 0x80
 80151a0:	dc05      	bgt.n	80151ae <_ZN3USB4TaskEv+0x176>
 80151a2:	2b50      	cmp	r3, #80	; 0x50
 80151a4:	d06c      	beq.n	8015280 <_ZN3USB4TaskEv+0x248>
 80151a6:	2b51      	cmp	r3, #81	; 0x51
 80151a8:	f000 80b2 	beq.w	8015310 <_ZN3USB4TaskEv+0x2d8>
 80151ac:	e135      	b.n	801541a <_ZN3USB4TaskEv+0x3e2>
 80151ae:	2b90      	cmp	r3, #144	; 0x90
 80151b0:	f000 812a 	beq.w	8015408 <_ZN3USB4TaskEv+0x3d0>
 80151b4:	2ba0      	cmp	r3, #160	; 0xa0
 80151b6:	f000 80f8 	beq.w	80153aa <_ZN3USB4TaskEv+0x372>
 80151ba:	e12e      	b.n	801541a <_ZN3USB4TaskEv+0x3e2>
		case USB_DETACHED_SUBSTATE_INITIALIZE:
				init();
 80151bc:	6878      	ldr	r0, [r7, #4]
 80151be:	f7ff f977 	bl	80144b0 <_ZN3USB4initEv>

				for (uint8_t i = 0; i < USB_NUMDEVICES; i++)
 80151c2:	f04f 0300 	mov.w	r3, #0
 80151c6:	757b      	strb	r3, [r7, #21]
 80151c8:	e025      	b.n	8015216 <_ZN3USB4TaskEv+0x1de>
					if (devConfig[i])
 80151ca:	7d7b      	ldrb	r3, [r7, #21]
 80151cc:	687a      	ldr	r2, [r7, #4]
 80151ce:	f103 031e 	add.w	r3, r3, #30
 80151d2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80151d6:	18d3      	adds	r3, r2, r3
 80151d8:	685b      	ldr	r3, [r3, #4]
 80151da:	2b00      	cmp	r3, #0
 80151dc:	d017      	beq.n	801520e <_ZN3USB4TaskEv+0x1d6>
							rcode = devConfig[i]->Release();
 80151de:	7d7b      	ldrb	r3, [r7, #21]
 80151e0:	687a      	ldr	r2, [r7, #4]
 80151e2:	f103 031e 	add.w	r3, r3, #30
 80151e6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80151ea:	18d3      	adds	r3, r2, r3
 80151ec:	685b      	ldr	r3, [r3, #4]
 80151ee:	681b      	ldr	r3, [r3, #0]
 80151f0:	f103 0308 	add.w	r3, r3, #8
 80151f4:	681a      	ldr	r2, [r3, #0]
 80151f6:	7d7b      	ldrb	r3, [r7, #21]
 80151f8:	6879      	ldr	r1, [r7, #4]
 80151fa:	f103 031e 	add.w	r3, r3, #30
 80151fe:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8015202:	18cb      	adds	r3, r1, r3
 8015204:	685b      	ldr	r3, [r3, #4]
 8015206:	4618      	mov	r0, r3
 8015208:	4790      	blx	r2
 801520a:	4603      	mov	r3, r0
 801520c:	74fb      	strb	r3, [r7, #19]

	switch (usb_task_state) {
		case USB_DETACHED_SUBSTATE_INITIALIZE:
				init();

				for (uint8_t i = 0; i < USB_NUMDEVICES; i++)
 801520e:	7d7b      	ldrb	r3, [r7, #21]
 8015210:	f103 0301 	add.w	r3, r3, #1
 8015214:	757b      	strb	r3, [r7, #21]
 8015216:	7d7b      	ldrb	r3, [r7, #21]
 8015218:	2b0f      	cmp	r3, #15
 801521a:	bf8c      	ite	hi
 801521c:	2300      	movhi	r3, #0
 801521e:	2301      	movls	r3, #1
 8015220:	b2db      	uxtb	r3, r3
 8015222:	2b00      	cmp	r3, #0
 8015224:	d1d1      	bne.n	80151ca <_ZN3USB4TaskEv+0x192>
					if (devConfig[i])
							rcode = devConfig[i]->Release();

				usb_task_state = USB_DETACHED_SUBSTATE_WAIT_FOR_DEVICE;
 8015226:	f640 4360 	movw	r3, #3168	; 0xc60
 801522a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801522e:	f04f 0212 	mov.w	r2, #18
 8015232:	701a      	strb	r2, [r3, #0]
				break;
 8015234:	e0f1      	b.n	801541a <_ZN3USB4TaskEv+0x3e2>
		case USB_DETACHED_SUBSTATE_WAIT_FOR_DEVICE: //just sit here
				break;
		case USB_DETACHED_SUBSTATE_ILLEGAL: //just sit here
				break;
		case USB_ATTACHED_SUBSTATE_SETTLE: //settle time for just attached device
			if ((long)(millis() - timeout >= 0))	//timeout < millis())
 8015236:	f243 630c 	movw	r3, #13836	; 0x360c
 801523a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801523e:	681b      	ldr	r3, [r3, #0]
 8015240:	689b      	ldr	r3, [r3, #8]
 8015242:	4798      	blx	r3
 8015244:	f04f 0301 	mov.w	r3, #1
 8015248:	2b00      	cmp	r3, #0
 801524a:	f000 80df 	beq.w	801540c <_ZN3USB4TaskEv+0x3d4>
				usb_task_state = USB_ATTACHED_SUBSTATE_RESET_DEVICE;
 801524e:	f640 4360 	movw	r3, #3168	; 0xc60
 8015252:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015256:	f04f 0230 	mov.w	r2, #48	; 0x30
 801525a:	701a      	strb	r2, [r3, #0]
			break;
 801525c:	e0d6      	b.n	801540c <_ZN3USB4TaskEv+0x3d4>
		case USB_ATTACHED_SUBSTATE_RESET_DEVICE:
			toggle_led3();
 801525e:	f000 fe23 	bl	8015ea8 <_ZN7STM32F2I1a1bE11toggle_led3Ev>
			//regWr(rHCTL, bmBUSRST); //issue bus reset
			// what if i want to reset the specified device? (need to survey usb hub feature later)
			//pdev->host.SofHits = 0;
			usbhost_cb->reset_device_cb();	//HCD_ResetPort(pdev);
 8015262:	f243 6310 	movw	r3, #13840	; 0x3610
 8015266:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801526a:	681b      	ldr	r3, [r3, #0]
 801526c:	69db      	ldr	r3, [r3, #28]
 801526e:	4798      	blx	r3

			//usb_task_state = USB_ATTACHED_SUBSTATE_WAIT_RESET_COMPLETE;
			// the HCD_ResetPort() function will take care of a complete bus reset. so skip next phase.
			usb_task_state = USB_ATTACHED_SUBSTATE_WAIT_SOF;
 8015270:	f640 4360 	movw	r3, #3168	; 0xc60
 8015274:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015278:	f04f 0250 	mov.w	r2, #80	; 0x50
 801527c:	701a      	strb	r2, [r3, #0]
			break;
 801527e:	e0cc      	b.n	801541a <_ZN3USB4TaskEv+0x3e2>
						//timeout = millis() + 20; //20ms wait after reset per USB spec
				}
				break;*/

		case USB_ATTACHED_SUBSTATE_WAIT_SOF: //todo: change check order
			if(usbhost_cb->need_second_reset_cb()) {	//pdev->host.port_need_reset) {
 8015280:	f243 6310 	movw	r3, #13840	; 0x3610
 8015284:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015288:	681b      	ldr	r3, [r3, #0]
 801528a:	68db      	ldr	r3, [r3, #12]
 801528c:	4798      	blx	r3
 801528e:	4603      	mov	r3, r0
 8015290:	2b00      	cmp	r3, #0
 8015292:	bf0c      	ite	eq
 8015294:	2300      	moveq	r3, #0
 8015296:	2301      	movne	r3, #1
 8015298:	b2db      	uxtb	r3, r3
 801529a:	2b00      	cmp	r3, #0
 801529c:	d00f      	beq.n	80152be <_ZN3USB4TaskEv+0x286>
				usb_task_state = USB_ATTACHED_SUBSTATE_RESET_DEVICE;
 801529e:	f640 4360 	movw	r3, #3168	; 0xc60
 80152a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80152a6:	f04f 0230 	mov.w	r2, #48	; 0x30
 80152aa:	701a      	strb	r2, [r3, #0]
				//pdev->host.port_need_reset = 0;
				USBTRACE("\nLS Dev, reset again");
 80152ac:	f24e 70a0 	movw	r0, #59296	; 0xe7a0
 80152b0:	f6c0 0001 	movt	r0, #2049	; 0x801
 80152b4:	f04f 0180 	mov.w	r1, #128	; 0x80
 80152b8:	f004 f87c 	bl	80193b4 <_Z8E_NotifyPKci>
				break;
 80152bc:	e0ad      	b.n	801541a <_ZN3USB4TaskEv+0x3e2>
			}
			toggle_led3();
 80152be:	f000 fdf3 	bl	8015ea8 <_ZN7STM32F2I1a1bE11toggle_led3Ev>

			//if (regRd(rHIRQ) & bmFRAMEIRQ) {
			if(usbhost_cb->get_sof_hits_cb()) {	//pdev->host.SofHits) {
 80152c2:	f243 6310 	movw	r3, #13840	; 0x3610
 80152c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80152ca:	681b      	ldr	r3, [r3, #0]
 80152cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80152ce:	4798      	blx	r3
 80152d0:	4603      	mov	r3, r0
 80152d2:	2b00      	cmp	r3, #0
 80152d4:	bf0c      	ite	eq
 80152d6:	2300      	moveq	r3, #0
 80152d8:	2301      	movne	r3, #1
 80152da:	b2db      	uxtb	r3, r3
 80152dc:	2b00      	cmp	r3, #0
 80152de:	f000 8097 	beq.w	8015410 <_ZN3USB4TaskEv+0x3d8>
				//when first SOF received _and_ 20ms has passed we can continue
				usb_task_state = USB_ATTACHED_SUBSTATE_WAIT_RESET;
 80152e2:	f640 4360 	movw	r3, #3168	; 0xc60
 80152e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80152ea:	f04f 0251 	mov.w	r2, #81	; 0x51
 80152ee:	701a      	strb	r2, [r3, #0]
				timeout = millis() + 20;
 80152f0:	f243 630c 	movw	r3, #13836	; 0x360c
 80152f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80152f8:	681b      	ldr	r3, [r3, #0]
 80152fa:	689b      	ldr	r3, [r3, #8]
 80152fc:	4798      	blx	r3
 80152fe:	4603      	mov	r3, r0
 8015300:	f103 0214 	add.w	r2, r3, #20
 8015304:	f640 4364 	movw	r3, #3172	; 0xc64
 8015308:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801530c:	601a      	str	r2, [r3, #0]
			}
			break;
 801530e:	e07f      	b.n	8015410 <_ZN3USB4TaskEv+0x3d8>
		case USB_ATTACHED_SUBSTATE_WAIT_RESET:
			if ((long)(millis() - timeout > 0)) {		//timeout < millis()) {
 8015310:	f243 630c 	movw	r3, #13836	; 0x360c
 8015314:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015318:	681b      	ldr	r3, [r3, #0]
 801531a:	689b      	ldr	r3, [r3, #8]
 801531c:	4798      	blx	r3
 801531e:	4603      	mov	r3, r0
 8015320:	461a      	mov	r2, r3
 8015322:	f640 4364 	movw	r3, #3172	; 0xc64
 8015326:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801532a:	681b      	ldr	r3, [r3, #0]
 801532c:	429a      	cmp	r2, r3
 801532e:	bf0c      	ite	eq
 8015330:	2300      	moveq	r3, #0
 8015332:	2301      	movne	r3, #1
 8015334:	b2db      	uxtb	r3, r3
 8015336:	2b00      	cmp	r3, #0
 8015338:	d06c      	beq.n	8015414 <_ZN3USB4TaskEv+0x3dc>
				usb_task_state = USB_STATE_CONFIGURING;
 801533a:	f640 4360 	movw	r3, #3168	; 0xc60
 801533e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015342:	f04f 0280 	mov.w	r2, #128	; 0x80
 8015346:	701a      	strb	r2, [r3, #0]
			}
			break;
 8015348:	e064      	b.n	8015414 <_ZN3USB4TaskEv+0x3dc>
		case USB_STATE_CONFIGURING:
			toggle_led3();
 801534a:	f000 fdad 	bl	8015ea8 <_ZN7STM32F2I1a1bE11toggle_led3Ev>
					//Serial.print("\r\nConf.LS: ");
					//Serial.println(lowspeed, HEX);
			USBTRACE("\nTODO:Support all 8 USB pipe?");
 801534e:	f24e 70b8 	movw	r0, #59320	; 0xe7b8
 8015352:	f6c0 0001 	movt	r0, #2049	; 0x801
 8015356:	f04f 0180 	mov.w	r1, #128	; 0x80
 801535a:	f004 f82b 	bl	80193b4 <_Z8E_NotifyPKci>
			rcode = Configuring(0, 0, lowspeed);
 801535e:	7dfb      	ldrb	r3, [r7, #23]
 8015360:	6878      	ldr	r0, [r7, #4]
 8015362:	f04f 0100 	mov.w	r1, #0
 8015366:	f04f 0200 	mov.w	r2, #0
 801536a:	f000 f935 	bl	80155d8 <_ZN3USB11ConfiguringEhhb>
 801536e:	4603      	mov	r3, r0
 8015370:	74fb      	strb	r3, [r7, #19]

			if (rcode) {
 8015372:	7cfb      	ldrb	r3, [r7, #19]
 8015374:	2b00      	cmp	r3, #0
 8015376:	d010      	beq.n	801539a <_ZN3USB4TaskEv+0x362>
				if (rcode != USB_DEV_CONFIG_ERROR_DEVICE_INIT_INCOMPLETE) {
 8015378:	7cfb      	ldrb	r3, [r7, #19]
 801537a:	2bd2      	cmp	r3, #210	; 0xd2
 801537c:	d04c      	beq.n	8015418 <_ZN3USB4TaskEv+0x3e0>
					usb_error = rcode;
 801537e:	f640 435f 	movw	r3, #3167	; 0xc5f
 8015382:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015386:	7cfa      	ldrb	r2, [r7, #19]
 8015388:	701a      	strb	r2, [r3, #0]
					usb_task_state = USB_STATE_ERROR;
 801538a:	f640 4360 	movw	r3, #3168	; 0xc60
 801538e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015392:	f04f 02a0 	mov.w	r2, #160	; 0xa0
 8015396:	701a      	strb	r2, [r3, #0]
				}
			} else
				usb_task_state = USB_STATE_RUNNING;
			break;
 8015398:	e03e      	b.n	8015418 <_ZN3USB4TaskEv+0x3e0>
				if (rcode != USB_DEV_CONFIG_ERROR_DEVICE_INIT_INCOMPLETE) {
					usb_error = rcode;
					usb_task_state = USB_STATE_ERROR;
				}
			} else
				usb_task_state = USB_STATE_RUNNING;
 801539a:	f640 4360 	movw	r3, #3168	; 0xc60
 801539e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80153a2:	f04f 0290 	mov.w	r2, #144	; 0x90
 80153a6:	701a      	strb	r2, [r3, #0]
			break;
 80153a8:	e036      	b.n	8015418 <_ZN3USB4TaskEv+0x3e0>
		case USB_STATE_RUNNING:
			break;
		case USB_STATE_ERROR:
	        AddressPool &addrPool = GetAddressPool();
 80153aa:	6878      	ldr	r0, [r7, #4]
 80153ac:	f7ff f834 	bl	8014418 <_ZN3USB14GetAddressPoolEv>
 80153b0:	60f8      	str	r0, [r7, #12]
	        // Get pointer to pseudo device with address 0 assigned
	        UsbDevice *p = addrPool.GetUsbDevicePtr(0);
 80153b2:	68fb      	ldr	r3, [r7, #12]
 80153b4:	681b      	ldr	r3, [r3, #0]
 80153b6:	681b      	ldr	r3, [r3, #0]
 80153b8:	68f8      	ldr	r0, [r7, #12]
 80153ba:	f04f 0100 	mov.w	r1, #0
 80153be:	4798      	blx	r3
 80153c0:	4603      	mov	r3, r0
 80153c2:	60bb      	str	r3, [r7, #8]

			//USBH_Free_Channel(pdev, p->epinfo->hcNumOut);
			usbhost_cb->device_removed_cb(p->epinfo->hcNumOut);
 80153c4:	f243 6310 	movw	r3, #13840	; 0x3610
 80153c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80153cc:	681b      	ldr	r3, [r3, #0]
 80153ce:	699b      	ldr	r3, [r3, #24]
 80153d0:	68ba      	ldr	r2, [r7, #8]
 80153d2:	6812      	ldr	r2, [r2, #0]
 80153d4:	78d2      	ldrb	r2, [r2, #3]
 80153d6:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80153da:	b2d2      	uxtb	r2, r2
 80153dc:	4610      	mov	r0, r2
 80153de:	4798      	blx	r3
			//USBH_Free_Channel(pdev, p->epinfo->hcNumIn);
			usbhost_cb->device_removed_cb(p->epinfo->hcNumIn);
 80153e0:	f243 6310 	movw	r3, #13840	; 0x3610
 80153e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80153e8:	681b      	ldr	r3, [r3, #0]
 80153ea:	699b      	ldr	r3, [r3, #24]
 80153ec:	68ba      	ldr	r2, [r7, #8]
 80153ee:	6812      	ldr	r2, [r2, #0]
 80153f0:	78d2      	ldrb	r2, [r2, #3]
 80153f2:	f3c2 0203 	ubfx	r2, r2, #0, #4
 80153f6:	b2d2      	uxtb	r2, r2
 80153f8:	4610      	mov	r0, r2
 80153fa:	4798      	blx	r3
			break;
 80153fc:	bf00      	nop
 80153fe:	e00c      	b.n	801541a <_ZN3USB4TaskEv+0x3e2>
							rcode = devConfig[i]->Release();

				usb_task_state = USB_DETACHED_SUBSTATE_WAIT_FOR_DEVICE;
				break;
		case USB_DETACHED_SUBSTATE_WAIT_FOR_DEVICE: //just sit here
				break;
 8015400:	bf00      	nop
 8015402:	e00a      	b.n	801541a <_ZN3USB4TaskEv+0x3e2>
		case USB_DETACHED_SUBSTATE_ILLEGAL: //just sit here
				break;
 8015404:	bf00      	nop
 8015406:	e008      	b.n	801541a <_ZN3USB4TaskEv+0x3e2>
				}
			} else
				usb_task_state = USB_STATE_RUNNING;
			break;
		case USB_STATE_RUNNING:
			break;
 8015408:	bf00      	nop
 801540a:	e006      	b.n	801541a <_ZN3USB4TaskEv+0x3e2>
		case USB_DETACHED_SUBSTATE_ILLEGAL: //just sit here
				break;
		case USB_ATTACHED_SUBSTATE_SETTLE: //settle time for just attached device
			if ((long)(millis() - timeout >= 0))	//timeout < millis())
				usb_task_state = USB_ATTACHED_SUBSTATE_RESET_DEVICE;
			break;
 801540c:	bf00      	nop
 801540e:	e004      	b.n	801541a <_ZN3USB4TaskEv+0x3e2>
			if(usbhost_cb->get_sof_hits_cb()) {	//pdev->host.SofHits) {
				//when first SOF received _and_ 20ms has passed we can continue
				usb_task_state = USB_ATTACHED_SUBSTATE_WAIT_RESET;
				timeout = millis() + 20;
			}
			break;
 8015410:	bf00      	nop
 8015412:	e002      	b.n	801541a <_ZN3USB4TaskEv+0x3e2>
		case USB_ATTACHED_SUBSTATE_WAIT_RESET:
			if ((long)(millis() - timeout > 0)) {		//timeout < millis()) {
				usb_task_state = USB_STATE_CONFIGURING;
			}
			break;
 8015414:	bf00      	nop
 8015416:	e000      	b.n	801541a <_ZN3USB4TaskEv+0x3e2>
					usb_error = rcode;
					usb_task_state = USB_STATE_ERROR;
				}
			} else
				usb_task_state = USB_STATE_RUNNING;
			break;
 8015418:	bf00      	nop
			usbhost_cb->device_removed_cb(p->epinfo->hcNumOut);
			//USBH_Free_Channel(pdev, p->epinfo->hcNumIn);
			usbhost_cb->device_removed_cb(p->epinfo->hcNumIn);
			break;
	} // switch( usb_task_state )
}
 801541a:	f107 0718 	add.w	r7, r7, #24
 801541e:	46bd      	mov	sp, r7
 8015420:	bd80      	pop	{r7, pc}
 8015422:	bf00      	nop

08015424 <_ZN3USB17DefaultAddressingEhhb>:

uint8_t USB::DefaultAddressing(uint8_t parent, uint8_t port, bool lowspeed) {
 8015424:	b580      	push	{r7, lr}
 8015426:	b086      	sub	sp, #24
 8015428:	af00      	add	r7, sp, #0
 801542a:	6078      	str	r0, [r7, #4]
 801542c:	70f9      	strb	r1, [r7, #3]
 801542e:	70ba      	strb	r2, [r7, #2]
 8015430:	707b      	strb	r3, [r7, #1]
        //uint8_t		buf[12];
        uint8_t rcode;
        UsbDevice *p0 = NULL, *p = NULL;
 8015432:	f04f 0300 	mov.w	r3, #0
 8015436:	617b      	str	r3, [r7, #20]
 8015438:	f04f 0300 	mov.w	r3, #0
 801543c:	613b      	str	r3, [r7, #16]

        // Get pointer to pseudo device with address 0 assigned
        p0 = addrPool.GetUsbDevicePtr(0);
 801543e:	687b      	ldr	r3, [r7, #4]
 8015440:	4618      	mov	r0, r3
 8015442:	f04f 0100 	mov.w	r1, #0
 8015446:	f000 fcf5 	bl	8015e34 <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh>
 801544a:	4603      	mov	r3, r0
 801544c:	617b      	str	r3, [r7, #20]

        if (!p0)
 801544e:	697b      	ldr	r3, [r7, #20]
 8015450:	2b00      	cmp	r3, #0
 8015452:	d102      	bne.n	801545a <_ZN3USB17DefaultAddressingEhhb+0x36>
			return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
 8015454:	f04f 03d6 	mov.w	r3, #214	; 0xd6
 8015458:	e045      	b.n	80154e6 <_ZN3USB17DefaultAddressingEhhb+0xc2>

        if (!p0->epinfo)
 801545a:	697b      	ldr	r3, [r7, #20]
 801545c:	681b      	ldr	r3, [r3, #0]
 801545e:	2b00      	cmp	r3, #0
 8015460:	d102      	bne.n	8015468 <_ZN3USB17DefaultAddressingEhhb+0x44>
			return USB_ERROR_EPINFO_IS_NULL;
 8015462:	f04f 03d7 	mov.w	r3, #215	; 0xd7
 8015466:	e03e      	b.n	80154e6 <_ZN3USB17DefaultAddressingEhhb+0xc2>

        p0->lowspeed = (lowspeed) ? true : false;
 8015468:	697b      	ldr	r3, [r7, #20]
 801546a:	787a      	ldrb	r2, [r7, #1]
 801546c:	719a      	strb	r2, [r3, #6]

        // Allocate new address according to device class
        uint8_t bAddress = addrPool.AllocAddress(parent, false, port);
 801546e:	6879      	ldr	r1, [r7, #4]
 8015470:	78fa      	ldrb	r2, [r7, #3]
 8015472:	78bb      	ldrb	r3, [r7, #2]
 8015474:	4608      	mov	r0, r1
 8015476:	4611      	mov	r1, r2
 8015478:	f04f 0200 	mov.w	r2, #0
 801547c:	f000 fd40 	bl	8015f00 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh>
 8015480:	4603      	mov	r3, r0
 8015482:	73fb      	strb	r3, [r7, #15]

        if (!bAddress)
 8015484:	7bfb      	ldrb	r3, [r7, #15]
 8015486:	2b00      	cmp	r3, #0
 8015488:	d102      	bne.n	8015490 <_ZN3USB17DefaultAddressingEhhb+0x6c>
			return USB_ERROR_OUT_OF_ADDRESS_SPACE_IN_POOL;
 801548a:	f04f 03d4 	mov.w	r3, #212	; 0xd4
 801548e:	e02a      	b.n	80154e6 <_ZN3USB17DefaultAddressingEhhb+0xc2>

        p = addrPool.GetUsbDevicePtr(bAddress);
 8015490:	687a      	ldr	r2, [r7, #4]
 8015492:	7bfb      	ldrb	r3, [r7, #15]
 8015494:	4610      	mov	r0, r2
 8015496:	4619      	mov	r1, r3
 8015498:	f000 fccc 	bl	8015e34 <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh>
 801549c:	4603      	mov	r3, r0
 801549e:	613b      	str	r3, [r7, #16]

        if (!p)
 80154a0:	693b      	ldr	r3, [r7, #16]
 80154a2:	2b00      	cmp	r3, #0
 80154a4:	d102      	bne.n	80154ac <_ZN3USB17DefaultAddressingEhhb+0x88>
                return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
 80154a6:	f04f 03d6 	mov.w	r3, #214	; 0xd6
 80154aa:	e01c      	b.n	80154e6 <_ZN3USB17DefaultAddressingEhhb+0xc2>

        p->lowspeed = lowspeed;
 80154ac:	693b      	ldr	r3, [r7, #16]
 80154ae:	787a      	ldrb	r2, [r7, #1]
 80154b0:	719a      	strb	r2, [r3, #6]

        // Assign new address to the device
        rcode = setAddr(0, 0, bAddress);
 80154b2:	7bfb      	ldrb	r3, [r7, #15]
 80154b4:	6878      	ldr	r0, [r7, #4]
 80154b6:	f04f 0100 	mov.w	r1, #0
 80154ba:	f04f 0200 	mov.w	r2, #0
 80154be:	f000 fc05 	bl	8015ccc <_ZN3USB7setAddrEhhh>
 80154c2:	4603      	mov	r3, r0
 80154c4:	73bb      	strb	r3, [r7, #14]

        if (rcode) {
 80154c6:	7bbb      	ldrb	r3, [r7, #14]
 80154c8:	2b00      	cmp	r3, #0
 80154ca:	d00a      	beq.n	80154e2 <_ZN3USB17DefaultAddressingEhhb+0xbe>
			addrPool.FreeAddress(bAddress);
 80154cc:	687a      	ldr	r2, [r7, #4]
 80154ce:	7bfb      	ldrb	r3, [r7, #15]
 80154d0:	4610      	mov	r0, r2
 80154d2:	4619      	mov	r1, r3
 80154d4:	f000 fdbc 	bl	8016050 <_ZN15AddressPoolImplILh16EE11FreeAddressEh>
			bAddress = 0;
 80154d8:	f04f 0300 	mov.w	r3, #0
 80154dc:	73fb      	strb	r3, [r7, #15]
			return rcode;
 80154de:	7bbb      	ldrb	r3, [r7, #14]
 80154e0:	e001      	b.n	80154e6 <_ZN3USB17DefaultAddressingEhhb+0xc2>
        }
        return 0;
 80154e2:	f04f 0300 	mov.w	r3, #0
};
 80154e6:	4618      	mov	r0, r3
 80154e8:	f107 0718 	add.w	r7, r7, #24
 80154ec:	46bd      	mov	sp, r7
 80154ee:	bd80      	pop	{r7, pc}

080154f0 <_ZN3USB13AttemptConfigEhhhb>:

uint8_t USB::AttemptConfig(uint8_t driver, uint8_t parent, uint8_t port, bool lowspeed) {
 80154f0:	b590      	push	{r4, r7, lr}
 80154f2:	b085      	sub	sp, #20
 80154f4:	af00      	add	r7, sp, #0
 80154f6:	6078      	str	r0, [r7, #4]
 80154f8:	70f9      	strb	r1, [r7, #3]
 80154fa:	70ba      	strb	r2, [r7, #2]
 80154fc:	707b      	strb	r3, [r7, #1]
	uint8_t rcode = 0;
 80154fe:	f04f 0300 	mov.w	r3, #0
 8015502:	73fb      	strb	r3, [r7, #15]
	//xprintf("AttemptConfig: parent = %i, port = %i\r\n", parent, port);

	rcode = devConfig[driver]->ConfigureDevice(parent, port, lowspeed);
 8015504:	78fb      	ldrb	r3, [r7, #3]
 8015506:	687a      	ldr	r2, [r7, #4]
 8015508:	f103 031e 	add.w	r3, r3, #30
 801550c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8015510:	18d3      	adds	r3, r2, r3
 8015512:	685b      	ldr	r3, [r3, #4]
 8015514:	681b      	ldr	r3, [r3, #0]
 8015516:	f103 0304 	add.w	r3, r3, #4
 801551a:	681c      	ldr	r4, [r3, #0]
 801551c:	78fb      	ldrb	r3, [r7, #3]
 801551e:	687a      	ldr	r2, [r7, #4]
 8015520:	f103 031e 	add.w	r3, r3, #30
 8015524:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8015528:	18d3      	adds	r3, r2, r3
 801552a:	6858      	ldr	r0, [r3, #4]
 801552c:	78b9      	ldrb	r1, [r7, #2]
 801552e:	787a      	ldrb	r2, [r7, #1]
 8015530:	f897 3020 	ldrb.w	r3, [r7, #32]
 8015534:	47a0      	blx	r4
 8015536:	4603      	mov	r3, r0
 8015538:	73fb      	strb	r3, [r7, #15]
	if (rcode == USB_ERROR_CONFIG_REQUIRES_ADDITIONAL_RESET) {
 801553a:	7bfb      	ldrb	r3, [r7, #15]
 801553c:	2be0      	cmp	r3, #224	; 0xe0
 801553e:	d12c      	bne.n	801559a <_ZN3USB13AttemptConfigEhhhb+0xaa>
		if (parent == 0) {
 8015540:	78bb      	ldrb	r3, [r7, #2]
 8015542:	2b00      	cmp	r3, #0
 8015544:	d111      	bne.n	801556a <_ZN3USB13AttemptConfigEhhhb+0x7a>
			// Send a bus reset on the root interface.
			USBTRACE("\n\rusb::atte need reset?");
 8015546:	f24e 70d8 	movw	r0, #59352	; 0xe7d8
 801554a:	f6c0 0001 	movt	r0, #2049	; 0x801
 801554e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8015552:	f003 ff2f 	bl	80193b4 <_Z8E_NotifyPKci>
//TODO: but reset			regWr(rHCTL, bmBUSRST); //issue bus reset
			delay_ms(102); // delay 102ms, compensate for clock inaccuracy.
 8015556:	f243 630c 	movw	r3, #13836	; 0x360c
 801555a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801555e:	681b      	ldr	r3, [r3, #0]
 8015560:	685b      	ldr	r3, [r3, #4]
 8015562:	f04f 0066 	mov.w	r0, #102	; 0x66
 8015566:	4798      	blx	r3
 8015568:	e017      	b.n	801559a <_ZN3USB13AttemptConfigEhhhb+0xaa>
		} else {
			// reset parent port
			devConfig[parent]->ResetHubPort(port);
 801556a:	78bb      	ldrb	r3, [r7, #2]
 801556c:	687a      	ldr	r2, [r7, #4]
 801556e:	f103 031e 	add.w	r3, r3, #30
 8015572:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8015576:	18d3      	adds	r3, r2, r3
 8015578:	685b      	ldr	r3, [r3, #4]
 801557a:	681b      	ldr	r3, [r3, #0]
 801557c:	f103 0314 	add.w	r3, r3, #20
 8015580:	681a      	ldr	r2, [r3, #0]
 8015582:	78bb      	ldrb	r3, [r7, #2]
 8015584:	6879      	ldr	r1, [r7, #4]
 8015586:	f103 031e 	add.w	r3, r3, #30
 801558a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801558e:	18cb      	adds	r3, r1, r3
 8015590:	6859      	ldr	r1, [r3, #4]
 8015592:	787b      	ldrb	r3, [r7, #1]
 8015594:	4608      	mov	r0, r1
 8015596:	4619      	mov	r1, r3
 8015598:	4790      	blx	r2
		}
	}
	rcode = devConfig[driver]->Init(parent, port, lowspeed);
 801559a:	78fb      	ldrb	r3, [r7, #3]
 801559c:	687a      	ldr	r2, [r7, #4]
 801559e:	f103 031e 	add.w	r3, r3, #30
 80155a2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80155a6:	18d3      	adds	r3, r2, r3
 80155a8:	685b      	ldr	r3, [r3, #4]
 80155aa:	681b      	ldr	r3, [r3, #0]
 80155ac:	681c      	ldr	r4, [r3, #0]
 80155ae:	78fb      	ldrb	r3, [r7, #3]
 80155b0:	687a      	ldr	r2, [r7, #4]
 80155b2:	f103 031e 	add.w	r3, r3, #30
 80155b6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80155ba:	18d3      	adds	r3, r2, r3
 80155bc:	6858      	ldr	r0, [r3, #4]
 80155be:	78b9      	ldrb	r1, [r7, #2]
 80155c0:	787a      	ldrb	r2, [r7, #1]
 80155c2:	f897 3020 	ldrb.w	r3, [r7, #32]
 80155c6:	47a0      	blx	r4
 80155c8:	4603      	mov	r3, r0
 80155ca:	73fb      	strb	r3, [r7, #15]
	return rcode;
 80155cc:	7bfb      	ldrb	r3, [r7, #15]
}
 80155ce:	4618      	mov	r0, r3
 80155d0:	f107 0714 	add.w	r7, r7, #20
 80155d4:	46bd      	mov	sp, r7
 80155d6:	bd90      	pop	{r4, r7, pc}

080155d8 <_ZN3USB11ConfiguringEhhb>:
 * 7: for(each driver) {
 *      7a: Ask device if it knows this VID/PID. Acts exactly like 6a, but using VID/PID
 * 8: if we get here, no driver likes the device plugged in, so exit failure.
 *
 */
uint8_t USB::Configuring(uint8_t parent, uint8_t port, bool lowspeed) {
 80155d8:	b590      	push	{r4, r7, lr}
 80155da:	b091      	sub	sp, #68	; 0x44
 80155dc:	af02      	add	r7, sp, #8
 80155de:	6078      	str	r0, [r7, #4]
 80155e0:	70f9      	strb	r1, [r7, #3]
 80155e2:	70ba      	strb	r2, [r7, #2]
 80155e4:	707b      	strb	r3, [r7, #1]
        //uint8_t bAddress = 0;
        //printf("\r\nConfiguring: parent = %i, port = %i", parent, port);
        uint8_t devConfigIndex;
        uint8_t rcode = 0;
 80155e6:	f04f 0300 	mov.w	r3, #0
 80155ea:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
        uint8_t buf[sizeof (USB_DEVICE_DESCRIPTOR)];
        UsbDevice *p = NULL;
 80155ee:	f04f 0300 	mov.w	r3, #0
 80155f2:	633b      	str	r3, [r7, #48]	; 0x30
//        EpInfo *oldep_ptr = NULL;
        EpInfo epInfo;
        //USB_OTG_CORE_HANDLE *pdev = coreConfig;

        epInfo.epAddr = 0;
 80155f4:	f04f 0300 	mov.w	r3, #0
 80155f8:	723b      	strb	r3, [r7, #8]
        epInfo.maxPktSize = 8;
 80155fa:	f04f 0308 	mov.w	r3, #8
 80155fe:	727b      	strb	r3, [r7, #9]
        epInfo.epAttribs = 0;
 8015600:	f04f 0300 	mov.w	r3, #0
 8015604:	733b      	strb	r3, [r7, #12]
        epInfo.bmNakPower = USB_NAK_MAX_POWER;
 8015606:	7b3b      	ldrb	r3, [r7, #12]
 8015608:	f04f 020f 	mov.w	r2, #15
 801560c:	f362 0387 	bfi	r3, r2, #2, #6
 8015610:	733b      	strb	r3, [r7, #12]

        uint8_t pipe_num = usbhost_cb->device_attached_cb(lowspeed, epInfo.bmNakPower);
 8015612:	f243 6310 	movw	r3, #13840	; 0x3610
 8015616:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801561a:	681b      	ldr	r3, [r3, #0]
 801561c:	681b      	ldr	r3, [r3, #0]
 801561e:	7879      	ldrb	r1, [r7, #1]
 8015620:	7b3a      	ldrb	r2, [r7, #12]
 8015622:	f3c2 0285 	ubfx	r2, r2, #2, #6
 8015626:	b2d2      	uxtb	r2, r2
 8015628:	4608      	mov	r0, r1
 801562a:	4611      	mov	r1, r2
 801562c:	4798      	blx	r3
 801562e:	4603      	mov	r3, r0
 8015630:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		epInfo.hcNumOut = (pipe_num >> 4) & 0xF;
 8015634:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8015638:	ea4f 1313 	mov.w	r3, r3, lsr #4
 801563c:	b2db      	uxtb	r3, r3
 801563e:	f003 030f 	and.w	r3, r3, #15
 8015642:	b2da      	uxtb	r2, r3
 8015644:	7afb      	ldrb	r3, [r7, #11]
 8015646:	f362 1307 	bfi	r3, r2, #4, #4
 801564a:	72fb      	strb	r3, [r7, #11]
		epInfo.hcNumIn = pipe_num & 0xF;
 801564c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8015650:	f003 030f 	and.w	r3, r3, #15
 8015654:	b2da      	uxtb	r2, r3
 8015656:	7afb      	ldrb	r3, [r7, #11]
 8015658:	f362 0303 	bfi	r3, r2, #0, #4
 801565c:	72fb      	strb	r3, [r7, #11]
		USBTRACE2("\nControl Pipe: out = %d (0)", epInfo.hcNumOut);
 801565e:	f24e 70f0 	movw	r0, #59376	; 0xe7f0
 8015662:	f6c0 0001 	movt	r0, #2049	; 0x801
 8015666:	f04f 0180 	mov.w	r1, #128	; 0x80
 801566a:	f003 fea3 	bl	80193b4 <_Z8E_NotifyPKci>
 801566e:	7afb      	ldrb	r3, [r7, #11]
 8015670:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8015674:	b2db      	uxtb	r3, r3
 8015676:	4618      	mov	r0, r3
 8015678:	f04f 0180 	mov.w	r1, #128	; 0x80
 801567c:	f000 fc04 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 8015680:	f24e 7030 	movw	r0, #59184	; 0xe730
 8015684:	f6c0 0001 	movt	r0, #2049	; 0x801
 8015688:	f04f 0180 	mov.w	r1, #128	; 0x80
 801568c:	f003 fe92 	bl	80193b4 <_Z8E_NotifyPKci>
		USBTRACE2(", in = %d (1)", epInfo.hcNumIn);
 8015690:	f64e 000c 	movw	r0, #59404	; 0xe80c
 8015694:	f6c0 0001 	movt	r0, #2049	; 0x801
 8015698:	f04f 0180 	mov.w	r1, #128	; 0x80
 801569c:	f003 fe8a 	bl	80193b4 <_Z8E_NotifyPKci>
 80156a0:	7afb      	ldrb	r3, [r7, #11]
 80156a2:	f3c3 0303 	ubfx	r3, r3, #0, #4
 80156a6:	b2db      	uxtb	r3, r3
 80156a8:	4618      	mov	r0, r3
 80156aa:	f04f 0180 	mov.w	r1, #128	; 0x80
 80156ae:	f000 fbeb 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 80156b2:	f24e 7030 	movw	r0, #59184	; 0xe730
 80156b6:	f6c0 0001 	movt	r0, #2049	; 0x801
 80156ba:	f04f 0180 	mov.w	r1, #128	; 0x80
 80156be:	f003 fe79 	bl	80193b4 <_Z8E_NotifyPKci>
        system_cb->delay_micro_second_cb(1000);
 80156c2:	f243 630c 	movw	r3, #13836	; 0x360c
 80156c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80156ca:	681b      	ldr	r3, [r3, #0]
 80156cc:	681b      	ldr	r3, [r3, #0]
 80156ce:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80156d2:	4798      	blx	r3
        AddressPool &addrPool = GetAddressPool();
 80156d4:	6878      	ldr	r0, [r7, #4]
 80156d6:	f7fe fe9f 	bl	8014418 <_ZN3USB14GetAddressPoolEv>
 80156da:	62b8      	str	r0, [r7, #40]	; 0x28
        // Get pointer to pseudo device with address 0 assigned
        p = addrPool.GetUsbDevicePtr(0);
 80156dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80156de:	681b      	ldr	r3, [r3, #0]
 80156e0:	681b      	ldr	r3, [r3, #0]
 80156e2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80156e4:	f04f 0100 	mov.w	r1, #0
 80156e8:	4798      	blx	r3
 80156ea:	4603      	mov	r3, r0
 80156ec:	633b      	str	r3, [r7, #48]	; 0x30
        if (!p) {
 80156ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80156f0:	2b00      	cmp	r3, #0
 80156f2:	d10a      	bne.n	801570a <_ZN3USB11ConfiguringEhhb+0x132>
        	USBTRACE("Configuring error: USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL\r\n");
 80156f4:	f64e 001c 	movw	r0, #59420	; 0xe81c
 80156f8:	f6c0 0001 	movt	r0, #2049	; 0x801
 80156fc:	f04f 0180 	mov.w	r1, #128	; 0x80
 8015700:	f003 fe58 	bl	80193b4 <_Z8E_NotifyPKci>
			return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
 8015704:	f04f 03d6 	mov.w	r3, #214	; 0xd6
 8015708:	e181      	b.n	8015a0e <_ZN3USB11ConfiguringEhhb+0x436>
        // oldep_ptr = p->epinfo;

        // Temporary assign new pointer to epInfo to p->epinfo in order to
        // avoid toggle inconsistence

        p->epinfo = &epInfo;
 801570a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801570c:	f107 0208 	add.w	r2, r7, #8
 8015710:	601a      	str	r2, [r3, #0]

        p->lowspeed = lowspeed;
 8015712:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015714:	787a      	ldrb	r2, [r7, #1]
 8015716:	719a      	strb	r2, [r3, #6]

        // Get device descriptor
        rcode = getDevDescr(0, 0, 8, (uint8_t*)buf);	// 8 should be enough, sizeof (USB_DEVICE_DESCRIPTOR)
 8015718:	f107 0310 	add.w	r3, r7, #16
 801571c:	9300      	str	r3, [sp, #0]
 801571e:	6878      	ldr	r0, [r7, #4]
 8015720:	f04f 0100 	mov.w	r1, #0
 8015724:	f04f 0200 	mov.w	r2, #0
 8015728:	f04f 0308 	mov.w	r3, #8
 801572c:	f000 f9de 	bl	8015aec <_ZN3USB11getDevDescrEhhtPh>
 8015730:	4603      	mov	r3, r0
 8015732:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
        USBTRACE("\nControl - Got 1st 8 bytes desc");
 8015736:	f64e 0058 	movw	r0, #59480	; 0xe858
 801573a:	f6c0 0001 	movt	r0, #2049	; 0x801
 801573e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8015742:	f003 fe37 	bl	80193b4 <_Z8E_NotifyPKci>

        // Extract Max Packet Size from the device descriptor
        epInfo.maxPktSize = (uint8_t)((USB_DEVICE_DESCRIPTOR*)buf)->bMaxPacketSize0;
 8015746:	f107 0310 	add.w	r3, r7, #16
 801574a:	79db      	ldrb	r3, [r3, #7]
 801574c:	727b      	strb	r3, [r7, #9]

        // Restore p->epinfo
//         keep CtrlXfer's hcNumOut/In in p->epinfo. p->epinfo = oldep_ptr;

        if (rcode) {
 801574e:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8015752:	2b00      	cmp	r3, #0
 8015754:	d019      	beq.n	801578a <_ZN3USB11ConfiguringEhhb+0x1b2>
        	USBTRACE2("Configuring error: Can't get USB_DEVICE_DESCRIPTOR\r\n", rcode);
 8015756:	f64e 0078 	movw	r0, #59512	; 0xe878
 801575a:	f6c0 0001 	movt	r0, #2049	; 0x801
 801575e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8015762:	f003 fe27 	bl	80193b4 <_Z8E_NotifyPKci>
 8015766:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 801576a:	4618      	mov	r0, r3
 801576c:	f04f 0180 	mov.w	r1, #128	; 0x80
 8015770:	f000 fb8a 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 8015774:	f24e 7030 	movw	r0, #59184	; 0xe730
 8015778:	f6c0 0001 	movt	r0, #2049	; 0x801
 801577c:	f04f 0180 	mov.w	r1, #128	; 0x80
 8015780:	f003 fe18 	bl	80193b4 <_Z8E_NotifyPKci>
            return rcode;
 8015784:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8015788:	e141      	b.n	8015a0e <_ZN3USB11ConfiguringEhhb+0x436>
        // Allocate new address according to device class
        //bAddress = addrPool.AllocAddress(parent, false, port);

        //if (!bAddress)
        //        return USB_ERROR_OUT_OF_ADDRESS_SPACE_IN_POOL;
        rcode = getDevDescr(0, 0, sizeof(USB_DEVICE_DESCRIPTOR), (uint8_t*)buf);
 801578a:	f107 0310 	add.w	r3, r7, #16
 801578e:	9300      	str	r3, [sp, #0]
 8015790:	6878      	ldr	r0, [r7, #4]
 8015792:	f04f 0100 	mov.w	r1, #0
 8015796:	f04f 0200 	mov.w	r2, #0
 801579a:	f04f 0312 	mov.w	r3, #18
 801579e:	f000 f9a5 	bl	8015aec <_ZN3USB11getDevDescrEhhtPh>
 80157a2:	4603      	mov	r3, r0
 80157a4:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
        USBTRACE("\nControl - Got 2nd 18 bytes desc.");
 80157a8:	f64e 00b0 	movw	r0, #59568	; 0xe8b0
 80157ac:	f6c0 0001 	movt	r0, #2049	; 0x801
 80157b0:	f04f 0180 	mov.w	r1, #128	; 0x80
 80157b4:	f003 fdfe 	bl	80193b4 <_Z8E_NotifyPKci>

        uint16_t vid = (uint16_t)((USB_DEVICE_DESCRIPTOR*)buf)->idVendor;
 80157b8:	f107 0310 	add.w	r3, r7, #16
 80157bc:	7a1a      	ldrb	r2, [r3, #8]
 80157be:	7a5b      	ldrb	r3, [r3, #9]
 80157c0:	ea4f 2303 	mov.w	r3, r3, lsl #8
 80157c4:	4313      	orrs	r3, r2
 80157c6:	84fb      	strh	r3, [r7, #38]	; 0x26
        uint16_t pid = (uint16_t)((USB_DEVICE_DESCRIPTOR*)buf)->idProduct;
 80157c8:	f107 0310 	add.w	r3, r7, #16
 80157cc:	7a9a      	ldrb	r2, [r3, #10]
 80157ce:	7adb      	ldrb	r3, [r3, #11]
 80157d0:	ea4f 2303 	mov.w	r3, r3, lsl #8
 80157d4:	4313      	orrs	r3, r2
 80157d6:	84bb      	strh	r3, [r7, #36]	; 0x24
        uint8_t klass = ((USB_DEVICE_DESCRIPTOR*)buf)->bDeviceClass;
 80157d8:	f107 0310 	add.w	r3, r7, #16
 80157dc:	791b      	ldrb	r3, [r3, #4]
 80157de:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

        // Attempt to configure if VID/PID or device class matches with a driver
        for (devConfigIndex = 0; devConfigIndex < USB_NUMDEVICES; devConfigIndex++) {
 80157e2:	f04f 0300 	mov.w	r3, #0
 80157e6:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 80157ea:	e099      	b.n	8015920 <_ZN3USB11ConfiguringEhhb+0x348>
			if (!devConfig[devConfigIndex]) continue; // no driver
 80157ec:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80157f0:	687a      	ldr	r2, [r7, #4]
 80157f2:	f103 031e 	add.w	r3, r3, #30
 80157f6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80157fa:	18d3      	adds	r3, r2, r3
 80157fc:	685b      	ldr	r3, [r3, #4]
 80157fe:	2b00      	cmp	r3, #0
 8015800:	f000 8085 	beq.w	801590e <_ZN3USB11ConfiguringEhhb+0x336>
			if (devConfig[devConfigIndex]->GetAddress()) continue; // consumed
 8015804:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8015808:	687a      	ldr	r2, [r7, #4]
 801580a:	f103 031e 	add.w	r3, r3, #30
 801580e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8015812:	18d3      	adds	r3, r2, r3
 8015814:	685b      	ldr	r3, [r3, #4]
 8015816:	681b      	ldr	r3, [r3, #0]
 8015818:	f103 0310 	add.w	r3, r3, #16
 801581c:	681a      	ldr	r2, [r3, #0]
 801581e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8015822:	6879      	ldr	r1, [r7, #4]
 8015824:	f103 031e 	add.w	r3, r3, #30
 8015828:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801582c:	18cb      	adds	r3, r1, r3
 801582e:	685b      	ldr	r3, [r3, #4]
 8015830:	4618      	mov	r0, r3
 8015832:	4790      	blx	r2
 8015834:	4603      	mov	r3, r0
 8015836:	2b00      	cmp	r3, #0
 8015838:	bf0c      	ite	eq
 801583a:	2300      	moveq	r3, #0
 801583c:	2301      	movne	r3, #1
 801583e:	b2db      	uxtb	r3, r3
 8015840:	2b00      	cmp	r3, #0
 8015842:	d166      	bne.n	8015912 <_ZN3USB11ConfiguringEhhb+0x33a>
			if (devConfig[devConfigIndex]->VIDPIDOK(vid, pid)) {
 8015844:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8015848:	687a      	ldr	r2, [r7, #4]
 801584a:	f103 031e 	add.w	r3, r3, #30
 801584e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8015852:	18d3      	adds	r3, r2, r3
 8015854:	685b      	ldr	r3, [r3, #4]
 8015856:	681b      	ldr	r3, [r3, #0]
 8015858:	f103 0318 	add.w	r3, r3, #24
 801585c:	681c      	ldr	r4, [r3, #0]
 801585e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8015862:	687a      	ldr	r2, [r7, #4]
 8015864:	f103 031e 	add.w	r3, r3, #30
 8015868:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801586c:	18d3      	adds	r3, r2, r3
 801586e:	6859      	ldr	r1, [r3, #4]
 8015870:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8015872:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8015874:	4608      	mov	r0, r1
 8015876:	4611      	mov	r1, r2
 8015878:	461a      	mov	r2, r3
 801587a:	47a0      	blx	r4
 801587c:	4603      	mov	r3, r0
 801587e:	2b00      	cmp	r3, #0
 8015880:	bf0c      	ite	eq
 8015882:	2300      	moveq	r3, #0
 8015884:	2301      	movne	r3, #1
 8015886:	b2db      	uxtb	r3, r3
 8015888:	2b00      	cmp	r3, #0
 801588a:	d00c      	beq.n	80158a6 <_ZN3USB11ConfiguringEhhb+0x2ce>
				rcode = AttemptConfig(devConfigIndex, parent, port, lowspeed);
 801588c:	f897 1037 	ldrb.w	r1, [r7, #55]	; 0x37
 8015890:	78fa      	ldrb	r2, [r7, #3]
 8015892:	78bb      	ldrb	r3, [r7, #2]
 8015894:	7878      	ldrb	r0, [r7, #1]
 8015896:	9000      	str	r0, [sp, #0]
 8015898:	6878      	ldr	r0, [r7, #4]
 801589a:	f7ff fe29 	bl	80154f0 <_ZN3USB13AttemptConfigEhhhb>
 801589e:	4603      	mov	r3, r0
 80158a0:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
				break;
 80158a4:	e048      	b.n	8015938 <_ZN3USB11ConfiguringEhhb+0x360>
			} else if (devConfig[devConfigIndex]->DEVCLASSOK(klass)) {
 80158a6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80158aa:	687a      	ldr	r2, [r7, #4]
 80158ac:	f103 031e 	add.w	r3, r3, #30
 80158b0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80158b4:	18d3      	adds	r3, r2, r3
 80158b6:	685b      	ldr	r3, [r3, #4]
 80158b8:	681b      	ldr	r3, [r3, #0]
 80158ba:	f103 031c 	add.w	r3, r3, #28
 80158be:	681a      	ldr	r2, [r3, #0]
 80158c0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80158c4:	6879      	ldr	r1, [r7, #4]
 80158c6:	f103 031e 	add.w	r3, r3, #30
 80158ca:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80158ce:	18cb      	adds	r3, r1, r3
 80158d0:	6859      	ldr	r1, [r3, #4]
 80158d2:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 80158d6:	4608      	mov	r0, r1
 80158d8:	4619      	mov	r1, r3
 80158da:	4790      	blx	r2
 80158dc:	4603      	mov	r3, r0
 80158de:	2b00      	cmp	r3, #0
 80158e0:	bf0c      	ite	eq
 80158e2:	2300      	moveq	r3, #0
 80158e4:	2301      	movne	r3, #1
 80158e6:	b2db      	uxtb	r3, r3
 80158e8:	2b00      	cmp	r3, #0
 80158ea:	d013      	beq.n	8015914 <_ZN3USB11ConfiguringEhhb+0x33c>
				rcode = AttemptConfig(devConfigIndex, parent, port, lowspeed);
 80158ec:	f897 1037 	ldrb.w	r1, [r7, #55]	; 0x37
 80158f0:	78fa      	ldrb	r2, [r7, #3]
 80158f2:	78bb      	ldrb	r3, [r7, #2]
 80158f4:	7878      	ldrb	r0, [r7, #1]
 80158f6:	9000      	str	r0, [sp, #0]
 80158f8:	6878      	ldr	r0, [r7, #4]
 80158fa:	f7ff fdf9 	bl	80154f0 <_ZN3USB13AttemptConfigEhhhb>
 80158fe:	4603      	mov	r3, r0
 8015900:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
				if (!rcode) break;
 8015904:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8015908:	2b00      	cmp	r3, #0
 801590a:	d014      	beq.n	8015936 <_ZN3USB11ConfiguringEhhb+0x35e>
 801590c:	e002      	b.n	8015914 <_ZN3USB11ConfiguringEhhb+0x33c>
        uint16_t pid = (uint16_t)((USB_DEVICE_DESCRIPTOR*)buf)->idProduct;
        uint8_t klass = ((USB_DEVICE_DESCRIPTOR*)buf)->bDeviceClass;

        // Attempt to configure if VID/PID or device class matches with a driver
        for (devConfigIndex = 0; devConfigIndex < USB_NUMDEVICES; devConfigIndex++) {
			if (!devConfig[devConfigIndex]) continue; // no driver
 801590e:	bf00      	nop
 8015910:	e000      	b.n	8015914 <_ZN3USB11ConfiguringEhhb+0x33c>
			if (devConfig[devConfigIndex]->GetAddress()) continue; // consumed
 8015912:	bf00      	nop
        uint16_t vid = (uint16_t)((USB_DEVICE_DESCRIPTOR*)buf)->idVendor;
        uint16_t pid = (uint16_t)((USB_DEVICE_DESCRIPTOR*)buf)->idProduct;
        uint8_t klass = ((USB_DEVICE_DESCRIPTOR*)buf)->bDeviceClass;

        // Attempt to configure if VID/PID or device class matches with a driver
        for (devConfigIndex = 0; devConfigIndex < USB_NUMDEVICES; devConfigIndex++) {
 8015914:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8015918:	f103 0301 	add.w	r3, r3, #1
 801591c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8015920:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8015924:	2b0f      	cmp	r3, #15
 8015926:	bf8c      	ite	hi
 8015928:	2300      	movhi	r3, #0
 801592a:	2301      	movls	r3, #1
 801592c:	b2db      	uxtb	r3, r3
 801592e:	2b00      	cmp	r3, #0
 8015930:	f47f af5c 	bne.w	80157ec <_ZN3USB11ConfiguringEhhb+0x214>
 8015934:	e000      	b.n	8015938 <_ZN3USB11ConfiguringEhhb+0x360>
			if (devConfig[devConfigIndex]->VIDPIDOK(vid, pid)) {
				rcode = AttemptConfig(devConfigIndex, parent, port, lowspeed);
				break;
			} else if (devConfig[devConfigIndex]->DEVCLASSOK(klass)) {
				rcode = AttemptConfig(devConfigIndex, parent, port, lowspeed);
				if (!rcode) break;
 8015936:	bf00      	nop
			}
        }

        if (devConfigIndex < USB_NUMDEVICES) {
 8015938:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801593c:	2b0f      	cmp	r3, #15
 801593e:	d802      	bhi.n	8015946 <_ZN3USB11ConfiguringEhhb+0x36e>
			return rcode;
 8015940:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8015944:	e063      	b.n	8015a0e <_ZN3USB11ConfiguringEhhb+0x436>
        }


        // blindly attempt to configure
        for (devConfigIndex = 0; devConfigIndex < USB_NUMDEVICES; devConfigIndex++) {
 8015946:	f04f 0300 	mov.w	r3, #0
 801594a:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 801594e:	e04a      	b.n	80159e6 <_ZN3USB11ConfiguringEhhb+0x40e>
                if (!devConfig[devConfigIndex]) continue;
 8015950:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8015954:	687a      	ldr	r2, [r7, #4]
 8015956:	f103 031e 	add.w	r3, r3, #30
 801595a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801595e:	18d3      	adds	r3, r2, r3
 8015960:	685b      	ldr	r3, [r3, #4]
 8015962:	2b00      	cmp	r3, #0
 8015964:	d036      	beq.n	80159d4 <_ZN3USB11ConfiguringEhhb+0x3fc>
                if (devConfig[devConfigIndex]->GetAddress()) continue; // consumed
 8015966:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801596a:	687a      	ldr	r2, [r7, #4]
 801596c:	f103 031e 	add.w	r3, r3, #30
 8015970:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8015974:	18d3      	adds	r3, r2, r3
 8015976:	685b      	ldr	r3, [r3, #4]
 8015978:	681b      	ldr	r3, [r3, #0]
 801597a:	f103 0310 	add.w	r3, r3, #16
 801597e:	681a      	ldr	r2, [r3, #0]
 8015980:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8015984:	6879      	ldr	r1, [r7, #4]
 8015986:	f103 031e 	add.w	r3, r3, #30
 801598a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801598e:	18cb      	adds	r3, r1, r3
 8015990:	685b      	ldr	r3, [r3, #4]
 8015992:	4618      	mov	r0, r3
 8015994:	4790      	blx	r2
 8015996:	4603      	mov	r3, r0
 8015998:	2b00      	cmp	r3, #0
 801599a:	bf0c      	ite	eq
 801599c:	2300      	moveq	r3, #0
 801599e:	2301      	movne	r3, #1
 80159a0:	b2db      	uxtb	r3, r3
 80159a2:	2b00      	cmp	r3, #0
 80159a4:	d118      	bne.n	80159d8 <_ZN3USB11ConfiguringEhhb+0x400>
                rcode = AttemptConfig(devConfigIndex, parent, port, lowspeed);
 80159a6:	f897 1037 	ldrb.w	r1, [r7, #55]	; 0x37
 80159aa:	78fa      	ldrb	r2, [r7, #3]
 80159ac:	78bb      	ldrb	r3, [r7, #2]
 80159ae:	7878      	ldrb	r0, [r7, #1]
 80159b0:	9000      	str	r0, [sp, #0]
 80159b2:	6878      	ldr	r0, [r7, #4]
 80159b4:	f7ff fd9c 	bl	80154f0 <_ZN3USB13AttemptConfigEhhhb>
 80159b8:	4603      	mov	r3, r0
 80159ba:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

                //xprintf("ERROR ENUMERATING %2.2x\r\n", rcode);
                if (!(rcode == USB_DEV_CONFIG_ERROR_DEVICE_NOT_SUPPORTED || rcode == USB_ERROR_CLASS_INSTANCE_ALREADY_IN_USE)) {
 80159be:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 80159c2:	2bd1      	cmp	r3, #209	; 0xd1
 80159c4:	d009      	beq.n	80159da <_ZN3USB11ConfiguringEhhb+0x402>
 80159c6:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 80159ca:	2bd9      	cmp	r3, #217	; 0xd9
 80159cc:	d005      	beq.n	80159da <_ZN3USB11ConfiguringEhhb+0x402>
                        // in case of an error dev_index should be reset to 0
                        //		in order to start from the very beginning the
                        //		next time the program gets here
                        //if (rcode != USB_DEV_CONFIG_ERROR_DEVICE_INIT_INCOMPLETE)
                        //        devConfigIndex = 0;
                        return rcode;
 80159ce:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 80159d2:	e01c      	b.n	8015a0e <_ZN3USB11ConfiguringEhhb+0x436>
        }


        // blindly attempt to configure
        for (devConfigIndex = 0; devConfigIndex < USB_NUMDEVICES; devConfigIndex++) {
                if (!devConfig[devConfigIndex]) continue;
 80159d4:	bf00      	nop
 80159d6:	e000      	b.n	80159da <_ZN3USB11ConfiguringEhhb+0x402>
                if (devConfig[devConfigIndex]->GetAddress()) continue; // consumed
 80159d8:	bf00      	nop
			return rcode;
        }


        // blindly attempt to configure
        for (devConfigIndex = 0; devConfigIndex < USB_NUMDEVICES; devConfigIndex++) {
 80159da:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80159de:	f103 0301 	add.w	r3, r3, #1
 80159e2:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 80159e6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80159ea:	2b0f      	cmp	r3, #15
 80159ec:	bf8c      	ite	hi
 80159ee:	2300      	movhi	r3, #0
 80159f0:	2301      	movls	r3, #1
 80159f2:	b2db      	uxtb	r3, r3
 80159f4:	2b00      	cmp	r3, #0
 80159f6:	d1ab      	bne.n	8015950 <_ZN3USB11ConfiguringEhhb+0x378>
                        //        devConfigIndex = 0;
                        return rcode;
                }
        }
        // if we get here that means that the device class is not supported by any of registered classes
        rcode = DefaultAddressing(parent, port, lowspeed);
 80159f8:	78f9      	ldrb	r1, [r7, #3]
 80159fa:	78ba      	ldrb	r2, [r7, #2]
 80159fc:	787b      	ldrb	r3, [r7, #1]
 80159fe:	6878      	ldr	r0, [r7, #4]
 8015a00:	f7ff fd10 	bl	8015424 <_ZN3USB17DefaultAddressingEhhb>
 8015a04:	4603      	mov	r3, r0
 8015a06:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        return rcode;
 8015a0a:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8015a0e:	e001      	b.n	8015a14 <_ZN3USB11ConfiguringEhhb+0x43c>
 8015a10:	f007 f836 	bl	801ca80 <__cxa_end_cleanup>
}
 8015a14:	4618      	mov	r0, r3
 8015a16:	f107 073c 	add.w	r7, r7, #60	; 0x3c
 8015a1a:	46bd      	mov	sp, r7
 8015a1c:	bd90      	pop	{r4, r7, pc}
 8015a1e:	bf00      	nop

08015a20 <_ZN3USB13ReleaseDeviceEh>:

uint8_t USB::ReleaseDevice(uint8_t addr) {
 8015a20:	b580      	push	{r7, lr}
 8015a22:	b084      	sub	sp, #16
 8015a24:	af00      	add	r7, sp, #0
 8015a26:	6078      	str	r0, [r7, #4]
 8015a28:	460b      	mov	r3, r1
 8015a2a:	70fb      	strb	r3, [r7, #3]
        if (!addr)
 8015a2c:	78fb      	ldrb	r3, [r7, #3]
 8015a2e:	2b00      	cmp	r3, #0
 8015a30:	d102      	bne.n	8015a38 <_ZN3USB13ReleaseDeviceEh+0x18>
                return 0;
 8015a32:	f04f 0300 	mov.w	r3, #0
 8015a36:	e053      	b.n	8015ae0 <_ZN3USB13ReleaseDeviceEh+0xc0>

        for (uint8_t i = 0; i < USB_NUMDEVICES; i++) {
 8015a38:	f04f 0300 	mov.w	r3, #0
 8015a3c:	73fb      	strb	r3, [r7, #15]
 8015a3e:	e045      	b.n	8015acc <_ZN3USB13ReleaseDeviceEh+0xac>
                if(!devConfig[i]) continue;
 8015a40:	7bfb      	ldrb	r3, [r7, #15]
 8015a42:	687a      	ldr	r2, [r7, #4]
 8015a44:	f103 031e 	add.w	r3, r3, #30
 8015a48:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8015a4c:	18d3      	adds	r3, r2, r3
 8015a4e:	685b      	ldr	r3, [r3, #4]
 8015a50:	2b00      	cmp	r3, #0
 8015a52:	d036      	beq.n	8015ac2 <_ZN3USB13ReleaseDeviceEh+0xa2>
                if (devConfig[i]->GetAddress() == addr)
 8015a54:	7bfb      	ldrb	r3, [r7, #15]
 8015a56:	687a      	ldr	r2, [r7, #4]
 8015a58:	f103 031e 	add.w	r3, r3, #30
 8015a5c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8015a60:	18d3      	adds	r3, r2, r3
 8015a62:	685b      	ldr	r3, [r3, #4]
 8015a64:	681b      	ldr	r3, [r3, #0]
 8015a66:	f103 0310 	add.w	r3, r3, #16
 8015a6a:	681a      	ldr	r2, [r3, #0]
 8015a6c:	7bfb      	ldrb	r3, [r7, #15]
 8015a6e:	6879      	ldr	r1, [r7, #4]
 8015a70:	f103 031e 	add.w	r3, r3, #30
 8015a74:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8015a78:	18cb      	adds	r3, r1, r3
 8015a7a:	685b      	ldr	r3, [r3, #4]
 8015a7c:	4618      	mov	r0, r3
 8015a7e:	4790      	blx	r2
 8015a80:	4603      	mov	r3, r0
 8015a82:	78fa      	ldrb	r2, [r7, #3]
 8015a84:	429a      	cmp	r2, r3
 8015a86:	bf14      	ite	ne
 8015a88:	2300      	movne	r3, #0
 8015a8a:	2301      	moveq	r3, #1
 8015a8c:	b2db      	uxtb	r3, r3
 8015a8e:	2b00      	cmp	r3, #0
 8015a90:	d018      	beq.n	8015ac4 <_ZN3USB13ReleaseDeviceEh+0xa4>
                        return devConfig[i]->Release();
 8015a92:	7bfb      	ldrb	r3, [r7, #15]
 8015a94:	687a      	ldr	r2, [r7, #4]
 8015a96:	f103 031e 	add.w	r3, r3, #30
 8015a9a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8015a9e:	18d3      	adds	r3, r2, r3
 8015aa0:	685b      	ldr	r3, [r3, #4]
 8015aa2:	681b      	ldr	r3, [r3, #0]
 8015aa4:	f103 0308 	add.w	r3, r3, #8
 8015aa8:	681a      	ldr	r2, [r3, #0]
 8015aaa:	7bfb      	ldrb	r3, [r7, #15]
 8015aac:	6879      	ldr	r1, [r7, #4]
 8015aae:	f103 031e 	add.w	r3, r3, #30
 8015ab2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8015ab6:	18cb      	adds	r3, r1, r3
 8015ab8:	685b      	ldr	r3, [r3, #4]
 8015aba:	4618      	mov	r0, r3
 8015abc:	4790      	blx	r2
 8015abe:	4603      	mov	r3, r0
 8015ac0:	e00e      	b.n	8015ae0 <_ZN3USB13ReleaseDeviceEh+0xc0>
uint8_t USB::ReleaseDevice(uint8_t addr) {
        if (!addr)
                return 0;

        for (uint8_t i = 0; i < USB_NUMDEVICES; i++) {
                if(!devConfig[i]) continue;
 8015ac2:	bf00      	nop

uint8_t USB::ReleaseDevice(uint8_t addr) {
        if (!addr)
                return 0;

        for (uint8_t i = 0; i < USB_NUMDEVICES; i++) {
 8015ac4:	7bfb      	ldrb	r3, [r7, #15]
 8015ac6:	f103 0301 	add.w	r3, r3, #1
 8015aca:	73fb      	strb	r3, [r7, #15]
 8015acc:	7bfb      	ldrb	r3, [r7, #15]
 8015ace:	2b0f      	cmp	r3, #15
 8015ad0:	bf8c      	ite	hi
 8015ad2:	2300      	movhi	r3, #0
 8015ad4:	2301      	movls	r3, #1
 8015ad6:	b2db      	uxtb	r3, r3
 8015ad8:	2b00      	cmp	r3, #0
 8015ada:	d1b1      	bne.n	8015a40 <_ZN3USB13ReleaseDeviceEh+0x20>
                if(!devConfig[i]) continue;
                if (devConfig[i]->GetAddress() == addr)
                        return devConfig[i]->Release();
        }
        return 0;
 8015adc:	f04f 0300 	mov.w	r3, #0
}
 8015ae0:	4618      	mov	r0, r3
 8015ae2:	f107 0710 	add.w	r7, r7, #16
 8015ae6:	46bd      	mov	sp, r7
 8015ae8:	bd80      	pop	{r7, pc}
 8015aea:	bf00      	nop

08015aec <_ZN3USB11getDevDescrEhhtPh>:

#if 1 //!defined(USB_METHODS_INLINE)
//get device descriptor

uint8_t USB::getDevDescr(uint8_t addr, uint8_t ep, uint16_t nbytes, uint8_t* dataptr) {
 8015aec:	b580      	push	{r7, lr}
 8015aee:	b08a      	sub	sp, #40	; 0x28
 8015af0:	af08      	add	r7, sp, #32
 8015af2:	6078      	str	r0, [r7, #4]
 8015af4:	70f9      	strb	r1, [r7, #3]
 8015af6:	70ba      	strb	r2, [r7, #2]
 8015af8:	803b      	strh	r3, [r7, #0]
        return ( ctrlReq(addr, ep, bmREQ_GET_DESCR, USB_REQUEST_GET_DESCRIPTOR, 0x00, USB_DESCRIPTOR_DEVICE, 0x0000, nbytes, nbytes, dataptr, NULL));
 8015afa:	78fa      	ldrb	r2, [r7, #3]
 8015afc:	78bb      	ldrb	r3, [r7, #2]
 8015afe:	f04f 0106 	mov.w	r1, #6
 8015b02:	9100      	str	r1, [sp, #0]
 8015b04:	f04f 0100 	mov.w	r1, #0
 8015b08:	9101      	str	r1, [sp, #4]
 8015b0a:	f04f 0101 	mov.w	r1, #1
 8015b0e:	9102      	str	r1, [sp, #8]
 8015b10:	f04f 0100 	mov.w	r1, #0
 8015b14:	9103      	str	r1, [sp, #12]
 8015b16:	8839      	ldrh	r1, [r7, #0]
 8015b18:	9104      	str	r1, [sp, #16]
 8015b1a:	8839      	ldrh	r1, [r7, #0]
 8015b1c:	9105      	str	r1, [sp, #20]
 8015b1e:	6939      	ldr	r1, [r7, #16]
 8015b20:	9106      	str	r1, [sp, #24]
 8015b22:	f04f 0100 	mov.w	r1, #0
 8015b26:	9107      	str	r1, [sp, #28]
 8015b28:	6878      	ldr	r0, [r7, #4]
 8015b2a:	4611      	mov	r1, r2
 8015b2c:	461a      	mov	r2, r3
 8015b2e:	f04f 0380 	mov.w	r3, #128	; 0x80
 8015b32:	f7fe fdb7 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 8015b36:	4603      	mov	r3, r0
}
 8015b38:	4618      	mov	r0, r3
 8015b3a:	f107 0708 	add.w	r7, r7, #8
 8015b3e:	46bd      	mov	sp, r7
 8015b40:	bd80      	pop	{r7, pc}
 8015b42:	bf00      	nop

08015b44 <_ZN3USB12getConfDescrEhhthPh>:
//get configuration descriptor

uint8_t USB::getConfDescr(uint8_t addr, uint8_t ep, uint16_t nbytes, uint8_t conf, uint8_t* dataptr) {
 8015b44:	b580      	push	{r7, lr}
 8015b46:	b08a      	sub	sp, #40	; 0x28
 8015b48:	af08      	add	r7, sp, #32
 8015b4a:	6078      	str	r0, [r7, #4]
 8015b4c:	70f9      	strb	r1, [r7, #3]
 8015b4e:	70ba      	strb	r2, [r7, #2]
 8015b50:	803b      	strh	r3, [r7, #0]
        return ( ctrlReq(addr, ep, bmREQ_GET_DESCR, USB_REQUEST_GET_DESCRIPTOR, conf, USB_DESCRIPTOR_CONFIGURATION, 0x0000, nbytes, nbytes, dataptr, NULL));
 8015b52:	78fa      	ldrb	r2, [r7, #3]
 8015b54:	78bb      	ldrb	r3, [r7, #2]
 8015b56:	f04f 0106 	mov.w	r1, #6
 8015b5a:	9100      	str	r1, [sp, #0]
 8015b5c:	7c39      	ldrb	r1, [r7, #16]
 8015b5e:	9101      	str	r1, [sp, #4]
 8015b60:	f04f 0102 	mov.w	r1, #2
 8015b64:	9102      	str	r1, [sp, #8]
 8015b66:	f04f 0100 	mov.w	r1, #0
 8015b6a:	9103      	str	r1, [sp, #12]
 8015b6c:	8839      	ldrh	r1, [r7, #0]
 8015b6e:	9104      	str	r1, [sp, #16]
 8015b70:	8839      	ldrh	r1, [r7, #0]
 8015b72:	9105      	str	r1, [sp, #20]
 8015b74:	6979      	ldr	r1, [r7, #20]
 8015b76:	9106      	str	r1, [sp, #24]
 8015b78:	f04f 0100 	mov.w	r1, #0
 8015b7c:	9107      	str	r1, [sp, #28]
 8015b7e:	6878      	ldr	r0, [r7, #4]
 8015b80:	4611      	mov	r1, r2
 8015b82:	461a      	mov	r2, r3
 8015b84:	f04f 0380 	mov.w	r3, #128	; 0x80
 8015b88:	f7fe fd8c 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 8015b8c:	4603      	mov	r3, r0
}
 8015b8e:	4618      	mov	r0, r3
 8015b90:	f107 0708 	add.w	r7, r7, #8
 8015b94:	46bd      	mov	sp, r7
 8015b96:	bd80      	pop	{r7, pc}

08015b98 <_ZN3USB12getConfDescrEhhhP13USBReadParser>:

uint8_t USB::getConfDescr(uint8_t addr, uint8_t ep, uint8_t conf, USBReadParser *p) {
 8015b98:	b590      	push	{r4, r7, lr}
 8015b9a:	b0cd      	sub	sp, #308	; 0x134
 8015b9c:	af08      	add	r7, sp, #32
 8015b9e:	f107 0404 	add.w	r4, r7, #4
 8015ba2:	6020      	str	r0, [r4, #0]
 8015ba4:	4608      	mov	r0, r1
 8015ba6:	4611      	mov	r1, r2
 8015ba8:	461a      	mov	r2, r3
 8015baa:	f107 0303 	add.w	r3, r7, #3
 8015bae:	7018      	strb	r0, [r3, #0]
 8015bb0:	f107 0302 	add.w	r3, r7, #2
 8015bb4:	7019      	strb	r1, [r3, #0]
 8015bb6:	f107 0301 	add.w	r3, r7, #1
 8015bba:	701a      	strb	r2, [r3, #0]
        const uint32_t bufSize = 256;	//64; due to receiving more than 1 packet (64bytes) in stm imple.
 8015bbc:	f44f 7380 	mov.w	r3, #256	; 0x100
 8015bc0:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
        									// we need a large buffer for BTD class, which has a 177 bytes desc.
        uint8_t buf[bufSize];

        uint8_t ret = getConfDescr(addr, ep, 8, conf, buf);
 8015bc4:	f107 0104 	add.w	r1, r7, #4
 8015bc8:	f107 0303 	add.w	r3, r7, #3
 8015bcc:	781a      	ldrb	r2, [r3, #0]
 8015bce:	f107 0302 	add.w	r3, r7, #2
 8015bd2:	781b      	ldrb	r3, [r3, #0]
 8015bd4:	f107 0001 	add.w	r0, r7, #1
 8015bd8:	7800      	ldrb	r0, [r0, #0]
 8015bda:	9000      	str	r0, [sp, #0]
 8015bdc:	f107 0008 	add.w	r0, r7, #8
 8015be0:	9001      	str	r0, [sp, #4]
 8015be2:	6808      	ldr	r0, [r1, #0]
 8015be4:	4611      	mov	r1, r2
 8015be6:	461a      	mov	r2, r3
 8015be8:	f04f 0308 	mov.w	r3, #8
 8015bec:	f7ff ffaa 	bl	8015b44 <_ZN3USB12getConfDescrEhhthPh>
 8015bf0:	4603      	mov	r3, r0
 8015bf2:	f887 310b 	strb.w	r3, [r7, #267]	; 0x10b

        if (ret)
 8015bf6:	f897 310b 	ldrb.w	r3, [r7, #267]	; 0x10b
 8015bfa:	2b00      	cmp	r3, #0
 8015bfc:	d002      	beq.n	8015c04 <_ZN3USB12getConfDescrEhhhP13USBReadParser+0x6c>
			return ret;
 8015bfe:	f897 310b 	ldrb.w	r3, [r7, #267]	; 0x10b
 8015c02:	e031      	b.n	8015c68 <_ZN3USB12getConfDescrEhhhP13USBReadParser+0xd0>

        uint16_t total = ((USB_CONFIGURATION_DESCRIPTOR*)buf)->wTotalLength;
 8015c04:	f107 0308 	add.w	r3, r7, #8
 8015c08:	789a      	ldrb	r2, [r3, #2]
 8015c0a:	78db      	ldrb	r3, [r3, #3]
 8015c0c:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8015c10:	4313      	orrs	r3, r2
 8015c12:	f8a7 3108 	strh.w	r3, [r7, #264]	; 0x108

        //USBTRACE2("\r\ntotal conf.size:", total);

        return ( ctrlReq(addr, ep, bmREQ_GET_DESCR, USB_REQUEST_GET_DESCRIPTOR, conf, USB_DESCRIPTOR_CONFIGURATION, 0x0000, total, bufSize, buf, p));
 8015c16:	f107 0104 	add.w	r1, r7, #4
 8015c1a:	f107 0303 	add.w	r3, r7, #3
 8015c1e:	781a      	ldrb	r2, [r3, #0]
 8015c20:	f107 0302 	add.w	r3, r7, #2
 8015c24:	781b      	ldrb	r3, [r3, #0]
 8015c26:	f04f 0006 	mov.w	r0, #6
 8015c2a:	9000      	str	r0, [sp, #0]
 8015c2c:	f107 0001 	add.w	r0, r7, #1
 8015c30:	7800      	ldrb	r0, [r0, #0]
 8015c32:	9001      	str	r0, [sp, #4]
 8015c34:	f04f 0002 	mov.w	r0, #2
 8015c38:	9002      	str	r0, [sp, #8]
 8015c3a:	f04f 0000 	mov.w	r0, #0
 8015c3e:	9003      	str	r0, [sp, #12]
 8015c40:	f8b7 0108 	ldrh.w	r0, [r7, #264]	; 0x108
 8015c44:	9004      	str	r0, [sp, #16]
 8015c46:	f44f 7080 	mov.w	r0, #256	; 0x100
 8015c4a:	9005      	str	r0, [sp, #20]
 8015c4c:	f107 0008 	add.w	r0, r7, #8
 8015c50:	9006      	str	r0, [sp, #24]
 8015c52:	f8d7 0120 	ldr.w	r0, [r7, #288]	; 0x120
 8015c56:	9007      	str	r0, [sp, #28]
 8015c58:	6808      	ldr	r0, [r1, #0]
 8015c5a:	4611      	mov	r1, r2
 8015c5c:	461a      	mov	r2, r3
 8015c5e:	f04f 0380 	mov.w	r3, #128	; 0x80
 8015c62:	f7fe fd1f 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 8015c66:	4603      	mov	r3, r0
 8015c68:	e001      	b.n	8015c6e <_ZN3USB12getConfDescrEhhhP13USBReadParser+0xd6>
 8015c6a:	f006 ff09 	bl	801ca80 <__cxa_end_cleanup>
}
 8015c6e:	4618      	mov	r0, r3
 8015c70:	f507 778a 	add.w	r7, r7, #276	; 0x114
 8015c74:	46bd      	mov	sp, r7
 8015c76:	bd90      	pop	{r4, r7, pc}

08015c78 <_ZN3USB11getStrDescrEhhthtPh>:

//get string descriptor

uint8_t USB::getStrDescr(uint8_t addr, uint8_t ep, uint16_t ns, uint8_t index, uint16_t langid, uint8_t* dataptr) {
 8015c78:	b580      	push	{r7, lr}
 8015c7a:	b08a      	sub	sp, #40	; 0x28
 8015c7c:	af08      	add	r7, sp, #32
 8015c7e:	6078      	str	r0, [r7, #4]
 8015c80:	70f9      	strb	r1, [r7, #3]
 8015c82:	70ba      	strb	r2, [r7, #2]
 8015c84:	803b      	strh	r3, [r7, #0]
        return ( ctrlReq(addr, ep, bmREQ_GET_DESCR, USB_REQUEST_GET_DESCRIPTOR, index, USB_DESCRIPTOR_STRING, langid, ns, ns, dataptr, NULL));
 8015c86:	78fa      	ldrb	r2, [r7, #3]
 8015c88:	78bb      	ldrb	r3, [r7, #2]
 8015c8a:	f04f 0106 	mov.w	r1, #6
 8015c8e:	9100      	str	r1, [sp, #0]
 8015c90:	7c39      	ldrb	r1, [r7, #16]
 8015c92:	9101      	str	r1, [sp, #4]
 8015c94:	f04f 0103 	mov.w	r1, #3
 8015c98:	9102      	str	r1, [sp, #8]
 8015c9a:	8ab9      	ldrh	r1, [r7, #20]
 8015c9c:	9103      	str	r1, [sp, #12]
 8015c9e:	8839      	ldrh	r1, [r7, #0]
 8015ca0:	9104      	str	r1, [sp, #16]
 8015ca2:	8839      	ldrh	r1, [r7, #0]
 8015ca4:	9105      	str	r1, [sp, #20]
 8015ca6:	69b9      	ldr	r1, [r7, #24]
 8015ca8:	9106      	str	r1, [sp, #24]
 8015caa:	f04f 0100 	mov.w	r1, #0
 8015cae:	9107      	str	r1, [sp, #28]
 8015cb0:	6878      	ldr	r0, [r7, #4]
 8015cb2:	4611      	mov	r1, r2
 8015cb4:	461a      	mov	r2, r3
 8015cb6:	f04f 0380 	mov.w	r3, #128	; 0x80
 8015cba:	f7fe fcf3 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 8015cbe:	4603      	mov	r3, r0
}
 8015cc0:	4618      	mov	r0, r3
 8015cc2:	f107 0708 	add.w	r7, r7, #8
 8015cc6:	46bd      	mov	sp, r7
 8015cc8:	bd80      	pop	{r7, pc}
 8015cca:	bf00      	nop

08015ccc <_ZN3USB7setAddrEhhh>:
//set address

uint8_t USB::setAddr(uint8_t oldaddr, uint8_t ep, uint8_t newaddr) {
 8015ccc:	b580      	push	{r7, lr}
 8015cce:	b08a      	sub	sp, #40	; 0x28
 8015cd0:	af08      	add	r7, sp, #32
 8015cd2:	6078      	str	r0, [r7, #4]
 8015cd4:	70f9      	strb	r1, [r7, #3]
 8015cd6:	70ba      	strb	r2, [r7, #2]
 8015cd8:	707b      	strb	r3, [r7, #1]
        return ( ctrlReq(oldaddr, ep, bmREQ_SET, USB_REQUEST_SET_ADDRESS, newaddr, 0x00, 0x0000, 0x0000, 0x0000, NULL, NULL));
 8015cda:	78fa      	ldrb	r2, [r7, #3]
 8015cdc:	78bb      	ldrb	r3, [r7, #2]
 8015cde:	f04f 0105 	mov.w	r1, #5
 8015ce2:	9100      	str	r1, [sp, #0]
 8015ce4:	7879      	ldrb	r1, [r7, #1]
 8015ce6:	9101      	str	r1, [sp, #4]
 8015ce8:	f04f 0100 	mov.w	r1, #0
 8015cec:	9102      	str	r1, [sp, #8]
 8015cee:	f04f 0100 	mov.w	r1, #0
 8015cf2:	9103      	str	r1, [sp, #12]
 8015cf4:	f04f 0100 	mov.w	r1, #0
 8015cf8:	9104      	str	r1, [sp, #16]
 8015cfa:	f04f 0100 	mov.w	r1, #0
 8015cfe:	9105      	str	r1, [sp, #20]
 8015d00:	f04f 0100 	mov.w	r1, #0
 8015d04:	9106      	str	r1, [sp, #24]
 8015d06:	f04f 0100 	mov.w	r1, #0
 8015d0a:	9107      	str	r1, [sp, #28]
 8015d0c:	6878      	ldr	r0, [r7, #4]
 8015d0e:	4611      	mov	r1, r2
 8015d10:	461a      	mov	r2, r3
 8015d12:	f04f 0300 	mov.w	r3, #0
 8015d16:	f7fe fcc5 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 8015d1a:	4603      	mov	r3, r0
}
 8015d1c:	4618      	mov	r0, r3
 8015d1e:	f107 0708 	add.w	r7, r7, #8
 8015d22:	46bd      	mov	sp, r7
 8015d24:	bd80      	pop	{r7, pc}
 8015d26:	bf00      	nop

08015d28 <_ZN3USB7setConfEhhh>:
//set configuration


uint8_t USB::setConf(uint8_t addr, uint8_t ep, uint8_t conf_value) {
 8015d28:	b580      	push	{r7, lr}
 8015d2a:	b08a      	sub	sp, #40	; 0x28
 8015d2c:	af08      	add	r7, sp, #32
 8015d2e:	6078      	str	r0, [r7, #4]
 8015d30:	70f9      	strb	r1, [r7, #3]
 8015d32:	70ba      	strb	r2, [r7, #2]
 8015d34:	707b      	strb	r3, [r7, #1]
        return ( ctrlReq(addr, ep, bmREQ_SET, USB_REQUEST_SET_CONFIGURATION, conf_value, 0x00, 0x0000, 0x0000, 0x0000, NULL, NULL));
 8015d36:	78fa      	ldrb	r2, [r7, #3]
 8015d38:	78bb      	ldrb	r3, [r7, #2]
 8015d3a:	f04f 0109 	mov.w	r1, #9
 8015d3e:	9100      	str	r1, [sp, #0]
 8015d40:	7879      	ldrb	r1, [r7, #1]
 8015d42:	9101      	str	r1, [sp, #4]
 8015d44:	f04f 0100 	mov.w	r1, #0
 8015d48:	9102      	str	r1, [sp, #8]
 8015d4a:	f04f 0100 	mov.w	r1, #0
 8015d4e:	9103      	str	r1, [sp, #12]
 8015d50:	f04f 0100 	mov.w	r1, #0
 8015d54:	9104      	str	r1, [sp, #16]
 8015d56:	f04f 0100 	mov.w	r1, #0
 8015d5a:	9105      	str	r1, [sp, #20]
 8015d5c:	f04f 0100 	mov.w	r1, #0
 8015d60:	9106      	str	r1, [sp, #24]
 8015d62:	f04f 0100 	mov.w	r1, #0
 8015d66:	9107      	str	r1, [sp, #28]
 8015d68:	6878      	ldr	r0, [r7, #4]
 8015d6a:	4611      	mov	r1, r2
 8015d6c:	461a      	mov	r2, r3
 8015d6e:	f04f 0300 	mov.w	r3, #0
 8015d72:	f7fe fc97 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 8015d76:	4603      	mov	r3, r0
}
 8015d78:	4618      	mov	r0, r3
 8015d7a:	f107 0708 	add.w	r7, r7, #8
 8015d7e:	46bd      	mov	sp, r7
 8015d80:	bd80      	pop	{r7, pc}
 8015d82:	bf00      	nop

08015d84 <_ZN7STM32F2I1a1bEC1Ev>:
template< typename SS, typename INTR >
        uint8_t STM32F2< SS, INTR >::vbusState = 0;

/* constructor */
template< typename SS, typename INTR >
STM32F2< SS, INTR >::STM32F2()
 8015d84:	b480      	push	{r7}
 8015d86:	b083      	sub	sp, #12
 8015d88:	af00      	add	r7, sp, #0
 8015d8a:	6078      	str	r0, [r7, #4]
 8015d8c:	687b      	ldr	r3, [r7, #4]
{	//USB_OTG_CORE_HANDLE *pDev) : coreConfig(pDev) {

};
 8015d8e:	4618      	mov	r0, r3
 8015d90:	f107 070c 	add.w	r7, r7, #12
 8015d94:	46bd      	mov	sp, r7
 8015d96:	bc80      	pop	{r7}
 8015d98:	4770      	bx	lr
 8015d9a:	bf00      	nop

08015d9c <_ZN11AddressPoolC1Ev>:
	uint8_t epcount; // number of endpoints
	bool lowspeed; // indicates if a device is the low speed one

} __attribute__((packed));

class AddressPool {
 8015d9c:	b480      	push	{r7}
 8015d9e:	b083      	sub	sp, #12
 8015da0:	af00      	add	r7, sp, #0
 8015da2:	6078      	str	r0, [r7, #4]
 8015da4:	687b      	ldr	r3, [r7, #4]
 8015da6:	4a04      	ldr	r2, [pc, #16]	; (8015db8 <_ZN11AddressPoolC1Ev+0x1c>)
 8015da8:	601a      	str	r2, [r3, #0]
 8015daa:	687b      	ldr	r3, [r7, #4]
 8015dac:	4618      	mov	r0, r3
 8015dae:	f107 070c 	add.w	r7, r7, #12
 8015db2:	46bd      	mov	sp, r7
 8015db4:	bc80      	pop	{r7}
 8015db6:	4770      	bx	lr
 8015db8:	080204d8 	.word	0x080204d8

08015dbc <_ZN15AddressPoolImplILh16EEC1Ev>:
                hubCounter = 0;
        };

public:

        AddressPoolImpl() : hubCounter(0) {
 8015dbc:	b580      	push	{r7, lr}
 8015dbe:	b082      	sub	sp, #8
 8015dc0:	af00      	add	r7, sp, #0
 8015dc2:	6078      	str	r0, [r7, #4]
 8015dc4:	687b      	ldr	r3, [r7, #4]
 8015dc6:	4618      	mov	r0, r3
 8015dc8:	f7ff ffe8 	bl	8015d9c <_ZN11AddressPoolC1Ev>
 8015dcc:	687b      	ldr	r3, [r7, #4]
 8015dce:	4a18      	ldr	r2, [pc, #96]	; (8015e30 <_ZN15AddressPoolImplILh16EEC1Ev+0x74>)
 8015dd0:	601a      	str	r2, [r3, #0]
 8015dd2:	687b      	ldr	r3, [r7, #4]
 8015dd4:	f04f 0200 	mov.w	r2, #0
 8015dd8:	725a      	strb	r2, [r3, #9]
                // Zero address is reserved
                InitEntry(0);
 8015dda:	6878      	ldr	r0, [r7, #4]
 8015ddc:	f04f 0100 	mov.w	r1, #0
 8015de0:	f000 f954 	bl	801608c <_ZN15AddressPoolImplILh16EE9InitEntryEh>

                thePool[0].address = 0;
 8015de4:	687b      	ldr	r3, [r7, #4]
 8015de6:	f04f 0200 	mov.w	r2, #0
 8015dea:	739a      	strb	r2, [r3, #14]
                thePool[0].epinfo = &dev0ep;
 8015dec:	687b      	ldr	r3, [r7, #4]
 8015dee:	f103 0204 	add.w	r2, r3, #4
 8015df2:	687b      	ldr	r3, [r7, #4]
 8015df4:	f8c3 200a 	str.w	r2, [r3, #10]
                dev0ep.epAddr = 0;
 8015df8:	687b      	ldr	r3, [r7, #4]
 8015dfa:	f04f 0200 	mov.w	r2, #0
 8015dfe:	711a      	strb	r2, [r3, #4]
                dev0ep.maxPktSize = 8;
 8015e00:	687b      	ldr	r3, [r7, #4]
 8015e02:	f04f 0208 	mov.w	r2, #8
 8015e06:	715a      	strb	r2, [r3, #5]
                dev0ep.epAttribs = 0; //set DATA0/1 toggles to 0
 8015e08:	687b      	ldr	r3, [r7, #4]
 8015e0a:	f04f 0200 	mov.w	r2, #0
 8015e0e:	721a      	strb	r2, [r3, #8]
                dev0ep.bmNakPower = USB_NAK_MAX_POWER;
 8015e10:	687a      	ldr	r2, [r7, #4]
 8015e12:	7a13      	ldrb	r3, [r2, #8]
 8015e14:	f04f 010f 	mov.w	r1, #15
 8015e18:	f361 0387 	bfi	r3, r1, #2, #6
 8015e1c:	7213      	strb	r3, [r2, #8]

                InitAllAddresses();
 8015e1e:	6878      	ldr	r0, [r7, #4]
 8015e20:	f000 f972 	bl	8016108 <_ZN15AddressPoolImplILh16EE16InitAllAddressesEv>
 8015e24:	687b      	ldr	r3, [r7, #4]
        };
 8015e26:	4618      	mov	r0, r3
 8015e28:	f107 0708 	add.w	r7, r7, #8
 8015e2c:	46bd      	mov	sp, r7
 8015e2e:	bd80      	pop	{r7, pc}
 8015e30:	080204c0 	.word	0x080204c0

08015e34 <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh>:
        // Returns a pointer to a specified address entry

        virtual UsbDevice* GetUsbDevicePtr(uint8_t addr) {
 8015e34:	b580      	push	{r7, lr}
 8015e36:	b084      	sub	sp, #16
 8015e38:	af00      	add	r7, sp, #0
 8015e3a:	6078      	str	r0, [r7, #4]
 8015e3c:	460b      	mov	r3, r1
 8015e3e:	70fb      	strb	r3, [r7, #3]
			if(!addr)
 8015e40:	78fb      	ldrb	r3, [r7, #3]
 8015e42:	2b00      	cmp	r3, #0
 8015e44:	d103      	bne.n	8015e4e <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh+0x1a>
				return thePool;
 8015e46:	687b      	ldr	r3, [r7, #4]
 8015e48:	f103 030a 	add.w	r3, r3, #10
 8015e4c:	e017      	b.n	8015e7e <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh+0x4a>

			uint8_t index = FindAddressIndex(addr);
 8015e4e:	78fb      	ldrb	r3, [r7, #3]
 8015e50:	6878      	ldr	r0, [r7, #4]
 8015e52:	4619      	mov	r1, r3
 8015e54:	f000 f97a 	bl	801614c <_ZN15AddressPoolImplILh16EE16FindAddressIndexEh>
 8015e58:	4603      	mov	r3, r0
 8015e5a:	73fb      	strb	r3, [r7, #15]

			return(!index) ? NULL : thePool + index;
 8015e5c:	7bfb      	ldrb	r3, [r7, #15]
 8015e5e:	2b00      	cmp	r3, #0
 8015e60:	d00b      	beq.n	8015e7a <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh+0x46>
 8015e62:	7bfa      	ldrb	r2, [r7, #15]
 8015e64:	4613      	mov	r3, r2
 8015e66:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8015e6a:	1a9b      	subs	r3, r3, r2
 8015e6c:	f103 0308 	add.w	r3, r3, #8
 8015e70:	687a      	ldr	r2, [r7, #4]
 8015e72:	18d3      	adds	r3, r2, r3
 8015e74:	f103 0302 	add.w	r3, r3, #2
 8015e78:	e001      	b.n	8015e7e <_ZN15AddressPoolImplILh16EE15GetUsbDevicePtrEh+0x4a>
 8015e7a:	f04f 0300 	mov.w	r3, #0
        };
 8015e7e:	4618      	mov	r0, r3
 8015e80:	f107 0710 	add.w	r7, r7, #16
 8015e84:	46bd      	mov	sp, r7
 8015e86:	bd80      	pop	{r7, pc}

08015e88 <_Z10D_PrintHexIhEvT_i>:
                mask >>= 4;
        }
        prn->print((T) val, HEX);
}
#endif
template <class T> void D_PrintHex(T val, int lvl) {
 8015e88:	b580      	push	{r7, lr}
 8015e8a:	b082      	sub	sp, #8
 8015e8c:	af00      	add	r7, sp, #0
 8015e8e:	4603      	mov	r3, r0
 8015e90:	6039      	str	r1, [r7, #0]
 8015e92:	71fb      	strb	r3, [r7, #7]
#ifdef DEBUG_USB_HOST
	PrintHex<T>(val, lvl);
 8015e94:	79fb      	ldrb	r3, [r7, #7]
 8015e96:	4618      	mov	r0, r3
 8015e98:	6839      	ldr	r1, [r7, #0]
 8015e9a:	f000 f985 	bl	80161a8 <_Z8PrintHexIhEvT_i>
#endif
}
 8015e9e:	f107 0708 	add.w	r7, r7, #8
 8015ea2:	46bd      	mov	sp, r7
 8015ea4:	bd80      	pop	{r7, pc}
 8015ea6:	bf00      	nop

08015ea8 <_ZN7STM32F2I1a1bE11toggle_led3Ev>:
	};
	static void toggle_led2(void)
	{
		//STM_EVAL_LEDToggle(LED2);
	};
	static void toggle_led3(void)
 8015ea8:	b580      	push	{r7, lr}
 8015eaa:	af00      	add	r7, sp, #0
	{
		//STM_EVAL_LEDToggle(LED3);
		system_cb->debug_pin_toggle_cb(DEBUG_PIN);
 8015eac:	f243 630c 	movw	r3, #13836	; 0x360c
 8015eb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015eb4:	681b      	ldr	r3, [r3, #0]
 8015eb6:	691b      	ldr	r3, [r3, #16]
 8015eb8:	f04f 0002 	mov.w	r0, #2
 8015ebc:	4798      	blx	r3
	};
 8015ebe:	bd80      	pop	{r7, pc}

08015ec0 <_ZN7STM32F2I1a1bE4TaskEv>:

/* state change task and interrupt handler */
// all usb phy state and interrupt matters are handled by int handler.
// so we should no longer need this function.
template< typename SS, typename INTR >
uint32_t STM32F2< SS, INTR >::Task(void) {
 8015ec0:	b580      	push	{r7, lr}
 8015ec2:	b084      	sub	sp, #16
 8015ec4:	af00      	add	r7, sp, #0
 8015ec6:	6078      	str	r0, [r7, #4]
	uint32_t rcode = 0;
 8015ec8:	f04f 0300 	mov.w	r3, #0
 8015ecc:	60fb      	str	r3, [r7, #12]
//        if(pinvalue == 0) {
//			rcode = IntHandler();
//        }
	// it seems only connection status is cared.
	// and we have no necessary to lookup connected devices all the time.
	busprobe();
 8015ece:	6878      	ldr	r0, [r7, #4]
 8015ed0:	f7fd ff8c 	bl	8013dec <_ZN7STM32F2I1a1bE8busprobeEv>

	return(rcode);
 8015ed4:	68fb      	ldr	r3, [r7, #12]
}
 8015ed6:	4618      	mov	r0, r3
 8015ed8:	f107 0710 	add.w	r7, r7, #16
 8015edc:	46bd      	mov	sp, r7
 8015ede:	bd80      	pop	{r7, pc}

08015ee0 <_ZN7STM32F2I1a1bE12getVbusStateEv>:

	STM32F2();	//USB_OTG_CORE_HANDLE *pDev);
	uint16_t reset();
	int8_t Init();

	uint8_t getVbusState(void) {
 8015ee0:	b480      	push	{r7}
 8015ee2:	b083      	sub	sp, #12
 8015ee4:	af00      	add	r7, sp, #0
 8015ee6:	6078      	str	r0, [r7, #4]
			return vbusState;
 8015ee8:	f640 4348 	movw	r3, #3144	; 0xc48
 8015eec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015ef0:	781b      	ldrb	r3, [r3, #0]
	};
 8015ef2:	4618      	mov	r0, r3
 8015ef4:	f107 070c 	add.w	r7, r7, #12
 8015ef8:	46bd      	mov	sp, r7
 8015efa:	bc80      	pop	{r7}
 8015efc:	4770      	bx	lr
 8015efe:	bf00      	nop

08015f00 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh>:
                        if(thePool[i].address)
                                pfunc(thePool + i);
        };
        // Allocates new address

        virtual uint8_t AllocAddress(uint8_t parent, bool is_hub = false, uint8_t port = 0) {
 8015f00:	b580      	push	{r7, lr}
 8015f02:	b084      	sub	sp, #16
 8015f04:	af00      	add	r7, sp, #0
 8015f06:	6078      	str	r0, [r7, #4]
 8015f08:	70f9      	strb	r1, [r7, #3]
 8015f0a:	70ba      	strb	r2, [r7, #2]
 8015f0c:	707b      	strb	r3, [r7, #1]
                /* if (parent != 0 && port == 0)
                        USB_HOST_SERIAL.println("PRT:0"); */

                if(parent > 127 || port > 7)
 8015f0e:	78fb      	ldrb	r3, [r7, #3]
 8015f10:	b2db      	uxtb	r3, r3
 8015f12:	b25b      	sxtb	r3, r3
 8015f14:	2b00      	cmp	r3, #0
 8015f16:	db02      	blt.n	8015f1e <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x1e>
 8015f18:	787b      	ldrb	r3, [r7, #1]
 8015f1a:	2b07      	cmp	r3, #7
 8015f1c:	d902      	bls.n	8015f24 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x24>
					return 0;
 8015f1e:	f04f 0300 	mov.w	r3, #0
 8015f22:	e090      	b.n	8016046 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x146>

                if(is_hub && hubCounter == 7)
 8015f24:	78bb      	ldrb	r3, [r7, #2]
 8015f26:	2b00      	cmp	r3, #0
 8015f28:	d006      	beq.n	8015f38 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x38>
 8015f2a:	687b      	ldr	r3, [r7, #4]
 8015f2c:	7a5b      	ldrb	r3, [r3, #9]
 8015f2e:	2b07      	cmp	r3, #7
 8015f30:	d102      	bne.n	8015f38 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x38>
					return 0;
 8015f32:	f04f 0300 	mov.w	r3, #0
 8015f36:	e086      	b.n	8016046 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x146>

                // finds first empty address entry starting from one
                uint8_t index = FindAddressIndex(0);
 8015f38:	6878      	ldr	r0, [r7, #4]
 8015f3a:	f04f 0100 	mov.w	r1, #0
 8015f3e:	f000 f905 	bl	801614c <_ZN15AddressPoolImplILh16EE16FindAddressIndexEh>
 8015f42:	4603      	mov	r3, r0
 8015f44:	73fb      	strb	r3, [r7, #15]

                if(!index) // if empty entry is not found
 8015f46:	7bfb      	ldrb	r3, [r7, #15]
 8015f48:	2b00      	cmp	r3, #0
 8015f4a:	d102      	bne.n	8015f52 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x52>
					return 0;
 8015f4c:	f04f 0300 	mov.w	r3, #0
 8015f50:	e079      	b.n	8016046 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x146>

                if(parent == 0) {
 8015f52:	78fb      	ldrb	r3, [r7, #3]
 8015f54:	2b00      	cmp	r3, #0
 8015f56:	d12d      	bne.n	8015fb4 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0xb4>
					if(is_hub) {
 8015f58:	78bb      	ldrb	r3, [r7, #2]
 8015f5a:	2b00      	cmp	r3, #0
 8015f5c:	d013      	beq.n	8015f86 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x86>
						thePool[index].address = 0x41;
 8015f5e:	7bfa      	ldrb	r2, [r7, #15]
 8015f60:	6879      	ldr	r1, [r7, #4]
 8015f62:	4613      	mov	r3, r2
 8015f64:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8015f68:	1a9b      	subs	r3, r3, r2
 8015f6a:	18cb      	adds	r3, r1, r3
 8015f6c:	f103 0308 	add.w	r3, r3, #8
 8015f70:	f04f 0241 	mov.w	r2, #65	; 0x41
 8015f74:	719a      	strb	r2, [r3, #6]
						hubCounter++;
 8015f76:	687b      	ldr	r3, [r7, #4]
 8015f78:	7a5b      	ldrb	r3, [r3, #9]
 8015f7a:	f103 0301 	add.w	r3, r3, #1
 8015f7e:	b2da      	uxtb	r2, r3
 8015f80:	687b      	ldr	r3, [r7, #4]
 8015f82:	725a      	strb	r2, [r3, #9]
 8015f84:	e00b      	b.n	8015f9e <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x9e>
					} else
						thePool[index].address = 1;
 8015f86:	7bfa      	ldrb	r2, [r7, #15]
 8015f88:	6879      	ldr	r1, [r7, #4]
 8015f8a:	4613      	mov	r3, r2
 8015f8c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8015f90:	1a9b      	subs	r3, r3, r2
 8015f92:	18cb      	adds	r3, r1, r3
 8015f94:	f103 0308 	add.w	r3, r3, #8
 8015f98:	f04f 0201 	mov.w	r2, #1
 8015f9c:	719a      	strb	r2, [r3, #6]

					return thePool[index].address;
 8015f9e:	7bfa      	ldrb	r2, [r7, #15]
 8015fa0:	6879      	ldr	r1, [r7, #4]
 8015fa2:	4613      	mov	r3, r2
 8015fa4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8015fa8:	1a9b      	subs	r3, r3, r2
 8015faa:	18cb      	adds	r3, r1, r3
 8015fac:	f103 0308 	add.w	r3, r3, #8
 8015fb0:	799b      	ldrb	r3, [r3, #6]
 8015fb2:	e048      	b.n	8016046 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x146>
                }

                UsbDeviceAddress addr;
                addr.devAddress = 0; // Ensure all bits are zero
 8015fb4:	f04f 0300 	mov.w	r3, #0
 8015fb8:	733b      	strb	r3, [r7, #12]

                addr.bmParent = ((UsbDeviceAddress*) & parent)->bmAddress;
 8015fba:	f107 0303 	add.w	r3, r7, #3
 8015fbe:	781b      	ldrb	r3, [r3, #0]
 8015fc0:	f3c3 0302 	ubfx	r3, r3, #0, #3
 8015fc4:	b2da      	uxtb	r2, r3
 8015fc6:	7b3b      	ldrb	r3, [r7, #12]
 8015fc8:	f362 03c5 	bfi	r3, r2, #3, #3
 8015fcc:	733b      	strb	r3, [r7, #12]

                if(is_hub) {
 8015fce:	78bb      	ldrb	r3, [r7, #2]
 8015fd0:	2b00      	cmp	r3, #0
 8015fd2:	d014      	beq.n	8015ffe <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0xfe>
                        addr.bmHub = 1;
 8015fd4:	7b3b      	ldrb	r3, [r7, #12]
 8015fd6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015fda:	733b      	strb	r3, [r7, #12]
                        addr.bmAddress = ++hubCounter;
 8015fdc:	687b      	ldr	r3, [r7, #4]
 8015fde:	7a5b      	ldrb	r3, [r3, #9]
 8015fe0:	f103 0301 	add.w	r3, r3, #1
 8015fe4:	b2da      	uxtb	r2, r3
 8015fe6:	687b      	ldr	r3, [r7, #4]
 8015fe8:	725a      	strb	r2, [r3, #9]
 8015fea:	687b      	ldr	r3, [r7, #4]
 8015fec:	7a5b      	ldrb	r3, [r3, #9]
 8015fee:	f003 0307 	and.w	r3, r3, #7
 8015ff2:	b2da      	uxtb	r2, r3
 8015ff4:	7b3b      	ldrb	r3, [r7, #12]
 8015ff6:	f362 0302 	bfi	r3, r2, #0, #3
 8015ffa:	733b      	strb	r3, [r7, #12]
 8015ffc:	e00b      	b.n	8016016 <_ZN15AddressPoolImplILh16EE12AllocAddressEhbh+0x116>
                } else {
                        addr.bmHub = 0;
 8015ffe:	7b3b      	ldrb	r3, [r7, #12]
 8016000:	f36f 1386 	bfc	r3, #6, #1
 8016004:	733b      	strb	r3, [r7, #12]
                        addr.bmAddress = port;
 8016006:	787b      	ldrb	r3, [r7, #1]
 8016008:	f003 0307 	and.w	r3, r3, #7
 801600c:	b2da      	uxtb	r2, r3
 801600e:	7b3b      	ldrb	r3, [r7, #12]
 8016010:	f362 0302 	bfi	r3, r2, #0, #3
 8016014:	733b      	strb	r3, [r7, #12]
                }
                thePool[index].address = *((uint8_t*) & addr);
 8016016:	7bfa      	ldrb	r2, [r7, #15]
 8016018:	f107 030c 	add.w	r3, r7, #12
 801601c:	7819      	ldrb	r1, [r3, #0]
 801601e:	6878      	ldr	r0, [r7, #4]
 8016020:	4613      	mov	r3, r2
 8016022:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8016026:	1a9b      	subs	r3, r3, r2
 8016028:	18c3      	adds	r3, r0, r3
 801602a:	f103 0308 	add.w	r3, r3, #8
 801602e:	460a      	mov	r2, r1
 8016030:	719a      	strb	r2, [r3, #6]
                                USB_HOST_SERIAL.print(".");
                                USB_HOST_SERIAL.print(addr.bmParent, HEX);
                                USB_HOST_SERIAL.print(".");
                                USB_HOST_SERIAL.println(addr.bmAddress, HEX);
                 */
                return thePool[index].address;
 8016032:	7bfa      	ldrb	r2, [r7, #15]
 8016034:	6879      	ldr	r1, [r7, #4]
 8016036:	4613      	mov	r3, r2
 8016038:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801603c:	1a9b      	subs	r3, r3, r2
 801603e:	18cb      	adds	r3, r1, r3
 8016040:	f103 0308 	add.w	r3, r3, #8
 8016044:	799b      	ldrb	r3, [r3, #6]
        };
 8016046:	4618      	mov	r0, r3
 8016048:	f107 0710 	add.w	r7, r7, #16
 801604c:	46bd      	mov	sp, r7
 801604e:	bd80      	pop	{r7, pc}

08016050 <_ZN15AddressPoolImplILh16EE11FreeAddressEh>:
        // Empties pool entry

        virtual void FreeAddress(uint8_t addr) {
 8016050:	b580      	push	{r7, lr}
 8016052:	b084      	sub	sp, #16
 8016054:	af00      	add	r7, sp, #0
 8016056:	6078      	str	r0, [r7, #4]
 8016058:	460b      	mov	r3, r1
 801605a:	70fb      	strb	r3, [r7, #3]
                // if the root hub is disconnected all the addresses should be initialized
                if(addr == 0x41) {
 801605c:	78fb      	ldrb	r3, [r7, #3]
 801605e:	2b41      	cmp	r3, #65	; 0x41
 8016060:	d103      	bne.n	801606a <_ZN15AddressPoolImplILh16EE11FreeAddressEh+0x1a>
					InitAllAddresses();
 8016062:	6878      	ldr	r0, [r7, #4]
 8016064:	f000 f850 	bl	8016108 <_ZN15AddressPoolImplILh16EE16InitAllAddressesEv>
					return;
 8016068:	e00b      	b.n	8016082 <_ZN15AddressPoolImplILh16EE11FreeAddressEh+0x32>
                }
                uint8_t index = FindAddressIndex(addr);
 801606a:	78fb      	ldrb	r3, [r7, #3]
 801606c:	6878      	ldr	r0, [r7, #4]
 801606e:	4619      	mov	r1, r3
 8016070:	f000 f86c 	bl	801614c <_ZN15AddressPoolImplILh16EE16FindAddressIndexEh>
 8016074:	4603      	mov	r3, r0
 8016076:	73fb      	strb	r3, [r7, #15]
                FreeAddressByIndex(index);
 8016078:	7bfb      	ldrb	r3, [r7, #15]
 801607a:	6878      	ldr	r0, [r7, #4]
 801607c:	4619      	mov	r1, r3
 801607e:	f000 f8cb 	bl	8016218 <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh>
        };
 8016082:	f107 0710 	add.w	r7, r7, #16
 8016086:	46bd      	mov	sp, r7
 8016088:	bd80      	pop	{r7, pc}
 801608a:	bf00      	nop

0801608c <_ZN15AddressPoolImplILh16EE9InitEntryEh>:

        UsbDevice thePool[MAX_DEVICES_ALLOWED];

        // Initializes address pool entry

        void InitEntry(uint8_t index) {
 801608c:	b480      	push	{r7}
 801608e:	b083      	sub	sp, #12
 8016090:	af00      	add	r7, sp, #0
 8016092:	6078      	str	r0, [r7, #4]
 8016094:	460b      	mov	r3, r1
 8016096:	70fb      	strb	r3, [r7, #3]
                thePool[index].address = 0;
 8016098:	78fa      	ldrb	r2, [r7, #3]
 801609a:	6879      	ldr	r1, [r7, #4]
 801609c:	4613      	mov	r3, r2
 801609e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80160a2:	1a9b      	subs	r3, r3, r2
 80160a4:	18cb      	adds	r3, r1, r3
 80160a6:	f103 0308 	add.w	r3, r3, #8
 80160aa:	f04f 0200 	mov.w	r2, #0
 80160ae:	719a      	strb	r2, [r3, #6]
                thePool[index].epcount = 1;
 80160b0:	78fa      	ldrb	r2, [r7, #3]
 80160b2:	6879      	ldr	r1, [r7, #4]
 80160b4:	4613      	mov	r3, r2
 80160b6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80160ba:	1a9b      	subs	r3, r3, r2
 80160bc:	18cb      	adds	r3, r1, r3
 80160be:	f103 0308 	add.w	r3, r3, #8
 80160c2:	f04f 0201 	mov.w	r2, #1
 80160c6:	71da      	strb	r2, [r3, #7]
                thePool[index].lowspeed = 0;
 80160c8:	78fa      	ldrb	r2, [r7, #3]
 80160ca:	6879      	ldr	r1, [r7, #4]
 80160cc:	4613      	mov	r3, r2
 80160ce:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80160d2:	1a9b      	subs	r3, r3, r2
 80160d4:	18cb      	adds	r3, r1, r3
 80160d6:	f103 0308 	add.w	r3, r3, #8
 80160da:	f04f 0200 	mov.w	r2, #0
 80160de:	721a      	strb	r2, [r3, #8]
                thePool[index].epinfo = &dev0ep;
 80160e0:	78fa      	ldrb	r2, [r7, #3]
 80160e2:	687b      	ldr	r3, [r7, #4]
 80160e4:	f103 0104 	add.w	r1, r3, #4
 80160e8:	6878      	ldr	r0, [r7, #4]
 80160ea:	4613      	mov	r3, r2
 80160ec:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80160f0:	1a9b      	subs	r3, r3, r2
 80160f2:	18c3      	adds	r3, r0, r3
 80160f4:	f103 0308 	add.w	r3, r3, #8
 80160f8:	f8c3 1002 	str.w	r1, [r3, #2]
        };
 80160fc:	f107 070c 	add.w	r7, r7, #12
 8016100:	46bd      	mov	sp, r7
 8016102:	bc80      	pop	{r7}
 8016104:	4770      	bx	lr
 8016106:	bf00      	nop

08016108 <_ZN15AddressPoolImplILh16EE16InitAllAddressesEv>:
                }
                InitEntry(index);
        }
        // Initializes the whole address pool at once

        void InitAllAddresses() {
 8016108:	b580      	push	{r7, lr}
 801610a:	b084      	sub	sp, #16
 801610c:	af00      	add	r7, sp, #0
 801610e:	6078      	str	r0, [r7, #4]
                for(uint8_t i = 1; i < MAX_DEVICES_ALLOWED; i++)
 8016110:	f04f 0301 	mov.w	r3, #1
 8016114:	73fb      	strb	r3, [r7, #15]
 8016116:	e008      	b.n	801612a <_ZN15AddressPoolImplILh16EE16InitAllAddressesEv+0x22>
                        InitEntry(i);
 8016118:	7bfb      	ldrb	r3, [r7, #15]
 801611a:	6878      	ldr	r0, [r7, #4]
 801611c:	4619      	mov	r1, r3
 801611e:	f7ff ffb5 	bl	801608c <_ZN15AddressPoolImplILh16EE9InitEntryEh>
                InitEntry(index);
        }
        // Initializes the whole address pool at once

        void InitAllAddresses() {
                for(uint8_t i = 1; i < MAX_DEVICES_ALLOWED; i++)
 8016122:	7bfb      	ldrb	r3, [r7, #15]
 8016124:	f103 0301 	add.w	r3, r3, #1
 8016128:	73fb      	strb	r3, [r7, #15]
 801612a:	7bfb      	ldrb	r3, [r7, #15]
 801612c:	2b0f      	cmp	r3, #15
 801612e:	bf8c      	ite	hi
 8016130:	2300      	movhi	r3, #0
 8016132:	2301      	movls	r3, #1
 8016134:	b2db      	uxtb	r3, r3
 8016136:	2b00      	cmp	r3, #0
 8016138:	d1ee      	bne.n	8016118 <_ZN15AddressPoolImplILh16EE16InitAllAddressesEv+0x10>
                        InitEntry(i);

                hubCounter = 0;
 801613a:	687b      	ldr	r3, [r7, #4]
 801613c:	f04f 0200 	mov.w	r2, #0
 8016140:	725a      	strb	r2, [r3, #9]
        };
 8016142:	f107 0710 	add.w	r7, r7, #16
 8016146:	46bd      	mov	sp, r7
 8016148:	bd80      	pop	{r7, pc}
 801614a:	bf00      	nop

0801614c <_ZN15AddressPoolImplILh16EE16FindAddressIndexEh>:
                thePool[index].lowspeed = 0;
                thePool[index].epinfo = &dev0ep;
        };
        // Returns thePool index for a given address

        uint8_t FindAddressIndex(uint8_t address = 0) {
 801614c:	b480      	push	{r7}
 801614e:	b085      	sub	sp, #20
 8016150:	af00      	add	r7, sp, #0
 8016152:	6078      	str	r0, [r7, #4]
 8016154:	460b      	mov	r3, r1
 8016156:	70fb      	strb	r3, [r7, #3]
			for(uint8_t i = 1; i < MAX_DEVICES_ALLOWED; i++) {
 8016158:	f04f 0301 	mov.w	r3, #1
 801615c:	73fb      	strb	r3, [r7, #15]
 801615e:	e012      	b.n	8016186 <_ZN15AddressPoolImplILh16EE16FindAddressIndexEh+0x3a>
				if(thePool[i].address == address)
 8016160:	7bfa      	ldrb	r2, [r7, #15]
 8016162:	6879      	ldr	r1, [r7, #4]
 8016164:	4613      	mov	r3, r2
 8016166:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801616a:	1a9b      	subs	r3, r3, r2
 801616c:	18cb      	adds	r3, r1, r3
 801616e:	f103 0308 	add.w	r3, r3, #8
 8016172:	799b      	ldrb	r3, [r3, #6]
 8016174:	78fa      	ldrb	r2, [r7, #3]
 8016176:	429a      	cmp	r2, r3
 8016178:	d101      	bne.n	801617e <_ZN15AddressPoolImplILh16EE16FindAddressIndexEh+0x32>
					return i;
 801617a:	7bfb      	ldrb	r3, [r7, #15]
 801617c:	e00d      	b.n	801619a <_ZN15AddressPoolImplILh16EE16FindAddressIndexEh+0x4e>
                thePool[index].epinfo = &dev0ep;
        };
        // Returns thePool index for a given address

        uint8_t FindAddressIndex(uint8_t address = 0) {
			for(uint8_t i = 1; i < MAX_DEVICES_ALLOWED; i++) {
 801617e:	7bfb      	ldrb	r3, [r7, #15]
 8016180:	f103 0301 	add.w	r3, r3, #1
 8016184:	73fb      	strb	r3, [r7, #15]
 8016186:	7bfb      	ldrb	r3, [r7, #15]
 8016188:	2b0f      	cmp	r3, #15
 801618a:	bf8c      	ite	hi
 801618c:	2300      	movhi	r3, #0
 801618e:	2301      	movls	r3, #1
 8016190:	b2db      	uxtb	r3, r3
 8016192:	2b00      	cmp	r3, #0
 8016194:	d1e4      	bne.n	8016160 <_ZN15AddressPoolImplILh16EE16FindAddressIndexEh+0x14>
				if(thePool[i].address == address)
					return i;
			}
			return 0;
 8016196:	f04f 0300 	mov.w	r3, #0
        };
 801619a:	4618      	mov	r0, r3
 801619c:	f107 0714 	add.w	r7, r7, #20
 80161a0:	46bd      	mov	sp, r7
 80161a2:	bc80      	pop	{r7}
 80161a4:	4770      	bx	lr
 80161a6:	bf00      	nop

080161a8 <_Z8PrintHexIhEvT_i>:
void E_Notify(uint8_t b, int lvl);
void E_Notify(uint16_t b, int lvl);
void E_Notify(uint32_t b, int lvl);

template <class T>
void PrintHex(T val, int lvl) {
 80161a8:	b580      	push	{r7, lr}
 80161aa:	b084      	sub	sp, #16
 80161ac:	af00      	add	r7, sp, #0
 80161ae:	4603      	mov	r3, r0
 80161b0:	6039      	str	r1, [r7, #0]
 80161b2:	71fb      	strb	r3, [r7, #7]
	int num_nibbles = sizeof(T) * 2;
 80161b4:	f04f 0302 	mov.w	r3, #2
 80161b8:	60fb      	str	r3, [r7, #12]

	do {
		char v = 48 + (((val >> (num_nibbles - 1) * 4)) & 0x0f);
 80161ba:	79fa      	ldrb	r2, [r7, #7]
 80161bc:	68fb      	ldr	r3, [r7, #12]
 80161be:	f103 33ff 	add.w	r3, r3, #4294967295
 80161c2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80161c6:	fa42 f303 	asr.w	r3, r2, r3
 80161ca:	b2db      	uxtb	r3, r3
 80161cc:	f003 030f 	and.w	r3, r3, #15
 80161d0:	b2db      	uxtb	r3, r3
 80161d2:	f103 0330 	add.w	r3, r3, #48	; 0x30
 80161d6:	b2db      	uxtb	r3, r3
 80161d8:	72fb      	strb	r3, [r7, #11]
		if(v > 57) v += 7;
 80161da:	f997 300b 	ldrsb.w	r3, [r7, #11]
 80161de:	2b39      	cmp	r3, #57	; 0x39
 80161e0:	dd04      	ble.n	80161ec <_Z8PrintHexIhEvT_i+0x44>
 80161e2:	7afb      	ldrb	r3, [r7, #11]
 80161e4:	f103 0307 	add.w	r3, r3, #7
 80161e8:	b2db      	uxtb	r3, r3
 80161ea:	72fb      	strb	r3, [r7, #11]
		E_Notifyc(v, lvl);
 80161ec:	f997 300b 	ldrsb.w	r3, [r7, #11]
 80161f0:	4618      	mov	r0, r3
 80161f2:	6839      	ldr	r1, [r7, #0]
 80161f4:	f003 f8bc 	bl	8019370 <_Z9E_Notifycci>

template <class T>
void PrintHex(T val, int lvl) {
	int num_nibbles = sizeof(T) * 2;

	do {
 80161f8:	68fb      	ldr	r3, [r7, #12]
 80161fa:	f103 33ff 	add.w	r3, r3, #4294967295
 80161fe:	60fb      	str	r3, [r7, #12]
 8016200:	68fb      	ldr	r3, [r7, #12]
 8016202:	2b00      	cmp	r3, #0
 8016204:	bf0c      	ite	eq
 8016206:	2300      	moveq	r3, #0
 8016208:	2301      	movne	r3, #1
 801620a:	b2db      	uxtb	r3, r3
 801620c:	2b00      	cmp	r3, #0
 801620e:	d1d4      	bne.n	80161ba <_Z8PrintHexIhEvT_i+0x12>
		char v = 48 + (((val >> (num_nibbles - 1) * 4)) & 0x0f);
		if(v > 57) v += 7;
		E_Notifyc(v, lvl);
	} while(--num_nibbles);
}
 8016210:	f107 0710 	add.w	r7, r7, #16
 8016214:	46bd      	mov	sp, r7
 8016216:	bd80      	pop	{r7, pc}

08016218 <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh>:
                }
                return 0;
        };
        // Frees address entry specified by index parameter

        void FreeAddressByIndex(uint8_t index) {
 8016218:	b580      	push	{r7, lr}
 801621a:	b084      	sub	sp, #16
 801621c:	af00      	add	r7, sp, #0
 801621e:	6078      	str	r0, [r7, #4]
 8016220:	460b      	mov	r3, r1
 8016222:	70fb      	strb	r3, [r7, #3]
                // Zerro field is reserved and should not be affected
                if(index == 0)
 8016224:	78fb      	ldrb	r3, [r7, #3]
 8016226:	2b00      	cmp	r3, #0
 8016228:	d054      	beq.n	80162d4 <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh+0xbc>
					return;

                // If a hub was switched off all port addresses should be freed
                if(((UsbDeviceAddress*) & thePool[index].address)->bmHub == 1) {
 801622a:	78fa      	ldrb	r2, [r7, #3]
 801622c:	4613      	mov	r3, r2
 801622e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8016232:	1a9b      	subs	r3, r3, r2
 8016234:	f103 0308 	add.w	r3, r3, #8
 8016238:	687a      	ldr	r2, [r7, #4]
 801623a:	18d3      	adds	r3, r2, r3
 801623c:	f103 0306 	add.w	r3, r3, #6
 8016240:	781b      	ldrb	r3, [r3, #0]
 8016242:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8016246:	b2db      	uxtb	r3, r3
 8016248:	2b00      	cmp	r3, #0
 801624a:	d03d      	beq.n	80162c8 <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh+0xb0>
                        for(uint8_t i = 1; (i = FindChildIndex(*((UsbDeviceAddress*) & thePool[index].address), i));)
 801624c:	f04f 0301 	mov.w	r3, #1
 8016250:	73fb      	strb	r3, [r7, #15]
 8016252:	e004      	b.n	801625e <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh+0x46>
                                FreeAddressByIndex(i);
 8016254:	7bfb      	ldrb	r3, [r7, #15]
 8016256:	6878      	ldr	r0, [r7, #4]
 8016258:	4619      	mov	r1, r3
 801625a:	f7ff ffdd 	bl	8016218 <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh>
                if(index == 0)
					return;

                // If a hub was switched off all port addresses should be freed
                if(((UsbDeviceAddress*) & thePool[index].address)->bmHub == 1) {
                        for(uint8_t i = 1; (i = FindChildIndex(*((UsbDeviceAddress*) & thePool[index].address), i));)
 801625e:	78fa      	ldrb	r2, [r7, #3]
 8016260:	4613      	mov	r3, r2
 8016262:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8016266:	1a9b      	subs	r3, r3, r2
 8016268:	f103 0308 	add.w	r3, r3, #8
 801626c:	687a      	ldr	r2, [r7, #4]
 801626e:	18d3      	adds	r3, r2, r3
 8016270:	f103 0206 	add.w	r2, r3, #6
 8016274:	7bfb      	ldrb	r3, [r7, #15]
 8016276:	6878      	ldr	r0, [r7, #4]
 8016278:	7811      	ldrb	r1, [r2, #0]
 801627a:	461a      	mov	r2, r3
 801627c:	f000 f830 	bl	80162e0 <_ZN15AddressPoolImplILh16EE14FindChildIndexE16UsbDeviceAddressh>
 8016280:	4603      	mov	r3, r0
 8016282:	73fb      	strb	r3, [r7, #15]
 8016284:	7bfb      	ldrb	r3, [r7, #15]
 8016286:	2b00      	cmp	r3, #0
 8016288:	bf0c      	ite	eq
 801628a:	2300      	moveq	r3, #0
 801628c:	2301      	movne	r3, #1
 801628e:	b2db      	uxtb	r3, r3
 8016290:	2b00      	cmp	r3, #0
 8016292:	d1df      	bne.n	8016254 <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh+0x3c>
                                FreeAddressByIndex(i);

                        // If the hub had the last allocated address, hubCounter should be decremented
                        if(hubCounter == ((UsbDeviceAddress*) & thePool[index].address)->bmAddress)
 8016294:	687b      	ldr	r3, [r7, #4]
 8016296:	7a59      	ldrb	r1, [r3, #9]
 8016298:	78fa      	ldrb	r2, [r7, #3]
 801629a:	4613      	mov	r3, r2
 801629c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80162a0:	1a9b      	subs	r3, r3, r2
 80162a2:	f103 0308 	add.w	r3, r3, #8
 80162a6:	687a      	ldr	r2, [r7, #4]
 80162a8:	18d3      	adds	r3, r2, r3
 80162aa:	f103 0306 	add.w	r3, r3, #6
 80162ae:	781b      	ldrb	r3, [r3, #0]
 80162b0:	f3c3 0302 	ubfx	r3, r3, #0, #3
 80162b4:	b2db      	uxtb	r3, r3
 80162b6:	4299      	cmp	r1, r3
 80162b8:	d106      	bne.n	80162c8 <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh+0xb0>
                                hubCounter--;
 80162ba:	687b      	ldr	r3, [r7, #4]
 80162bc:	7a5b      	ldrb	r3, [r3, #9]
 80162be:	f103 33ff 	add.w	r3, r3, #4294967295
 80162c2:	b2da      	uxtb	r2, r3
 80162c4:	687b      	ldr	r3, [r7, #4]
 80162c6:	725a      	strb	r2, [r3, #9]
                }
                InitEntry(index);
 80162c8:	78fb      	ldrb	r3, [r7, #3]
 80162ca:	6878      	ldr	r0, [r7, #4]
 80162cc:	4619      	mov	r1, r3
 80162ce:	f7ff fedd 	bl	801608c <_ZN15AddressPoolImplILh16EE9InitEntryEh>
 80162d2:	e000      	b.n	80162d6 <_ZN15AddressPoolImplILh16EE18FreeAddressByIndexEh+0xbe>
        // Frees address entry specified by index parameter

        void FreeAddressByIndex(uint8_t index) {
                // Zerro field is reserved and should not be affected
                if(index == 0)
					return;
 80162d4:	bf00      	nop
                        // If the hub had the last allocated address, hubCounter should be decremented
                        if(hubCounter == ((UsbDeviceAddress*) & thePool[index].address)->bmAddress)
                                hubCounter--;
                }
                InitEntry(index);
        }
 80162d6:	f107 0710 	add.w	r7, r7, #16
 80162da:	46bd      	mov	sp, r7
 80162dc:	bd80      	pop	{r7, pc}
 80162de:	bf00      	nop

080162e0 <_ZN15AddressPoolImplILh16EE14FindChildIndexE16UsbDeviceAddressh>:
			}
			return 0;
        };
        // Returns thePool child index for a given parent

        uint8_t FindChildIndex(UsbDeviceAddress addr, uint8_t start = 1) {
 80162e0:	b480      	push	{r7}
 80162e2:	b085      	sub	sp, #20
 80162e4:	af00      	add	r7, sp, #0
 80162e6:	6078      	str	r0, [r7, #4]
 80162e8:	7039      	strb	r1, [r7, #0]
 80162ea:	4613      	mov	r3, r2
 80162ec:	70fb      	strb	r3, [r7, #3]
                for(uint8_t i = (start < 1 || start >= MAX_DEVICES_ALLOWED) ? 1 : start; i < MAX_DEVICES_ALLOWED; i++) {
 80162ee:	78fb      	ldrb	r3, [r7, #3]
 80162f0:	2b00      	cmp	r3, #0
 80162f2:	d004      	beq.n	80162fe <_ZN15AddressPoolImplILh16EE14FindChildIndexE16UsbDeviceAddressh+0x1e>
 80162f4:	78fb      	ldrb	r3, [r7, #3]
 80162f6:	2b0f      	cmp	r3, #15
 80162f8:	d801      	bhi.n	80162fe <_ZN15AddressPoolImplILh16EE14FindChildIndexE16UsbDeviceAddressh+0x1e>
 80162fa:	78fb      	ldrb	r3, [r7, #3]
 80162fc:	e001      	b.n	8016302 <_ZN15AddressPoolImplILh16EE14FindChildIndexE16UsbDeviceAddressh+0x22>
 80162fe:	f04f 0301 	mov.w	r3, #1
 8016302:	73fb      	strb	r3, [r7, #15]
 8016304:	e01a      	b.n	801633c <_ZN15AddressPoolImplILh16EE14FindChildIndexE16UsbDeviceAddressh+0x5c>
                        if(((UsbDeviceAddress*) & thePool[i].address)->bmParent == addr.bmAddress)
 8016306:	7bfa      	ldrb	r2, [r7, #15]
 8016308:	4613      	mov	r3, r2
 801630a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801630e:	1a9b      	subs	r3, r3, r2
 8016310:	f103 0308 	add.w	r3, r3, #8
 8016314:	687a      	ldr	r2, [r7, #4]
 8016316:	18d3      	adds	r3, r2, r3
 8016318:	f103 0306 	add.w	r3, r3, #6
 801631c:	781b      	ldrb	r3, [r3, #0]
 801631e:	f3c3 03c2 	ubfx	r3, r3, #3, #3
 8016322:	b2da      	uxtb	r2, r3
 8016324:	783b      	ldrb	r3, [r7, #0]
 8016326:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801632a:	b2db      	uxtb	r3, r3
 801632c:	429a      	cmp	r2, r3
 801632e:	d101      	bne.n	8016334 <_ZN15AddressPoolImplILh16EE14FindChildIndexE16UsbDeviceAddressh+0x54>
                                return i;
 8016330:	7bfb      	ldrb	r3, [r7, #15]
 8016332:	e00d      	b.n	8016350 <_ZN15AddressPoolImplILh16EE14FindChildIndexE16UsbDeviceAddressh+0x70>
			return 0;
        };
        // Returns thePool child index for a given parent

        uint8_t FindChildIndex(UsbDeviceAddress addr, uint8_t start = 1) {
                for(uint8_t i = (start < 1 || start >= MAX_DEVICES_ALLOWED) ? 1 : start; i < MAX_DEVICES_ALLOWED; i++) {
 8016334:	7bfb      	ldrb	r3, [r7, #15]
 8016336:	f103 0301 	add.w	r3, r3, #1
 801633a:	73fb      	strb	r3, [r7, #15]
 801633c:	7bfb      	ldrb	r3, [r7, #15]
 801633e:	2b0f      	cmp	r3, #15
 8016340:	bf8c      	ite	hi
 8016342:	2300      	movhi	r3, #0
 8016344:	2301      	movls	r3, #1
 8016346:	b2db      	uxtb	r3, r3
 8016348:	2b00      	cmp	r3, #0
 801634a:	d1dc      	bne.n	8016306 <_ZN15AddressPoolImplILh16EE14FindChildIndexE16UsbDeviceAddressh+0x26>
                        if(((UsbDeviceAddress*) & thePool[i].address)->bmParent == addr.bmAddress)
                                return i;
                }
                return 0;
 801634c:	f04f 0300 	mov.w	r3, #0
        };
 8016350:	4618      	mov	r0, r3
 8016352:	f107 0714 	add.w	r7, r7, #20
 8016356:	46bd      	mov	sp, r7
 8016358:	bc80      	pop	{r7}
 801635a:	4770      	bx	lr

0801635c <_ZN15USBDeviceConfig4InitEhhb>:
#define USB_STATE_RUNNING                                   0x90
#define USB_STATE_ERROR                                     0xa0

class USBDeviceConfig {
public:
        virtual uint8_t Init(uint8_t parent, uint8_t port, bool lowspeed) { return 0; }
 801635c:	b480      	push	{r7}
 801635e:	b083      	sub	sp, #12
 8016360:	af00      	add	r7, sp, #0
 8016362:	6078      	str	r0, [r7, #4]
 8016364:	70f9      	strb	r1, [r7, #3]
 8016366:	70ba      	strb	r2, [r7, #2]
 8016368:	707b      	strb	r3, [r7, #1]
 801636a:	f04f 0300 	mov.w	r3, #0
 801636e:	4618      	mov	r0, r3
 8016370:	f107 070c 	add.w	r7, r7, #12
 8016374:	46bd      	mov	sp, r7
 8016376:	bc80      	pop	{r7}
 8016378:	4770      	bx	lr
 801637a:	bf00      	nop

0801637c <_ZN15USBDeviceConfig15ConfigureDeviceEhhb>:
        virtual uint8_t ConfigureDevice(uint8_t parent, uint8_t port, bool lowspeed) {return 0; }
 801637c:	b480      	push	{r7}
 801637e:	b083      	sub	sp, #12
 8016380:	af00      	add	r7, sp, #0
 8016382:	6078      	str	r0, [r7, #4]
 8016384:	70f9      	strb	r1, [r7, #3]
 8016386:	70ba      	strb	r2, [r7, #2]
 8016388:	707b      	strb	r3, [r7, #1]
 801638a:	f04f 0300 	mov.w	r3, #0
 801638e:	4618      	mov	r0, r3
 8016390:	f107 070c 	add.w	r7, r7, #12
 8016394:	46bd      	mov	sp, r7
 8016396:	bc80      	pop	{r7}
 8016398:	4770      	bx	lr
 801639a:	bf00      	nop

0801639c <_ZN15USBDeviceConfig7ReleaseEv>:
        virtual uint8_t Release() { return 0; }
 801639c:	b480      	push	{r7}
 801639e:	b083      	sub	sp, #12
 80163a0:	af00      	add	r7, sp, #0
 80163a2:	6078      	str	r0, [r7, #4]
 80163a4:	f04f 0300 	mov.w	r3, #0
 80163a8:	4618      	mov	r0, r3
 80163aa:	f107 070c 	add.w	r7, r7, #12
 80163ae:	46bd      	mov	sp, r7
 80163b0:	bc80      	pop	{r7}
 80163b2:	4770      	bx	lr

080163b4 <_ZN15USBDeviceConfig4PollEv>:
        virtual uint8_t Poll() { return 0; }
 80163b4:	b480      	push	{r7}
 80163b6:	b083      	sub	sp, #12
 80163b8:	af00      	add	r7, sp, #0
 80163ba:	6078      	str	r0, [r7, #4]
 80163bc:	f04f 0300 	mov.w	r3, #0
 80163c0:	4618      	mov	r0, r3
 80163c2:	f107 070c 	add.w	r7, r7, #12
 80163c6:	46bd      	mov	sp, r7
 80163c8:	bc80      	pop	{r7}
 80163ca:	4770      	bx	lr

080163cc <_ZN15USBDeviceConfig10GetAddressEv>:
        virtual uint8_t GetAddress() { return 0; }
 80163cc:	b480      	push	{r7}
 80163ce:	b083      	sub	sp, #12
 80163d0:	af00      	add	r7, sp, #0
 80163d2:	6078      	str	r0, [r7, #4]
 80163d4:	f04f 0300 	mov.w	r3, #0
 80163d8:	4618      	mov	r0, r3
 80163da:	f107 070c 	add.w	r7, r7, #12
 80163de:	46bd      	mov	sp, r7
 80163e0:	bc80      	pop	{r7}
 80163e2:	4770      	bx	lr

080163e4 <_ZN15USBDeviceConfig12ResetHubPortEh>:
        virtual void ResetHubPort(uint8_t port) { return; } // Note used for hubs only!
 80163e4:	b480      	push	{r7}
 80163e6:	b083      	sub	sp, #12
 80163e8:	af00      	add	r7, sp, #0
 80163ea:	6078      	str	r0, [r7, #4]
 80163ec:	460b      	mov	r3, r1
 80163ee:	70fb      	strb	r3, [r7, #3]
 80163f0:	bf00      	nop
 80163f2:	f107 070c 	add.w	r7, r7, #12
 80163f6:	46bd      	mov	sp, r7
 80163f8:	bc80      	pop	{r7}
 80163fa:	4770      	bx	lr

080163fc <_ZN15USBDeviceConfig8VIDPIDOKEtt>:
        virtual uint8_t VIDPIDOK(uint16_t vid, uint16_t pid) { return false; }
 80163fc:	b480      	push	{r7}
 80163fe:	b083      	sub	sp, #12
 8016400:	af00      	add	r7, sp, #0
 8016402:	6078      	str	r0, [r7, #4]
 8016404:	4613      	mov	r3, r2
 8016406:	460a      	mov	r2, r1
 8016408:	807a      	strh	r2, [r7, #2]
 801640a:	803b      	strh	r3, [r7, #0]
 801640c:	f04f 0300 	mov.w	r3, #0
 8016410:	4618      	mov	r0, r3
 8016412:	f107 070c 	add.w	r7, r7, #12
 8016416:	46bd      	mov	sp, r7
 8016418:	bc80      	pop	{r7}
 801641a:	4770      	bx	lr

0801641c <_ZN15USBDeviceConfig10DEVCLASSOKEh>:
        virtual uint8_t DEVCLASSOK(uint8_t klass) { return false; }
 801641c:	b480      	push	{r7}
 801641e:	b083      	sub	sp, #12
 8016420:	af00      	add	r7, sp, #0
 8016422:	6078      	str	r0, [r7, #4]
 8016424:	460b      	mov	r3, r1
 8016426:	70fb      	strb	r3, [r7, #3]
 8016428:	f04f 0300 	mov.w	r3, #0
 801642c:	4618      	mov	r0, r3
 801642e:	f107 070c 	add.w	r7, r7, #12
 8016432:	46bd      	mov	sp, r7
 8016434:	bc80      	pop	{r7}
 8016436:	4770      	bx	lr

08016438 <_ZN3USB19RegisterDeviceClassEP15USBDeviceConfig>:

        AddressPool& GetAddressPool() {
			return(AddressPool&) addrPool;
        };

        uint8_t RegisterDeviceClass(USBDeviceConfig *pdev) {
 8016438:	b480      	push	{r7}
 801643a:	b085      	sub	sp, #20
 801643c:	af00      	add	r7, sp, #0
 801643e:	6078      	str	r0, [r7, #4]
 8016440:	6039      	str	r1, [r7, #0]
                for(uint8_t i = 0; i < USB_NUMDEVICES; i++) {
 8016442:	f04f 0300 	mov.w	r3, #0
 8016446:	73fb      	strb	r3, [r7, #15]
 8016448:	e019      	b.n	801647e <_ZN3USB19RegisterDeviceClassEP15USBDeviceConfig+0x46>
					if(!devConfig[i]) {
 801644a:	7bfb      	ldrb	r3, [r7, #15]
 801644c:	687a      	ldr	r2, [r7, #4]
 801644e:	f103 031e 	add.w	r3, r3, #30
 8016452:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8016456:	18d3      	adds	r3, r2, r3
 8016458:	685b      	ldr	r3, [r3, #4]
 801645a:	2b00      	cmp	r3, #0
 801645c:	d10b      	bne.n	8016476 <_ZN3USB19RegisterDeviceClassEP15USBDeviceConfig+0x3e>
						devConfig[i] = pdev;
 801645e:	7bfb      	ldrb	r3, [r7, #15]
 8016460:	687a      	ldr	r2, [r7, #4]
 8016462:	f103 031e 	add.w	r3, r3, #30
 8016466:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801646a:	18d3      	adds	r3, r2, r3
 801646c:	683a      	ldr	r2, [r7, #0]
 801646e:	605a      	str	r2, [r3, #4]
						return 0;
 8016470:	f04f 0300 	mov.w	r3, #0
 8016474:	e00d      	b.n	8016492 <_ZN3USB19RegisterDeviceClassEP15USBDeviceConfig+0x5a>
        AddressPool& GetAddressPool() {
			return(AddressPool&) addrPool;
        };

        uint8_t RegisterDeviceClass(USBDeviceConfig *pdev) {
                for(uint8_t i = 0; i < USB_NUMDEVICES; i++) {
 8016476:	7bfb      	ldrb	r3, [r7, #15]
 8016478:	f103 0301 	add.w	r3, r3, #1
 801647c:	73fb      	strb	r3, [r7, #15]
 801647e:	7bfb      	ldrb	r3, [r7, #15]
 8016480:	2b0f      	cmp	r3, #15
 8016482:	bf8c      	ite	hi
 8016484:	2300      	movhi	r3, #0
 8016486:	2301      	movls	r3, #1
 8016488:	b2db      	uxtb	r3, r3
 801648a:	2b00      	cmp	r3, #0
 801648c:	d1dd      	bne.n	801644a <_ZN3USB19RegisterDeviceClassEP15USBDeviceConfig+0x12>
					if(!devConfig[i]) {
						devConfig[i] = pdev;
						return 0;
					}
                }
                return USB_ERROR_UNABLE_TO_REGISTER_DEVICE_CLASS;
 801648e:	f04f 03d3 	mov.w	r3, #211	; 0xd3
        };
 8016492:	4618      	mov	r0, r3
 8016494:	f107 0714 	add.w	r7, r7, #20
 8016498:	46bd      	mov	sp, r7
 801649a:	bc80      	pop	{r7}
 801649c:	4770      	bx	lr
 801649e:	bf00      	nop

080164a0 <_ZN20MultiByteValueParserC1Ev>:
        uint8_t countDown;
        uint8_t valueSize;

public:

        MultiByteValueParser() : pBuf(NULL), countDown(0), valueSize(0) {
 80164a0:	b480      	push	{r7}
 80164a2:	b083      	sub	sp, #12
 80164a4:	af00      	add	r7, sp, #0
 80164a6:	6078      	str	r0, [r7, #4]
 80164a8:	687b      	ldr	r3, [r7, #4]
 80164aa:	f04f 0200 	mov.w	r2, #0
 80164ae:	601a      	str	r2, [r3, #0]
 80164b0:	687b      	ldr	r3, [r7, #4]
 80164b2:	f04f 0200 	mov.w	r2, #0
 80164b6:	711a      	strb	r2, [r3, #4]
 80164b8:	687b      	ldr	r3, [r7, #4]
 80164ba:	f04f 0200 	mov.w	r2, #0
 80164be:	715a      	strb	r2, [r3, #5]
        };
 80164c0:	687b      	ldr	r3, [r7, #4]
 80164c2:	4618      	mov	r0, r3
 80164c4:	f107 070c 	add.w	r7, r7, #12
 80164c8:	46bd      	mov	sp, r7
 80164ca:	bc80      	pop	{r7}
 80164cc:	4770      	bx	lr
 80164ce:	bf00      	nop

080164d0 <_ZN20MultiByteValueParser10InitializeEP16MultiValueBuffer>:

        const uint8_t* GetBuffer() {
                return pBuf;
        };

        void Initialize(MultiValueBuffer * const pbuf) {
 80164d0:	b480      	push	{r7}
 80164d2:	b083      	sub	sp, #12
 80164d4:	af00      	add	r7, sp, #0
 80164d6:	6078      	str	r0, [r7, #4]
 80164d8:	6039      	str	r1, [r7, #0]
			pBuf = (uint8_t*) pbuf->pValue;
 80164da:	683b      	ldr	r3, [r7, #0]
 80164dc:	f8d3 2001 	ldr.w	r2, [r3, #1]
 80164e0:	687b      	ldr	r3, [r7, #4]
 80164e2:	601a      	str	r2, [r3, #0]
			countDown = valueSize = pbuf->valueSize;
 80164e4:	683b      	ldr	r3, [r7, #0]
 80164e6:	781a      	ldrb	r2, [r3, #0]
 80164e8:	687b      	ldr	r3, [r7, #4]
 80164ea:	715a      	strb	r2, [r3, #5]
 80164ec:	687b      	ldr	r3, [r7, #4]
 80164ee:	795a      	ldrb	r2, [r3, #5]
 80164f0:	687b      	ldr	r3, [r7, #4]
 80164f2:	711a      	strb	r2, [r3, #4]
        };
 80164f4:	f107 070c 	add.w	r7, r7, #12
 80164f8:	46bd      	mov	sp, r7
 80164fa:	bc80      	pop	{r7}
 80164fc:	4770      	bx	lr
 80164fe:	bf00      	nop

08016500 <_ZN11ByteSkipperC1Ev>:
        uint8_t nStage;
        uint16_t countDown;

public:

        ByteSkipper() : pBuf(NULL), nStage(0), countDown(0) {
 8016500:	b480      	push	{r7}
 8016502:	b083      	sub	sp, #12
 8016504:	af00      	add	r7, sp, #0
 8016506:	6078      	str	r0, [r7, #4]
 8016508:	687b      	ldr	r3, [r7, #4]
 801650a:	f04f 0200 	mov.w	r2, #0
 801650e:	601a      	str	r2, [r3, #0]
 8016510:	687b      	ldr	r3, [r7, #4]
 8016512:	f04f 0200 	mov.w	r2, #0
 8016516:	711a      	strb	r2, [r3, #4]
 8016518:	687b      	ldr	r3, [r7, #4]
 801651a:	f04f 0200 	mov.w	r2, #0
 801651e:	80da      	strh	r2, [r3, #6]
        };
 8016520:	687b      	ldr	r3, [r7, #4]
 8016522:	4618      	mov	r0, r3
 8016524:	f107 070c 	add.w	r7, r7, #12
 8016528:	46bd      	mov	sp, r7
 801652a:	bc80      	pop	{r7}
 801652c:	4770      	bx	lr
 801652e:	bf00      	nop

08016530 <_ZN11ByteSkipper10InitializeEP16MultiValueBuffer>:

        void Initialize(MultiValueBuffer *pbuf) {
 8016530:	b480      	push	{r7}
 8016532:	b083      	sub	sp, #12
 8016534:	af00      	add	r7, sp, #0
 8016536:	6078      	str	r0, [r7, #4]
 8016538:	6039      	str	r1, [r7, #0]
			pBuf = (uint8_t*) pbuf->pValue;
 801653a:	683b      	ldr	r3, [r7, #0]
 801653c:	f8d3 2001 	ldr.w	r2, [r3, #1]
 8016540:	687b      	ldr	r3, [r7, #4]
 8016542:	601a      	str	r2, [r3, #0]
			countDown = 0;
 8016544:	687b      	ldr	r3, [r7, #4]
 8016546:	f04f 0200 	mov.w	r2, #0
 801654a:	80da      	strh	r2, [r3, #6]
        };
 801654c:	f107 070c 	add.w	r7, r7, #12
 8016550:	46bd      	mov	sp, r7
 8016552:	bc80      	pop	{r7}
 8016554:	4770      	bx	lr
 8016556:	bf00      	nop

08016558 <_ZN11ByteSkipper4SkipEPPhPtt>:

        bool Skip(uint8_t **pp, uint16_t *pcntdn, uint16_t bytes_to_skip) {
 8016558:	b480      	push	{r7}
 801655a:	b085      	sub	sp, #20
 801655c:	af00      	add	r7, sp, #0
 801655e:	60f8      	str	r0, [r7, #12]
 8016560:	60b9      	str	r1, [r7, #8]
 8016562:	607a      	str	r2, [r7, #4]
 8016564:	807b      	strh	r3, [r7, #2]
                switch(nStage) {
 8016566:	68fb      	ldr	r3, [r7, #12]
 8016568:	791b      	ldrb	r3, [r3, #4]
 801656a:	2b00      	cmp	r3, #0
 801656c:	d002      	beq.n	8016574 <_ZN11ByteSkipper4SkipEPPhPtt+0x1c>
 801656e:	2b01      	cmp	r3, #1
 8016570:	d01f      	beq.n	80165b2 <_ZN11ByteSkipper4SkipEPPhPtt+0x5a>
 8016572:	e035      	b.n	80165e0 <_ZN11ByteSkipper4SkipEPPhPtt+0x88>
                        case 0:
                                countDown = bytes_to_skip;
 8016574:	68fb      	ldr	r3, [r7, #12]
 8016576:	887a      	ldrh	r2, [r7, #2]
 8016578:	80da      	strh	r2, [r3, #6]
                                nStage++;
 801657a:	68fb      	ldr	r3, [r7, #12]
 801657c:	791b      	ldrb	r3, [r3, #4]
 801657e:	f103 0301 	add.w	r3, r3, #1
 8016582:	b2da      	uxtb	r2, r3
 8016584:	68fb      	ldr	r3, [r7, #12]
 8016586:	711a      	strb	r2, [r3, #4]
                        case 1:
                                for(; countDown && (*pcntdn); countDown--, (*pp)++, (*pcntdn)--);
 8016588:	e013      	b.n	80165b2 <_ZN11ByteSkipper4SkipEPPhPtt+0x5a>
 801658a:	68fb      	ldr	r3, [r7, #12]
 801658c:	88db      	ldrh	r3, [r3, #6]
 801658e:	f103 33ff 	add.w	r3, r3, #4294967295
 8016592:	b29a      	uxth	r2, r3
 8016594:	68fb      	ldr	r3, [r7, #12]
 8016596:	80da      	strh	r2, [r3, #6]
 8016598:	68bb      	ldr	r3, [r7, #8]
 801659a:	681b      	ldr	r3, [r3, #0]
 801659c:	f103 0201 	add.w	r2, r3, #1
 80165a0:	68bb      	ldr	r3, [r7, #8]
 80165a2:	601a      	str	r2, [r3, #0]
 80165a4:	687b      	ldr	r3, [r7, #4]
 80165a6:	881b      	ldrh	r3, [r3, #0]
 80165a8:	f103 33ff 	add.w	r3, r3, #4294967295
 80165ac:	b29a      	uxth	r2, r3
 80165ae:	687b      	ldr	r3, [r7, #4]
 80165b0:	801a      	strh	r2, [r3, #0]
 80165b2:	68fb      	ldr	r3, [r7, #12]
 80165b4:	88db      	ldrh	r3, [r3, #6]
 80165b6:	2b00      	cmp	r3, #0
 80165b8:	d006      	beq.n	80165c8 <_ZN11ByteSkipper4SkipEPPhPtt+0x70>
 80165ba:	687b      	ldr	r3, [r7, #4]
 80165bc:	881b      	ldrh	r3, [r3, #0]
 80165be:	2b00      	cmp	r3, #0
 80165c0:	d002      	beq.n	80165c8 <_ZN11ByteSkipper4SkipEPPhPtt+0x70>
 80165c2:	f04f 0301 	mov.w	r3, #1
 80165c6:	e001      	b.n	80165cc <_ZN11ByteSkipper4SkipEPPhPtt+0x74>
 80165c8:	f04f 0300 	mov.w	r3, #0
 80165cc:	2b00      	cmp	r3, #0
 80165ce:	d1dc      	bne.n	801658a <_ZN11ByteSkipper4SkipEPPhPtt+0x32>

                                if(!countDown)
 80165d0:	68fb      	ldr	r3, [r7, #12]
 80165d2:	88db      	ldrh	r3, [r3, #6]
 80165d4:	2b00      	cmp	r3, #0
 80165d6:	d103      	bne.n	80165e0 <_ZN11ByteSkipper4SkipEPPhPtt+0x88>
                                        nStage = 0;
 80165d8:	68fb      	ldr	r3, [r7, #12]
 80165da:	f04f 0200 	mov.w	r2, #0
 80165de:	711a      	strb	r2, [r3, #4]
                };
                return(!countDown);
 80165e0:	68fb      	ldr	r3, [r7, #12]
 80165e2:	88db      	ldrh	r3, [r3, #6]
 80165e4:	2b00      	cmp	r3, #0
 80165e6:	bf14      	ite	ne
 80165e8:	2300      	movne	r3, #0
 80165ea:	2301      	moveq	r3, #1
 80165ec:	b2db      	uxtb	r3, r3
        };
 80165ee:	4618      	mov	r0, r3
 80165f0:	f107 0714 	add.w	r7, r7, #20
 80165f4:	46bd      	mov	sp, r7
 80165f6:	bc80      	pop	{r7}
 80165f8:	4770      	bx	lr
 80165fa:	bf00      	nop

080165fc <_ZN8BulkOnly6OnInitEv>:
        void PrintEndpointDescriptor(const USB_ENDPOINT_DESCRIPTOR* ep_ptr);


        // Additional Initialization Method for Subclasses

        virtual uint8_t OnInit() {
 80165fc:	b480      	push	{r7}
 80165fe:	b083      	sub	sp, #12
 8016600:	af00      	add	r7, sp, #0
 8016602:	6078      	str	r0, [r7, #4]
                return 0;
 8016604:	f04f 0300 	mov.w	r3, #0
        };
 8016608:	4618      	mov	r0, r3
 801660a:	f107 070c 	add.w	r7, r7, #12
 801660e:	46bd      	mov	sp, r7
 8016610:	bc80      	pop	{r7}
 8016612:	4770      	bx	lr

08016614 <_ZN8BulkOnly10GetAddressEv>:
        };
        void EnablePolling() {
        	//bPollEnable = true;
        	pUsb->bGlobalPollEnable = true;
        };
        virtual uint8_t GetAddress() {
 8016614:	b480      	push	{r7}
 8016616:	b083      	sub	sp, #12
 8016618:	af00      	add	r7, sp, #0
 801661a:	6078      	str	r0, [r7, #4]
                return bAddress;
 801661c:	687b      	ldr	r3, [r7, #4]
 801661e:	7b1b      	ldrb	r3, [r3, #12]
        };
 8016620:	4618      	mov	r0, r3
 8016622:	f107 070c 	add.w	r7, r7, #12
 8016626:	46bd      	mov	sp, r7
 8016628:	bc80      	pop	{r7}
 801662a:	4770      	bx	lr

0801662c <_ZN8BulkOnly10DEVCLASSOKEh>:

        // UsbConfigXtracter implementation
        virtual void EndpointXtract(uint8_t conf, uint8_t iface, uint8_t alt, uint8_t proto, const USB_ENDPOINT_DESCRIPTOR *ep);
        virtual uint8_t DEVCLASSOK(uint8_t klass) { return (klass == USB_CLASS_MASS_STORAGE); }
 801662c:	b480      	push	{r7}
 801662e:	b083      	sub	sp, #12
 8016630:	af00      	add	r7, sp, #0
 8016632:	6078      	str	r0, [r7, #4]
 8016634:	460b      	mov	r3, r1
 8016636:	70fb      	strb	r3, [r7, #3]
 8016638:	78fb      	ldrb	r3, [r7, #3]
 801663a:	2b08      	cmp	r3, #8
 801663c:	bf14      	ite	ne
 801663e:	2300      	movne	r3, #0
 8016640:	2301      	moveq	r3, #1
 8016642:	b2db      	uxtb	r3, r3
 8016644:	4618      	mov	r0, r3
 8016646:	f107 070c 	add.w	r7, r7, #12
 801664a:	46bd      	mov	sp, r7
 801664c:	bc80      	pop	{r7}
 801664e:	4770      	bx	lr

08016650 <_ZN8BulkOnly11GetCapacityEh>:
 * Get the capacity of the media
 *
 * @param lun Logical Unit Number
 * @return media capacity
 */
uint32_t BulkOnly::GetCapacity(uint8_t lun) {
 8016650:	b480      	push	{r7}
 8016652:	b083      	sub	sp, #12
 8016654:	af00      	add	r7, sp, #0
 8016656:	6078      	str	r0, [r7, #4]
 8016658:	460b      	mov	r3, r1
 801665a:	70fb      	strb	r3, [r7, #3]
	if (LUNOk[lun])
 801665c:	78fb      	ldrb	r3, [r7, #3]
 801665e:	687a      	ldr	r2, [r7, #4]
 8016660:	18d3      	adds	r3, r2, r3
 8016662:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8016666:	2b00      	cmp	r3, #0
 8016668:	d006      	beq.n	8016678 <_ZN8BulkOnly11GetCapacityEh+0x28>
		return CurrentCapacity[lun];
 801666a:	78fa      	ldrb	r2, [r7, #3]
 801666c:	687b      	ldr	r3, [r7, #4]
 801666e:	f102 020c 	add.w	r2, r2, #12
 8016672:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8016676:	e001      	b.n	801667c <_ZN8BulkOnly11GetCapacityEh+0x2c>
	return 0LU;
 8016678:	f04f 0300 	mov.w	r3, #0
}
 801667c:	4618      	mov	r0, r3
 801667e:	f107 070c 	add.w	r7, r7, #12
 8016682:	46bd      	mov	sp, r7
 8016684:	bc80      	pop	{r7}
 8016686:	4770      	bx	lr

08016688 <_ZN8BulkOnly13GetSectorSizeEh>:
 * Get the sector (block) size used on the media
 *
 * @param lun Logical Unit Number
 * @return media sector size
 */
uint16_t BulkOnly::GetSectorSize(uint8_t lun) {
 8016688:	b480      	push	{r7}
 801668a:	b083      	sub	sp, #12
 801668c:	af00      	add	r7, sp, #0
 801668e:	6078      	str	r0, [r7, #4]
 8016690:	460b      	mov	r3, r1
 8016692:	70fb      	strb	r3, [r7, #3]
	if (LUNOk[lun])
 8016694:	78fb      	ldrb	r3, [r7, #3]
 8016696:	687a      	ldr	r2, [r7, #4]
 8016698:	18d3      	adds	r3, r2, r3
 801669a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 801669e:	2b00      	cmp	r3, #0
 80166a0:	d006      	beq.n	80166b0 <_ZN8BulkOnly13GetSectorSizeEh+0x28>
		return CurrentSectorSize[lun];
 80166a2:	78fa      	ldrb	r2, [r7, #3]
 80166a4:	687b      	ldr	r3, [r7, #4]
 80166a6:	f102 0228 	add.w	r2, r2, #40	; 0x28
 80166aa:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80166ae:	e001      	b.n	80166b4 <_ZN8BulkOnly13GetSectorSizeEh+0x2c>
	return 0U;
 80166b0:	f04f 0300 	mov.w	r3, #0
}
 80166b4:	4618      	mov	r0, r3
 80166b6:	f107 070c 	add.w	r7, r7, #12
 80166ba:	46bd      	mov	sp, r7
 80166bc:	bc80      	pop	{r7}
 80166be:	4770      	bx	lr

080166c0 <_ZN8BulkOnly9LUNIsGoodEh>:
 * Test if LUN is ready for use
 *
 * @param lun Logical Unit Number
 * @return true if LUN is ready for use
 */
bool BulkOnly::LUNIsGood(uint8_t lun) {
 80166c0:	b480      	push	{r7}
 80166c2:	b083      	sub	sp, #12
 80166c4:	af00      	add	r7, sp, #0
 80166c6:	6078      	str	r0, [r7, #4]
 80166c8:	460b      	mov	r3, r1
 80166ca:	70fb      	strb	r3, [r7, #3]
        return LUNOk[lun];
 80166cc:	78fb      	ldrb	r3, [r7, #3]
 80166ce:	687a      	ldr	r2, [r7, #4]
 80166d0:	18d3      	adds	r3, r2, r3
 80166d2:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
}
 80166d6:	4618      	mov	r0, r3
 80166d8:	f107 070c 	add.w	r7, r7, #12
 80166dc:	46bd      	mov	sp, r7
 80166de:	bc80      	pop	{r7}
 80166e0:	4770      	bx	lr
 80166e2:	bf00      	nop

080166e4 <_ZN8BulkOnly14WriteProtectedEh>:
 * Test if LUN is write protected
 *
 * @param lun Logical Unit Number
 * @return cached status of write protect switch
 */
uint8_t BulkOnly::WriteProtected(uint8_t lun) {
 80166e4:	b480      	push	{r7}
 80166e6:	b083      	sub	sp, #12
 80166e8:	af00      	add	r7, sp, #0
 80166ea:	6078      	str	r0, [r7, #4]
 80166ec:	460b      	mov	r3, r1
 80166ee:	70fb      	strb	r3, [r7, #3]
        return WriteOk[lun];
 80166f0:	78fb      	ldrb	r3, [r7, #3]
 80166f2:	687a      	ldr	r2, [r7, #4]
 80166f4:	18d3      	adds	r3, r2, r3
 80166f6:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
}
 80166fa:	4618      	mov	r0, r3
 80166fc:	f107 070c 	add.w	r7, r7, #12
 8016700:	46bd      	mov	sp, r7
 8016702:	bc80      	pop	{r7}
 8016704:	4770      	bx	lr
 8016706:	bf00      	nop

08016708 <_ZN8BulkOnly9LockMediaEhh>:
 *
 * @param lun Logical Unit Number
 * @param lock 1 to lock, 0 to unlock
 * @return
 */
uint8_t BulkOnly::LockMedia(uint8_t lun, uint8_t lock) {
 8016708:	b580      	push	{r7, lr}
 801670a:	b08c      	sub	sp, #48	; 0x30
 801670c:	af02      	add	r7, sp, #8
 801670e:	6078      	str	r0, [r7, #4]
 8016710:	4613      	mov	r3, r2
 8016712:	460a      	mov	r2, r1
 8016714:	70fa      	strb	r2, [r7, #3]
 8016716:	70bb      	strb	r3, [r7, #2]
        Notify(PSTR("\r\nLockMedia\r\n"), 0x80);
 8016718:	f64e 00d4 	movw	r0, #59604	; 0xe8d4
 801671c:	f6c0 0001 	movt	r0, #2049	; 0x801
 8016720:	f04f 0180 	mov.w	r1, #128	; 0x80
 8016724:	f002 fe46 	bl	80193b4 <_Z8E_NotifyPKci>
        Notify(PSTR("---------\r\n"), 0x80);
 8016728:	f64e 00e4 	movw	r0, #59620	; 0xe8e4
 801672c:	f6c0 0001 	movt	r0, #2049	; 0x801
 8016730:	f04f 0180 	mov.w	r1, #128	; 0x80
 8016734:	f002 fe3e 	bl	80193b4 <_Z8E_NotifyPKci>

        CommandBlockWrapper cbw;
        SetCurLUN(lun);
 8016738:	78fb      	ldrb	r3, [r7, #3]
 801673a:	6878      	ldr	r0, [r7, #4]
 801673c:	4619      	mov	r1, r3
 801673e:	f002 f989 	bl	8018a54 <_ZN8BulkOnly9SetCurLUNEh>
        cbw.dCBWSignature = MASS_CBW_SIGNATURE;
 8016742:	f245 3355 	movw	r3, #21333	; 0x5355
 8016746:	f2c4 3342 	movt	r3, #17218	; 0x4342
 801674a:	60bb      	str	r3, [r7, #8]
        cbw.dCBWTag = ++dCBWTag;
 801674c:	687b      	ldr	r3, [r7, #4]
 801674e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016750:	f103 0201 	add.w	r2, r3, #1
 8016754:	687b      	ldr	r3, [r7, #4]
 8016756:	625a      	str	r2, [r3, #36]	; 0x24
 8016758:	687b      	ldr	r3, [r7, #4]
 801675a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801675c:	60fb      	str	r3, [r7, #12]
        cbw.dCBWDataTransferLength = 0;
 801675e:	f04f 0300 	mov.w	r3, #0
 8016762:	613b      	str	r3, [r7, #16]
        cbw.bmCBWFlags = MASS_CMD_DIR_IN;
 8016764:	f04f 0380 	mov.w	r3, #128	; 0x80
 8016768:	753b      	strb	r3, [r7, #20]
        cbw.bmCBWLUN = lun;
 801676a:	78fb      	ldrb	r3, [r7, #3]
 801676c:	f003 030f 	and.w	r3, r3, #15
 8016770:	b2da      	uxtb	r2, r3
 8016772:	7d7b      	ldrb	r3, [r7, #21]
 8016774:	f362 0303 	bfi	r3, r2, #0, #4
 8016778:	757b      	strb	r3, [r7, #21]
        cbw.bmCBWCBLength = 6;
 801677a:	7dbb      	ldrb	r3, [r7, #22]
 801677c:	f04f 0206 	mov.w	r2, #6
 8016780:	f362 0303 	bfi	r3, r2, #0, #4
 8016784:	75bb      	strb	r3, [r7, #22]

        for (uint8_t i = 0; i < 16; i++)
 8016786:	f04f 0300 	mov.w	r3, #0
 801678a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 801678e:	e00e      	b.n	80167ae <_ZN8BulkOnly9LockMediaEhh+0xa6>
                cbw.CBWCB[i] = 0;
 8016790:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8016794:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8016798:	18d3      	adds	r3, r2, r3
 801679a:	f04f 0200 	mov.w	r2, #0
 801679e:	f803 2c11 	strb.w	r2, [r3, #-17]
        cbw.dCBWDataTransferLength = 0;
        cbw.bmCBWFlags = MASS_CMD_DIR_IN;
        cbw.bmCBWLUN = lun;
        cbw.bmCBWCBLength = 6;

        for (uint8_t i = 0; i < 16; i++)
 80167a2:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80167a6:	f103 0301 	add.w	r3, r3, #1
 80167aa:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 80167ae:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80167b2:	2b0f      	cmp	r3, #15
 80167b4:	bf8c      	ite	hi
 80167b6:	2300      	movhi	r3, #0
 80167b8:	2301      	movls	r3, #1
 80167ba:	b2db      	uxtb	r3, r3
 80167bc:	2b00      	cmp	r3, #0
 80167be:	d1e7      	bne.n	8016790 <_ZN8BulkOnly9LockMediaEhh+0x88>
                cbw.CBWCB[i] = 0;

        cbw.CBWCB[0] = SCSI_CMD_PREVENT_REMOVAL;
 80167c0:	f04f 031e 	mov.w	r3, #30
 80167c4:	75fb      	strb	r3, [r7, #23]
        cbw.CBWCB[4] = lock;
 80167c6:	78bb      	ldrb	r3, [r7, #2]
 80167c8:	76fb      	strb	r3, [r7, #27]

        return (HandleSCSIError(Transaction(&cbw, 0, NULL, 0)));
 80167ca:	f107 0308 	add.w	r3, r7, #8
 80167ce:	f04f 0200 	mov.w	r2, #0
 80167d2:	9200      	str	r2, [sp, #0]
 80167d4:	6878      	ldr	r0, [r7, #4]
 80167d6:	4619      	mov	r1, r3
 80167d8:	f04f 0200 	mov.w	r2, #0
 80167dc:	f04f 0300 	mov.w	r3, #0
 80167e0:	f001 fee8 	bl	80185b4 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh>
 80167e4:	4603      	mov	r3, r0
 80167e6:	6878      	ldr	r0, [r7, #4]
 80167e8:	4619      	mov	r1, r3
 80167ea:	f002 f94f 	bl	8018a8c <_ZN8BulkOnly15HandleSCSIErrorEh>
 80167ee:	4603      	mov	r3, r0
 80167f0:	e001      	b.n	80167f6 <_ZN8BulkOnly9LockMediaEhh+0xee>
 80167f2:	f006 f945 	bl	801ca80 <__cxa_end_cleanup>

}
 80167f6:	4618      	mov	r0, r3
 80167f8:	f107 0728 	add.w	r7, r7, #40	; 0x28
 80167fc:	46bd      	mov	sp, r7
 80167fe:	bd80      	pop	{r7, pc}

08016800 <_ZN8BulkOnly8MediaCTLEhh>:
 *
 * @param lun Logical Unit Number
 * @param ctl 0x00 Stop Motor, 0x01 Start Motor, 0x02 Eject Media, 0x03 Load Media
 * @return 0 on success
 */
uint8_t BulkOnly::MediaCTL(uint8_t lun, uint8_t ctl) {
 8016800:	b580      	push	{r7, lr}
 8016802:	b08e      	sub	sp, #56	; 0x38
 8016804:	af02      	add	r7, sp, #8
 8016806:	6078      	str	r0, [r7, #4]
 8016808:	4613      	mov	r3, r2
 801680a:	460a      	mov	r2, r1
 801680c:	70fa      	strb	r2, [r7, #3]
 801680e:	70bb      	strb	r3, [r7, #2]
        Notify(PSTR("\r\nMediaCTL\r\n"), 0x80);
 8016810:	f64e 00f0 	movw	r0, #59632	; 0xe8f0
 8016814:	f6c0 0001 	movt	r0, #2049	; 0x801
 8016818:	f04f 0180 	mov.w	r1, #128	; 0x80
 801681c:	f002 fdca 	bl	80193b4 <_Z8E_NotifyPKci>
        Notify(PSTR("-----------------\r\n"), 0x80);
 8016820:	f64e 1000 	movw	r0, #59648	; 0xe900
 8016824:	f6c0 0001 	movt	r0, #2049	; 0x801
 8016828:	f04f 0180 	mov.w	r1, #128	; 0x80
 801682c:	f002 fdc2 	bl	80193b4 <_Z8E_NotifyPKci>
        SetCurLUN(lun);
 8016830:	78fb      	ldrb	r3, [r7, #3]
 8016832:	6878      	ldr	r0, [r7, #4]
 8016834:	4619      	mov	r1, r3
 8016836:	f002 f90d 	bl	8018a54 <_ZN8BulkOnly9SetCurLUNEh>
        uint8_t rcode = MASS_ERR_UNIT_NOT_READY;
 801683a:	f04f 0303 	mov.w	r3, #3
 801683e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        if (bAddress) {
 8016842:	687b      	ldr	r3, [r7, #4]
 8016844:	7b1b      	ldrb	r3, [r3, #12]
 8016846:	2b00      	cmp	r3, #0
 8016848:	d060      	beq.n	801690c <_ZN8BulkOnly8MediaCTLEhh+0x10c>
                CommandBlockWrapper cbw;

                cbw.dCBWSignature = MASS_CBW_SIGNATURE;
 801684a:	f245 3355 	movw	r3, #21333	; 0x5355
 801684e:	f2c4 3342 	movt	r3, #17218	; 0x4342
 8016852:	60fb      	str	r3, [r7, #12]
                cbw.dCBWTag = ++dCBWTag;
 8016854:	687b      	ldr	r3, [r7, #4]
 8016856:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016858:	f103 0201 	add.w	r2, r3, #1
 801685c:	687b      	ldr	r3, [r7, #4]
 801685e:	625a      	str	r2, [r3, #36]	; 0x24
 8016860:	687b      	ldr	r3, [r7, #4]
 8016862:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016864:	613b      	str	r3, [r7, #16]
                cbw.dCBWDataTransferLength = 0;
 8016866:	f04f 0300 	mov.w	r3, #0
 801686a:	617b      	str	r3, [r7, #20]
                cbw.bmCBWFlags = MASS_CMD_DIR_OUT;
 801686c:	f04f 0300 	mov.w	r3, #0
 8016870:	763b      	strb	r3, [r7, #24]
                cbw.bmCBWLUN = lun;
 8016872:	78fb      	ldrb	r3, [r7, #3]
 8016874:	f003 030f 	and.w	r3, r3, #15
 8016878:	b2da      	uxtb	r2, r3
 801687a:	7e7b      	ldrb	r3, [r7, #25]
 801687c:	f362 0303 	bfi	r3, r2, #0, #4
 8016880:	767b      	strb	r3, [r7, #25]
                cbw.bmCBWCBLength = 6;
 8016882:	7ebb      	ldrb	r3, [r7, #26]
 8016884:	f04f 0206 	mov.w	r2, #6
 8016888:	f362 0303 	bfi	r3, r2, #0, #4
 801688c:	76bb      	strb	r3, [r7, #26]

                for (uint8_t i = 0; i < 16; i++)
 801688e:	f04f 0300 	mov.w	r3, #0
 8016892:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
 8016896:	e00e      	b.n	80168b6 <_ZN8BulkOnly8MediaCTLEhh+0xb6>
                        cbw.CBWCB[i] = 0;
 8016898:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 801689c:	f107 0230 	add.w	r2, r7, #48	; 0x30
 80168a0:	18d3      	adds	r3, r2, r3
 80168a2:	f04f 0200 	mov.w	r2, #0
 80168a6:	f803 2c15 	strb.w	r2, [r3, #-21]
                cbw.dCBWDataTransferLength = 0;
                cbw.bmCBWFlags = MASS_CMD_DIR_OUT;
                cbw.bmCBWLUN = lun;
                cbw.bmCBWCBLength = 6;

                for (uint8_t i = 0; i < 16; i++)
 80168aa:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 80168ae:	f103 0301 	add.w	r3, r3, #1
 80168b2:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
 80168b6:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 80168ba:	2b0f      	cmp	r3, #15
 80168bc:	bf8c      	ite	hi
 80168be:	2300      	movhi	r3, #0
 80168c0:	2301      	movls	r3, #1
 80168c2:	b2db      	uxtb	r3, r3
 80168c4:	2b00      	cmp	r3, #0
 80168c6:	d1e7      	bne.n	8016898 <_ZN8BulkOnly8MediaCTLEhh+0x98>
                        cbw.CBWCB[i] = 0;

                cbw.CBWCB[0] = SCSI_CMD_START_STOP_UNIT;
 80168c8:	f04f 031b 	mov.w	r3, #27
 80168cc:	76fb      	strb	r3, [r7, #27]
                cbw.CBWCB[1] = lun << 5;
 80168ce:	78fb      	ldrb	r3, [r7, #3]
 80168d0:	ea4f 1343 	mov.w	r3, r3, lsl #5
 80168d4:	b2db      	uxtb	r3, r3
 80168d6:	773b      	strb	r3, [r7, #28]
                cbw.CBWCB[4] = ctl & 0x03;
 80168d8:	78bb      	ldrb	r3, [r7, #2]
 80168da:	f003 0303 	and.w	r3, r3, #3
 80168de:	b2db      	uxtb	r3, r3
 80168e0:	77fb      	strb	r3, [r7, #31]

                rcode = HandleSCSIError(Transaction(&cbw, 0, NULL, 0));
 80168e2:	f107 030c 	add.w	r3, r7, #12
 80168e6:	f04f 0200 	mov.w	r2, #0
 80168ea:	9200      	str	r2, [sp, #0]
 80168ec:	6878      	ldr	r0, [r7, #4]
 80168ee:	4619      	mov	r1, r3
 80168f0:	f04f 0200 	mov.w	r2, #0
 80168f4:	f04f 0300 	mov.w	r3, #0
 80168f8:	f001 fe5c 	bl	80185b4 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh>
 80168fc:	4603      	mov	r3, r0
 80168fe:	6878      	ldr	r0, [r7, #4]
 8016900:	4619      	mov	r1, r3
 8016902:	f002 f8c3 	bl	8018a8c <_ZN8BulkOnly15HandleSCSIErrorEh>
 8016906:	4603      	mov	r3, r0
 8016908:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        }
        return rcode;
 801690c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016910:	e001      	b.n	8016916 <_ZN8BulkOnly8MediaCTLEhh+0x116>
 8016912:	f006 f8b5 	bl	801ca80 <__cxa_end_cleanup>
}
 8016916:	4618      	mov	r0, r3
 8016918:	f107 0730 	add.w	r7, r7, #48	; 0x30
 801691c:	46bd      	mov	sp, r7
 801691e:	bd80      	pop	{r7, pc}

08016920 <_ZN8BulkOnly4ReadEhmthPh>:
 * @param bsize size of a block (we should probably use the cached size)
 * @param blocks how many blocks to read
 * @param buf memory that is able to hold the requested data
 * @return 0 on success
 */
uint8_t BulkOnly::Read(uint8_t lun, uint32_t addr, uint16_t bsize, uint8_t blocks, uint8_t *buf) {
 8016920:	b580      	push	{r7, lr}
 8016922:	b090      	sub	sp, #64	; 0x40
 8016924:	af02      	add	r7, sp, #8
 8016926:	60f8      	str	r0, [r7, #12]
 8016928:	607a      	str	r2, [r7, #4]
 801692a:	460a      	mov	r2, r1
 801692c:	72fa      	strb	r2, [r7, #11]
 801692e:	813b      	strh	r3, [r7, #8]
        if (!LUNOk[lun]) return MASS_ERR_NO_MEDIA;
 8016930:	7afb      	ldrb	r3, [r7, #11]
 8016932:	68fa      	ldr	r2, [r7, #12]
 8016934:	18d3      	adds	r3, r2, r3
 8016936:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 801693a:	f083 0301 	eor.w	r3, r3, #1
 801693e:	b2db      	uxtb	r3, r3
 8016940:	2b00      	cmp	r3, #0
 8016942:	d002      	beq.n	801694a <_ZN8BulkOnly4ReadEhmthPh+0x2a>
 8016944:	f04f 0308 	mov.w	r3, #8
 8016948:	e0e9      	b.n	8016b1e <_ZN8BulkOnly4ReadEhmthPh+0x1fe>
        Notify(PSTR("\r\nRead LUN:\t"), 0x80);
 801694a:	f64e 1014 	movw	r0, #59668	; 0xe914
 801694e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8016952:	f04f 0180 	mov.w	r1, #128	; 0x80
 8016956:	f002 fd2d 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint8_t > (lun, 0x90);
 801695a:	7afb      	ldrb	r3, [r7, #11]
 801695c:	4618      	mov	r0, r3
 801695e:	f04f 0190 	mov.w	r1, #144	; 0x90
 8016962:	f7ff fa91 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
        //xprintf("LUN=%i LBA=%8.8X BLOCKS=%i SIZE=%i\r\n", lun, addr, blocks, bsize);
        Notify(PSTR("\r\nLBA:\t\t"), 0x90);
 8016966:	f64e 1024 	movw	r0, #59684	; 0xe924
 801696a:	f6c0 0001 	movt	r0, #2049	; 0x801
 801696e:	f04f 0190 	mov.w	r1, #144	; 0x90
 8016972:	f002 fd1f 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint32_t > (addr, 0x90);
 8016976:	6878      	ldr	r0, [r7, #4]
 8016978:	f04f 0190 	mov.w	r1, #144	; 0x90
 801697c:	f002 fa06 	bl	8018d8c <_Z10D_PrintHexImEvT_i>
        Notify(PSTR("\r\nblocks:\t\t"), 0x90);
 8016980:	f64e 1030 	movw	r0, #59696	; 0xe930
 8016984:	f6c0 0001 	movt	r0, #2049	; 0x801
 8016988:	f04f 0190 	mov.w	r1, #144	; 0x90
 801698c:	f002 fd12 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint8_t > (blocks, 0x90);
 8016990:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 8016994:	4618      	mov	r0, r3
 8016996:	f04f 0190 	mov.w	r1, #144	; 0x90
 801699a:	f7ff fa75 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
        Notify(PSTR("\r\nblock size:\t"), 0x90);
 801699e:	f64e 103c 	movw	r0, #59708	; 0xe93c
 80169a2:	f6c0 0001 	movt	r0, #2049	; 0x801
 80169a6:	f04f 0190 	mov.w	r1, #144	; 0x90
 80169aa:	f002 fd03 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint16_t > (bsize, 0x90);
 80169ae:	893b      	ldrh	r3, [r7, #8]
 80169b0:	4618      	mov	r0, r3
 80169b2:	f04f 0190 	mov.w	r1, #144	; 0x90
 80169b6:	f002 f9f7 	bl	8018da8 <_Z10D_PrintHexItEvT_i>
        Notify(PSTR("\r\n---------\r\n"), 0x80);
 80169ba:	f64e 104c 	movw	r0, #59724	; 0xe94c
 80169be:	f6c0 0001 	movt	r0, #2049	; 0x801
 80169c2:	f04f 0180 	mov.w	r1, #128	; 0x80
 80169c6:	f002 fcf5 	bl	80193b4 <_Z8E_NotifyPKci>
 80169ca:	e000      	b.n	80169ce <_ZN8BulkOnly4ReadEhmthPh+0xae>
        SetCurLUN(lun);
        uint8_t er = HandleSCSIError(Transaction(&cbw, bsize, buf, 0));
        if (er == MASS_ERR_STALL) {
                MediaCTL(lun, 1);
                delay_ms(150);
                if (!TestUnitReady(lun)) goto again;
 80169cc:	bf00      	nop
        D_PrintHex<uint16_t > (bsize, 0x90);
        Notify(PSTR("\r\n---------\r\n"), 0x80);
        CommandBlockWrapper cbw;

again:
        cbw.dCBWSignature = MASS_CBW_SIGNATURE;
 80169ce:	f245 3355 	movw	r3, #21333	; 0x5355
 80169d2:	f2c4 3342 	movt	r3, #17218	; 0x4342
 80169d6:	617b      	str	r3, [r7, #20]
        cbw.dCBWDataTransferLength = ((uint32_t)bsize * blocks);
 80169d8:	893b      	ldrh	r3, [r7, #8]
 80169da:	f897 2040 	ldrb.w	r2, [r7, #64]	; 0x40
 80169de:	fb02 f303 	mul.w	r3, r2, r3
 80169e2:	61fb      	str	r3, [r7, #28]
        cbw.bmCBWFlags = MASS_CMD_DIR_IN;
 80169e4:	f04f 0380 	mov.w	r3, #128	; 0x80
 80169e8:	f887 3020 	strb.w	r3, [r7, #32]
        cbw.bmCBWLUN = lun;
 80169ec:	7afb      	ldrb	r3, [r7, #11]
 80169ee:	f003 030f 	and.w	r3, r3, #15
 80169f2:	b2da      	uxtb	r2, r3
 80169f4:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80169f8:	f362 0303 	bfi	r3, r2, #0, #4
 80169fc:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
        cbw.bmCBWCBLength = 10;
 8016a00:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8016a04:	f04f 020a 	mov.w	r2, #10
 8016a08:	f362 0303 	bfi	r3, r2, #0, #4
 8016a0c:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22

        for (uint8_t i = 0; i < 16; i++)
 8016a10:	f04f 0300 	mov.w	r3, #0
 8016a14:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8016a18:	e00e      	b.n	8016a38 <_ZN8BulkOnly4ReadEhmthPh+0x118>
                cbw.CBWCB[i] = 0;
 8016a1a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8016a1e:	f107 0238 	add.w	r2, r7, #56	; 0x38
 8016a22:	18d3      	adds	r3, r2, r3
 8016a24:	f04f 0200 	mov.w	r2, #0
 8016a28:	f803 2c15 	strb.w	r2, [r3, #-21]
        cbw.dCBWDataTransferLength = ((uint32_t)bsize * blocks);
        cbw.bmCBWFlags = MASS_CMD_DIR_IN;
        cbw.bmCBWLUN = lun;
        cbw.bmCBWCBLength = 10;

        for (uint8_t i = 0; i < 16; i++)
 8016a2c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8016a30:	f103 0301 	add.w	r3, r3, #1
 8016a34:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8016a38:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8016a3c:	2b0f      	cmp	r3, #15
 8016a3e:	bf8c      	ite	hi
 8016a40:	2300      	movhi	r3, #0
 8016a42:	2301      	movls	r3, #1
 8016a44:	b2db      	uxtb	r3, r3
 8016a46:	2b00      	cmp	r3, #0
 8016a48:	d1e7      	bne.n	8016a1a <_ZN8BulkOnly4ReadEhmthPh+0xfa>
                cbw.CBWCB[i] = 0;

        cbw.CBWCB[0] = SCSI_CMD_READ_10;
 8016a4a:	f04f 0328 	mov.w	r3, #40	; 0x28
 8016a4e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        cbw.CBWCB[1] = lun << 5;
 8016a52:	7afb      	ldrb	r3, [r7, #11]
 8016a54:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8016a58:	b2db      	uxtb	r3, r3
 8016a5a:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
        cbw.CBWCB[2] = ((addr >> 24) & 0xff);
 8016a5e:	687b      	ldr	r3, [r7, #4]
 8016a60:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8016a64:	b2db      	uxtb	r3, r3
 8016a66:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
        cbw.CBWCB[3] = ((addr >> 16) & 0xff);
 8016a6a:	687b      	ldr	r3, [r7, #4]
 8016a6c:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8016a70:	b2db      	uxtb	r3, r3
 8016a72:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
        cbw.CBWCB[4] = ((addr >> 8) & 0xff);
 8016a76:	687b      	ldr	r3, [r7, #4]
 8016a78:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8016a7c:	b2db      	uxtb	r3, r3
 8016a7e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        cbw.CBWCB[5] = (addr & 0xff);
 8016a82:	687b      	ldr	r3, [r7, #4]
 8016a84:	b2db      	uxtb	r3, r3
 8016a86:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
        cbw.CBWCB[8] = blocks;
 8016a8a:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 8016a8e:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        cbw.dCBWTag = ++dCBWTag;
 8016a92:	68fb      	ldr	r3, [r7, #12]
 8016a94:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016a96:	f103 0201 	add.w	r2, r3, #1
 8016a9a:	68fb      	ldr	r3, [r7, #12]
 8016a9c:	625a      	str	r2, [r3, #36]	; 0x24
 8016a9e:	68fb      	ldr	r3, [r7, #12]
 8016aa0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016aa2:	61bb      	str	r3, [r7, #24]
        SetCurLUN(lun);
 8016aa4:	7afb      	ldrb	r3, [r7, #11]
 8016aa6:	68f8      	ldr	r0, [r7, #12]
 8016aa8:	4619      	mov	r1, r3
 8016aaa:	f001 ffd3 	bl	8018a54 <_ZN8BulkOnly9SetCurLUNEh>
        uint8_t er = HandleSCSIError(Transaction(&cbw, bsize, buf, 0));
 8016aae:	f107 0214 	add.w	r2, r7, #20
 8016ab2:	893b      	ldrh	r3, [r7, #8]
 8016ab4:	f04f 0100 	mov.w	r1, #0
 8016ab8:	9100      	str	r1, [sp, #0]
 8016aba:	68f8      	ldr	r0, [r7, #12]
 8016abc:	4611      	mov	r1, r2
 8016abe:	461a      	mov	r2, r3
 8016ac0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016ac2:	f001 fd77 	bl	80185b4 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh>
 8016ac6:	4603      	mov	r3, r0
 8016ac8:	68f8      	ldr	r0, [r7, #12]
 8016aca:	4619      	mov	r1, r3
 8016acc:	f001 ffde 	bl	8018a8c <_ZN8BulkOnly15HandleSCSIErrorEh>
 8016ad0:	4603      	mov	r3, r0
 8016ad2:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
        if (er == MASS_ERR_STALL) {
 8016ad6:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8016ada:	2b05      	cmp	r3, #5
 8016adc:	d11d      	bne.n	8016b1a <_ZN8BulkOnly4ReadEhmthPh+0x1fa>
                MediaCTL(lun, 1);
 8016ade:	7afb      	ldrb	r3, [r7, #11]
 8016ae0:	68f8      	ldr	r0, [r7, #12]
 8016ae2:	4619      	mov	r1, r3
 8016ae4:	f04f 0201 	mov.w	r2, #1
 8016ae8:	f7ff fe8a 	bl	8016800 <_ZN8BulkOnly8MediaCTLEhh>
                delay_ms(150);
 8016aec:	f243 630c 	movw	r3, #13836	; 0x360c
 8016af0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016af4:	681b      	ldr	r3, [r3, #0]
 8016af6:	685b      	ldr	r3, [r3, #4]
 8016af8:	f04f 0096 	mov.w	r0, #150	; 0x96
 8016afc:	4798      	blx	r3
                if (!TestUnitReady(lun)) goto again;
 8016afe:	7afb      	ldrb	r3, [r7, #11]
 8016b00:	68f8      	ldr	r0, [r7, #12]
 8016b02:	4619      	mov	r1, r3
 8016b04:	f001 f962 	bl	8017dcc <_ZN8BulkOnly13TestUnitReadyEh>
 8016b08:	4603      	mov	r3, r0
 8016b0a:	2b00      	cmp	r3, #0
 8016b0c:	bf14      	ite	ne
 8016b0e:	2300      	movne	r3, #0
 8016b10:	2301      	moveq	r3, #1
 8016b12:	b2db      	uxtb	r3, r3
 8016b14:	2b00      	cmp	r3, #0
 8016b16:	f47f af59 	bne.w	80169cc <_ZN8BulkOnly4ReadEhmthPh+0xac>
        }
        return er;
 8016b1a:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8016b1e:	e001      	b.n	8016b24 <_ZN8BulkOnly4ReadEhmthPh+0x204>
 8016b20:	f005 ffae 	bl	801ca80 <__cxa_end_cleanup>
}
 8016b24:	4618      	mov	r0, r3
 8016b26:	f107 0738 	add.w	r7, r7, #56	; 0x38
 8016b2a:	46bd      	mov	sp, r7
 8016b2c:	bd80      	pop	{r7, pc}
 8016b2e:	bf00      	nop

08016b30 <_ZN8BulkOnly5WriteEhmthPh>:
 * @param bsize size of a block (we should probably use the cached size)
 * @param blocks how many blocks to write
 * @param buf memory that contains the data to write
 * @return 0 on success
 */
uint8_t BulkOnly::Write(uint8_t lun, uint32_t addr, uint16_t bsize, uint8_t blocks, uint8_t * buf) {
 8016b30:	b580      	push	{r7, lr}
 8016b32:	b090      	sub	sp, #64	; 0x40
 8016b34:	af02      	add	r7, sp, #8
 8016b36:	60f8      	str	r0, [r7, #12]
 8016b38:	607a      	str	r2, [r7, #4]
 8016b3a:	460a      	mov	r2, r1
 8016b3c:	72fa      	strb	r2, [r7, #11]
 8016b3e:	813b      	strh	r3, [r7, #8]
        if (!LUNOk[lun]) return MASS_ERR_NO_MEDIA;
 8016b40:	7afb      	ldrb	r3, [r7, #11]
 8016b42:	68fa      	ldr	r2, [r7, #12]
 8016b44:	18d3      	adds	r3, r2, r3
 8016b46:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8016b4a:	f083 0301 	eor.w	r3, r3, #1
 8016b4e:	b2db      	uxtb	r3, r3
 8016b50:	2b00      	cmp	r3, #0
 8016b52:	d002      	beq.n	8016b5a <_ZN8BulkOnly5WriteEhmthPh+0x2a>
 8016b54:	f04f 0308 	mov.w	r3, #8
 8016b58:	e0f6      	b.n	8016d48 <_ZN8BulkOnly5WriteEhmthPh+0x218>
        if (!WriteOk[lun]) return MASS_ERR_WRITE_PROTECTED;
 8016b5a:	7afb      	ldrb	r3, [r7, #11]
 8016b5c:	68fa      	ldr	r2, [r7, #12]
 8016b5e:	18d3      	adds	r3, r2, r3
 8016b60:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
 8016b64:	f083 0301 	eor.w	r3, r3, #1
 8016b68:	b2db      	uxtb	r3, r3
 8016b6a:	2b00      	cmp	r3, #0
 8016b6c:	d002      	beq.n	8016b74 <_ZN8BulkOnly5WriteEhmthPh+0x44>
 8016b6e:	f04f 0317 	mov.w	r3, #23
 8016b72:	e0e9      	b.n	8016d48 <_ZN8BulkOnly5WriteEhmthPh+0x218>
        Notify(PSTR("\r\nWrite LUN:\t"), 0x80);
 8016b74:	f64e 105c 	movw	r0, #59740	; 0xe95c
 8016b78:	f6c0 0001 	movt	r0, #2049	; 0x801
 8016b7c:	f04f 0180 	mov.w	r1, #128	; 0x80
 8016b80:	f002 fc18 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint8_t > (lun, 0x90);
 8016b84:	7afb      	ldrb	r3, [r7, #11]
 8016b86:	4618      	mov	r0, r3
 8016b88:	f04f 0190 	mov.w	r1, #144	; 0x90
 8016b8c:	f7ff f97c 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
        //xprintf("LUN=%i LBA=%8.8X BLOCKS=%i SIZE=%i\r\n", lun, addr, blocks, bsize);
        Notify(PSTR("\r\nLBA:\t\t"), 0x90);
 8016b90:	f64e 1024 	movw	r0, #59684	; 0xe924
 8016b94:	f6c0 0001 	movt	r0, #2049	; 0x801
 8016b98:	f04f 0190 	mov.w	r1, #144	; 0x90
 8016b9c:	f002 fc0a 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint32_t > (addr, 0x90);
 8016ba0:	6878      	ldr	r0, [r7, #4]
 8016ba2:	f04f 0190 	mov.w	r1, #144	; 0x90
 8016ba6:	f002 f8f1 	bl	8018d8c <_Z10D_PrintHexImEvT_i>
        Notify(PSTR("\r\nblocks:\t\t"), 0x90);
 8016baa:	f64e 1030 	movw	r0, #59696	; 0xe930
 8016bae:	f6c0 0001 	movt	r0, #2049	; 0x801
 8016bb2:	f04f 0190 	mov.w	r1, #144	; 0x90
 8016bb6:	f002 fbfd 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint8_t > (blocks, 0x90);
 8016bba:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 8016bbe:	4618      	mov	r0, r3
 8016bc0:	f04f 0190 	mov.w	r1, #144	; 0x90
 8016bc4:	f7ff f960 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
        Notify(PSTR("\r\nblock size:\t"), 0x90);
 8016bc8:	f64e 103c 	movw	r0, #59708	; 0xe93c
 8016bcc:	f6c0 0001 	movt	r0, #2049	; 0x801
 8016bd0:	f04f 0190 	mov.w	r1, #144	; 0x90
 8016bd4:	f002 fbee 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint16_t > (bsize, 0x90);
 8016bd8:	893b      	ldrh	r3, [r7, #8]
 8016bda:	4618      	mov	r0, r3
 8016bdc:	f04f 0190 	mov.w	r1, #144	; 0x90
 8016be0:	f002 f8e2 	bl	8018da8 <_Z10D_PrintHexItEvT_i>
        Notify(PSTR("\r\n---------\r\n"), 0x80);
 8016be4:	f64e 104c 	movw	r0, #59724	; 0xe94c
 8016be8:	f6c0 0001 	movt	r0, #2049	; 0x801
 8016bec:	f04f 0180 	mov.w	r1, #128	; 0x80
 8016bf0:	f002 fbe0 	bl	80193b4 <_Z8E_NotifyPKci>
 8016bf4:	e000      	b.n	8016bf8 <_ZN8BulkOnly5WriteEhmthPh+0xc8>
        SetCurLUN(lun);
        uint8_t er = HandleSCSIError(Transaction(&cbw, bsize, (void*)buf, 0));
        if (er == MASS_ERR_WRITE_STALL) {
                MediaCTL(lun, 1);
                delay_ms(150);
                if (!TestUnitReady(lun)) goto again;
 8016bf6:	bf00      	nop
        Notify(PSTR("\r\n---------\r\n"), 0x80);
        //MediaCTL(lun, 0x01);
        CommandBlockWrapper cbw;

again:
        cbw.dCBWSignature = MASS_CBW_SIGNATURE;
 8016bf8:	f245 3355 	movw	r3, #21333	; 0x5355
 8016bfc:	f2c4 3342 	movt	r3, #17218	; 0x4342
 8016c00:	617b      	str	r3, [r7, #20]
        cbw.dCBWTag = ++dCBWTag;
 8016c02:	68fb      	ldr	r3, [r7, #12]
 8016c04:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016c06:	f103 0201 	add.w	r2, r3, #1
 8016c0a:	68fb      	ldr	r3, [r7, #12]
 8016c0c:	625a      	str	r2, [r3, #36]	; 0x24
 8016c0e:	68fb      	ldr	r3, [r7, #12]
 8016c10:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016c12:	61bb      	str	r3, [r7, #24]
        cbw.dCBWDataTransferLength = ((uint32_t)bsize * blocks);
 8016c14:	893b      	ldrh	r3, [r7, #8]
 8016c16:	f897 2040 	ldrb.w	r2, [r7, #64]	; 0x40
 8016c1a:	fb02 f303 	mul.w	r3, r2, r3
 8016c1e:	61fb      	str	r3, [r7, #28]
        cbw.bmCBWFlags = MASS_CMD_DIR_OUT;
 8016c20:	f04f 0300 	mov.w	r3, #0
 8016c24:	f887 3020 	strb.w	r3, [r7, #32]
        cbw.bmCBWLUN = lun;
 8016c28:	7afb      	ldrb	r3, [r7, #11]
 8016c2a:	f003 030f 	and.w	r3, r3, #15
 8016c2e:	b2da      	uxtb	r2, r3
 8016c30:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8016c34:	f362 0303 	bfi	r3, r2, #0, #4
 8016c38:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
        cbw.bmCBWCBLength = 10;
 8016c3c:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8016c40:	f04f 020a 	mov.w	r2, #10
 8016c44:	f362 0303 	bfi	r3, r2, #0, #4
 8016c48:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22

        for (uint8_t i = 0; i < 16; i++)
 8016c4c:	f04f 0300 	mov.w	r3, #0
 8016c50:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8016c54:	e00e      	b.n	8016c74 <_ZN8BulkOnly5WriteEhmthPh+0x144>
                cbw.CBWCB[i] = 0;
 8016c56:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8016c5a:	f107 0238 	add.w	r2, r7, #56	; 0x38
 8016c5e:	18d3      	adds	r3, r2, r3
 8016c60:	f04f 0200 	mov.w	r2, #0
 8016c64:	f803 2c15 	strb.w	r2, [r3, #-21]
        cbw.dCBWDataTransferLength = ((uint32_t)bsize * blocks);
        cbw.bmCBWFlags = MASS_CMD_DIR_OUT;
        cbw.bmCBWLUN = lun;
        cbw.bmCBWCBLength = 10;

        for (uint8_t i = 0; i < 16; i++)
 8016c68:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8016c6c:	f103 0301 	add.w	r3, r3, #1
 8016c70:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8016c74:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8016c78:	2b0f      	cmp	r3, #15
 8016c7a:	bf8c      	ite	hi
 8016c7c:	2300      	movhi	r3, #0
 8016c7e:	2301      	movls	r3, #1
 8016c80:	b2db      	uxtb	r3, r3
 8016c82:	2b00      	cmp	r3, #0
 8016c84:	d1e7      	bne.n	8016c56 <_ZN8BulkOnly5WriteEhmthPh+0x126>
                cbw.CBWCB[i] = 0;

        cbw.CBWCB[0] = SCSI_CMD_WRITE_10;
 8016c86:	f04f 032a 	mov.w	r3, #42	; 0x2a
 8016c8a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        cbw.CBWCB[1] = lun << 5;
 8016c8e:	7afb      	ldrb	r3, [r7, #11]
 8016c90:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8016c94:	b2db      	uxtb	r3, r3
 8016c96:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
        cbw.CBWCB[2] = ((addr >> 24) & 0xff);
 8016c9a:	687b      	ldr	r3, [r7, #4]
 8016c9c:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8016ca0:	b2db      	uxtb	r3, r3
 8016ca2:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
        cbw.CBWCB[3] = ((addr >> 16) & 0xff);
 8016ca6:	687b      	ldr	r3, [r7, #4]
 8016ca8:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8016cac:	b2db      	uxtb	r3, r3
 8016cae:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
        cbw.CBWCB[4] = ((addr >> 8) & 0xff);
 8016cb2:	687b      	ldr	r3, [r7, #4]
 8016cb4:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8016cb8:	b2db      	uxtb	r3, r3
 8016cba:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        cbw.CBWCB[5] = (addr & 0xff);
 8016cbe:	687b      	ldr	r3, [r7, #4]
 8016cc0:	b2db      	uxtb	r3, r3
 8016cc2:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
        cbw.CBWCB[8] = 1;
 8016cc6:	f04f 0301 	mov.w	r3, #1
 8016cca:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        *(buf+256) = (uint8_t)dCBWTag;
        *(buf+320) = (uint8_t)dCBWTag;
        *(buf+384) = (uint8_t)dCBWTag;
        *(buf+448) = (uint8_t)dCBWTag;
#endif
        SetCurLUN(lun);
 8016cce:	7afb      	ldrb	r3, [r7, #11]
 8016cd0:	68f8      	ldr	r0, [r7, #12]
 8016cd2:	4619      	mov	r1, r3
 8016cd4:	f001 febe 	bl	8018a54 <_ZN8BulkOnly9SetCurLUNEh>
        uint8_t er = HandleSCSIError(Transaction(&cbw, bsize, (void*)buf, 0));
 8016cd8:	f107 0214 	add.w	r2, r7, #20
 8016cdc:	893b      	ldrh	r3, [r7, #8]
 8016cde:	f04f 0100 	mov.w	r1, #0
 8016ce2:	9100      	str	r1, [sp, #0]
 8016ce4:	68f8      	ldr	r0, [r7, #12]
 8016ce6:	4611      	mov	r1, r2
 8016ce8:	461a      	mov	r2, r3
 8016cea:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016cec:	f001 fc62 	bl	80185b4 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh>
 8016cf0:	4603      	mov	r3, r0
 8016cf2:	68f8      	ldr	r0, [r7, #12]
 8016cf4:	4619      	mov	r1, r3
 8016cf6:	f001 fec9 	bl	8018a8c <_ZN8BulkOnly15HandleSCSIErrorEh>
 8016cfa:	4603      	mov	r3, r0
 8016cfc:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
        if (er == MASS_ERR_WRITE_STALL) {
 8016d00:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8016d04:	2b14      	cmp	r3, #20
 8016d06:	d11d      	bne.n	8016d44 <_ZN8BulkOnly5WriteEhmthPh+0x214>
                MediaCTL(lun, 1);
 8016d08:	7afb      	ldrb	r3, [r7, #11]
 8016d0a:	68f8      	ldr	r0, [r7, #12]
 8016d0c:	4619      	mov	r1, r3
 8016d0e:	f04f 0201 	mov.w	r2, #1
 8016d12:	f7ff fd75 	bl	8016800 <_ZN8BulkOnly8MediaCTLEhh>
                delay_ms(150);
 8016d16:	f243 630c 	movw	r3, #13836	; 0x360c
 8016d1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016d1e:	681b      	ldr	r3, [r3, #0]
 8016d20:	685b      	ldr	r3, [r3, #4]
 8016d22:	f04f 0096 	mov.w	r0, #150	; 0x96
 8016d26:	4798      	blx	r3
                if (!TestUnitReady(lun)) goto again;
 8016d28:	7afb      	ldrb	r3, [r7, #11]
 8016d2a:	68f8      	ldr	r0, [r7, #12]
 8016d2c:	4619      	mov	r1, r3
 8016d2e:	f001 f84d 	bl	8017dcc <_ZN8BulkOnly13TestUnitReadyEh>
 8016d32:	4603      	mov	r3, r0
 8016d34:	2b00      	cmp	r3, #0
 8016d36:	bf14      	ite	ne
 8016d38:	2300      	movne	r3, #0
 8016d3a:	2301      	moveq	r3, #1
 8016d3c:	b2db      	uxtb	r3, r3
 8016d3e:	2b00      	cmp	r3, #0
 8016d40:	f47f af59 	bne.w	8016bf6 <_ZN8BulkOnly5WriteEhmthPh+0xc6>
        }
        return er;
 8016d44:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8016d48:	e001      	b.n	8016d4e <_ZN8BulkOnly5WriteEhmthPh+0x21e>
 8016d4a:	f005 fe99 	bl	801ca80 <__cxa_end_cleanup>
}
 8016d4e:	4618      	mov	r0, r3
 8016d50:	f107 0738 	add.w	r7, r7, #56	; 0x38
 8016d54:	46bd      	mov	sp, r7
 8016d56:	bd80      	pop	{r7, pc}

08016d58 <_ZN15USBDeviceConfigC1Ev>:
#define USB_STATE_ADDRESSING                                0x70
#define USB_STATE_CONFIGURING                               0x80
#define USB_STATE_RUNNING                                   0x90
#define USB_STATE_ERROR                                     0xa0

class USBDeviceConfig {
 8016d58:	b480      	push	{r7}
 8016d5a:	b083      	sub	sp, #12
 8016d5c:	af00      	add	r7, sp, #0
 8016d5e:	6078      	str	r0, [r7, #4]
 8016d60:	687b      	ldr	r3, [r7, #4]
 8016d62:	4a04      	ldr	r2, [pc, #16]	; (8016d74 <_ZN15USBDeviceConfigC1Ev+0x1c>)
 8016d64:	601a      	str	r2, [r3, #0]
 8016d66:	687b      	ldr	r3, [r7, #4]
 8016d68:	4618      	mov	r0, r3
 8016d6a:	f107 070c 	add.w	r7, r7, #12
 8016d6e:	46bd      	mov	sp, r7
 8016d70:	bc80      	pop	{r7}
 8016d72:	4770      	bx	lr
 8016d74:	080205a8 	.word	0x080205a8

08016d78 <_ZN17UsbConfigXtracterC1Ev>:
#include "message.h"
#include "parsetools.h"

//#include "hid.h"

class UsbConfigXtracter {
 8016d78:	b480      	push	{r7}
 8016d7a:	b083      	sub	sp, #12
 8016d7c:	af00      	add	r7, sp, #0
 8016d7e:	6078      	str	r0, [r7, #4]
 8016d80:	687b      	ldr	r3, [r7, #4]
 8016d82:	4a04      	ldr	r2, [pc, #16]	; (8016d94 <_ZN17UsbConfigXtracterC1Ev+0x1c>)
 8016d84:	601a      	str	r2, [r3, #0]
 8016d86:	687b      	ldr	r3, [r7, #4]
 8016d88:	4618      	mov	r0, r3
 8016d8a:	f107 070c 	add.w	r7, r7, #12
 8016d8e:	46bd      	mov	sp, r7
 8016d90:	bc80      	pop	{r7}
 8016d92:	4770      	bx	lr
 8016d94:	08020588 	.word	0x08020588

08016d98 <_ZN8BulkOnlyC1EP3USB>:

// Main driver code

////////////////////////////////////////////////////////////////////////////////

BulkOnly::BulkOnly(USB *p) :
 8016d98:	b580      	push	{r7, lr}
 8016d9a:	b082      	sub	sp, #8
 8016d9c:	af00      	add	r7, sp, #0
 8016d9e:	6078      	str	r0, [r7, #4]
 8016da0:	6039      	str	r1, [r7, #0]
bIface(0),
bNumEP(1),
qNextPollTime(0),
bPollEnable(false),
dCBWTag(0),
bLastUsbError(0) {
 8016da2:	687b      	ldr	r3, [r7, #4]
 8016da4:	4618      	mov	r0, r3
 8016da6:	f7ff ffd7 	bl	8016d58 <_ZN15USBDeviceConfigC1Ev>
 8016daa:	687b      	ldr	r3, [r7, #4]
 8016dac:	f103 0304 	add.w	r3, r3, #4
 8016db0:	4618      	mov	r0, r3
 8016db2:	f7ff ffe1 	bl	8016d78 <_ZN17UsbConfigXtracterC1Ev>
 8016db6:	687b      	ldr	r3, [r7, #4]
 8016db8:	4a1e      	ldr	r2, [pc, #120]	; (8016e34 <_ZN8BulkOnlyC1EP3USB+0x9c>)
 8016dba:	601a      	str	r2, [r3, #0]
 8016dbc:	687b      	ldr	r3, [r7, #4]
 8016dbe:	4a1e      	ldr	r2, [pc, #120]	; (8016e38 <_ZN8BulkOnlyC1EP3USB+0xa0>)
 8016dc0:	605a      	str	r2, [r3, #4]
 8016dc2:	687b      	ldr	r3, [r7, #4]
 8016dc4:	683a      	ldr	r2, [r7, #0]
 8016dc6:	609a      	str	r2, [r3, #8]
 8016dc8:	687b      	ldr	r3, [r7, #4]
 8016dca:	f04f 0200 	mov.w	r2, #0
 8016dce:	731a      	strb	r2, [r3, #12]
 8016dd0:	687b      	ldr	r3, [r7, #4]
 8016dd2:	f04f 0200 	mov.w	r2, #0
 8016dd6:	739a      	strb	r2, [r3, #14]
 8016dd8:	687b      	ldr	r3, [r7, #4]
 8016dda:	f04f 0201 	mov.w	r2, #1
 8016dde:	73da      	strb	r2, [r3, #15]
 8016de0:	687b      	ldr	r3, [r7, #4]
 8016de2:	f04f 0200 	mov.w	r2, #0
 8016de6:	611a      	str	r2, [r3, #16]
 8016de8:	687b      	ldr	r3, [r7, #4]
 8016dea:	f04f 0200 	mov.w	r2, #0
 8016dee:	751a      	strb	r2, [r3, #20]
 8016df0:	687b      	ldr	r3, [r7, #4]
 8016df2:	f04f 0200 	mov.w	r2, #0
 8016df6:	625a      	str	r2, [r3, #36]	; 0x24
 8016df8:	687b      	ldr	r3, [r7, #4]
 8016dfa:	f04f 0200 	mov.w	r2, #0
 8016dfe:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
	ClearAllEP();
 8016e02:	6878      	ldr	r0, [r7, #4]
 8016e04:	f001 fa3c 	bl	8018280 <_ZN8BulkOnly10ClearAllEPEv>
	dCBWTag = 0;
 8016e08:	687b      	ldr	r3, [r7, #4]
 8016e0a:	f04f 0200 	mov.w	r2, #0
 8016e0e:	625a      	str	r2, [r3, #36]	; 0x24
	if (pUsb)
 8016e10:	687b      	ldr	r3, [r7, #4]
 8016e12:	689b      	ldr	r3, [r3, #8]
 8016e14:	2b00      	cmp	r3, #0
 8016e16:	d006      	beq.n	8016e26 <_ZN8BulkOnlyC1EP3USB+0x8e>
		pUsb->RegisterDeviceClass(this);
 8016e18:	687b      	ldr	r3, [r7, #4]
 8016e1a:	689a      	ldr	r2, [r3, #8]
 8016e1c:	687b      	ldr	r3, [r7, #4]
 8016e1e:	4610      	mov	r0, r2
 8016e20:	4619      	mov	r1, r3
 8016e22:	f7ff fb09 	bl	8016438 <_ZN3USB19RegisterDeviceClassEP15USBDeviceConfig>
}
 8016e26:	687b      	ldr	r3, [r7, #4]
 8016e28:	4618      	mov	r0, r3
 8016e2a:	f107 0708 	add.w	r7, r7, #8
 8016e2e:	46bd      	mov	sp, r7
 8016e30:	bd80      	pop	{r7, pc}
 8016e32:	bf00      	nop
 8016e34:	08020548 	.word	0x08020548
 8016e38:	08020578 	.word	0x08020578

08016e3c <_ZN8BulkOnly15ConfigureDeviceEhhb>:
 * @param parent USB address of parent
 * @param port address of port on parent
 * @param lowspeed true if device is low speed
 * @return
 */
uint8_t BulkOnly::ConfigureDevice(uint8_t parent, uint8_t port, bool lowspeed) {
 8016e3c:	b590      	push	{r4, r7, lr}
 8016e3e:	b08f      	sub	sp, #60	; 0x3c
 8016e40:	af02      	add	r7, sp, #8
 8016e42:	6078      	str	r0, [r7, #4]
 8016e44:	70f9      	strb	r1, [r7, #3]
 8016e46:	70ba      	strb	r2, [r7, #2]
 8016e48:	707b      	strb	r3, [r7, #1]

	const uint8_t constBufSize = sizeof (USB_DEVICE_DESCRIPTOR);
 8016e4a:	f04f 0312 	mov.w	r3, #18
 8016e4e:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e

	uint8_t buf[constBufSize];
	uint8_t rcode;
	UsbDevice *p = NULL;
 8016e52:	f04f 0300 	mov.w	r3, #0
 8016e56:	62bb      	str	r3, [r7, #40]	; 0x28
	EpInfo *oldep_ptr = NULL;
 8016e58:	f04f 0300 	mov.w	r3, #0
 8016e5c:	627b      	str	r3, [r7, #36]	; 0x24

	USBTRACE("\nMSC ConfigureDevice\r\n");
 8016e5e:	f64e 106c 	movw	r0, #59756	; 0xe96c
 8016e62:	f6c0 0001 	movt	r0, #2049	; 0x801
 8016e66:	f04f 0180 	mov.w	r1, #128	; 0x80
 8016e6a:	f002 faa3 	bl	80193b4 <_Z8E_NotifyPKci>
	ClearAllEP();
 8016e6e:	6878      	ldr	r0, [r7, #4]
 8016e70:	f001 fa06 	bl	8018280 <_ZN8BulkOnly10ClearAllEPEv>
	//delay(2000);
	AddressPool &addrPool = pUsb->GetAddressPool();
 8016e74:	687b      	ldr	r3, [r7, #4]
 8016e76:	689b      	ldr	r3, [r3, #8]
 8016e78:	4618      	mov	r0, r3
 8016e7a:	f7fd facd 	bl	8014418 <_ZN3USB14GetAddressPoolEv>
 8016e7e:	6238      	str	r0, [r7, #32]


	if (bAddress)
 8016e80:	687b      	ldr	r3, [r7, #4]
 8016e82:	7b1b      	ldrb	r3, [r3, #12]
 8016e84:	2b00      	cmp	r3, #0
 8016e86:	d002      	beq.n	8016e8e <_ZN8BulkOnly15ConfigureDeviceEhhb+0x52>
		return USB_ERROR_CLASS_INSTANCE_ALREADY_IN_USE;
 8016e88:	f04f 03d9 	mov.w	r3, #217	; 0xd9
 8016e8c:	e097      	b.n	8016fbe <_ZN8BulkOnly15ConfigureDeviceEhhb+0x182>

	// <TECHNICAL>
	// Get pointer to pseudo device with address 0 assigned
	p = addrPool.GetUsbDevicePtr(0);
 8016e8e:	6a3b      	ldr	r3, [r7, #32]
 8016e90:	681b      	ldr	r3, [r3, #0]
 8016e92:	681b      	ldr	r3, [r3, #0]
 8016e94:	6a38      	ldr	r0, [r7, #32]
 8016e96:	f04f 0100 	mov.w	r1, #0
 8016e9a:	4798      	blx	r3
 8016e9c:	4603      	mov	r3, r0
 8016e9e:	62bb      	str	r3, [r7, #40]	; 0x28
	if (!p) {
 8016ea0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ea2:	2b00      	cmp	r3, #0
 8016ea4:	d102      	bne.n	8016eac <_ZN8BulkOnly15ConfigureDeviceEhhb+0x70>
		return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
 8016ea6:	f04f 03d6 	mov.w	r3, #214	; 0xd6
 8016eaa:	e088      	b.n	8016fbe <_ZN8BulkOnly15ConfigureDeviceEhhb+0x182>
	}

	if (!p->epinfo) {
 8016eac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016eae:	681b      	ldr	r3, [r3, #0]
 8016eb0:	2b00      	cmp	r3, #0
 8016eb2:	d10a      	bne.n	8016eca <_ZN8BulkOnly15ConfigureDeviceEhhb+0x8e>
		USBTRACE("epinfo\r\n");
 8016eb4:	f64e 1084 	movw	r0, #59780	; 0xe984
 8016eb8:	f6c0 0001 	movt	r0, #2049	; 0x801
 8016ebc:	f04f 0180 	mov.w	r1, #128	; 0x80
 8016ec0:	f002 fa78 	bl	80193b4 <_Z8E_NotifyPKci>
		return USB_ERROR_EPINFO_IS_NULL;
 8016ec4:	f04f 03d7 	mov.w	r3, #215	; 0xd7
 8016ec8:	e079      	b.n	8016fbe <_ZN8BulkOnly15ConfigureDeviceEhhb+0x182>
	}

	// Save old pointer to EP_RECORD of address 0
	oldep_ptr = p->epinfo;
 8016eca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ecc:	681b      	ldr	r3, [r3, #0]
 8016ece:	627b      	str	r3, [r7, #36]	; 0x24

	// Temporary assign new pointer to epInfo to p->epinfo in order to avoid toggle inconsistence
	p->epinfo = epInfo;
 8016ed0:	687b      	ldr	r3, [r7, #4]
 8016ed2:	f103 0215 	add.w	r2, r3, #21
 8016ed6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ed8:	601a      	str	r2, [r3, #0]

	// still use mother's host channel
	p->epinfo->hcNumber = oldep_ptr->hcNumber;
 8016eda:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016edc:	681b      	ldr	r3, [r3, #0]
 8016ede:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016ee0:	78d2      	ldrb	r2, [r2, #3]
 8016ee2:	70da      	strb	r2, [r3, #3]

	p->lowspeed = lowspeed;
 8016ee4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ee6:	787a      	ldrb	r2, [r7, #1]
 8016ee8:	719a      	strb	r2, [r3, #6]
	// Get device descriptor
	rcode = pUsb->getDevDescr(0, 0, 8, (uint8_t*)buf);
 8016eea:	687b      	ldr	r3, [r7, #4]
 8016eec:	689b      	ldr	r3, [r3, #8]
 8016eee:	f107 020c 	add.w	r2, r7, #12
 8016ef2:	9200      	str	r2, [sp, #0]
 8016ef4:	4618      	mov	r0, r3
 8016ef6:	f04f 0100 	mov.w	r1, #0
 8016efa:	f04f 0200 	mov.w	r2, #0
 8016efe:	f04f 0308 	mov.w	r3, #8
 8016f02:	f7fe fdf3 	bl	8015aec <_ZN3USB11getDevDescrEhhtPh>
 8016f06:	4603      	mov	r3, r0
 8016f08:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	if(!rcode) {
 8016f0c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016f10:	2b00      	cmp	r3, #0
 8016f12:	d116      	bne.n	8016f42 <_ZN8BulkOnly15ConfigureDeviceEhhb+0x106>
		p->epinfo->maxPktSize = (uint8_t)((USB_DEVICE_DESCRIPTOR*)buf)->bMaxPacketSize0;
 8016f14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f16:	681b      	ldr	r3, [r3, #0]
 8016f18:	f107 020c 	add.w	r2, r7, #12
 8016f1c:	79d2      	ldrb	r2, [r2, #7]
 8016f1e:	705a      	strb	r2, [r3, #1]
		rcode = pUsb->getDevDescr(0, 0, constBufSize, (uint8_t*)buf);
 8016f20:	687b      	ldr	r3, [r7, #4]
 8016f22:	689b      	ldr	r3, [r3, #8]
 8016f24:	f107 020c 	add.w	r2, r7, #12
 8016f28:	9200      	str	r2, [sp, #0]
 8016f2a:	4618      	mov	r0, r3
 8016f2c:	f04f 0100 	mov.w	r1, #0
 8016f30:	f04f 0200 	mov.w	r2, #0
 8016f34:	f04f 0312 	mov.w	r3, #18
 8016f38:	f7fe fdd8 	bl	8015aec <_ZN3USB11getDevDescrEhhtPh>
 8016f3c:	4603      	mov	r3, r0
 8016f3e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	}
	// Restore p->epinfo
	p->epinfo = oldep_ptr;
 8016f42:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f44:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016f46:	601a      	str	r2, [r3, #0]

	if (rcode) {
 8016f48:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016f4c:	2b00      	cmp	r3, #0
 8016f4e:	d123      	bne.n	8016f98 <_ZN8BulkOnly15ConfigureDeviceEhhb+0x15c>
		goto FailGetDevDescr;
	}

	// Allocate new address according to device class
	bAddress = addrPool.AllocAddress(parent, false, port);
 8016f50:	6a3b      	ldr	r3, [r7, #32]
 8016f52:	681b      	ldr	r3, [r3, #0]
 8016f54:	f103 0304 	add.w	r3, r3, #4
 8016f58:	681c      	ldr	r4, [r3, #0]
 8016f5a:	78fa      	ldrb	r2, [r7, #3]
 8016f5c:	78bb      	ldrb	r3, [r7, #2]
 8016f5e:	6a38      	ldr	r0, [r7, #32]
 8016f60:	4611      	mov	r1, r2
 8016f62:	f04f 0200 	mov.w	r2, #0
 8016f66:	47a0      	blx	r4
 8016f68:	4603      	mov	r3, r0
 8016f6a:	461a      	mov	r2, r3
 8016f6c:	687b      	ldr	r3, [r7, #4]
 8016f6e:	731a      	strb	r2, [r3, #12]

	if (!bAddress)
 8016f70:	687b      	ldr	r3, [r7, #4]
 8016f72:	7b1b      	ldrb	r3, [r3, #12]
 8016f74:	2b00      	cmp	r3, #0
 8016f76:	d102      	bne.n	8016f7e <_ZN8BulkOnly15ConfigureDeviceEhhb+0x142>
		return USB_ERROR_OUT_OF_ADDRESS_SPACE_IN_POOL;
 8016f78:	f04f 03d4 	mov.w	r3, #212	; 0xd4
 8016f7c:	e01f      	b.n	8016fbe <_ZN8BulkOnly15ConfigureDeviceEhhb+0x182>

	// Extract Max Packet Size from the device descriptor
	epInfo[0].maxPktSize = (uint8_t)((USB_DEVICE_DESCRIPTOR*)buf)->bMaxPacketSize0;
 8016f7e:	f107 030c 	add.w	r3, r7, #12
 8016f82:	79da      	ldrb	r2, [r3, #7]
 8016f84:	687b      	ldr	r3, [r7, #4]
 8016f86:	759a      	strb	r2, [r3, #22]
	// Steal and abuse from epInfo structure to save on memory.
	epInfo[1].epAddr = ((USB_DEVICE_DESCRIPTOR*)buf)->bNumConfigurations;
 8016f88:	f107 030c 	add.w	r3, r7, #12
 8016f8c:	7c5a      	ldrb	r2, [r3, #17]
 8016f8e:	687b      	ldr	r3, [r7, #4]
 8016f90:	769a      	strb	r2, [r3, #26]
	// </TECHNICAL>
	return USB_ERROR_CONFIG_REQUIRES_ADDITIONAL_RESET;
 8016f92:	f04f 03e0 	mov.w	r3, #224	; 0xe0
 8016f96:	e012      	b.n	8016fbe <_ZN8BulkOnly15ConfigureDeviceEhhb+0x182>
	}
	// Restore p->epinfo
	p->epinfo = oldep_ptr;

	if (rcode) {
		goto FailGetDevDescr;
 8016f98:	bf00      	nop
	// </TECHNICAL>
	return USB_ERROR_CONFIG_REQUIRES_ADDITIONAL_RESET;

FailGetDevDescr:
#ifdef DEBUG_USB_HOST
	NotifyFailGetDevDescr(rcode);
 8016f9a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016f9e:	4618      	mov	r0, r3
 8016fa0:	f002 fb06 	bl	80195b0 <_Z21NotifyFailGetDevDescrh>
#endif
	rcode = USB_ERROR_FailGetDevDescr;
 8016fa4:	f04f 03e1 	mov.w	r3, #225	; 0xe1
 8016fa8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

Fail:
	Release();
 8016fac:	687b      	ldr	r3, [r7, #4]
 8016fae:	681b      	ldr	r3, [r3, #0]
 8016fb0:	f103 0308 	add.w	r3, r3, #8
 8016fb4:	681b      	ldr	r3, [r3, #0]
 8016fb6:	6878      	ldr	r0, [r7, #4]
 8016fb8:	4798      	blx	r3
	return rcode;
 8016fba:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016fbe:	e001      	b.n	8016fc4 <_ZN8BulkOnly15ConfigureDeviceEhhb+0x188>
 8016fc0:	f005 fd5e 	bl	801ca80 <__cxa_end_cleanup>
};
 8016fc4:	4618      	mov	r0, r3
 8016fc6:	f107 0734 	add.w	r7, r7, #52	; 0x34
 8016fca:	46bd      	mov	sp, r7
 8016fcc:	bd90      	pop	{r4, r7, pc}
 8016fce:	bf00      	nop

08016fd0 <_ZN8BulkOnly4InitEhhb>:
 * @param parent (not used)
 * @param port (not used)
 * @param lowspeed true if device is low speed
 * @return 0 for success
 */
uint8_t BulkOnly::Init(uint8_t parent, uint8_t port, bool lowspeed) {
 8016fd0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8016fd2:	b09d      	sub	sp, #116	; 0x74
 8016fd4:	af06      	add	r7, sp, #24
 8016fd6:	6078      	str	r0, [r7, #4]
 8016fd8:	70f9      	strb	r1, [r7, #3]
 8016fda:	70ba      	strb	r2, [r7, #2]
 8016fdc:	707b      	strb	r3, [r7, #1]
        uint8_t rcode;
        uint8_t ep_no;
        uint8_t num_of_conf = epInfo[1].epAddr; // number of configurations
 8016fde:	687b      	ldr	r3, [r7, #4]
 8016fe0:	7e9b      	ldrb	r3, [r3, #26]
 8016fe2:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
        epInfo[1].epAddr = 0;
 8016fe6:	687b      	ldr	r3, [r7, #4]
 8016fe8:	f04f 0200 	mov.w	r2, #0
 8016fec:	769a      	strb	r2, [r3, #26]
        USBTRACE("\nMSC Init");
 8016fee:	f64e 1090 	movw	r0, #59792	; 0xe990
 8016ff2:	f6c0 0001 	movt	r0, #2049	; 0x801
 8016ff6:	f04f 0180 	mov.w	r1, #128	; 0x80
 8016ffa:	f002 f9db 	bl	80193b4 <_Z8E_NotifyPKci>

        AddressPool &addrPool = pUsb->GetAddressPool();
 8016ffe:	687b      	ldr	r3, [r7, #4]
 8017000:	689b      	ldr	r3, [r3, #8]
 8017002:	4618      	mov	r0, r3
 8017004:	f7fd fa08 	bl	8014418 <_ZN3USB14GetAddressPoolEv>
 8017008:	64f8      	str	r0, [r7, #76]	; 0x4c
        UsbDevice *p = addrPool.GetUsbDevicePtr(bAddress);
 801700a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801700c:	681b      	ldr	r3, [r3, #0]
 801700e:	681b      	ldr	r3, [r3, #0]
 8017010:	687a      	ldr	r2, [r7, #4]
 8017012:	7b12      	ldrb	r2, [r2, #12]
 8017014:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8017016:	4611      	mov	r1, r2
 8017018:	4798      	blx	r3
 801701a:	4603      	mov	r3, r0
 801701c:	64bb      	str	r3, [r7, #72]	; 0x48

        if (!p)
 801701e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017020:	2b00      	cmp	r3, #0
 8017022:	d102      	bne.n	801702a <_ZN8BulkOnly4InitEhhb+0x5a>
			return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
 8017024:	f04f 03d6 	mov.w	r3, #214	; 0xd6
 8017028:	e2e9      	b.n	80175fe <_ZN8BulkOnly4InitEhhb+0x62e>

        // Assign new address to the device
        delay_ms(2000);
 801702a:	f243 630c 	movw	r3, #13836	; 0x360c
 801702e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017032:	681b      	ldr	r3, [r3, #0]
 8017034:	685b      	ldr	r3, [r3, #4]
 8017036:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 801703a:	4798      	blx	r3
        rcode = pUsb->setAddr(0, 0, bAddress);
 801703c:	687b      	ldr	r3, [r7, #4]
 801703e:	689a      	ldr	r2, [r3, #8]
 8017040:	687b      	ldr	r3, [r7, #4]
 8017042:	7b1b      	ldrb	r3, [r3, #12]
 8017044:	4610      	mov	r0, r2
 8017046:	f04f 0100 	mov.w	r1, #0
 801704a:	f04f 0200 	mov.w	r2, #0
 801704e:	f7fe fe3d 	bl	8015ccc <_ZN3USB7setAddrEhhh>
 8017052:	4603      	mov	r3, r0
 8017054:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

        if (rcode) {
 8017058:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801705c:	2b00      	cmp	r3, #0
 801705e:	d02b      	beq.n	80170b8 <_ZN8BulkOnly4InitEhhb+0xe8>
			p->lowspeed = false;
 8017060:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017062:	f04f 0200 	mov.w	r2, #0
 8017066:	719a      	strb	r2, [r3, #6]
			addrPool.FreeAddress(bAddress);
 8017068:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801706a:	681b      	ldr	r3, [r3, #0]
 801706c:	f103 0308 	add.w	r3, r3, #8
 8017070:	681b      	ldr	r3, [r3, #0]
 8017072:	687a      	ldr	r2, [r7, #4]
 8017074:	7b12      	ldrb	r2, [r2, #12]
 8017076:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8017078:	4611      	mov	r1, r2
 801707a:	4798      	blx	r3
			bAddress = 0;
 801707c:	687b      	ldr	r3, [r7, #4]
 801707e:	f04f 0200 	mov.w	r2, #0
 8017082:	731a      	strb	r2, [r3, #12]
			USBTRACE2("setAddr:", rcode);
 8017084:	f64e 109c 	movw	r0, #59804	; 0xe99c
 8017088:	f6c0 0001 	movt	r0, #2049	; 0x801
 801708c:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017090:	f002 f990 	bl	80193b4 <_Z8E_NotifyPKci>
 8017094:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8017098:	4618      	mov	r0, r3
 801709a:	f04f 0180 	mov.w	r1, #128	; 0x80
 801709e:	f7fe fef3 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 80170a2:	f64e 10a8 	movw	r0, #59816	; 0xe9a8
 80170a6:	f6c0 0001 	movt	r0, #2049	; 0x801
 80170aa:	f04f 0180 	mov.w	r1, #128	; 0x80
 80170ae:	f002 f981 	bl	80193b4 <_Z8E_NotifyPKci>
			return rcode;
 80170b2:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 80170b6:	e2a2      	b.n	80175fe <_ZN8BulkOnly4InitEhhb+0x62e>
        }

        USBTRACE2("\nMSC Addr:%d", bAddress);
 80170b8:	f64e 10ac 	movw	r0, #59820	; 0xe9ac
 80170bc:	f6c0 0001 	movt	r0, #2049	; 0x801
 80170c0:	f04f 0180 	mov.w	r1, #128	; 0x80
 80170c4:	f002 f976 	bl	80193b4 <_Z8E_NotifyPKci>
 80170c8:	687b      	ldr	r3, [r7, #4]
 80170ca:	7b1b      	ldrb	r3, [r3, #12]
 80170cc:	4618      	mov	r0, r3
 80170ce:	f04f 0180 	mov.w	r1, #128	; 0x80
 80170d2:	f7fe fed9 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 80170d6:	f64e 10a8 	movw	r0, #59816	; 0xe9a8
 80170da:	f6c0 0001 	movt	r0, #2049	; 0x801
 80170de:	f04f 0180 	mov.w	r1, #128	; 0x80
 80170e2:	f002 f967 	bl	80193b4 <_Z8E_NotifyPKci>

        p->lowspeed = false;
 80170e6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80170e8:	f04f 0200 	mov.w	r2, #0
 80170ec:	719a      	strb	r2, [r3, #6]

        p = addrPool.GetUsbDevicePtr(bAddress);
 80170ee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80170f0:	681b      	ldr	r3, [r3, #0]
 80170f2:	681b      	ldr	r3, [r3, #0]
 80170f4:	687a      	ldr	r2, [r7, #4]
 80170f6:	7b12      	ldrb	r2, [r2, #12]
 80170f8:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 80170fa:	4611      	mov	r1, r2
 80170fc:	4798      	blx	r3
 80170fe:	4603      	mov	r3, r0
 8017100:	64bb      	str	r3, [r7, #72]	; 0x48

        if (!p)
 8017102:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017104:	2b00      	cmp	r3, #0
 8017106:	d102      	bne.n	801710e <_ZN8BulkOnly4InitEhhb+0x13e>
			return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
 8017108:	f04f 03d6 	mov.w	r3, #214	; 0xd6
 801710c:	e277      	b.n	80175fe <_ZN8BulkOnly4InitEhhb+0x62e>

        p->lowspeed = lowspeed;
 801710e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017110:	787a      	ldrb	r2, [r7, #1]
 8017112:	719a      	strb	r2, [r3, #6]

        // Assign epInfo to epinfo pointer
        rcode = pUsb->setEpInfoEntry(bAddress, 1, epInfo);
 8017114:	687b      	ldr	r3, [r7, #4]
 8017116:	6899      	ldr	r1, [r3, #8]
 8017118:	687b      	ldr	r3, [r7, #4]
 801711a:	7b1a      	ldrb	r2, [r3, #12]
 801711c:	687b      	ldr	r3, [r7, #4]
 801711e:	f103 0315 	add.w	r3, r3, #21
 8017122:	4608      	mov	r0, r1
 8017124:	4611      	mov	r1, r2
 8017126:	f04f 0201 	mov.w	r2, #1
 801712a:	f7fd fa33 	bl	8014594 <_ZN3USB14setEpInfoEntryEhhP6EpInfo>
 801712e:	4603      	mov	r3, r0
 8017130:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

        if (rcode)
 8017134:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8017138:	2b00      	cmp	r3, #0
 801713a:	f040 824a 	bne.w	80175d2 <_ZN8BulkOnly4InitEhhb+0x602>
			goto FailSetDevTblEntry;

        for (uint8_t i = 0; i < num_of_conf; i++) {
 801713e:	f04f 0300 	mov.w	r3, #0
 8017142:	f887 3056 	strb.w	r3, [r7, #86]	; 0x56
 8017146:	e029      	b.n	801719c <_ZN8BulkOnly4InitEhhb+0x1cc>
			ConfigDescParser< USB_CLASS_MASS_STORAGE,
					MASS_SUBCLASS_SCSI,
					MASS_PROTO_BBB,
					CP_MASK_COMPARE_CLASS |
					CP_MASK_COMPARE_SUBCLASS |
					CP_MASK_COMPARE_PROTOCOL > BulkOnlyParser(this);
 8017148:	687b      	ldr	r3, [r7, #4]
 801714a:	f103 0304 	add.w	r3, r3, #4
 801714e:	f107 020c 	add.w	r2, r7, #12
 8017152:	4610      	mov	r0, r2
 8017154:	4619      	mov	r1, r3
 8017156:	f001 fe47 	bl	8018de8 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EEC1EP17UsbConfigXtracter>

			rcode = pUsb->getConfDescr(bAddress, 0, i, &BulkOnlyParser);
 801715a:	687b      	ldr	r3, [r7, #4]
 801715c:	6899      	ldr	r1, [r3, #8]
 801715e:	687b      	ldr	r3, [r7, #4]
 8017160:	7b1a      	ldrb	r2, [r3, #12]
 8017162:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 8017166:	f107 000c 	add.w	r0, r7, #12
 801716a:	9000      	str	r0, [sp, #0]
 801716c:	4608      	mov	r0, r1
 801716e:	4611      	mov	r1, r2
 8017170:	f04f 0200 	mov.w	r2, #0
 8017174:	f7fe fd10 	bl	8015b98 <_ZN3USB12getConfDescrEhhhP13USBReadParser>
 8017178:	4603      	mov	r3, r0
 801717a:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

			if (rcode)
 801717e:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8017182:	2b00      	cmp	r3, #0
 8017184:	f040 822b 	bne.w	80175de <_ZN8BulkOnly4InitEhhb+0x60e>
				goto FailGetConfDescr;

			if (bNumEP > 1)
 8017188:	687b      	ldr	r3, [r7, #4]
 801718a:	7bdb      	ldrb	r3, [r3, #15]
 801718c:	2b01      	cmp	r3, #1
 801718e:	d810      	bhi.n	80171b2 <_ZN8BulkOnly4InitEhhb+0x1e2>
        rcode = pUsb->setEpInfoEntry(bAddress, 1, epInfo);

        if (rcode)
			goto FailSetDevTblEntry;

        for (uint8_t i = 0; i < num_of_conf; i++) {
 8017190:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 8017194:	f103 0301 	add.w	r3, r3, #1
 8017198:	f887 3056 	strb.w	r3, [r7, #86]	; 0x56
 801719c:	f897 2056 	ldrb.w	r2, [r7, #86]	; 0x56
 80171a0:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 80171a4:	429a      	cmp	r2, r3
 80171a6:	bf2c      	ite	cs
 80171a8:	2300      	movcs	r3, #0
 80171aa:	2301      	movcc	r3, #1
 80171ac:	b2db      	uxtb	r3, r3
 80171ae:	2b00      	cmp	r3, #0
 80171b0:	d1ca      	bne.n	8017148 <_ZN8BulkOnly4InitEhhb+0x178>

			if (bNumEP > 1)
				break;
        } // for

        if (bNumEP < 3) {
 80171b2:	687b      	ldr	r3, [r7, #4]
 80171b4:	7bdb      	ldrb	r3, [r3, #15]
 80171b6:	2b02      	cmp	r3, #2
 80171b8:	d81b      	bhi.n	80171f2 <_ZN8BulkOnly4InitEhhb+0x222>
        	USBTRACE2("MSC Dev not supported, bNumEP:", bNumEP);
 80171ba:	f64e 10bc 	movw	r0, #59836	; 0xe9bc
 80171be:	f6c0 0001 	movt	r0, #2049	; 0x801
 80171c2:	f04f 0180 	mov.w	r1, #128	; 0x80
 80171c6:	f002 f8f5 	bl	80193b4 <_Z8E_NotifyPKci>
 80171ca:	687b      	ldr	r3, [r7, #4]
 80171cc:	7bdb      	ldrb	r3, [r3, #15]
 80171ce:	4618      	mov	r0, r3
 80171d0:	f04f 0180 	mov.w	r1, #128	; 0x80
 80171d4:	f7fe fe58 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 80171d8:	f64e 10a8 	movw	r0, #59816	; 0xe9a8
 80171dc:	f6c0 0001 	movt	r0, #2049	; 0x801
 80171e0:	f04f 0180 	mov.w	r1, #128	; 0x80
 80171e4:	f002 f8e6 	bl	80193b4 <_Z8E_NotifyPKci>
			rcode = USB_DEV_CONFIG_ERROR_DEVICE_NOT_SUPPORTED;
 80171e8:	f04f 03d1 	mov.w	r3, #209	; 0xd1
 80171ec:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
			goto Fail;
 80171f0:	e1f7      	b.n	80175e2 <_ZN8BulkOnly4InitEhhb+0x612>
        }
        // Assign epInfo to epinfo pointer
        pUsb->setEpInfoEntry(bAddress, bNumEP, epInfo);
 80171f2:	687b      	ldr	r3, [r7, #4]
 80171f4:	6898      	ldr	r0, [r3, #8]
 80171f6:	687b      	ldr	r3, [r7, #4]
 80171f8:	7b19      	ldrb	r1, [r3, #12]
 80171fa:	687b      	ldr	r3, [r7, #4]
 80171fc:	7bda      	ldrb	r2, [r3, #15]
 80171fe:	687b      	ldr	r3, [r7, #4]
 8017200:	f103 0315 	add.w	r3, r3, #21
 8017204:	f7fd f9c6 	bl	8014594 <_ZN3USB14setEpInfoEntryEhhP6EpInfo>

        // Set Configuration Value
        rcode = pUsb->setConf(bAddress, 0, bConfNum);
 8017208:	687b      	ldr	r3, [r7, #4]
 801720a:	6899      	ldr	r1, [r3, #8]
 801720c:	687b      	ldr	r3, [r7, #4]
 801720e:	7b1a      	ldrb	r2, [r3, #12]
 8017210:	687b      	ldr	r3, [r7, #4]
 8017212:	7b5b      	ldrb	r3, [r3, #13]
 8017214:	4608      	mov	r0, r1
 8017216:	4611      	mov	r1, r2
 8017218:	f04f 0200 	mov.w	r2, #0
 801721c:	f7fe fd84 	bl	8015d28 <_ZN3USB7setConfEhhh>
 8017220:	4603      	mov	r3, r0
 8017222:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

        if (rcode)
 8017226:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801722a:	2b00      	cmp	r3, #0
 801722c:	f040 81b9 	bne.w	80175a2 <_ZN8BulkOnly4InitEhhb+0x5d2>
			goto FailSetConfDescr;

        //Linux does a 1sec delay after this.
        delay_ms(1000);
 8017230:	f243 630c 	movw	r3, #13836	; 0x360c
 8017234:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017238:	681b      	ldr	r3, [r3, #0]
 801723a:	685b      	ldr	r3, [r3, #4]
 801723c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8017240:	4798      	blx	r3

        rcode = GetMaxLUN(&bMaxLUN);
 8017242:	687b      	ldr	r3, [r7, #4]
 8017244:	f103 032d 	add.w	r3, r3, #45	; 0x2d
 8017248:	6878      	ldr	r0, [r7, #4]
 801724a:	4619      	mov	r1, r3
 801724c:	f000 fbfa 	bl	8017a44 <_ZN8BulkOnly9GetMaxLUNEPh>
 8017250:	4603      	mov	r3, r0
 8017252:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
        if (rcode)
 8017256:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801725a:	2b00      	cmp	r3, #0
 801725c:	f040 81af 	bne.w	80175be <_ZN8BulkOnly4InitEhhb+0x5ee>
			goto FailGetMaxLUN;

        if (bMaxLUN >= MASS_MAX_SUPPORTED_LUN) bMaxLUN = MASS_MAX_SUPPORTED_LUN - 1;
 8017260:	687b      	ldr	r3, [r7, #4]
 8017262:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 8017266:	2b07      	cmp	r3, #7
 8017268:	d904      	bls.n	8017274 <_ZN8BulkOnly4InitEhhb+0x2a4>
 801726a:	687b      	ldr	r3, [r7, #4]
 801726c:	f04f 0207 	mov.w	r2, #7
 8017270:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
        ErrorMessage<uint8_t > (PSTR("MaxLUN"), bMaxLUN);
 8017274:	687b      	ldr	r3, [r7, #4]
 8017276:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 801727a:	f64e 10dc 	movw	r0, #59868	; 0xe9dc
 801727e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017282:	4619      	mov	r1, r3
 8017284:	f001 fdfc 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>

        delay_ms(1000); // Delay a bit for slow firmware.
 8017288:	f243 630c 	movw	r3, #13836	; 0x360c
 801728c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017290:	681b      	ldr	r3, [r3, #0]
 8017292:	685b      	ldr	r3, [r3, #4]
 8017294:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8017298:	4798      	blx	r3

        //bTheLUN = bMaxLUN;
        // Assign new epInfo to epinfo pointer
        //rcode = pUsb->setEpInfoEntry(bAddress, bNumEP, &epInfo[1]);
        //rcode |= pUsb->setEpInfoEntry(bAddress, bNumEP, &epInfo[2]);
        if (rcode)
 801729a:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801729e:	2b00      	cmp	r3, #0
 80172a0:	f040 8199 	bne.w	80175d6 <_ZN8BulkOnly4InitEhhb+0x606>
			goto FailSetDevTblEntry;

        ep_no = usbhost_cb->device_added_cb(bAddress, lowspeed, epInfo[2].bmNakPower,
    			epInfo[2].epAddr, epInfo[2].maxPktSize, eEpTypeBulk,
    			epInfo[1].epAddr, epInfo[1].maxPktSize, eEpTypeBulk);
 80172a4:	f243 6310 	movw	r3, #13840	; 0x3610
 80172a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80172ac:	681b      	ldr	r3, [r3, #0]
 80172ae:	695c      	ldr	r4, [r3, #20]
 80172b0:	687b      	ldr	r3, [r7, #4]
 80172b2:	7b18      	ldrb	r0, [r3, #12]
 80172b4:	7879      	ldrb	r1, [r7, #1]
 80172b6:	687b      	ldr	r3, [r7, #4]
 80172b8:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 80172bc:	f3c3 0385 	ubfx	r3, r3, #2, #6
 80172c0:	b2db      	uxtb	r3, r3
 80172c2:	461a      	mov	r2, r3
 80172c4:	687b      	ldr	r3, [r7, #4]
 80172c6:	7fdb      	ldrb	r3, [r3, #31]
 80172c8:	687d      	ldr	r5, [r7, #4]
 80172ca:	f895 e020 	ldrb.w	lr, [r5, #32]
 80172ce:	687d      	ldr	r5, [r7, #4]
 80172d0:	7eae      	ldrb	r6, [r5, #26]
 80172d2:	687d      	ldr	r5, [r7, #4]
 80172d4:	7eed      	ldrb	r5, [r5, #27]
 80172d6:	f8cd e000 	str.w	lr, [sp]
 80172da:	f04f 0e02 	mov.w	lr, #2
 80172de:	f8cd e004 	str.w	lr, [sp, #4]
 80172e2:	9602      	str	r6, [sp, #8]
 80172e4:	9503      	str	r5, [sp, #12]
 80172e6:	f04f 0502 	mov.w	r5, #2
 80172ea:	9504      	str	r5, [sp, #16]
 80172ec:	47a0      	blx	r4
 80172ee:	4603      	mov	r3, r0
 80172f0:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47

        epInfo[1].hcNumIn = ep_no & 0xF;	//USBH_Alloc_Channel(pUsb->coreConfig, epInfo[1].epAddr);	//In, addr = 0x81
 80172f4:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80172f8:	f003 030f 	and.w	r3, r3, #15
 80172fc:	b2d9      	uxtb	r1, r3
 80172fe:	687a      	ldr	r2, [r7, #4]
 8017300:	7f53      	ldrb	r3, [r2, #29]
 8017302:	f361 0303 	bfi	r3, r1, #0, #4
 8017306:	7753      	strb	r3, [r2, #29]
        epInfo[2].hcNumOut = (ep_no >> 4) & 0xF;	//USBH_Alloc_Channel(pUsb->coreConfig, epInfo[2].epAddr);	//out, addr = 0x2
 8017308:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801730c:	ea4f 1313 	mov.w	r3, r3, lsr #4
 8017310:	b2db      	uxtb	r3, r3
 8017312:	f003 030f 	and.w	r3, r3, #15
 8017316:	b2d9      	uxtb	r1, r3
 8017318:	687a      	ldr	r2, [r7, #4]
 801731a:	f892 3022 	ldrb.w	r3, [r2, #34]	; 0x22
 801731e:	f361 1307 	bfi	r3, r1, #4, #4
 8017322:	f882 3022 	strb.w	r3, [r2, #34]	; 0x22
        //USBH_Open_Channel(pUsb->coreConfig, epInfo[1].hcNumIn, bAddress,
        //		(lowspeed)?bmLOWSPEED:bmFULLSPEED, EP_TYPE_BULK, epInfo[1].maxPktSize);
        //USBH_Open_Channel(pUsb->coreConfig, epInfo[2].hcNumOut, bAddress,
        //		(lowspeed)?bmLOWSPEED:bmFULLSPEED, EP_TYPE_BULK, epInfo[2].maxPktSize);

        USBTRACE2("\nMSC Pipe EP1 in = %x, ", epInfo[1].hcNumIn);
 8017326:	f64e 10e4 	movw	r0, #59876	; 0xe9e4
 801732a:	f6c0 0001 	movt	r0, #2049	; 0x801
 801732e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017332:	f002 f83f 	bl	80193b4 <_Z8E_NotifyPKci>
 8017336:	687b      	ldr	r3, [r7, #4]
 8017338:	7f5b      	ldrb	r3, [r3, #29]
 801733a:	f3c3 0303 	ubfx	r3, r3, #0, #4
 801733e:	b2db      	uxtb	r3, r3
 8017340:	4618      	mov	r0, r3
 8017342:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017346:	f7fe fd9f 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801734a:	f64e 10a8 	movw	r0, #59816	; 0xe9a8
 801734e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017352:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017356:	f002 f82d 	bl	80193b4 <_Z8E_NotifyPKci>
        USBTRACE2("addr = 0x%x(0x81", epInfo[1].epAddr);
 801735a:	f64e 10fc 	movw	r0, #59900	; 0xe9fc
 801735e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017362:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017366:	f002 f825 	bl	80193b4 <_Z8E_NotifyPKci>
 801736a:	687b      	ldr	r3, [r7, #4]
 801736c:	7e9b      	ldrb	r3, [r3, #26]
 801736e:	4618      	mov	r0, r3
 8017370:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017374:	f7fe fd88 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 8017378:	f64e 10a8 	movw	r0, #59816	; 0xe9a8
 801737c:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017380:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017384:	f002 f816 	bl	80193b4 <_Z8E_NotifyPKci>
        USBTRACE2("\nMSC Pipe EP2 out = %x", epInfo[2].hcNumOut);
 8017388:	f64e 2010 	movw	r0, #59920	; 0xea10
 801738c:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017390:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017394:	f002 f80e 	bl	80193b4 <_Z8E_NotifyPKci>
 8017398:	687b      	ldr	r3, [r7, #4]
 801739a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 801739e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80173a2:	b2db      	uxtb	r3, r3
 80173a4:	4618      	mov	r0, r3
 80173a6:	f04f 0180 	mov.w	r1, #128	; 0x80
 80173aa:	f7fe fd6d 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 80173ae:	f64e 10a8 	movw	r0, #59816	; 0xe9a8
 80173b2:	f6c0 0001 	movt	r0, #2049	; 0x801
 80173b6:	f04f 0180 	mov.w	r1, #128	; 0x80
 80173ba:	f001 fffb 	bl	80193b4 <_Z8E_NotifyPKci>
        USBTRACE2(", addr = 0x%x(0x2)", epInfo[2].epAddr);
 80173be:	f64e 2028 	movw	r0, #59944	; 0xea28
 80173c2:	f6c0 0001 	movt	r0, #2049	; 0x801
 80173c6:	f04f 0180 	mov.w	r1, #128	; 0x80
 80173ca:	f001 fff3 	bl	80193b4 <_Z8E_NotifyPKci>
 80173ce:	687b      	ldr	r3, [r7, #4]
 80173d0:	7fdb      	ldrb	r3, [r3, #31]
 80173d2:	4618      	mov	r0, r3
 80173d4:	f04f 0180 	mov.w	r1, #128	; 0x80
 80173d8:	f7fe fd56 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 80173dc:	f64e 10a8 	movw	r0, #59816	; 0xe9a8
 80173e0:	f6c0 0001 	movt	r0, #2049	; 0x801
 80173e4:	f04f 0180 	mov.w	r1, #128	; 0x80
 80173e8:	f001 ffe4 	bl	80193b4 <_Z8E_NotifyPKci>

        for (uint8_t lun = 0; lun <= bMaxLUN; lun++) {
 80173ec:	f04f 0300 	mov.w	r3, #0
 80173f0:	f887 3055 	strb.w	r3, [r7, #85]	; 0x55
 80173f4:	e0a8      	b.n	8017548 <_ZN8BulkOnly4InitEhhb+0x578>
                InquiryResponse response;
                rcode = Inquiry(lun, sizeof (InquiryResponse), (uint8_t*) & response);
 80173f6:	f897 2055 	ldrb.w	r2, [r7, #85]	; 0x55
 80173fa:	f107 030c 	add.w	r3, r7, #12
 80173fe:	6878      	ldr	r0, [r7, #4]
 8017400:	4611      	mov	r1, r2
 8017402:	f04f 0224 	mov.w	r2, #36	; 0x24
 8017406:	f000 fb55 	bl	8017ab4 <_ZN8BulkOnly7InquiryEhtPh>
 801740a:	4603      	mov	r3, r0
 801740c:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
                if (rcode) {
 8017410:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8017414:	2b00      	cmp	r3, #0
 8017416:	d009      	beq.n	801742c <_ZN8BulkOnly4InitEhhb+0x45c>
                        ErrorMessage<uint8_t > (PSTR("Inquiry"), rcode);
 8017418:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801741c:	f64e 203c 	movw	r0, #59964	; 0xea3c
 8017420:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017424:	4619      	mov	r1, r3
 8017426:	f001 fd2b 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
 801742a:	e087      	b.n	801753c <_ZN8BulkOnly4InitEhhb+0x56c>
                } else {
                        uint8_t tries = 0xf0;
 801742c:	f04f 03f0 	mov.w	r3, #240	; 0xf0
 8017430:	f887 3054 	strb.w	r3, [r7, #84]	; 0x54
                        while (rcode = TestUnitReady(lun)) {
 8017434:	e030      	b.n	8017498 <_ZN8BulkOnly4InitEhhb+0x4c8>
							if (rcode == 0x08) break; // break on no media, this is OK to do.
 8017436:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801743a:	2b08      	cmp	r3, #8
 801743c:	d03f      	beq.n	80174be <_ZN8BulkOnly4InitEhhb+0x4ee>
							// try to lock media and spin up
							if (tries < 14) {
 801743e:	f897 3054 	ldrb.w	r3, [r7, #84]	; 0x54
 8017442:	2b0d      	cmp	r3, #13
 8017444:	d810      	bhi.n	8017468 <_ZN8BulkOnly4InitEhhb+0x498>
								LockMedia(lun, 1);
 8017446:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 801744a:	6878      	ldr	r0, [r7, #4]
 801744c:	4619      	mov	r1, r3
 801744e:	f04f 0201 	mov.w	r2, #1
 8017452:	f7ff f959 	bl	8016708 <_ZN8BulkOnly9LockMediaEhh>
								//STM_EVAL_LEDToggle(LED1);
								MediaCTL(lun, 1); // I actually have a USB stick that needs this!
 8017456:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 801745a:	6878      	ldr	r0, [r7, #4]
 801745c:	4619      	mov	r1, r3
 801745e:	f04f 0201 	mov.w	r2, #1
 8017462:	f7ff f9cd 	bl	8016800 <_ZN8BulkOnly8MediaCTLEhh>
 8017466:	e00d      	b.n	8017484 <_ZN8BulkOnly4InitEhhb+0x4b4>
								//STM_EVAL_LEDToggle(LED1);
							} else delay_ms(2 * (tries + 1));
 8017468:	f243 630c 	movw	r3, #13836	; 0x360c
 801746c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017470:	681b      	ldr	r3, [r3, #0]
 8017472:	685b      	ldr	r3, [r3, #4]
 8017474:	f897 2054 	ldrb.w	r2, [r7, #84]	; 0x54
 8017478:	f102 0201 	add.w	r2, r2, #1
 801747c:	ea4f 0242 	mov.w	r2, r2, lsl #1
 8017480:	4610      	mov	r0, r2
 8017482:	4798      	blx	r3
							tries++;
 8017484:	f897 3054 	ldrb.w	r3, [r7, #84]	; 0x54
 8017488:	f103 0301 	add.w	r3, r3, #1
 801748c:	f887 3054 	strb.w	r3, [r7, #84]	; 0x54
							if (!tries) break;
 8017490:	f897 3054 	ldrb.w	r3, [r7, #84]	; 0x54
 8017494:	2b00      	cmp	r3, #0
 8017496:	d014      	beq.n	80174c2 <_ZN8BulkOnly4InitEhhb+0x4f2>
                rcode = Inquiry(lun, sizeof (InquiryResponse), (uint8_t*) & response);
                if (rcode) {
                        ErrorMessage<uint8_t > (PSTR("Inquiry"), rcode);
                } else {
                        uint8_t tries = 0xf0;
                        while (rcode = TestUnitReady(lun)) {
 8017498:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 801749c:	6878      	ldr	r0, [r7, #4]
 801749e:	4619      	mov	r1, r3
 80174a0:	f000 fc94 	bl	8017dcc <_ZN8BulkOnly13TestUnitReadyEh>
 80174a4:	4603      	mov	r3, r0
 80174a6:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
 80174aa:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 80174ae:	2b00      	cmp	r3, #0
 80174b0:	bf0c      	ite	eq
 80174b2:	2300      	moveq	r3, #0
 80174b4:	2301      	movne	r3, #1
 80174b6:	b2db      	uxtb	r3, r3
 80174b8:	2b00      	cmp	r3, #0
 80174ba:	d1bc      	bne.n	8017436 <_ZN8BulkOnly4InitEhhb+0x466>
 80174bc:	e002      	b.n	80174c4 <_ZN8BulkOnly4InitEhhb+0x4f4>
							if (rcode == 0x08) break; // break on no media, this is OK to do.
 80174be:	bf00      	nop
 80174c0:	e000      	b.n	80174c4 <_ZN8BulkOnly4InitEhhb+0x4f4>
								//STM_EVAL_LEDToggle(LED1);
								MediaCTL(lun, 1); // I actually have a USB stick that needs this!
								//STM_EVAL_LEDToggle(LED1);
							} else delay_ms(2 * (tries + 1));
							tries++;
							if (!tries) break;
 80174c2:	bf00      	nop
                        }
                        if (!rcode) {
 80174c4:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 80174c8:	2b00      	cmp	r3, #0
 80174ca:	d137      	bne.n	801753c <_ZN8BulkOnly4InitEhhb+0x56c>
							delay_ms(1000);
 80174cc:	f243 630c 	movw	r3, #13836	; 0x360c
 80174d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80174d4:	681b      	ldr	r3, [r3, #0]
 80174d6:	685b      	ldr	r3, [r3, #4]
 80174d8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80174dc:	4798      	blx	r3
							LUNOk[lun] = CheckLUN(lun);
 80174de:	f897 4055 	ldrb.w	r4, [r7, #85]	; 0x55
 80174e2:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 80174e6:	6878      	ldr	r0, [r7, #4]
 80174e8:	4619      	mov	r1, r3
 80174ea:	f000 f949 	bl	8017780 <_ZN8BulkOnly8CheckLUNEh>
 80174ee:	4603      	mov	r3, r0
 80174f0:	2b00      	cmp	r3, #0
 80174f2:	bf0c      	ite	eq
 80174f4:	2300      	moveq	r3, #0
 80174f6:	2301      	movne	r3, #1
 80174f8:	b2da      	uxtb	r2, r3
 80174fa:	687b      	ldr	r3, [r7, #4]
 80174fc:	191b      	adds	r3, r3, r4
 80174fe:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
							if (!LUNOk[lun]) LUNOk[lun] = CheckLUN(lun);
 8017502:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 8017506:	687a      	ldr	r2, [r7, #4]
 8017508:	18d3      	adds	r3, r2, r3
 801750a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 801750e:	f083 0301 	eor.w	r3, r3, #1
 8017512:	b2db      	uxtb	r3, r3
 8017514:	2b00      	cmp	r3, #0
 8017516:	d011      	beq.n	801753c <_ZN8BulkOnly4InitEhhb+0x56c>
 8017518:	f897 4055 	ldrb.w	r4, [r7, #85]	; 0x55
 801751c:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 8017520:	6878      	ldr	r0, [r7, #4]
 8017522:	4619      	mov	r1, r3
 8017524:	f000 f92c 	bl	8017780 <_ZN8BulkOnly8CheckLUNEh>
 8017528:	4603      	mov	r3, r0
 801752a:	2b00      	cmp	r3, #0
 801752c:	bf0c      	ite	eq
 801752e:	2300      	moveq	r3, #0
 8017530:	2301      	movne	r3, #1
 8017532:	b2da      	uxtb	r2, r3
 8017534:	687b      	ldr	r3, [r7, #4]
 8017536:	191b      	adds	r3, r3, r4
 8017538:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
        USBTRACE2("\nMSC Pipe EP1 in = %x, ", epInfo[1].hcNumIn);
        USBTRACE2("addr = 0x%x(0x81", epInfo[1].epAddr);
        USBTRACE2("\nMSC Pipe EP2 out = %x", epInfo[2].hcNumOut);
        USBTRACE2(", addr = 0x%x(0x2)", epInfo[2].epAddr);

        for (uint8_t lun = 0; lun <= bMaxLUN; lun++) {
 801753c:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 8017540:	f103 0301 	add.w	r3, r3, #1
 8017544:	f887 3055 	strb.w	r3, [r7, #85]	; 0x55
 8017548:	687b      	ldr	r3, [r7, #4]
 801754a:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 801754e:	f897 2055 	ldrb.w	r2, [r7, #85]	; 0x55
 8017552:	429a      	cmp	r2, r3
 8017554:	bf8c      	ite	hi
 8017556:	2300      	movhi	r3, #0
 8017558:	2301      	movls	r3, #1
 801755a:	b2db      	uxtb	r3, r3
 801755c:	2b00      	cmp	r3, #0
 801755e:	f47f af4a 	bne.w	80173f6 <_ZN8BulkOnly4InitEhhb+0x426>
                        if (good) break;
                        delay(118); // 255 loops =~ 30 seconds to allow for spin up, as per SCSI spec.
                }
        }
#else
        CheckMedia();
 8017562:	6878      	ldr	r0, [r7, #4]
 8017564:	f000 f9ee 	bl	8017944 <_ZN8BulkOnly10CheckMediaEv>
#endif

        rcode = OnInit();
 8017568:	687b      	ldr	r3, [r7, #4]
 801756a:	681b      	ldr	r3, [r3, #0]
 801756c:	f103 0320 	add.w	r3, r3, #32
 8017570:	681b      	ldr	r3, [r3, #0]
 8017572:	6878      	ldr	r0, [r7, #4]
 8017574:	4798      	blx	r3
 8017576:	4603      	mov	r3, r0
 8017578:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

        if (rcode)
 801757c:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8017580:	2b00      	cmp	r3, #0
 8017582:	d112      	bne.n	80175aa <_ZN8BulkOnly4InitEhhb+0x5da>
                goto FailOnInit;

        USBTRACE("\nMSC configured\r\n\r\n");
 8017584:	f64e 2044 	movw	r0, #59972	; 0xea44
 8017588:	f6c0 0001 	movt	r0, #2049	; 0x801
 801758c:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017590:	f001 ff10 	bl	80193b4 <_Z8E_NotifyPKci>

        bPollEnable = true;
 8017594:	687b      	ldr	r3, [r7, #4]
 8017596:	f04f 0201 	mov.w	r2, #1
 801759a:	751a      	strb	r2, [r3, #20]

        //USBTRACE("Poll enabled\r\n");
        return 0;
 801759c:	f04f 0300 	mov.w	r3, #0
 80175a0:	e02d      	b.n	80175fe <_ZN8BulkOnly4InitEhhb+0x62e>

        // Set Configuration Value
        rcode = pUsb->setConf(bAddress, 0, bConfNum);

        if (rcode)
			goto FailSetConfDescr;
 80175a2:	bf00      	nop
        //USBTRACE("Poll enabled\r\n");
        return 0;

FailSetConfDescr:
#ifdef DEBUG_USB_HOST
        NotifyFailSetConfDescr();
 80175a4:	f001 fff8 	bl	8019598 <_Z22NotifyFailSetConfDescrv>
        goto Fail;
 80175a8:	e01b      	b.n	80175e2 <_ZN8BulkOnly4InitEhhb+0x612>
#endif

        rcode = OnInit();

        if (rcode)
                goto FailOnInit;
 80175aa:	bf00      	nop
        goto Fail;
#endif

FailOnInit:
#ifdef DEBUG_USB_HOST
        USBTRACE("OnInit:");
 80175ac:	f64e 2058 	movw	r0, #59992	; 0xea58
 80175b0:	f6c0 0001 	movt	r0, #2049	; 0x801
 80175b4:	f04f 0180 	mov.w	r1, #128	; 0x80
 80175b8:	f001 fefc 	bl	80193b4 <_Z8E_NotifyPKci>
        goto Fail;
 80175bc:	e011      	b.n	80175e2 <_ZN8BulkOnly4InitEhhb+0x612>
        //Linux does a 1sec delay after this.
        delay_ms(1000);

        rcode = GetMaxLUN(&bMaxLUN);
        if (rcode)
			goto FailGetMaxLUN;
 80175be:	bf00      	nop
        goto Fail;
#endif

FailGetMaxLUN:
#ifdef DEBUG_USB_HOST
        USBTRACE("GetMaxLUN:");
 80175c0:	f64e 2060 	movw	r0, #60000	; 0xea60
 80175c4:	f6c0 0001 	movt	r0, #2049	; 0x801
 80175c8:	f04f 0180 	mov.w	r1, #128	; 0x80
 80175cc:	f001 fef2 	bl	80193b4 <_Z8E_NotifyPKci>
        goto Fail;
 80175d0:	e007      	b.n	80175e2 <_ZN8BulkOnly4InitEhhb+0x612>

        // Assign epInfo to epinfo pointer
        rcode = pUsb->setEpInfoEntry(bAddress, 1, epInfo);

        if (rcode)
			goto FailSetDevTblEntry;
 80175d2:	bf00      	nop
 80175d4:	e000      	b.n	80175d8 <_ZN8BulkOnly4InitEhhb+0x608>
        //bTheLUN = bMaxLUN;
        // Assign new epInfo to epinfo pointer
        //rcode = pUsb->setEpInfoEntry(bAddress, bNumEP, &epInfo[1]);
        //rcode |= pUsb->setEpInfoEntry(bAddress, bNumEP, &epInfo[2]);
        if (rcode)
			goto FailSetDevTblEntry;
 80175d6:	bf00      	nop
        goto Fail;
#endif

FailSetDevTblEntry:
#ifdef DEBUG_USB_HOST
        NotifyFailSetDevTblEntry();
 80175d8:	f001 ffc6 	bl	8019568 <_Z24NotifyFailSetDevTblEntryv>
        goto Fail;
 80175dc:	e001      	b.n	80175e2 <_ZN8BulkOnly4InitEhhb+0x612>
#endif

FailGetConfDescr:
#ifdef DEBUG_USB_HOST
        NotifyFailGetConfDescr();
 80175de:	f001 ffcf 	bl	8019580 <_Z22NotifyFailGetConfDescrv>
#endif

Fail:
#ifdef DEBUG_USB_HOST
        NotifyFail(rcode);
 80175e2:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 80175e6:	4618      	mov	r0, r3
 80175e8:	f002 f84a 	bl	8019680 <_Z10NotifyFailh>
#endif
        Release();
 80175ec:	687b      	ldr	r3, [r7, #4]
 80175ee:	681b      	ldr	r3, [r3, #0]
 80175f0:	f103 0308 	add.w	r3, r3, #8
 80175f4:	681b      	ldr	r3, [r3, #0]
 80175f6:	6878      	ldr	r0, [r7, #4]
 80175f8:	4798      	blx	r3
        return rcode;
 80175fa:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 80175fe:	e003      	b.n	8017608 <_ZN8BulkOnly4InitEhhb+0x638>
 8017600:	f005 fa3e 	bl	801ca80 <__cxa_end_cleanup>
 8017604:	f005 fa3c 	bl	801ca80 <__cxa_end_cleanup>
}
 8017608:	4618      	mov	r0, r3
 801760a:	f107 075c 	add.w	r7, r7, #92	; 0x5c
 801760e:	46bd      	mov	sp, r7
 8017610:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8017612:	bf00      	nop

08017614 <_ZN8BulkOnly14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR>:
 * @param iface
 * @param alt
 * @param proto
 * @param pep
 */
void BulkOnly::EndpointXtract(uint8_t conf, uint8_t iface, uint8_t alt, uint8_t proto, const USB_ENDPOINT_DESCRIPTOR * pep) {
 8017614:	b580      	push	{r7, lr}
 8017616:	b084      	sub	sp, #16
 8017618:	af00      	add	r7, sp, #0
 801761a:	6078      	str	r0, [r7, #4]
 801761c:	70f9      	strb	r1, [r7, #3]
 801761e:	70ba      	strb	r2, [r7, #2]
 8017620:	707b      	strb	r3, [r7, #1]
        ErrorMessage<uint8_t > (PSTR("Conf.Val"), conf);
 8017622:	78fb      	ldrb	r3, [r7, #3]
 8017624:	f64e 206c 	movw	r0, #60012	; 0xea6c
 8017628:	f6c0 0001 	movt	r0, #2049	; 0x801
 801762c:	4619      	mov	r1, r3
 801762e:	f001 fc27 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
        ErrorMessage<uint8_t > (PSTR("Iface Num"), iface);
 8017632:	78bb      	ldrb	r3, [r7, #2]
 8017634:	f64e 2078 	movw	r0, #60024	; 0xea78
 8017638:	f6c0 0001 	movt	r0, #2049	; 0x801
 801763c:	4619      	mov	r1, r3
 801763e:	f001 fc1f 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
        ErrorMessage<uint8_t > (PSTR("Alt.Set"), alt);
 8017642:	787b      	ldrb	r3, [r7, #1]
 8017644:	f64e 2084 	movw	r0, #60036	; 0xea84
 8017648:	f6c0 0001 	movt	r0, #2049	; 0x801
 801764c:	4619      	mov	r1, r3
 801764e:	f001 fc17 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>

        bConfNum = conf;
 8017652:	687b      	ldr	r3, [r7, #4]
 8017654:	78fa      	ldrb	r2, [r7, #3]
 8017656:	735a      	strb	r2, [r3, #13]

        uint8_t index;
#if 1
        if((pep->bmAttributes & 0x02) == 2) {
 8017658:	69fb      	ldr	r3, [r7, #28]
 801765a:	78db      	ldrb	r3, [r3, #3]
 801765c:	f003 0302 	and.w	r3, r3, #2
 8017660:	2b00      	cmp	r3, #0
 8017662:	d044      	beq.n	80176ee <_ZN8BulkOnly14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR+0xda>
			index = ((pep->bEndpointAddress & 0x80) == 0x80) ? epDataInIndex : epDataOutIndex;
 8017664:	69fb      	ldr	r3, [r7, #28]
 8017666:	789b      	ldrb	r3, [r3, #2]
 8017668:	b2db      	uxtb	r3, r3
 801766a:	b25b      	sxtb	r3, r3
 801766c:	2b00      	cmp	r3, #0
 801766e:	da05      	bge.n	801767c <_ZN8BulkOnly14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR+0x68>
 8017670:	f240 5328 	movw	r3, #1320	; 0x528
 8017674:	f6c0 0302 	movt	r3, #2050	; 0x802
 8017678:	781b      	ldrb	r3, [r3, #0]
 801767a:	e004      	b.n	8017686 <_ZN8BulkOnly14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR+0x72>
 801767c:	f240 5329 	movw	r3, #1321	; 0x529
 8017680:	f6c0 0302 	movt	r3, #2050	; 0x802
 8017684:	781b      	ldrb	r3, [r3, #0]
 8017686:	73fb      	strb	r3, [r7, #15]
			// Fill in the endpoint info structure
			epInfo[index].epAddr = pep->bEndpointAddress;	//(pep->bEndpointAddress & 0x0F);
 8017688:	7bfa      	ldrb	r2, [r7, #15]
 801768a:	69fb      	ldr	r3, [r7, #28]
 801768c:	7899      	ldrb	r1, [r3, #2]
 801768e:	6878      	ldr	r0, [r7, #4]
 8017690:	4613      	mov	r3, r2
 8017692:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017696:	189b      	adds	r3, r3, r2
 8017698:	18c3      	adds	r3, r0, r3
 801769a:	f103 0310 	add.w	r3, r3, #16
 801769e:	460a      	mov	r2, r1
 80176a0:	715a      	strb	r2, [r3, #5]
			epInfo[index].maxPktSize = (uint8_t)pep->wMaxPacketSize;
 80176a2:	7bfa      	ldrb	r2, [r7, #15]
 80176a4:	69fb      	ldr	r3, [r7, #28]
 80176a6:	889b      	ldrh	r3, [r3, #4]
 80176a8:	b29b      	uxth	r3, r3
 80176aa:	b2d9      	uxtb	r1, r3
 80176ac:	6878      	ldr	r0, [r7, #4]
 80176ae:	4613      	mov	r3, r2
 80176b0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80176b4:	189b      	adds	r3, r3, r2
 80176b6:	18c3      	adds	r3, r0, r3
 80176b8:	f103 0310 	add.w	r3, r3, #16
 80176bc:	460a      	mov	r2, r1
 80176be:	719a      	strb	r2, [r3, #6]
			epInfo[index].epAttribs = 0;
 80176c0:	7bfa      	ldrb	r2, [r7, #15]
 80176c2:	6879      	ldr	r1, [r7, #4]
 80176c4:	4613      	mov	r3, r2
 80176c6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80176ca:	189b      	adds	r3, r3, r2
 80176cc:	18cb      	adds	r3, r1, r3
 80176ce:	f103 0310 	add.w	r3, r3, #16
 80176d2:	f04f 0200 	mov.w	r2, #0
 80176d6:	725a      	strb	r2, [r3, #9]

			bNumEP++;
 80176d8:	687b      	ldr	r3, [r7, #4]
 80176da:	7bdb      	ldrb	r3, [r3, #15]
 80176dc:	f103 0301 	add.w	r3, r3, #1
 80176e0:	b2da      	uxtb	r2, r3
 80176e2:	687b      	ldr	r3, [r7, #4]
 80176e4:	73da      	strb	r2, [r3, #15]

			PrintEndpointDescriptor(pep);
 80176e6:	6878      	ldr	r0, [r7, #4]
 80176e8:	69f9      	ldr	r1, [r7, #28]
 80176ea:	f001 fabf 	bl	8018c6c <_ZN8BulkOnly23PrintEndpointDescriptorEPK23USB_ENDPOINT_DESCRIPTOR>

        bNumEP++;

        PrintEndpointDescriptor(pep);
#endif
}
 80176ee:	f107 0710 	add.w	r7, r7, #16
 80176f2:	46bd      	mov	sp, r7
 80176f4:	bd80      	pop	{r7, pc}
 80176f6:	bf00      	nop

080176f8 <_ZThn4_N8BulkOnly14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR>:
 80176f8:	f1a0 0004 	sub.w	r0, r0, #4
 80176fc:	f7ff bf8a 	b.w	8017614 <_ZN8BulkOnly14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR>

08017700 <_ZN8BulkOnly7ReleaseEv>:
 * For driver use only.
 *
 * @return
 */
uint8_t BulkOnly::Release()
{
 8017700:	b580      	push	{r7, lr}
 8017702:	b082      	sub	sp, #8
 8017704:	af00      	add	r7, sp, #0
 8017706:	6078      	str	r0, [r7, #4]
	if(epInfo[1].hcNumber != 0)
 8017708:	687b      	ldr	r3, [r7, #4]
 801770a:	7f5b      	ldrb	r3, [r3, #29]
 801770c:	2b00      	cmp	r3, #0
 801770e:	d00c      	beq.n	801772a <_ZN8BulkOnly7ReleaseEv+0x2a>
	{	// HC0&HC1 are taken by control pipe.
		//USB_OTG_HC_Halt(pUsb->coreConfig, epInfo[1].hcNumIn);
		//USBH_Free_Channel(pUsb->coreConfig, epInfo[1].hcNumIn);
		usbhost_cb->device_removed_cb(epInfo[1].hcNumIn);
 8017710:	f243 6310 	movw	r3, #13840	; 0x3610
 8017714:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017718:	681b      	ldr	r3, [r3, #0]
 801771a:	699b      	ldr	r3, [r3, #24]
 801771c:	687a      	ldr	r2, [r7, #4]
 801771e:	7f52      	ldrb	r2, [r2, #29]
 8017720:	f3c2 0203 	ubfx	r2, r2, #0, #4
 8017724:	b2d2      	uxtb	r2, r2
 8017726:	4610      	mov	r0, r2
 8017728:	4798      	blx	r3
	}
	if(epInfo[2].hcNumber != 0)
 801772a:	687b      	ldr	r3, [r7, #4]
 801772c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8017730:	2b00      	cmp	r3, #0
 8017732:	d00d      	beq.n	8017750 <_ZN8BulkOnly7ReleaseEv+0x50>
	{
		//USB_OTG_HC_Halt(pUsb->coreConfig, epInfo[2].hcNumOut);
		//USBH_Free_Channel(pUsb->coreConfig, epInfo[2].hcNumOut);
		usbhost_cb->device_removed_cb(epInfo[2].hcNumOut);
 8017734:	f243 6310 	movw	r3, #13840	; 0x3610
 8017738:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801773c:	681b      	ldr	r3, [r3, #0]
 801773e:	699b      	ldr	r3, [r3, #24]
 8017740:	687a      	ldr	r2, [r7, #4]
 8017742:	f892 2022 	ldrb.w	r2, [r2, #34]	; 0x22
 8017746:	f3c2 1203 	ubfx	r2, r2, #4, #4
 801774a:	b2d2      	uxtb	r2, r2
 801774c:	4610      	mov	r0, r2
 801774e:	4798      	blx	r3
	}
	ClearAllEP();
 8017750:	6878      	ldr	r0, [r7, #4]
 8017752:	f000 fd95 	bl	8018280 <_ZN8BulkOnly10ClearAllEPEv>
	pUsb->GetAddressPool().FreeAddress(bAddress);
 8017756:	687b      	ldr	r3, [r7, #4]
 8017758:	689b      	ldr	r3, [r3, #8]
 801775a:	4618      	mov	r0, r3
 801775c:	f7fc fe5c 	bl	8014418 <_ZN3USB14GetAddressPoolEv>
 8017760:	4603      	mov	r3, r0
 8017762:	681a      	ldr	r2, [r3, #0]
 8017764:	f102 0208 	add.w	r2, r2, #8
 8017768:	6812      	ldr	r2, [r2, #0]
 801776a:	6879      	ldr	r1, [r7, #4]
 801776c:	7b09      	ldrb	r1, [r1, #12]
 801776e:	4618      	mov	r0, r3
 8017770:	4790      	blx	r2
	return 0;
 8017772:	f04f 0300 	mov.w	r3, #0
}
 8017776:	4618      	mov	r0, r3
 8017778:	f107 0708 	add.w	r7, r7, #8
 801777c:	46bd      	mov	sp, r7
 801777e:	bd80      	pop	{r7, pc}

08017780 <_ZN8BulkOnly8CheckLUNEh>:
 * For driver use only.
 *
 * @param lun Logical Unit Number
 * @return true if LUN is ready for use.
 */
uint8_t BulkOnly::CheckLUN(uint8_t lun) {
 8017780:	b580      	push	{r7, lr}
 8017782:	b086      	sub	sp, #24
 8017784:	af00      	add	r7, sp, #0
 8017786:	6078      	str	r0, [r7, #4]
 8017788:	460b      	mov	r3, r1
 801778a:	70fb      	strb	r3, [r7, #3]
        uint8_t rcode;
        Capacity capacity;
        for (uint8_t i = 0; i<sizeof (Capacity); i++) capacity.data[i] = 0;
 801778c:	f04f 0300 	mov.w	r3, #0
 8017790:	75fb      	strb	r3, [r7, #23]
 8017792:	e00b      	b.n	80177ac <_ZN8BulkOnly8CheckLUNEh+0x2c>
 8017794:	7dfb      	ldrb	r3, [r7, #23]
 8017796:	f107 0218 	add.w	r2, r7, #24
 801779a:	18d3      	adds	r3, r2, r3
 801779c:	f04f 0200 	mov.w	r2, #0
 80177a0:	f803 2c10 	strb.w	r2, [r3, #-16]
 80177a4:	7dfb      	ldrb	r3, [r7, #23]
 80177a6:	f103 0301 	add.w	r3, r3, #1
 80177aa:	75fb      	strb	r3, [r7, #23]
 80177ac:	7dfb      	ldrb	r3, [r7, #23]
 80177ae:	2b07      	cmp	r3, #7
 80177b0:	bf8c      	ite	hi
 80177b2:	2300      	movhi	r3, #0
 80177b4:	2301      	movls	r3, #1
 80177b6:	b2db      	uxtb	r3, r3
 80177b8:	2b00      	cmp	r3, #0
 80177ba:	d1eb      	bne.n	8017794 <_ZN8BulkOnly8CheckLUNEh+0x14>

        rcode = ReadCapacity(lun, sizeof (Capacity), (uint8_t*) & capacity);
 80177bc:	78fa      	ldrb	r2, [r7, #3]
 80177be:	f107 0308 	add.w	r3, r7, #8
 80177c2:	6878      	ldr	r0, [r7, #4]
 80177c4:	4611      	mov	r1, r2
 80177c6:	f04f 0208 	mov.w	r2, #8
 80177ca:	f000 fa7f 	bl	8017ccc <_ZN8BulkOnly12ReadCapacityEhtPh>
 80177ce:	4603      	mov	r3, r0
 80177d0:	757b      	strb	r3, [r7, #21]
        if (rcode) {
 80177d2:	7d7b      	ldrb	r3, [r7, #21]
 80177d4:	2b00      	cmp	r3, #0
 80177d6:	d002      	beq.n	80177de <_ZN8BulkOnly8CheckLUNEh+0x5e>
                //xprintf(">>>>>>>>>>>>>>>>ReadCapacity returned %i\r\n", rcode);
                return false;
 80177d8:	f04f 0300 	mov.w	r3, #0
 80177dc:	e0aa      	b.n	8017934 <_ZN8BulkOnly8CheckLUNEh+0x1b4>
        }
        ErrorMessage<uint8_t > (PSTR(">>>>>>>>>>>>>>>>CAPACITY OK ON LUN"), lun);
 80177de:	78fb      	ldrb	r3, [r7, #3]
 80177e0:	f64e 208c 	movw	r0, #60044	; 0xea8c
 80177e4:	f6c0 0001 	movt	r0, #2049	; 0x801
 80177e8:	4619      	mov	r1, r3
 80177ea:	f001 fb49 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
        for (uint8_t i = 0; i<sizeof (Capacity); i++)
 80177ee:	f04f 0300 	mov.w	r3, #0
 80177f2:	75bb      	strb	r3, [r7, #22]
 80177f4:	e00e      	b.n	8017814 <_ZN8BulkOnly8CheckLUNEh+0x94>
                D_PrintHex<uint8_t > (capacity.data[i], 0x80);
 80177f6:	7dbb      	ldrb	r3, [r7, #22]
 80177f8:	f107 0218 	add.w	r2, r7, #24
 80177fc:	18d3      	adds	r3, r2, r3
 80177fe:	f813 3c10 	ldrb.w	r3, [r3, #-16]
 8017802:	4618      	mov	r0, r3
 8017804:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017808:	f7fe fb3e 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
        if (rcode) {
                //xprintf(">>>>>>>>>>>>>>>>ReadCapacity returned %i\r\n", rcode);
                return false;
        }
        ErrorMessage<uint8_t > (PSTR(">>>>>>>>>>>>>>>>CAPACITY OK ON LUN"), lun);
        for (uint8_t i = 0; i<sizeof (Capacity); i++)
 801780c:	7dbb      	ldrb	r3, [r7, #22]
 801780e:	f103 0301 	add.w	r3, r3, #1
 8017812:	75bb      	strb	r3, [r7, #22]
 8017814:	7dbb      	ldrb	r3, [r7, #22]
 8017816:	2b07      	cmp	r3, #7
 8017818:	bf8c      	ite	hi
 801781a:	2300      	movhi	r3, #0
 801781c:	2301      	movls	r3, #1
 801781e:	b2db      	uxtb	r3, r3
 8017820:	2b00      	cmp	r3, #0
 8017822:	d1e8      	bne.n	80177f6 <_ZN8BulkOnly8CheckLUNEh+0x76>
                D_PrintHex<uint8_t > (capacity.data[i], 0x80);
        Notify(PSTR("\r\n\r\n"), 0x80);
 8017824:	f64e 20b0 	movw	r0, #60080	; 0xeab0
 8017828:	f6c0 0001 	movt	r0, #2049	; 0x801
 801782c:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017830:	f001 fdc0 	bl	80193b4 <_Z8E_NotifyPKci>
        // Only 512/1024/2048/4096 are valid values!
        uint32_t c = ((uint32_t)capacity.data[4] << 24) + ((uint32_t)capacity.data[5] << 16) + ((uint32_t)capacity.data[6] << 8) + (uint32_t)capacity.data[7];
 8017834:	7b3b      	ldrb	r3, [r7, #12]
 8017836:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801783a:	7b7b      	ldrb	r3, [r7, #13]
 801783c:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8017840:	18d2      	adds	r2, r2, r3
 8017842:	7bbb      	ldrb	r3, [r7, #14]
 8017844:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8017848:	18d2      	adds	r2, r2, r3
 801784a:	7bfb      	ldrb	r3, [r7, #15]
 801784c:	18d3      	adds	r3, r2, r3
 801784e:	613b      	str	r3, [r7, #16]
        if (c != 0x0200LU && c != 0x0400LU && c != 0x0800LU && c != 0x1000LU) {
 8017850:	693b      	ldr	r3, [r7, #16]
 8017852:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8017856:	d00e      	beq.n	8017876 <_ZN8BulkOnly8CheckLUNEh+0xf6>
 8017858:	693b      	ldr	r3, [r7, #16]
 801785a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 801785e:	d00a      	beq.n	8017876 <_ZN8BulkOnly8CheckLUNEh+0xf6>
 8017860:	693b      	ldr	r3, [r7, #16]
 8017862:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8017866:	d006      	beq.n	8017876 <_ZN8BulkOnly8CheckLUNEh+0xf6>
 8017868:	693b      	ldr	r3, [r7, #16]
 801786a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 801786e:	d002      	beq.n	8017876 <_ZN8BulkOnly8CheckLUNEh+0xf6>
                return false;
 8017870:	f04f 0300 	mov.w	r3, #0
 8017874:	e05e      	b.n	8017934 <_ZN8BulkOnly8CheckLUNEh+0x1b4>
        }
        // Store capacity information.
        CurrentSectorSize[lun] = (uint16_t)(c & 0xFFFF);
 8017876:	78fa      	ldrb	r2, [r7, #3]
 8017878:	693b      	ldr	r3, [r7, #16]
 801787a:	b299      	uxth	r1, r3
 801787c:	687b      	ldr	r3, [r7, #4]
 801787e:	f102 0228 	add.w	r2, r2, #40	; 0x28
 8017882:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        CurrentCapacity[lun] = ((uint32_t)capacity.data[0] << 24) + ((uint32_t)capacity.data[1] << 16) + ((uint32_t)capacity.data[2] << 8) + (uint32_t)capacity.data[3];
 8017886:	78fa      	ldrb	r2, [r7, #3]
 8017888:	7a3b      	ldrb	r3, [r7, #8]
 801788a:	ea4f 6103 	mov.w	r1, r3, lsl #24
 801788e:	7a7b      	ldrb	r3, [r7, #9]
 8017890:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8017894:	18c9      	adds	r1, r1, r3
 8017896:	7abb      	ldrb	r3, [r7, #10]
 8017898:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801789c:	18c9      	adds	r1, r1, r3
 801789e:	7afb      	ldrb	r3, [r7, #11]
 80178a0:	18c9      	adds	r1, r1, r3
 80178a2:	687b      	ldr	r3, [r7, #4]
 80178a4:	f102 020c 	add.w	r2, r2, #12
 80178a8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        if (CurrentCapacity[lun] == 0xffffffffLU || CurrentCapacity[lun] == 0x00LU) {
 80178ac:	78fa      	ldrb	r2, [r7, #3]
 80178ae:	687b      	ldr	r3, [r7, #4]
 80178b0:	f102 020c 	add.w	r2, r2, #12
 80178b4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80178b8:	f1b3 3fff 	cmp.w	r3, #4294967295
 80178bc:	d007      	beq.n	80178ce <_ZN8BulkOnly8CheckLUNEh+0x14e>
 80178be:	78fa      	ldrb	r2, [r7, #3]
 80178c0:	687b      	ldr	r3, [r7, #4]
 80178c2:	f102 020c 	add.w	r2, r2, #12
 80178c6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80178ca:	2b00      	cmp	r3, #0
 80178cc:	d112      	bne.n	80178f4 <_ZN8BulkOnly8CheckLUNEh+0x174>
                // Buggy firmware will report 0xffffffff or 0 for no media
                if (CurrentCapacity[lun])
 80178ce:	78fa      	ldrb	r2, [r7, #3]
 80178d0:	687b      	ldr	r3, [r7, #4]
 80178d2:	f102 020c 	add.w	r2, r2, #12
 80178d6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80178da:	2b00      	cmp	r3, #0
 80178dc:	d007      	beq.n	80178ee <_ZN8BulkOnly8CheckLUNEh+0x16e>
                        ErrorMessage<uint8_t > (PSTR(">>>>>>>>>>>>>>>>BUGGY FIRMWARE. CAPACITY FAIL ON LUN"), lun);
 80178de:	78fb      	ldrb	r3, [r7, #3]
 80178e0:	f64e 20b8 	movw	r0, #60088	; 0xeab8
 80178e4:	f6c0 0001 	movt	r0, #2049	; 0x801
 80178e8:	4619      	mov	r1, r3
 80178ea:	f001 fac9 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                return false;
 80178ee:	f04f 0300 	mov.w	r3, #0
 80178f2:	e01f      	b.n	8017934 <_ZN8BulkOnly8CheckLUNEh+0x1b4>
        }
        delay_ms(20);
 80178f4:	f243 630c 	movw	r3, #13836	; 0x360c
 80178f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80178fc:	681b      	ldr	r3, [r3, #0]
 80178fe:	685b      	ldr	r3, [r3, #4]
 8017900:	f04f 0014 	mov.w	r0, #20
 8017904:	4798      	blx	r3
        Page3F(lun);
 8017906:	78fb      	ldrb	r3, [r7, #3]
 8017908:	6878      	ldr	r0, [r7, #4]
 801790a:	4619      	mov	r1, r3
 801790c:	f000 fae4 	bl	8017ed8 <_ZN8BulkOnly6Page3FEh>
        if (!TestUnitReady(lun)) return true;
 8017910:	78fb      	ldrb	r3, [r7, #3]
 8017912:	6878      	ldr	r0, [r7, #4]
 8017914:	4619      	mov	r1, r3
 8017916:	f000 fa59 	bl	8017dcc <_ZN8BulkOnly13TestUnitReadyEh>
 801791a:	4603      	mov	r3, r0
 801791c:	2b00      	cmp	r3, #0
 801791e:	bf14      	ite	ne
 8017920:	2300      	movne	r3, #0
 8017922:	2301      	moveq	r3, #1
 8017924:	b2db      	uxtb	r3, r3
 8017926:	2b00      	cmp	r3, #0
 8017928:	d002      	beq.n	8017930 <_ZN8BulkOnly8CheckLUNEh+0x1b0>
 801792a:	f04f 0301 	mov.w	r3, #1
 801792e:	e001      	b.n	8017934 <_ZN8BulkOnly8CheckLUNEh+0x1b4>
        return false;
 8017930:	f04f 0300 	mov.w	r3, #0
 8017934:	e001      	b.n	801793a <_ZN8BulkOnly8CheckLUNEh+0x1ba>
 8017936:	f005 f8a3 	bl	801ca80 <__cxa_end_cleanup>
}
 801793a:	4618      	mov	r0, r3
 801793c:	f107 0718 	add.w	r7, r7, #24
 8017940:	46bd      	mov	sp, r7
 8017942:	bd80      	pop	{r7, pc}

08017944 <_ZN8BulkOnly10CheckMediaEv>:
/**
 * For driver use only.
 *
 * Scan for media change on all LUNs
 */
void BulkOnly::CheckMedia() {
 8017944:	b590      	push	{r4, r7, lr}
 8017946:	b085      	sub	sp, #20
 8017948:	af00      	add	r7, sp, #0
 801794a:	6078      	str	r0, [r7, #4]
	for (uint8_t lun = 0; lun <= bMaxLUN; lun++) {
 801794c:	f04f 0300 	mov.w	r3, #0
 8017950:	73fb      	strb	r3, [r7, #15]
 8017952:	e032      	b.n	80179ba <_ZN8BulkOnly10CheckMediaEv+0x76>
		if (TestUnitReady(lun)) {
 8017954:	7bfb      	ldrb	r3, [r7, #15]
 8017956:	6878      	ldr	r0, [r7, #4]
 8017958:	4619      	mov	r1, r3
 801795a:	f000 fa37 	bl	8017dcc <_ZN8BulkOnly13TestUnitReadyEh>
 801795e:	4603      	mov	r3, r0
 8017960:	2b00      	cmp	r3, #0
 8017962:	bf0c      	ite	eq
 8017964:	2300      	moveq	r3, #0
 8017966:	2301      	movne	r3, #1
 8017968:	b2db      	uxtb	r3, r3
 801796a:	2b00      	cmp	r3, #0
 801796c:	d007      	beq.n	801797e <_ZN8BulkOnly10CheckMediaEv+0x3a>
			LUNOk[lun] = false;
 801796e:	7bfb      	ldrb	r3, [r7, #15]
 8017970:	687a      	ldr	r2, [r7, #4]
 8017972:	18d3      	adds	r3, r2, r3
 8017974:	f04f 0200 	mov.w	r2, #0
 8017978:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
			continue;
 801797c:	e019      	b.n	80179b2 <_ZN8BulkOnly10CheckMediaEv+0x6e>
		}
		if (!LUNOk[lun])
 801797e:	7bfb      	ldrb	r3, [r7, #15]
 8017980:	687a      	ldr	r2, [r7, #4]
 8017982:	18d3      	adds	r3, r2, r3
 8017984:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8017988:	f083 0301 	eor.w	r3, r3, #1
 801798c:	b2db      	uxtb	r3, r3
 801798e:	2b00      	cmp	r3, #0
 8017990:	d00f      	beq.n	80179b2 <_ZN8BulkOnly10CheckMediaEv+0x6e>
			LUNOk[lun] = CheckLUN(lun);
 8017992:	7bfc      	ldrb	r4, [r7, #15]
 8017994:	7bfb      	ldrb	r3, [r7, #15]
 8017996:	6878      	ldr	r0, [r7, #4]
 8017998:	4619      	mov	r1, r3
 801799a:	f7ff fef1 	bl	8017780 <_ZN8BulkOnly8CheckLUNEh>
 801799e:	4603      	mov	r3, r0
 80179a0:	2b00      	cmp	r3, #0
 80179a2:	bf0c      	ite	eq
 80179a4:	2300      	moveq	r3, #0
 80179a6:	2301      	movne	r3, #1
 80179a8:	b2da      	uxtb	r2, r3
 80179aa:	687b      	ldr	r3, [r7, #4]
 80179ac:	191b      	adds	r3, r3, r4
 80179ae:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
 * For driver use only.
 *
 * Scan for media change on all LUNs
 */
void BulkOnly::CheckMedia() {
	for (uint8_t lun = 0; lun <= bMaxLUN; lun++) {
 80179b2:	7bfb      	ldrb	r3, [r7, #15]
 80179b4:	f103 0301 	add.w	r3, r3, #1
 80179b8:	73fb      	strb	r3, [r7, #15]
 80179ba:	687b      	ldr	r3, [r7, #4]
 80179bc:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 80179c0:	7bfa      	ldrb	r2, [r7, #15]
 80179c2:	429a      	cmp	r2, r3
 80179c4:	bf8c      	ite	hi
 80179c6:	2300      	movhi	r3, #0
 80179c8:	2301      	movls	r3, #1
 80179ca:	b2db      	uxtb	r3, r3
 80179cc:	2b00      	cmp	r3, #0
 80179ce:	d1c1      	bne.n	8017954 <_ZN8BulkOnly10CheckMediaEv+0x10>
			xprintf("#");
		else xprintf(".");
	}
	xprintf("\r\n");
#endif
	qNextPollTime = millis() + 2000;
 80179d0:	f243 630c 	movw	r3, #13836	; 0x360c
 80179d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80179d8:	681b      	ldr	r3, [r3, #0]
 80179da:	689b      	ldr	r3, [r3, #8]
 80179dc:	4798      	blx	r3
 80179de:	4603      	mov	r3, r0
 80179e0:	f503 62fa 	add.w	r2, r3, #2000	; 0x7d0
 80179e4:	687b      	ldr	r3, [r7, #4]
 80179e6:	611a      	str	r2, [r3, #16]
}
 80179e8:	f107 0714 	add.w	r7, r7, #20
 80179ec:	46bd      	mov	sp, r7
 80179ee:	bd90      	pop	{r4, r7, pc}

080179f0 <_ZN8BulkOnly4PollEv>:
/**
 * For driver use only.
 *
 * @return
 */
uint8_t BulkOnly::Poll() {
 80179f0:	b590      	push	{r4, r7, lr}
 80179f2:	b083      	sub	sp, #12
 80179f4:	af00      	add	r7, sp, #0
 80179f6:	6078      	str	r0, [r7, #4]
	//uint8_t rcode = 0;

	if (!bPollEnable)
 80179f8:	687b      	ldr	r3, [r7, #4]
 80179fa:	7d1b      	ldrb	r3, [r3, #20]
 80179fc:	f083 0301 	eor.w	r3, r3, #1
 8017a00:	b2db      	uxtb	r3, r3
 8017a02:	2b00      	cmp	r3, #0
 8017a04:	d002      	beq.n	8017a0c <_ZN8BulkOnly4PollEv+0x1c>
		return 0;
 8017a06:	f04f 0300 	mov.w	r3, #0
 8017a0a:	e015      	b.n	8017a38 <_ZN8BulkOnly4PollEv+0x48>

	if (qNextPollTime <= millis()) {
 8017a0c:	687b      	ldr	r3, [r7, #4]
 8017a0e:	691c      	ldr	r4, [r3, #16]
 8017a10:	f243 630c 	movw	r3, #13836	; 0x360c
 8017a14:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017a18:	681b      	ldr	r3, [r3, #0]
 8017a1a:	689b      	ldr	r3, [r3, #8]
 8017a1c:	4798      	blx	r3
 8017a1e:	4603      	mov	r3, r0
 8017a20:	429c      	cmp	r4, r3
 8017a22:	bf8c      	ite	hi
 8017a24:	2300      	movhi	r3, #0
 8017a26:	2301      	movls	r3, #1
 8017a28:	b2db      	uxtb	r3, r3
 8017a2a:	2b00      	cmp	r3, #0
 8017a2c:	d002      	beq.n	8017a34 <_ZN8BulkOnly4PollEv+0x44>
		CheckMedia();
 8017a2e:	6878      	ldr	r0, [r7, #4]
 8017a30:	f7ff ff88 	bl	8017944 <_ZN8BulkOnly10CheckMediaEv>
	}
	//rcode = 0;

	return 0;
 8017a34:	f04f 0300 	mov.w	r3, #0
}
 8017a38:	4618      	mov	r0, r3
 8017a3a:	f107 070c 	add.w	r7, r7, #12
 8017a3e:	46bd      	mov	sp, r7
 8017a40:	bd90      	pop	{r4, r7, pc}
 8017a42:	bf00      	nop

08017a44 <_ZN8BulkOnly9GetMaxLUNEPh>:
 * For driver use only.
 *
 * @param plun
 * @return
 */
uint8_t BulkOnly::GetMaxLUN(uint8_t *plun) {
 8017a44:	b580      	push	{r7, lr}
 8017a46:	b08c      	sub	sp, #48	; 0x30
 8017a48:	af08      	add	r7, sp, #32
 8017a4a:	6078      	str	r0, [r7, #4]
 8017a4c:	6039      	str	r1, [r7, #0]
	uint8_t ret = pUsb->ctrlReq(bAddress, 0, bmREQ_MASSIN, MASS_REQ_GET_MAX_LUN, 0, 0, bIface, 1, 1, plun, NULL);
 8017a4e:	687b      	ldr	r3, [r7, #4]
 8017a50:	689a      	ldr	r2, [r3, #8]
 8017a52:	687b      	ldr	r3, [r7, #4]
 8017a54:	7b1b      	ldrb	r3, [r3, #12]
 8017a56:	6879      	ldr	r1, [r7, #4]
 8017a58:	7b89      	ldrb	r1, [r1, #14]
 8017a5a:	f04f 00fe 	mov.w	r0, #254	; 0xfe
 8017a5e:	9000      	str	r0, [sp, #0]
 8017a60:	f04f 0000 	mov.w	r0, #0
 8017a64:	9001      	str	r0, [sp, #4]
 8017a66:	f04f 0000 	mov.w	r0, #0
 8017a6a:	9002      	str	r0, [sp, #8]
 8017a6c:	9103      	str	r1, [sp, #12]
 8017a6e:	f04f 0101 	mov.w	r1, #1
 8017a72:	9104      	str	r1, [sp, #16]
 8017a74:	f04f 0101 	mov.w	r1, #1
 8017a78:	9105      	str	r1, [sp, #20]
 8017a7a:	6839      	ldr	r1, [r7, #0]
 8017a7c:	9106      	str	r1, [sp, #24]
 8017a7e:	f04f 0100 	mov.w	r1, #0
 8017a82:	9107      	str	r1, [sp, #28]
 8017a84:	4610      	mov	r0, r2
 8017a86:	4619      	mov	r1, r3
 8017a88:	f04f 0200 	mov.w	r2, #0
 8017a8c:	f04f 03a1 	mov.w	r3, #161	; 0xa1
 8017a90:	f7fc fe08 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 8017a94:	4603      	mov	r3, r0
 8017a96:	73fb      	strb	r3, [r7, #15]

	if (ret == hrSTALL)
 8017a98:	7bfb      	ldrb	r3, [r7, #15]
 8017a9a:	2b05      	cmp	r3, #5
 8017a9c:	d103      	bne.n	8017aa6 <_ZN8BulkOnly9GetMaxLUNEPh+0x62>
		*plun = 0;
 8017a9e:	683b      	ldr	r3, [r7, #0]
 8017aa0:	f04f 0200 	mov.w	r2, #0
 8017aa4:	701a      	strb	r2, [r3, #0]

	return 0;
 8017aa6:	f04f 0300 	mov.w	r3, #0
}
 8017aaa:	4618      	mov	r0, r3
 8017aac:	f107 0710 	add.w	r7, r7, #16
 8017ab0:	46bd      	mov	sp, r7
 8017ab2:	bd80      	pop	{r7, pc}

08017ab4 <_ZN8BulkOnly7InquiryEhtPh>:
 * @param lun Logical Unit Number
 * @param bsize
 * @param buf
 * @return
 */
uint8_t BulkOnly::Inquiry(uint8_t lun, uint16_t bsize, uint8_t *buf) {
 8017ab4:	b580      	push	{r7, lr}
 8017ab6:	b090      	sub	sp, #64	; 0x40
 8017ab8:	af02      	add	r7, sp, #8
 8017aba:	60f8      	str	r0, [r7, #12]
 8017abc:	607b      	str	r3, [r7, #4]
 8017abe:	460b      	mov	r3, r1
 8017ac0:	72fb      	strb	r3, [r7, #11]
 8017ac2:	4613      	mov	r3, r2
 8017ac4:	813b      	strh	r3, [r7, #8]
        Notify(PSTR("\r\nInquiry\r\n"), 0x80);
 8017ac6:	f64e 20f0 	movw	r0, #60144	; 0xeaf0
 8017aca:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017ace:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017ad2:	f001 fc6f 	bl	80193b4 <_Z8E_NotifyPKci>
        Notify(PSTR("---------\r\n"), 0x80);
 8017ad6:	f64e 00e4 	movw	r0, #59620	; 0xe8e4
 8017ada:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017ade:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017ae2:	f001 fc67 	bl	80193b4 <_Z8E_NotifyPKci>

        CommandBlockWrapper cbw;
        SetCurLUN(lun);
 8017ae6:	7afb      	ldrb	r3, [r7, #11]
 8017ae8:	68f8      	ldr	r0, [r7, #12]
 8017aea:	4619      	mov	r1, r3
 8017aec:	f000 ffb2 	bl	8018a54 <_ZN8BulkOnly9SetCurLUNEh>
        cbw.dCBWSignature = MASS_CBW_SIGNATURE;
 8017af0:	f245 3355 	movw	r3, #21333	; 0x5355
 8017af4:	f2c4 3342 	movt	r3, #17218	; 0x4342
 8017af8:	617b      	str	r3, [r7, #20]
        cbw.dCBWTag = ++dCBWTag;
 8017afa:	68fb      	ldr	r3, [r7, #12]
 8017afc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017afe:	f103 0201 	add.w	r2, r3, #1
 8017b02:	68fb      	ldr	r3, [r7, #12]
 8017b04:	625a      	str	r2, [r3, #36]	; 0x24
 8017b06:	68fb      	ldr	r3, [r7, #12]
 8017b08:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017b0a:	61bb      	str	r3, [r7, #24]
        cbw.dCBWDataTransferLength = bsize;
 8017b0c:	893b      	ldrh	r3, [r7, #8]
 8017b0e:	61fb      	str	r3, [r7, #28]
        cbw.bmCBWFlags = MASS_CMD_DIR_IN;
 8017b10:	f04f 0380 	mov.w	r3, #128	; 0x80
 8017b14:	f887 3020 	strb.w	r3, [r7, #32]
        cbw.bmCBWLUN = lun;
 8017b18:	7afb      	ldrb	r3, [r7, #11]
 8017b1a:	f003 030f 	and.w	r3, r3, #15
 8017b1e:	b2da      	uxtb	r2, r3
 8017b20:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8017b24:	f362 0303 	bfi	r3, r2, #0, #4
 8017b28:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
        cbw.bmCBWCBLength = 6;
 8017b2c:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8017b30:	f04f 0206 	mov.w	r2, #6
 8017b34:	f362 0303 	bfi	r3, r2, #0, #4
 8017b38:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22

        for (uint8_t i = 0; i < 16; i++)
 8017b3c:	f04f 0300 	mov.w	r3, #0
 8017b40:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8017b44:	e00e      	b.n	8017b64 <_ZN8BulkOnly7InquiryEhtPh+0xb0>
                cbw.CBWCB[i] = 0;
 8017b46:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8017b4a:	f107 0238 	add.w	r2, r7, #56	; 0x38
 8017b4e:	18d3      	adds	r3, r2, r3
 8017b50:	f04f 0200 	mov.w	r2, #0
 8017b54:	f803 2c15 	strb.w	r2, [r3, #-21]
        cbw.dCBWDataTransferLength = bsize;
        cbw.bmCBWFlags = MASS_CMD_DIR_IN;
        cbw.bmCBWLUN = lun;
        cbw.bmCBWCBLength = 6;

        for (uint8_t i = 0; i < 16; i++)
 8017b58:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8017b5c:	f103 0301 	add.w	r3, r3, #1
 8017b60:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8017b64:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8017b68:	2b0f      	cmp	r3, #15
 8017b6a:	bf8c      	ite	hi
 8017b6c:	2300      	movhi	r3, #0
 8017b6e:	2301      	movls	r3, #1
 8017b70:	b2db      	uxtb	r3, r3
 8017b72:	2b00      	cmp	r3, #0
 8017b74:	d1e7      	bne.n	8017b46 <_ZN8BulkOnly7InquiryEhtPh+0x92>
                cbw.CBWCB[i] = 0;

        cbw.CBWCB[0] = SCSI_CMD_INQUIRY;
 8017b76:	f04f 0312 	mov.w	r3, #18
 8017b7a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        cbw.CBWCB[1] = lun << 5;
 8017b7e:	7afb      	ldrb	r3, [r7, #11]
 8017b80:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8017b84:	b2db      	uxtb	r3, r3
 8017b86:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
        cbw.CBWCB[4] = bsize;
 8017b8a:	893b      	ldrh	r3, [r7, #8]
 8017b8c:	b2db      	uxtb	r3, r3
 8017b8e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

        uint8_t rc = HandleSCSIError(Transaction(&cbw, bsize, buf, 0));
 8017b92:	f107 0214 	add.w	r2, r7, #20
 8017b96:	893b      	ldrh	r3, [r7, #8]
 8017b98:	f04f 0100 	mov.w	r1, #0
 8017b9c:	9100      	str	r1, [sp, #0]
 8017b9e:	68f8      	ldr	r0, [r7, #12]
 8017ba0:	4611      	mov	r1, r2
 8017ba2:	461a      	mov	r2, r3
 8017ba4:	687b      	ldr	r3, [r7, #4]
 8017ba6:	f000 fd05 	bl	80185b4 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh>
 8017baa:	4603      	mov	r3, r0
 8017bac:	68f8      	ldr	r0, [r7, #12]
 8017bae:	4619      	mov	r1, r3
 8017bb0:	f000 ff6c 	bl	8018a8c <_ZN8BulkOnly15HandleSCSIErrorEh>
 8017bb4:	4603      	mov	r3, r0
 8017bb6:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
                                xprintf("unknown");
                }
                xprintf(" standards.\r\n");
        }
#endif
        return rc;
 8017bba:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8017bbe:	e001      	b.n	8017bc4 <_ZN8BulkOnly7InquiryEhtPh+0x110>
 8017bc0:	f004 ff5e 	bl	801ca80 <__cxa_end_cleanup>
}
 8017bc4:	4618      	mov	r0, r3
 8017bc6:	f107 0738 	add.w	r7, r7, #56	; 0x38
 8017bca:	46bd      	mov	sp, r7
 8017bcc:	bd80      	pop	{r7, pc}
 8017bce:	bf00      	nop

08017bd0 <_ZN8BulkOnly12RequestSenseEhtPh>:
 * @param lun Logical Unit Number
 * @param size
 * @param buf
 * @return
 */
uint8_t BulkOnly::RequestSense(uint8_t lun, uint16_t size, uint8_t *buf) {
 8017bd0:	b580      	push	{r7, lr}
 8017bd2:	b08e      	sub	sp, #56	; 0x38
 8017bd4:	af02      	add	r7, sp, #8
 8017bd6:	60f8      	str	r0, [r7, #12]
 8017bd8:	607b      	str	r3, [r7, #4]
 8017bda:	460b      	mov	r3, r1
 8017bdc:	72fb      	strb	r3, [r7, #11]
 8017bde:	4613      	mov	r3, r2
 8017be0:	813b      	strh	r3, [r7, #8]
        Notify(PSTR("\r\nRequestSense\r\n"), 0x80);
 8017be2:	f64e 20fc 	movw	r0, #60156	; 0xeafc
 8017be6:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017bea:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017bee:	f001 fbe1 	bl	80193b4 <_Z8E_NotifyPKci>
        Notify(PSTR("----------------\r\n"), 0x80);
 8017bf2:	f64e 3010 	movw	r0, #60176	; 0xeb10
 8017bf6:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017bfa:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017bfe:	f001 fbd9 	bl	80193b4 <_Z8E_NotifyPKci>

        CommandBlockWrapper cbw;
        SetCurLUN(lun);
 8017c02:	7afb      	ldrb	r3, [r7, #11]
 8017c04:	68f8      	ldr	r0, [r7, #12]
 8017c06:	4619      	mov	r1, r3
 8017c08:	f000 ff24 	bl	8018a54 <_ZN8BulkOnly9SetCurLUNEh>

        cbw.dCBWSignature = MASS_CBW_SIGNATURE;
 8017c0c:	f245 3355 	movw	r3, #21333	; 0x5355
 8017c10:	f2c4 3342 	movt	r3, #17218	; 0x4342
 8017c14:	613b      	str	r3, [r7, #16]
        cbw.dCBWTag = ++dCBWTag;
 8017c16:	68fb      	ldr	r3, [r7, #12]
 8017c18:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017c1a:	f103 0201 	add.w	r2, r3, #1
 8017c1e:	68fb      	ldr	r3, [r7, #12]
 8017c20:	625a      	str	r2, [r3, #36]	; 0x24
 8017c22:	68fb      	ldr	r3, [r7, #12]
 8017c24:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017c26:	617b      	str	r3, [r7, #20]
        cbw.dCBWDataTransferLength = size;
 8017c28:	893b      	ldrh	r3, [r7, #8]
 8017c2a:	61bb      	str	r3, [r7, #24]
        cbw.bmCBWFlags = MASS_CMD_DIR_IN;
 8017c2c:	f04f 0380 	mov.w	r3, #128	; 0x80
 8017c30:	773b      	strb	r3, [r7, #28]
        cbw.bmCBWLUN = lun;
 8017c32:	7afb      	ldrb	r3, [r7, #11]
 8017c34:	f003 030f 	and.w	r3, r3, #15
 8017c38:	b2da      	uxtb	r2, r3
 8017c3a:	7f7b      	ldrb	r3, [r7, #29]
 8017c3c:	f362 0303 	bfi	r3, r2, #0, #4
 8017c40:	777b      	strb	r3, [r7, #29]
        cbw.bmCBWCBLength = 6;
 8017c42:	7fbb      	ldrb	r3, [r7, #30]
 8017c44:	f04f 0206 	mov.w	r2, #6
 8017c48:	f362 0303 	bfi	r3, r2, #0, #4
 8017c4c:	77bb      	strb	r3, [r7, #30]

        for (uint8_t i = 0; i < 16; i++)
 8017c4e:	f04f 0300 	mov.w	r3, #0
 8017c52:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8017c56:	e00e      	b.n	8017c76 <_ZN8BulkOnly12RequestSenseEhtPh+0xa6>
                cbw.CBWCB[i] = 0;
 8017c58:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8017c5c:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8017c60:	18d3      	adds	r3, r2, r3
 8017c62:	f04f 0200 	mov.w	r2, #0
 8017c66:	f803 2c11 	strb.w	r2, [r3, #-17]
        cbw.dCBWDataTransferLength = size;
        cbw.bmCBWFlags = MASS_CMD_DIR_IN;
        cbw.bmCBWLUN = lun;
        cbw.bmCBWCBLength = 6;

        for (uint8_t i = 0; i < 16; i++)
 8017c6a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8017c6e:	f103 0301 	add.w	r3, r3, #1
 8017c72:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8017c76:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8017c7a:	2b0f      	cmp	r3, #15
 8017c7c:	bf8c      	ite	hi
 8017c7e:	2300      	movhi	r3, #0
 8017c80:	2301      	movls	r3, #1
 8017c82:	b2db      	uxtb	r3, r3
 8017c84:	2b00      	cmp	r3, #0
 8017c86:	d1e7      	bne.n	8017c58 <_ZN8BulkOnly12RequestSenseEhtPh+0x88>
                cbw.CBWCB[i] = 0;

        cbw.CBWCB[0] = SCSI_CMD_REQUEST_SENSE;
 8017c88:	f04f 0303 	mov.w	r3, #3
 8017c8c:	77fb      	strb	r3, [r7, #31]
        cbw.CBWCB[1] = lun << 5;
 8017c8e:	7afb      	ldrb	r3, [r7, #11]
 8017c90:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8017c94:	b2db      	uxtb	r3, r3
 8017c96:	f887 3020 	strb.w	r3, [r7, #32]
        cbw.CBWCB[4] = size;
 8017c9a:	893b      	ldrh	r3, [r7, #8]
 8017c9c:	b2db      	uxtb	r3, r3
 8017c9e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

        return Transaction(&cbw, size, buf, 0);
 8017ca2:	f107 0210 	add.w	r2, r7, #16
 8017ca6:	893b      	ldrh	r3, [r7, #8]
 8017ca8:	f04f 0100 	mov.w	r1, #0
 8017cac:	9100      	str	r1, [sp, #0]
 8017cae:	68f8      	ldr	r0, [r7, #12]
 8017cb0:	4611      	mov	r1, r2
 8017cb2:	461a      	mov	r2, r3
 8017cb4:	687b      	ldr	r3, [r7, #4]
 8017cb6:	f000 fc7d 	bl	80185b4 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh>
 8017cba:	4603      	mov	r3, r0
 8017cbc:	e001      	b.n	8017cc2 <_ZN8BulkOnly12RequestSenseEhtPh+0xf2>
 8017cbe:	f004 fedf 	bl	801ca80 <__cxa_end_cleanup>
}
 8017cc2:	4618      	mov	r0, r3
 8017cc4:	f107 0730 	add.w	r7, r7, #48	; 0x30
 8017cc8:	46bd      	mov	sp, r7
 8017cca:	bd80      	pop	{r7, pc}

08017ccc <_ZN8BulkOnly12ReadCapacityEhtPh>:
 * @param lun Logical Unit Number
 * @param bsize
 * @param buf
 * @return
 */
uint8_t BulkOnly::ReadCapacity(uint8_t lun, uint16_t bsize, uint8_t *buf) {
 8017ccc:	b580      	push	{r7, lr}
 8017cce:	b08e      	sub	sp, #56	; 0x38
 8017cd0:	af02      	add	r7, sp, #8
 8017cd2:	60f8      	str	r0, [r7, #12]
 8017cd4:	607b      	str	r3, [r7, #4]
 8017cd6:	460b      	mov	r3, r1
 8017cd8:	72fb      	strb	r3, [r7, #11]
 8017cda:	4613      	mov	r3, r2
 8017cdc:	813b      	strh	r3, [r7, #8]
        Notify(PSTR("\r\nReadCapacity\r\n"), 0x80);
 8017cde:	f64e 3024 	movw	r0, #60196	; 0xeb24
 8017ce2:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017ce6:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017cea:	f001 fb63 	bl	80193b4 <_Z8E_NotifyPKci>
        Notify(PSTR("---------------\r\n"), 0x80);
 8017cee:	f64e 3038 	movw	r0, #60216	; 0xeb38
 8017cf2:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017cf6:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017cfa:	f001 fb5b 	bl	80193b4 <_Z8E_NotifyPKci>
        CommandBlockWrapper cbw;

        SetCurLUN(lun);
 8017cfe:	7afb      	ldrb	r3, [r7, #11]
 8017d00:	68f8      	ldr	r0, [r7, #12]
 8017d02:	4619      	mov	r1, r3
 8017d04:	f000 fea6 	bl	8018a54 <_ZN8BulkOnly9SetCurLUNEh>
        cbw.dCBWSignature = MASS_CBW_SIGNATURE;
 8017d08:	f245 3355 	movw	r3, #21333	; 0x5355
 8017d0c:	f2c4 3342 	movt	r3, #17218	; 0x4342
 8017d10:	613b      	str	r3, [r7, #16]
        cbw.dCBWTag = ++dCBWTag;
 8017d12:	68fb      	ldr	r3, [r7, #12]
 8017d14:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017d16:	f103 0201 	add.w	r2, r3, #1
 8017d1a:	68fb      	ldr	r3, [r7, #12]
 8017d1c:	625a      	str	r2, [r3, #36]	; 0x24
 8017d1e:	68fb      	ldr	r3, [r7, #12]
 8017d20:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017d22:	617b      	str	r3, [r7, #20]
        cbw.dCBWDataTransferLength = bsize;
 8017d24:	893b      	ldrh	r3, [r7, #8]
 8017d26:	61bb      	str	r3, [r7, #24]
        cbw.bmCBWFlags = MASS_CMD_DIR_IN;
 8017d28:	f04f 0380 	mov.w	r3, #128	; 0x80
 8017d2c:	773b      	strb	r3, [r7, #28]
        cbw.bmCBWLUN = lun;
 8017d2e:	7afb      	ldrb	r3, [r7, #11]
 8017d30:	f003 030f 	and.w	r3, r3, #15
 8017d34:	b2da      	uxtb	r2, r3
 8017d36:	7f7b      	ldrb	r3, [r7, #29]
 8017d38:	f362 0303 	bfi	r3, r2, #0, #4
 8017d3c:	777b      	strb	r3, [r7, #29]
        cbw.bmCBWCBLength = 10;
 8017d3e:	7fbb      	ldrb	r3, [r7, #30]
 8017d40:	f04f 020a 	mov.w	r2, #10
 8017d44:	f362 0303 	bfi	r3, r2, #0, #4
 8017d48:	77bb      	strb	r3, [r7, #30]

        for (uint8_t i = 0; i < 16; i++)
 8017d4a:	f04f 0300 	mov.w	r3, #0
 8017d4e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8017d52:	e00e      	b.n	8017d72 <_ZN8BulkOnly12ReadCapacityEhtPh+0xa6>
                cbw.CBWCB[i] = 0;
 8017d54:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8017d58:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8017d5c:	18d3      	adds	r3, r2, r3
 8017d5e:	f04f 0200 	mov.w	r2, #0
 8017d62:	f803 2c11 	strb.w	r2, [r3, #-17]
        cbw.dCBWDataTransferLength = bsize;
        cbw.bmCBWFlags = MASS_CMD_DIR_IN;
        cbw.bmCBWLUN = lun;
        cbw.bmCBWCBLength = 10;

        for (uint8_t i = 0; i < 16; i++)
 8017d66:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8017d6a:	f103 0301 	add.w	r3, r3, #1
 8017d6e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8017d72:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8017d76:	2b0f      	cmp	r3, #15
 8017d78:	bf8c      	ite	hi
 8017d7a:	2300      	movhi	r3, #0
 8017d7c:	2301      	movls	r3, #1
 8017d7e:	b2db      	uxtb	r3, r3
 8017d80:	2b00      	cmp	r3, #0
 8017d82:	d1e7      	bne.n	8017d54 <_ZN8BulkOnly12ReadCapacityEhtPh+0x88>
                cbw.CBWCB[i] = 0;

        cbw.CBWCB[0] = SCSI_CMD_READ_CAPACITY_10;
 8017d84:	f04f 0325 	mov.w	r3, #37	; 0x25
 8017d88:	77fb      	strb	r3, [r7, #31]
        cbw.CBWCB[1] = lun << 5;
 8017d8a:	7afb      	ldrb	r3, [r7, #11]
 8017d8c:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8017d90:	b2db      	uxtb	r3, r3
 8017d92:	f887 3020 	strb.w	r3, [r7, #32]

        return HandleSCSIError(Transaction(&cbw, bsize, buf, 0));
 8017d96:	f107 0210 	add.w	r2, r7, #16
 8017d9a:	893b      	ldrh	r3, [r7, #8]
 8017d9c:	f04f 0100 	mov.w	r1, #0
 8017da0:	9100      	str	r1, [sp, #0]
 8017da2:	68f8      	ldr	r0, [r7, #12]
 8017da4:	4611      	mov	r1, r2
 8017da6:	461a      	mov	r2, r3
 8017da8:	687b      	ldr	r3, [r7, #4]
 8017daa:	f000 fc03 	bl	80185b4 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh>
 8017dae:	4603      	mov	r3, r0
 8017db0:	68f8      	ldr	r0, [r7, #12]
 8017db2:	4619      	mov	r1, r3
 8017db4:	f000 fe6a 	bl	8018a8c <_ZN8BulkOnly15HandleSCSIErrorEh>
 8017db8:	4603      	mov	r3, r0
 8017dba:	e001      	b.n	8017dc0 <_ZN8BulkOnly12ReadCapacityEhtPh+0xf4>
 8017dbc:	f004 fe60 	bl	801ca80 <__cxa_end_cleanup>
}
 8017dc0:	4618      	mov	r0, r3
 8017dc2:	f107 0730 	add.w	r7, r7, #48	; 0x30
 8017dc6:	46bd      	mov	sp, r7
 8017dc8:	bd80      	pop	{r7, pc}
 8017dca:	bf00      	nop

08017dcc <_ZN8BulkOnly13TestUnitReadyEh>:
 * For driver use only.
 *
 * @param lun Logical Unit Number
 * @return
 */
uint8_t BulkOnly::TestUnitReady(uint8_t lun) {
 8017dcc:	b580      	push	{r7, lr}
 8017dce:	b08e      	sub	sp, #56	; 0x38
 8017dd0:	af02      	add	r7, sp, #8
 8017dd2:	6078      	str	r0, [r7, #4]
 8017dd4:	460b      	mov	r3, r1
 8017dd6:	70fb      	strb	r3, [r7, #3]
	SetCurLUN(lun);
 8017dd8:	78fb      	ldrb	r3, [r7, #3]
 8017dda:	6878      	ldr	r0, [r7, #4]
 8017ddc:	4619      	mov	r1, r3
 8017dde:	f000 fe39 	bl	8018a54 <_ZN8BulkOnly9SetCurLUNEh>
	if (!bAddress)
 8017de2:	687b      	ldr	r3, [r7, #4]
 8017de4:	7b1b      	ldrb	r3, [r3, #12]
 8017de6:	2b00      	cmp	r3, #0
 8017de8:	d102      	bne.n	8017df0 <_ZN8BulkOnly13TestUnitReadyEh+0x24>
		return MASS_ERR_UNIT_NOT_READY;
 8017dea:	f04f 0303 	mov.w	r3, #3
 8017dee:	e06a      	b.n	8017ec6 <_ZN8BulkOnly13TestUnitReadyEh+0xfa>

	Notify(PSTR("\r\nTestUnitReady\r\n"), 0x80);
 8017df0:	f64e 304c 	movw	r0, #60236	; 0xeb4c
 8017df4:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017df8:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017dfc:	f001 fada 	bl	80193b4 <_Z8E_NotifyPKci>
	Notify(PSTR("-----------------\r\n"), 0x80);
 8017e00:	f64e 1000 	movw	r0, #59648	; 0xe900
 8017e04:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017e08:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017e0c:	f001 fad2 	bl	80193b4 <_Z8E_NotifyPKci>

	CommandBlockWrapper cbw;
	uint8_t rc;

	cbw.dCBWSignature = MASS_CBW_SIGNATURE;
 8017e10:	f245 3355 	movw	r3, #21333	; 0x5355
 8017e14:	f2c4 3342 	movt	r3, #17218	; 0x4342
 8017e18:	60fb      	str	r3, [r7, #12]
	cbw.dCBWTag = ++dCBWTag;
 8017e1a:	687b      	ldr	r3, [r7, #4]
 8017e1c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017e1e:	f103 0201 	add.w	r2, r3, #1
 8017e22:	687b      	ldr	r3, [r7, #4]
 8017e24:	625a      	str	r2, [r3, #36]	; 0x24
 8017e26:	687b      	ldr	r3, [r7, #4]
 8017e28:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017e2a:	613b      	str	r3, [r7, #16]
	cbw.dCBWDataTransferLength = 0;
 8017e2c:	f04f 0300 	mov.w	r3, #0
 8017e30:	617b      	str	r3, [r7, #20]
	cbw.bmCBWFlags = MASS_CMD_DIR_OUT;
 8017e32:	f04f 0300 	mov.w	r3, #0
 8017e36:	763b      	strb	r3, [r7, #24]
	cbw.bmCBWLUN = lun;
 8017e38:	78fb      	ldrb	r3, [r7, #3]
 8017e3a:	f003 030f 	and.w	r3, r3, #15
 8017e3e:	b2da      	uxtb	r2, r3
 8017e40:	7e7b      	ldrb	r3, [r7, #25]
 8017e42:	f362 0303 	bfi	r3, r2, #0, #4
 8017e46:	767b      	strb	r3, [r7, #25]
	cbw.bmCBWCBLength = 6;
 8017e48:	7ebb      	ldrb	r3, [r7, #26]
 8017e4a:	f04f 0206 	mov.w	r2, #6
 8017e4e:	f362 0303 	bfi	r3, r2, #0, #4
 8017e52:	76bb      	strb	r3, [r7, #26]

	for (uint8_t i = 0; i < 16; i++)
 8017e54:	f04f 0300 	mov.w	r3, #0
 8017e58:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8017e5c:	e00e      	b.n	8017e7c <_ZN8BulkOnly13TestUnitReadyEh+0xb0>
		cbw.CBWCB[i] = 0;
 8017e5e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8017e62:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8017e66:	18d3      	adds	r3, r2, r3
 8017e68:	f04f 0200 	mov.w	r2, #0
 8017e6c:	f803 2c15 	strb.w	r2, [r3, #-21]
	cbw.dCBWDataTransferLength = 0;
	cbw.bmCBWFlags = MASS_CMD_DIR_OUT;
	cbw.bmCBWLUN = lun;
	cbw.bmCBWCBLength = 6;

	for (uint8_t i = 0; i < 16; i++)
 8017e70:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8017e74:	f103 0301 	add.w	r3, r3, #1
 8017e78:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8017e7c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8017e80:	2b0f      	cmp	r3, #15
 8017e82:	bf8c      	ite	hi
 8017e84:	2300      	movhi	r3, #0
 8017e86:	2301      	movls	r3, #1
 8017e88:	b2db      	uxtb	r3, r3
 8017e8a:	2b00      	cmp	r3, #0
 8017e8c:	d1e7      	bne.n	8017e5e <_ZN8BulkOnly13TestUnitReadyEh+0x92>
		cbw.CBWCB[i] = 0;

	cbw.CBWCB[0] = SCSI_CMD_TEST_UNIT_READY;
 8017e8e:	f04f 0300 	mov.w	r3, #0
 8017e92:	76fb      	strb	r3, [r7, #27]
	cbw.CBWCB[1] = lun;
 8017e94:	78fb      	ldrb	r3, [r7, #3]
 8017e96:	773b      	strb	r3, [r7, #28]
	rc = HandleSCSIError(Transaction(&cbw, 0, NULL, 0));
 8017e98:	f107 030c 	add.w	r3, r7, #12
 8017e9c:	f04f 0200 	mov.w	r2, #0
 8017ea0:	9200      	str	r2, [sp, #0]
 8017ea2:	6878      	ldr	r0, [r7, #4]
 8017ea4:	4619      	mov	r1, r3
 8017ea6:	f04f 0200 	mov.w	r2, #0
 8017eaa:	f04f 0300 	mov.w	r3, #0
 8017eae:	f000 fb81 	bl	80185b4 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh>
 8017eb2:	4603      	mov	r3, r0
 8017eb4:	6878      	ldr	r0, [r7, #4]
 8017eb6:	4619      	mov	r1, r3
 8017eb8:	f000 fde8 	bl	8018a8c <_ZN8BulkOnly15HandleSCSIErrorEh>
 8017ebc:	4603      	mov	r3, r0
 8017ebe:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
	return (rc);
 8017ec2:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8017ec6:	e001      	b.n	8017ecc <_ZN8BulkOnly13TestUnitReadyEh+0x100>
 8017ec8:	f004 fdda 	bl	801ca80 <__cxa_end_cleanup>
}
 8017ecc:	4618      	mov	r0, r3
 8017ece:	f107 0730 	add.w	r7, r7, #48	; 0x30
 8017ed2:	46bd      	mov	sp, r7
 8017ed4:	bd80      	pop	{r7, pc}
 8017ed6:	bf00      	nop

08017ed8 <_ZN8BulkOnly6Page3FEh>:
 * Page 3F contains write protect status.
 *
 * @param lun Logical Unit Number to test.
 * @return Write protect switch status.
 */
uint8_t BulkOnly::Page3F(uint8_t lun) {
 8017ed8:	b580      	push	{r7, lr}
 8017eda:	b0ba      	sub	sp, #232	; 0xe8
 8017edc:	af04      	add	r7, sp, #16
 8017ede:	6078      	str	r0, [r7, #4]
 8017ee0:	460b      	mov	r3, r1
 8017ee2:	70fb      	strb	r3, [r7, #3]
        uint8_t buf[192];
        for (int i = 0; i < 192; i++) {
 8017ee4:	f04f 0300 	mov.w	r3, #0
 8017ee8:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 8017eec:	e00d      	b.n	8017f0a <_ZN8BulkOnly6Page3FEh+0x32>
                buf[i] = 0x00;
 8017eee:	f107 020c 	add.w	r2, r7, #12
 8017ef2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8017ef6:	18d3      	adds	r3, r2, r3
 8017ef8:	f04f 0200 	mov.w	r2, #0
 8017efc:	701a      	strb	r2, [r3, #0]
 * @param lun Logical Unit Number to test.
 * @return Write protect switch status.
 */
uint8_t BulkOnly::Page3F(uint8_t lun) {
        uint8_t buf[192];
        for (int i = 0; i < 192; i++) {
 8017efe:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8017f02:	f103 0301 	add.w	r3, r3, #1
 8017f06:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 8017f0a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8017f0e:	2bbf      	cmp	r3, #191	; 0xbf
 8017f10:	bfcc      	ite	gt
 8017f12:	2300      	movgt	r3, #0
 8017f14:	2301      	movle	r3, #1
 8017f16:	b2db      	uxtb	r3, r3
 8017f18:	2b00      	cmp	r3, #0
 8017f1a:	d1e8      	bne.n	8017eee <_ZN8BulkOnly6Page3FEh+0x16>
                buf[i] = 0x00;
        }
        WriteOk[lun] = true;
 8017f1c:	78fb      	ldrb	r3, [r7, #3]
 8017f1e:	687a      	ldr	r2, [r7, #4]
 8017f20:	18d3      	adds	r3, r2, r3
 8017f22:	f04f 0201 	mov.w	r2, #1
 8017f26:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
        uint8_t rc = ModeSense(lun, 0, 0x3f, 0, 192, buf);
 8017f2a:	78fb      	ldrb	r3, [r7, #3]
 8017f2c:	f04f 0200 	mov.w	r2, #0
 8017f30:	9200      	str	r2, [sp, #0]
 8017f32:	f04f 02c0 	mov.w	r2, #192	; 0xc0
 8017f36:	9201      	str	r2, [sp, #4]
 8017f38:	f107 020c 	add.w	r2, r7, #12
 8017f3c:	9202      	str	r2, [sp, #8]
 8017f3e:	6878      	ldr	r0, [r7, #4]
 8017f40:	4619      	mov	r1, r3
 8017f42:	f04f 0200 	mov.w	r2, #0
 8017f46:	f04f 033f 	mov.w	r3, #63	; 0x3f
 8017f4a:	f000 fcfb 	bl	8018944 <_ZN8BulkOnly9ModeSenseEhhhhhPh>
 8017f4e:	4603      	mov	r3, r0
 8017f50:	f887 30cf 	strb.w	r3, [r7, #207]	; 0xcf
        if (!rc) {
 8017f54:	f897 30cf 	ldrb.w	r3, [r7, #207]	; 0xcf
 8017f58:	2b00      	cmp	r3, #0
 8017f5a:	d143      	bne.n	8017fe4 <_ZN8BulkOnly6Page3FEh+0x10c>
                WriteOk[lun] = ((buf[2] & 0x80) == 0);
 8017f5c:	78fb      	ldrb	r3, [r7, #3]
 8017f5e:	7bba      	ldrb	r2, [r7, #14]
 8017f60:	b2d2      	uxtb	r2, r2
 8017f62:	ea6f 0202 	mvn.w	r2, r2
 8017f66:	b2d2      	uxtb	r2, r2
 8017f68:	ea4f 12d2 	mov.w	r2, r2, lsr #7
 8017f6c:	b2d2      	uxtb	r2, r2
 8017f6e:	6879      	ldr	r1, [r7, #4]
 8017f70:	18cb      	adds	r3, r1, r3
 8017f72:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
                Notify(PSTR("Mode Sense: "), 0x80);
 8017f76:	f64e 3060 	movw	r0, #60256	; 0xeb60
 8017f7a:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017f7e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017f82:	f001 fa17 	bl	80193b4 <_Z8E_NotifyPKci>
                for (int i = 0; i < 4; i++) {
 8017f86:	f04f 0300 	mov.w	r3, #0
 8017f8a:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 8017f8e:	e018      	b.n	8017fc2 <_ZN8BulkOnly6Page3FEh+0xea>
                        D_PrintHex<uint8_t > (buf[i], 0x80);
 8017f90:	f107 020c 	add.w	r2, r7, #12
 8017f94:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8017f98:	18d3      	adds	r3, r2, r3
 8017f9a:	781b      	ldrb	r3, [r3, #0]
 8017f9c:	4618      	mov	r0, r3
 8017f9e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017fa2:	f7fd ff71 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
                        Notify(PSTR(" "), 0x80);
 8017fa6:	f64e 3070 	movw	r0, #60272	; 0xeb70
 8017faa:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017fae:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017fb2:	f001 f9ff 	bl	80193b4 <_Z8E_NotifyPKci>
        WriteOk[lun] = true;
        uint8_t rc = ModeSense(lun, 0, 0x3f, 0, 192, buf);
        if (!rc) {
                WriteOk[lun] = ((buf[2] & 0x80) == 0);
                Notify(PSTR("Mode Sense: "), 0x80);
                for (int i = 0; i < 4; i++) {
 8017fb6:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8017fba:	f103 0301 	add.w	r3, r3, #1
 8017fbe:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 8017fc2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8017fc6:	2b03      	cmp	r3, #3
 8017fc8:	bfcc      	ite	gt
 8017fca:	2300      	movgt	r3, #0
 8017fcc:	2301      	movle	r3, #1
 8017fce:	b2db      	uxtb	r3, r3
 8017fd0:	2b00      	cmp	r3, #0
 8017fd2:	d1dd      	bne.n	8017f90 <_ZN8BulkOnly6Page3FEh+0xb8>
                        D_PrintHex<uint8_t > (buf[i], 0x80);
                        Notify(PSTR(" "), 0x80);
                }
                Notify(PSTR("\r\n"), 0x80);
 8017fd4:	f64e 10a8 	movw	r0, #59816	; 0xe9a8
 8017fd8:	f6c0 0001 	movt	r0, #2049	; 0x801
 8017fdc:	f04f 0180 	mov.w	r1, #128	; 0x80
 8017fe0:	f001 f9e8 	bl	80193b4 <_Z8E_NotifyPKci>
        }
        return rc;
 8017fe4:	f897 30cf 	ldrb.w	r3, [r7, #207]	; 0xcf
 8017fe8:	e001      	b.n	8017fee <_ZN8BulkOnly6Page3FEh+0x116>
 8017fea:	f004 fd49 	bl	801ca80 <__cxa_end_cleanup>
}
 8017fee:	4618      	mov	r0, r3
 8017ff0:	f107 07d8 	add.w	r7, r7, #216	; 0xd8
 8017ff4:	46bd      	mov	sp, r7
 8017ff6:	bd80      	pop	{r7, pc}

08017ff8 <_ZN8BulkOnly11ClearEpHaltEh>:
 * For driver use only.
 *
 * @param index
 * @return
 */
uint8_t BulkOnly::ClearEpHalt(uint8_t index) {
 8017ff8:	b590      	push	{r4, r7, lr}
 8017ffa:	b08d      	sub	sp, #52	; 0x34
 8017ffc:	af08      	add	r7, sp, #32
 8017ffe:	6078      	str	r0, [r7, #4]
 8018000:	460b      	mov	r3, r1
 8018002:	70fb      	strb	r3, [r7, #3]
        if (index == 0)
 8018004:	78fb      	ldrb	r3, [r7, #3]
 8018006:	2b00      	cmp	r3, #0
 8018008:	d102      	bne.n	8018010 <_ZN8BulkOnly11ClearEpHaltEh+0x18>
			return 0;
 801800a:	f04f 0300 	mov.w	r3, #0
 801800e:	e0a1      	b.n	8018154 <_ZN8BulkOnly11ClearEpHaltEh+0x15c>

        uint8_t ret = 0;
 8018010:	f04f 0300 	mov.w	r3, #0
 8018014:	73fb      	strb	r3, [r7, #15]

        while (ret = (pUsb->ctrlReq(bAddress, 0, USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_ENDPOINT,
 8018016:	e008      	b.n	801802a <_ZN8BulkOnly11ClearEpHaltEh+0x32>
                USB_REQUEST_CLEAR_FEATURE, USB_FEATURE_ENDPOINT_HALT, 0, ((index == epDataInIndex) ? (0x80 | epInfo[index].epAddr) : epInfo[index].epAddr), 0, 0, NULL, NULL))
                == 0x01) delay_ms(6);
 8018018:	f243 630c 	movw	r3, #13836	; 0x360c
 801801c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018020:	681b      	ldr	r3, [r3, #0]
 8018022:	685b      	ldr	r3, [r3, #4]
 8018024:	f04f 0006 	mov.w	r0, #6
 8018028:	4798      	blx	r3
			return 0;

        uint8_t ret = 0;

        while (ret = (pUsb->ctrlReq(bAddress, 0, USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_ENDPOINT,
                USB_REQUEST_CLEAR_FEATURE, USB_FEATURE_ENDPOINT_HALT, 0, ((index == epDataInIndex) ? (0x80 | epInfo[index].epAddr) : epInfo[index].epAddr), 0, 0, NULL, NULL))
 801802a:	687b      	ldr	r3, [r7, #4]
 801802c:	6898      	ldr	r0, [r3, #8]
 801802e:	687b      	ldr	r3, [r7, #4]
 8018030:	7b19      	ldrb	r1, [r3, #12]
 8018032:	78fb      	ldrb	r3, [r7, #3]
 8018034:	2b01      	cmp	r3, #1
 8018036:	d10d      	bne.n	8018054 <_ZN8BulkOnly11ClearEpHaltEh+0x5c>
 8018038:	78fa      	ldrb	r2, [r7, #3]
 801803a:	687c      	ldr	r4, [r7, #4]
 801803c:	4613      	mov	r3, r2
 801803e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8018042:	189b      	adds	r3, r3, r2
 8018044:	18e3      	adds	r3, r4, r3
 8018046:	f103 0310 	add.w	r3, r3, #16
 801804a:	795b      	ldrb	r3, [r3, #5]
 801804c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8018050:	b2db      	uxtb	r3, r3
 8018052:	e009      	b.n	8018068 <_ZN8BulkOnly11ClearEpHaltEh+0x70>
 8018054:	78fa      	ldrb	r2, [r7, #3]
 8018056:	687c      	ldr	r4, [r7, #4]
 8018058:	4613      	mov	r3, r2
 801805a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801805e:	189b      	adds	r3, r3, r2
 8018060:	18e3      	adds	r3, r4, r3
 8018062:	f103 0310 	add.w	r3, r3, #16
 8018066:	795b      	ldrb	r3, [r3, #5]
 8018068:	f04f 0201 	mov.w	r2, #1
 801806c:	9200      	str	r2, [sp, #0]
 801806e:	f04f 0200 	mov.w	r2, #0
 8018072:	9201      	str	r2, [sp, #4]
 8018074:	f04f 0200 	mov.w	r2, #0
 8018078:	9202      	str	r2, [sp, #8]
 801807a:	9303      	str	r3, [sp, #12]
 801807c:	f04f 0300 	mov.w	r3, #0
 8018080:	9304      	str	r3, [sp, #16]
 8018082:	f04f 0300 	mov.w	r3, #0
 8018086:	9305      	str	r3, [sp, #20]
 8018088:	f04f 0300 	mov.w	r3, #0
 801808c:	9306      	str	r3, [sp, #24]
 801808e:	f04f 0300 	mov.w	r3, #0
 8018092:	9307      	str	r3, [sp, #28]
 8018094:	f04f 0200 	mov.w	r2, #0
 8018098:	f04f 0302 	mov.w	r3, #2
 801809c:	f7fc fb02 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 80180a0:	4603      	mov	r3, r0
        if (index == 0)
			return 0;

        uint8_t ret = 0;

        while (ret = (pUsb->ctrlReq(bAddress, 0, USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_ENDPOINT,
 80180a2:	2b01      	cmp	r3, #1
 80180a4:	bf14      	ite	ne
 80180a6:	2300      	movne	r3, #0
 80180a8:	2301      	moveq	r3, #1
 80180aa:	b2db      	uxtb	r3, r3
 80180ac:	73fb      	strb	r3, [r7, #15]
 80180ae:	7bfb      	ldrb	r3, [r7, #15]
 80180b0:	2b00      	cmp	r3, #0
 80180b2:	bf0c      	ite	eq
 80180b4:	2300      	moveq	r3, #0
 80180b6:	2301      	movne	r3, #1
 80180b8:	b2db      	uxtb	r3, r3
 80180ba:	2b00      	cmp	r3, #0
 80180bc:	d1ac      	bne.n	8018018 <_ZN8BulkOnly11ClearEpHaltEh+0x20>
                USB_REQUEST_CLEAR_FEATURE, USB_FEATURE_ENDPOINT_HALT, 0, ((index == epDataInIndex) ? (0x80 | epInfo[index].epAddr) : epInfo[index].epAddr), 0, 0, NULL, NULL))
                == 0x01) delay_ms(6);

        if (ret) {
 80180be:	7bfb      	ldrb	r3, [r7, #15]
 80180c0:	2b00      	cmp	r3, #0
 80180c2:	d02b      	beq.n	801811c <_ZN8BulkOnly11ClearEpHaltEh+0x124>
                ErrorMessage<uint8_t > (PSTR("ClearEpHalt"), ret);
 80180c4:	7bfb      	ldrb	r3, [r7, #15]
 80180c6:	f64e 3074 	movw	r0, #60276	; 0xeb74
 80180ca:	f6c0 0001 	movt	r0, #2049	; 0x801
 80180ce:	4619      	mov	r1, r3
 80180d0:	f000 fed6 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                ErrorMessage<uint8_t > (PSTR("EP"), ((index == epDataInIndex) ? (0x80 | epInfo[index].epAddr) : epInfo[index].epAddr));
 80180d4:	78fb      	ldrb	r3, [r7, #3]
 80180d6:	2b01      	cmp	r3, #1
 80180d8:	d10d      	bne.n	80180f6 <_ZN8BulkOnly11ClearEpHaltEh+0xfe>
 80180da:	78fa      	ldrb	r2, [r7, #3]
 80180dc:	6879      	ldr	r1, [r7, #4]
 80180de:	4613      	mov	r3, r2
 80180e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80180e4:	189b      	adds	r3, r3, r2
 80180e6:	18cb      	adds	r3, r1, r3
 80180e8:	f103 0310 	add.w	r3, r3, #16
 80180ec:	795b      	ldrb	r3, [r3, #5]
 80180ee:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80180f2:	b2db      	uxtb	r3, r3
 80180f4:	e009      	b.n	801810a <_ZN8BulkOnly11ClearEpHaltEh+0x112>
 80180f6:	78fa      	ldrb	r2, [r7, #3]
 80180f8:	6879      	ldr	r1, [r7, #4]
 80180fa:	4613      	mov	r3, r2
 80180fc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8018100:	189b      	adds	r3, r3, r2
 8018102:	18cb      	adds	r3, r1, r3
 8018104:	f103 0310 	add.w	r3, r3, #16
 8018108:	795b      	ldrb	r3, [r3, #5]
 801810a:	f64e 3080 	movw	r0, #60288	; 0xeb80
 801810e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018112:	4619      	mov	r1, r3
 8018114:	f000 feb4 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                return ret;
 8018118:	7bfb      	ldrb	r3, [r7, #15]
 801811a:	e01b      	b.n	8018154 <_ZN8BulkOnly11ClearEpHaltEh+0x15c>
        }
        epInfo[index].bmSndToggle = 0;
 801811c:	78fa      	ldrb	r2, [r7, #3]
 801811e:	6879      	ldr	r1, [r7, #4]
 8018120:	4613      	mov	r3, r2
 8018122:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8018126:	189b      	adds	r3, r3, r2
 8018128:	18cb      	adds	r3, r1, r3
 801812a:	f103 0210 	add.w	r2, r3, #16
 801812e:	7a53      	ldrb	r3, [r2, #9]
 8018130:	f36f 0300 	bfc	r3, #0, #1
 8018134:	7253      	strb	r3, [r2, #9]
        epInfo[index].bmRcvToggle = 0;
 8018136:	78fa      	ldrb	r2, [r7, #3]
 8018138:	6879      	ldr	r1, [r7, #4]
 801813a:	4613      	mov	r3, r2
 801813c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8018140:	189b      	adds	r3, r3, r2
 8018142:	18cb      	adds	r3, r1, r3
 8018144:	f103 0210 	add.w	r2, r3, #16
 8018148:	7a53      	ldrb	r3, [r2, #9]
 801814a:	f36f 0341 	bfc	r3, #1, #1
 801814e:	7253      	strb	r3, [r2, #9]
        // todo : need reconsider
        //USB_OTG_CORE_HANDLE *pdev = pUsb->coreConfig;
       //pdev->host.hc[epInfo[index].hcNumIn].toggle_in = 0;
        //pdev->host.hc[epInfo[index].hcNumOut].toggle_out = 0;
        // epAttribs = 0;
        return 0;
 8018150:	f04f 0300 	mov.w	r3, #0
}
 8018154:	4618      	mov	r0, r3
 8018156:	f107 0714 	add.w	r7, r7, #20
 801815a:	46bd      	mov	sp, r7
 801815c:	bd90      	pop	{r4, r7, pc}
 801815e:	bf00      	nop

08018160 <_ZN8BulkOnly5ResetEv>:

/**
 * For driver use only.
 *
 */
void BulkOnly::Reset() {
 8018160:	b580      	push	{r7, lr}
 8018162:	b08a      	sub	sp, #40	; 0x28
 8018164:	af08      	add	r7, sp, #32
 8018166:	6078      	str	r0, [r7, #4]
        while (pUsb->ctrlReq(bAddress, 0, bmREQ_MASSOUT, MASS_REQ_BOMSR, 0, 0, bIface, 0, 0, NULL, NULL) == 0x01) delay_ms(6);
 8018168:	e008      	b.n	801817c <_ZN8BulkOnly5ResetEv+0x1c>
 801816a:	f243 630c 	movw	r3, #13836	; 0x360c
 801816e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018172:	681b      	ldr	r3, [r3, #0]
 8018174:	685b      	ldr	r3, [r3, #4]
 8018176:	f04f 0006 	mov.w	r0, #6
 801817a:	4798      	blx	r3
 801817c:	687b      	ldr	r3, [r7, #4]
 801817e:	689a      	ldr	r2, [r3, #8]
 8018180:	687b      	ldr	r3, [r7, #4]
 8018182:	7b1b      	ldrb	r3, [r3, #12]
 8018184:	6879      	ldr	r1, [r7, #4]
 8018186:	7b89      	ldrb	r1, [r1, #14]
 8018188:	f04f 00ff 	mov.w	r0, #255	; 0xff
 801818c:	9000      	str	r0, [sp, #0]
 801818e:	f04f 0000 	mov.w	r0, #0
 8018192:	9001      	str	r0, [sp, #4]
 8018194:	f04f 0000 	mov.w	r0, #0
 8018198:	9002      	str	r0, [sp, #8]
 801819a:	9103      	str	r1, [sp, #12]
 801819c:	f04f 0100 	mov.w	r1, #0
 80181a0:	9104      	str	r1, [sp, #16]
 80181a2:	f04f 0100 	mov.w	r1, #0
 80181a6:	9105      	str	r1, [sp, #20]
 80181a8:	f04f 0100 	mov.w	r1, #0
 80181ac:	9106      	str	r1, [sp, #24]
 80181ae:	f04f 0100 	mov.w	r1, #0
 80181b2:	9107      	str	r1, [sp, #28]
 80181b4:	4610      	mov	r0, r2
 80181b6:	4619      	mov	r1, r3
 80181b8:	f04f 0200 	mov.w	r2, #0
 80181bc:	f04f 0321 	mov.w	r3, #33	; 0x21
 80181c0:	f7fc fa70 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 80181c4:	4603      	mov	r3, r0
 80181c6:	2b01      	cmp	r3, #1
 80181c8:	bf14      	ite	ne
 80181ca:	2300      	movne	r3, #0
 80181cc:	2301      	moveq	r3, #1
 80181ce:	b2db      	uxtb	r3, r3
 80181d0:	2b00      	cmp	r3, #0
 80181d2:	d1ca      	bne.n	801816a <_ZN8BulkOnly5ResetEv+0xa>
}
 80181d4:	f107 0708 	add.w	r7, r7, #8
 80181d8:	46bd      	mov	sp, r7
 80181da:	bd80      	pop	{r7, pc}

080181dc <_ZN8BulkOnly13ResetRecoveryEv>:
/**
 * For driver use only.
 *
 * @return 0 if successful
 */
uint8_t BulkOnly::ResetRecovery() {
 80181dc:	b580      	push	{r7, lr}
 80181de:	b082      	sub	sp, #8
 80181e0:	af00      	add	r7, sp, #0
 80181e2:	6078      	str	r0, [r7, #4]
        Notify(PSTR("\r\nResetRecovery\r\n"), 0x80);
 80181e4:	f64e 3084 	movw	r0, #60292	; 0xeb84
 80181e8:	f6c0 0001 	movt	r0, #2049	; 0x801
 80181ec:	f04f 0180 	mov.w	r1, #128	; 0x80
 80181f0:	f001 f8e0 	bl	80193b4 <_Z8E_NotifyPKci>
        Notify(PSTR("-----------------\r\n"), 0x80);
 80181f4:	f64e 1000 	movw	r0, #59648	; 0xe900
 80181f8:	f6c0 0001 	movt	r0, #2049	; 0x801
 80181fc:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018200:	f001 f8d8 	bl	80193b4 <_Z8E_NotifyPKci>
        //todo: need reconsider
        //USB_OTG_CORE_HANDLE *pdev = pUsb->coreConfig;
        //USB_OTG_StopHost(pdev);

        delay_ms(6);
 8018204:	f243 630c 	movw	r3, #13836	; 0x360c
 8018208:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801820c:	681b      	ldr	r3, [r3, #0]
 801820e:	685b      	ldr	r3, [r3, #4]
 8018210:	f04f 0006 	mov.w	r0, #6
 8018214:	4798      	blx	r3
        Reset();
 8018216:	6878      	ldr	r0, [r7, #4]
 8018218:	f7ff ffa2 	bl	8018160 <_ZN8BulkOnly5ResetEv>
        delay_ms(6);
 801821c:	f243 630c 	movw	r3, #13836	; 0x360c
 8018220:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018224:	681b      	ldr	r3, [r3, #0]
 8018226:	685b      	ldr	r3, [r3, #4]
 8018228:	f04f 0006 	mov.w	r0, #6
 801822c:	4798      	blx	r3
        ClearEpHalt(epDataInIndex);
 801822e:	6878      	ldr	r0, [r7, #4]
 8018230:	f04f 0101 	mov.w	r1, #1
 8018234:	f7ff fee0 	bl	8017ff8 <_ZN8BulkOnly11ClearEpHaltEh>
        delay_ms(6);
 8018238:	f243 630c 	movw	r3, #13836	; 0x360c
 801823c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018240:	681b      	ldr	r3, [r3, #0]
 8018242:	685b      	ldr	r3, [r3, #4]
 8018244:	f04f 0006 	mov.w	r0, #6
 8018248:	4798      	blx	r3
        bLastUsbError = ClearEpHalt(epDataOutIndex);
 801824a:	6878      	ldr	r0, [r7, #4]
 801824c:	f04f 0102 	mov.w	r1, #2
 8018250:	f7ff fed2 	bl	8017ff8 <_ZN8BulkOnly11ClearEpHaltEh>
 8018254:	4603      	mov	r3, r0
 8018256:	461a      	mov	r2, r3
 8018258:	687b      	ldr	r3, [r7, #4]
 801825a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
        delay_ms(6);
 801825e:	f243 630c 	movw	r3, #13836	; 0x360c
 8018262:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018266:	681b      	ldr	r3, [r3, #0]
 8018268:	685b      	ldr	r3, [r3, #4]
 801826a:	f04f 0006 	mov.w	r0, #6
 801826e:	4798      	blx	r3
        return bLastUsbError;
 8018270:	687b      	ldr	r3, [r7, #4]
 8018272:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
}
 8018276:	4618      	mov	r0, r3
 8018278:	f107 0708 	add.w	r7, r7, #8
 801827c:	46bd      	mov	sp, r7
 801827e:	bd80      	pop	{r7, pc}

08018280 <_ZN8BulkOnly10ClearAllEPEv>:
/**
 * For driver use only.
 *
 * Clear all EP data and clear all LUN status
 */
void BulkOnly::ClearAllEP() {
 8018280:	b480      	push	{r7}
 8018282:	b085      	sub	sp, #20
 8018284:	af00      	add	r7, sp, #0
 8018286:	6078      	str	r0, [r7, #4]
	for (uint8_t i = 0; i < MASS_MAX_ENDPOINTS; i++) {
 8018288:	f04f 0300 	mov.w	r3, #0
 801828c:	73fb      	strb	r3, [r7, #15]
 801828e:	e048      	b.n	8018322 <_ZN8BulkOnly10ClearAllEPEv+0xa2>
		epInfo[i].epAddr = 0;
 8018290:	7bfa      	ldrb	r2, [r7, #15]
 8018292:	6879      	ldr	r1, [r7, #4]
 8018294:	4613      	mov	r3, r2
 8018296:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801829a:	189b      	adds	r3, r3, r2
 801829c:	18cb      	adds	r3, r1, r3
 801829e:	f103 0310 	add.w	r3, r3, #16
 80182a2:	f04f 0200 	mov.w	r2, #0
 80182a6:	715a      	strb	r2, [r3, #5]
		epInfo[i].maxPktSize = (i) ? 0 : 8;
 80182a8:	7bf9      	ldrb	r1, [r7, #15]
 80182aa:	7bfb      	ldrb	r3, [r7, #15]
 80182ac:	2b00      	cmp	r3, #0
 80182ae:	d002      	beq.n	80182b6 <_ZN8BulkOnly10ClearAllEPEv+0x36>
 80182b0:	f04f 0200 	mov.w	r2, #0
 80182b4:	e001      	b.n	80182ba <_ZN8BulkOnly10ClearAllEPEv+0x3a>
 80182b6:	f04f 0208 	mov.w	r2, #8
 80182ba:	6878      	ldr	r0, [r7, #4]
 80182bc:	460b      	mov	r3, r1
 80182be:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80182c2:	185b      	adds	r3, r3, r1
 80182c4:	18c3      	adds	r3, r0, r3
 80182c6:	f103 0310 	add.w	r3, r3, #16
 80182ca:	719a      	strb	r2, [r3, #6]
		epInfo[i].epAttribs = 0;
 80182cc:	7bfa      	ldrb	r2, [r7, #15]
 80182ce:	6879      	ldr	r1, [r7, #4]
 80182d0:	4613      	mov	r3, r2
 80182d2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80182d6:	189b      	adds	r3, r3, r2
 80182d8:	18cb      	adds	r3, r1, r3
 80182da:	f103 0310 	add.w	r3, r3, #16
 80182de:	f04f 0200 	mov.w	r2, #0
 80182e2:	725a      	strb	r2, [r3, #9]
		epInfo[i].bmNakPower = USB_NAK_DEFAULT;
 80182e4:	7bfa      	ldrb	r2, [r7, #15]
 80182e6:	6879      	ldr	r1, [r7, #4]
 80182e8:	4613      	mov	r3, r2
 80182ea:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80182ee:	189b      	adds	r3, r3, r2
 80182f0:	18cb      	adds	r3, r1, r3
 80182f2:	f103 0210 	add.w	r2, r3, #16
 80182f6:	7a53      	ldrb	r3, [r2, #9]
 80182f8:	f04f 010e 	mov.w	r1, #14
 80182fc:	f361 0387 	bfi	r3, r1, #2, #6
 8018300:	7253      	strb	r3, [r2, #9]
		epInfo[i].hcNumber = 0;
 8018302:	7bfa      	ldrb	r2, [r7, #15]
 8018304:	6879      	ldr	r1, [r7, #4]
 8018306:	4613      	mov	r3, r2
 8018308:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801830c:	189b      	adds	r3, r3, r2
 801830e:	18cb      	adds	r3, r1, r3
 8018310:	f103 0310 	add.w	r3, r3, #16
 8018314:	f04f 0200 	mov.w	r2, #0
 8018318:	721a      	strb	r2, [r3, #8]
 * For driver use only.
 *
 * Clear all EP data and clear all LUN status
 */
void BulkOnly::ClearAllEP() {
	for (uint8_t i = 0; i < MASS_MAX_ENDPOINTS; i++) {
 801831a:	7bfb      	ldrb	r3, [r7, #15]
 801831c:	f103 0301 	add.w	r3, r3, #1
 8018320:	73fb      	strb	r3, [r7, #15]
 8018322:	7bfb      	ldrb	r3, [r7, #15]
 8018324:	2b02      	cmp	r3, #2
 8018326:	bf8c      	ite	hi
 8018328:	2300      	movhi	r3, #0
 801832a:	2301      	movls	r3, #1
 801832c:	b2db      	uxtb	r3, r3
 801832e:	2b00      	cmp	r3, #0
 8018330:	d1ae      	bne.n	8018290 <_ZN8BulkOnly10ClearAllEPEv+0x10>
		epInfo[i].epAttribs = 0;
		epInfo[i].bmNakPower = USB_NAK_DEFAULT;
		epInfo[i].hcNumber = 0;
	}

	for (uint8_t i = 0; i < MASS_MAX_SUPPORTED_LUN; i++) {
 8018332:	f04f 0300 	mov.w	r3, #0
 8018336:	73bb      	strb	r3, [r7, #14]
 8018338:	e021      	b.n	801837e <_ZN8BulkOnly10ClearAllEPEv+0xfe>
		LUNOk[i] = false;
 801833a:	7bbb      	ldrb	r3, [r7, #14]
 801833c:	687a      	ldr	r2, [r7, #4]
 801833e:	18d3      	adds	r3, r2, r3
 8018340:	f04f 0200 	mov.w	r2, #0
 8018344:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
		WriteOk[i] = false;
 8018348:	7bbb      	ldrb	r3, [r7, #14]
 801834a:	687a      	ldr	r2, [r7, #4]
 801834c:	18d3      	adds	r3, r2, r3
 801834e:	f04f 0200 	mov.w	r2, #0
 8018352:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
		CurrentCapacity[i] = 0lu;
 8018356:	7bba      	ldrb	r2, [r7, #14]
 8018358:	687b      	ldr	r3, [r7, #4]
 801835a:	f102 020c 	add.w	r2, r2, #12
 801835e:	f04f 0100 	mov.w	r1, #0
 8018362:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		CurrentSectorSize[i] = 0;
 8018366:	7bba      	ldrb	r2, [r7, #14]
 8018368:	687b      	ldr	r3, [r7, #4]
 801836a:	f102 0228 	add.w	r2, r2, #40	; 0x28
 801836e:	f04f 0100 	mov.w	r1, #0
 8018372:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
		epInfo[i].epAttribs = 0;
		epInfo[i].bmNakPower = USB_NAK_DEFAULT;
		epInfo[i].hcNumber = 0;
	}

	for (uint8_t i = 0; i < MASS_MAX_SUPPORTED_LUN; i++) {
 8018376:	7bbb      	ldrb	r3, [r7, #14]
 8018378:	f103 0301 	add.w	r3, r3, #1
 801837c:	73bb      	strb	r3, [r7, #14]
 801837e:	7bbb      	ldrb	r3, [r7, #14]
 8018380:	2b07      	cmp	r3, #7
 8018382:	bf8c      	ite	hi
 8018384:	2300      	movhi	r3, #0
 8018386:	2301      	movls	r3, #1
 8018388:	b2db      	uxtb	r3, r3
 801838a:	2b00      	cmp	r3, #0
 801838c:	d1d5      	bne.n	801833a <_ZN8BulkOnly10ClearAllEPEv+0xba>
		LUNOk[i] = false;
		WriteOk[i] = false;
		CurrentCapacity[i] = 0lu;
		CurrentSectorSize[i] = 0;
	}
	bIface = 0;
 801838e:	687b      	ldr	r3, [r7, #4]
 8018390:	f04f 0200 	mov.w	r2, #0
 8018394:	739a      	strb	r2, [r3, #14]
	bNumEP = 1;
 8018396:	687b      	ldr	r3, [r7, #4]
 8018398:	f04f 0201 	mov.w	r2, #1
 801839c:	73da      	strb	r2, [r3, #15]

	bAddress = 0;
 801839e:	687b      	ldr	r3, [r7, #4]
 80183a0:	f04f 0200 	mov.w	r2, #0
 80183a4:	731a      	strb	r2, [r3, #12]
	qNextPollTime = 0;
 80183a6:	687b      	ldr	r3, [r7, #4]
 80183a8:	f04f 0200 	mov.w	r2, #0
 80183ac:	611a      	str	r2, [r3, #16]
	bPollEnable = false;
 80183ae:	687b      	ldr	r3, [r7, #4]
 80183b0:	f04f 0200 	mov.w	r2, #0
 80183b4:	751a      	strb	r2, [r3, #20]
	bLastUsbError = 0;
 80183b6:	687b      	ldr	r3, [r7, #4]
 80183b8:	f04f 0200 	mov.w	r2, #0
 80183bc:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
	bMaxLUN = 0;
 80183c0:	687b      	ldr	r3, [r7, #4]
 80183c2:	f04f 0200 	mov.w	r2, #0
 80183c6:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
	bTheLUN = 0;
 80183ca:	687b      	ldr	r3, [r7, #4]
 80183cc:	f04f 0200 	mov.w	r2, #0
 80183d0:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
}
 80183d4:	f107 0714 	add.w	r7, r7, #20
 80183d8:	46bd      	mov	sp, r7
 80183da:	bc80      	pop	{r7}
 80183dc:	4770      	bx	lr
 80183de:	bf00      	nop

080183e0 <_ZN8BulkOnly10IsValidCSWEP20CommandStatusWrapperP23CommandBlockWrapperBase>:
 *
 * @param pcsw
 * @param pcbw
 * @return
 */
bool BulkOnly::IsValidCSW(CommandStatusWrapper *pcsw, CommandBlockWrapperBase *pcbw) {
 80183e0:	b580      	push	{r7, lr}
 80183e2:	b084      	sub	sp, #16
 80183e4:	af00      	add	r7, sp, #0
 80183e6:	60f8      	str	r0, [r7, #12]
 80183e8:	60b9      	str	r1, [r7, #8]
 80183ea:	607a      	str	r2, [r7, #4]
        if (pcsw->dCSWSignature != MASS_CSW_SIGNATURE) {
 80183ec:	68bb      	ldr	r3, [r7, #8]
 80183ee:	681a      	ldr	r2, [r3, #0]
 80183f0:	f245 3355 	movw	r3, #21333	; 0x5355
 80183f4:	f2c5 3342 	movt	r3, #21314	; 0x5342
 80183f8:	429a      	cmp	r2, r3
 80183fa:	d00a      	beq.n	8018412 <_ZN8BulkOnly10IsValidCSWEP20CommandStatusWrapperP23CommandBlockWrapperBase+0x32>
                Notify(PSTR("CSW:Sig error\r\n"), 0x80);
 80183fc:	f64e 3098 	movw	r0, #60312	; 0xeb98
 8018400:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018404:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018408:	f000 ffd4 	bl	80193b4 <_Z8E_NotifyPKci>
                //xprintf("%lx != %lx\r\n", MASS_CSW_SIGNATURE, pcsw->dCSWSignature);
                return false;
 801840c:	f04f 0300 	mov.w	r3, #0
 8018410:	e012      	b.n	8018438 <_ZN8BulkOnly10IsValidCSWEP20CommandStatusWrapperP23CommandBlockWrapperBase+0x58>
        }
        if (pcsw->dCSWTag != pcbw->dCBWTag) {
 8018412:	68bb      	ldr	r3, [r7, #8]
 8018414:	685a      	ldr	r2, [r3, #4]
 8018416:	687b      	ldr	r3, [r7, #4]
 8018418:	685b      	ldr	r3, [r3, #4]
 801841a:	429a      	cmp	r2, r3
 801841c:	d00a      	beq.n	8018434 <_ZN8BulkOnly10IsValidCSWEP20CommandStatusWrapperP23CommandBlockWrapperBase+0x54>
                Notify(PSTR("CSW:Wrong tag\r\n"), 0x80);
 801841e:	f64e 30a8 	movw	r0, #60328	; 0xeba8
 8018422:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018426:	f04f 0180 	mov.w	r1, #128	; 0x80
 801842a:	f000 ffc3 	bl	80193b4 <_Z8E_NotifyPKci>
                //xprintf("%lx != %lx\r\n", pcsw->dCSWTag, pcbw->dCBWTag);
                return false;
 801842e:	f04f 0300 	mov.w	r3, #0
 8018432:	e001      	b.n	8018438 <_ZN8BulkOnly10IsValidCSWEP20CommandStatusWrapperP23CommandBlockWrapperBase+0x58>
        }
        return true;
 8018434:	f04f 0301 	mov.w	r3, #1
}
 8018438:	4618      	mov	r0, r3
 801843a:	f107 0710 	add.w	r7, r7, #16
 801843e:	46bd      	mov	sp, r7
 8018440:	bd80      	pop	{r7, pc}
 8018442:	bf00      	nop

08018444 <_ZN8BulkOnly14HandleUsbErrorEhh>:
 *
 * @param error
 * @param index
 * @return
 */
uint8_t BulkOnly::HandleUsbError(uint8_t error, uint8_t index) {
 8018444:	b580      	push	{r7, lr}
 8018446:	b084      	sub	sp, #16
 8018448:	af00      	add	r7, sp, #0
 801844a:	6078      	str	r0, [r7, #4]
 801844c:	4613      	mov	r3, r2
 801844e:	460a      	mov	r2, r1
 8018450:	70fa      	strb	r2, [r7, #3]
 8018452:	70bb      	strb	r3, [r7, #2]
        uint8_t count = 3;
 8018454:	f04f 0303 	mov.w	r3, #3
 8018458:	73fb      	strb	r3, [r7, #15]

        bLastUsbError = error;
 801845a:	687b      	ldr	r3, [r7, #4]
 801845c:	78fa      	ldrb	r2, [r7, #3]
 801845e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
        //if (error)
        //ClearEpHalt(index);
        while (error && count) {
 8018462:	e089      	b.n	8018578 <_ZN8BulkOnly14HandleUsbErrorEhh+0x134>
                if (error != hrSUCCESS) {
 8018464:	78fb      	ldrb	r3, [r7, #3]
 8018466:	2b00      	cmp	r3, #0
 8018468:	d00f      	beq.n	801848a <_ZN8BulkOnly14HandleUsbErrorEhh+0x46>
                        ErrorMessage<uint8_t > (PSTR("USB Error"), error);
 801846a:	78fb      	ldrb	r3, [r7, #3]
 801846c:	f64e 30b8 	movw	r0, #60344	; 0xebb8
 8018470:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018474:	4619      	mov	r1, r3
 8018476:	f000 fd03 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                        ErrorMessage<uint8_t > (PSTR("Index"), index);
 801847a:	78bb      	ldrb	r3, [r7, #2]
 801847c:	f64e 30c4 	movw	r0, #60356	; 0xebc4
 8018480:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018484:	4619      	mov	r1, r3
 8018486:	f000 fcfb 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                }
                switch (error) {
 801848a:	78fb      	ldrb	r3, [r7, #3]
 801848c:	2b0e      	cmp	r3, #14
 801848e:	d863      	bhi.n	8018558 <_ZN8BulkOnly14HandleUsbErrorEhh+0x114>
 8018490:	a201      	add	r2, pc, #4	; (adr r2, 8018498 <_ZN8BulkOnly14HandleUsbErrorEhh+0x54>)
 8018492:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018496:	bf00      	nop
 8018498:	080184d5 	.word	0x080184d5
 801849c:	080184db 	.word	0x080184db
 80184a0:	08018559 	.word	0x08018559
 80184a4:	08018559 	.word	0x08018559
 80184a8:	0801850f 	.word	0x0801850f
 80184ac:	080184e7 	.word	0x080184e7
 80184b0:	08018521 	.word	0x08018521
 80184b4:	08018559 	.word	0x08018559
 80184b8:	08018559 	.word	0x08018559
 80184bc:	08018559 	.word	0x08018559
 80184c0:	08018559 	.word	0x08018559
 80184c4:	08018559 	.word	0x08018559
 80184c8:	08018559 	.word	0x08018559
 80184cc:	080184e1 	.word	0x080184e1
 80184d0:	080184e1 	.word	0x080184e1
                                // case hrWRONGPID:
                        case hrSUCCESS:
                                return MASS_ERR_SUCCESS;
 80184d4:	f04f 0300 	mov.w	r3, #0
 80184d8:	e067      	b.n	80185aa <_ZN8BulkOnly14HandleUsbErrorEhh+0x166>
                        case hrBUSY:
                                // SIE is busy, just hang out and try again.
                                return MASS_ERR_UNIT_BUSY;
 80184da:	f04f 0304 	mov.w	r3, #4
 80184de:	e064      	b.n	80185aa <_ZN8BulkOnly14HandleUsbErrorEhh+0x166>
                        case hrTIMEOUT:
                        case hrJERR: return MASS_ERR_DEVICE_DISCONNECTED;
 80184e0:	f04f 0311 	mov.w	r3, #17
 80184e4:	e061      	b.n	80185aa <_ZN8BulkOnly14HandleUsbErrorEhh+0x166>
                        case hrSTALL:
                                if (index == 0)
 80184e6:	78bb      	ldrb	r3, [r7, #2]
 80184e8:	2b00      	cmp	r3, #0
 80184ea:	d102      	bne.n	80184f2 <_ZN8BulkOnly14HandleUsbErrorEhh+0xae>
                                        return MASS_ERR_STALL;
 80184ec:	f04f 0305 	mov.w	r3, #5
 80184f0:	e05b      	b.n	80185aa <_ZN8BulkOnly14HandleUsbErrorEhh+0x166>
                                ClearEpHalt(index);
 80184f2:	78bb      	ldrb	r3, [r7, #2]
 80184f4:	6878      	ldr	r0, [r7, #4]
 80184f6:	4619      	mov	r1, r3
 80184f8:	f7ff fd7e 	bl	8017ff8 <_ZN8BulkOnly11ClearEpHaltEh>
                                if (index != epDataInIndex)
 80184fc:	78bb      	ldrb	r3, [r7, #2]
 80184fe:	2b01      	cmp	r3, #1
 8018500:	d002      	beq.n	8018508 <_ZN8BulkOnly14HandleUsbErrorEhh+0xc4>
                                        return MASS_ERR_WRITE_STALL;
 8018502:	f04f 0314 	mov.w	r3, #20
 8018506:	e050      	b.n	80185aa <_ZN8BulkOnly14HandleUsbErrorEhh+0x166>
                                return MASS_ERR_STALL;
 8018508:	f04f 0305 	mov.w	r3, #5
 801850c:	e04d      	b.n	80185aa <_ZN8BulkOnly14HandleUsbErrorEhh+0x166>

                        case hrNAK:
                                if (index == 0)
 801850e:	78bb      	ldrb	r3, [r7, #2]
 8018510:	2b00      	cmp	r3, #0
 8018512:	d102      	bne.n	801851a <_ZN8BulkOnly14HandleUsbErrorEhh+0xd6>
                                        return MASS_ERR_UNIT_BUSY;
 8018514:	f04f 0304 	mov.w	r3, #4
 8018518:	e047      	b.n	80185aa <_ZN8BulkOnly14HandleUsbErrorEhh+0x166>
                                return MASS_ERR_UNIT_BUSY;
 801851a:	f04f 0304 	mov.w	r3, #4
 801851e:	e044      	b.n	80185aa <_ZN8BulkOnly14HandleUsbErrorEhh+0x166>
                        case hrTOGERR:
                                // Handle a very super rare corner case, where toggles become de-synched.
                                // I have only ran into one device that has this firmware bug, and this is
                                // the only clean way to get back into sync with the buggy device firmware.
                                //   --AJK
                                if (bAddress && bConfNum) {
 8018520:	687b      	ldr	r3, [r7, #4]
 8018522:	7b1b      	ldrb	r3, [r3, #12]
 8018524:	2b00      	cmp	r3, #0
 8018526:	d014      	beq.n	8018552 <_ZN8BulkOnly14HandleUsbErrorEhh+0x10e>
 8018528:	687b      	ldr	r3, [r7, #4]
 801852a:	7b5b      	ldrb	r3, [r3, #13]
 801852c:	2b00      	cmp	r3, #0
 801852e:	d010      	beq.n	8018552 <_ZN8BulkOnly14HandleUsbErrorEhh+0x10e>
                                        error = pUsb->setConf(bAddress, 0, bConfNum);
 8018530:	687b      	ldr	r3, [r7, #4]
 8018532:	6899      	ldr	r1, [r3, #8]
 8018534:	687b      	ldr	r3, [r7, #4]
 8018536:	7b1a      	ldrb	r2, [r3, #12]
 8018538:	687b      	ldr	r3, [r7, #4]
 801853a:	7b5b      	ldrb	r3, [r3, #13]
 801853c:	4608      	mov	r0, r1
 801853e:	4611      	mov	r1, r2
 8018540:	f04f 0200 	mov.w	r2, #0
 8018544:	f7fd fbf0 	bl	8015d28 <_ZN3USB7setConfEhhh>
 8018548:	4603      	mov	r3, r0
 801854a:	70fb      	strb	r3, [r7, #3]

                                        if (error)
 801854c:	78fb      	ldrb	r3, [r7, #3]
 801854e:	2b00      	cmp	r3, #0
 8018550:	d10d      	bne.n	801856e <_ZN8BulkOnly14HandleUsbErrorEhh+0x12a>
                                                break;
                                }
                                return MASS_ERR_SUCCESS;
 8018552:	f04f 0300 	mov.w	r3, #0
 8018556:	e028      	b.n	80185aa <_ZN8BulkOnly14HandleUsbErrorEhh+0x166>
                        default:
                                ErrorMessage<uint8_t > (PSTR("\r\nUSB"), error);
 8018558:	78fb      	ldrb	r3, [r7, #3]
 801855a:	f64e 30cc 	movw	r0, #60364	; 0xebcc
 801855e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018562:	4619      	mov	r1, r3
 8018564:	f000 fc8c 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                                return MASS_ERR_GENERAL_USB_ERROR;
 8018568:	f04f 03ff 	mov.w	r3, #255	; 0xff
 801856c:	e01d      	b.n	80185aa <_ZN8BulkOnly14HandleUsbErrorEhh+0x166>
                                //   --AJK
                                if (bAddress && bConfNum) {
                                        error = pUsb->setConf(bAddress, 0, bConfNum);

                                        if (error)
                                                break;
 801856e:	bf00      	nop
                                return MASS_ERR_SUCCESS;
                        default:
                                ErrorMessage<uint8_t > (PSTR("\r\nUSB"), error);
                                return MASS_ERR_GENERAL_USB_ERROR;
                }
                count--;
 8018570:	7bfb      	ldrb	r3, [r7, #15]
 8018572:	f103 33ff 	add.w	r3, r3, #4294967295
 8018576:	73fb      	strb	r3, [r7, #15]
        uint8_t count = 3;

        bLastUsbError = error;
        //if (error)
        //ClearEpHalt(index);
        while (error && count) {
 8018578:	78fb      	ldrb	r3, [r7, #3]
 801857a:	2b00      	cmp	r3, #0
 801857c:	d005      	beq.n	801858a <_ZN8BulkOnly14HandleUsbErrorEhh+0x146>
 801857e:	7bfb      	ldrb	r3, [r7, #15]
 8018580:	2b00      	cmp	r3, #0
 8018582:	d002      	beq.n	801858a <_ZN8BulkOnly14HandleUsbErrorEhh+0x146>
 8018584:	f04f 0301 	mov.w	r3, #1
 8018588:	e001      	b.n	801858e <_ZN8BulkOnly14HandleUsbErrorEhh+0x14a>
 801858a:	f04f 0300 	mov.w	r3, #0
 801858e:	2b00      	cmp	r3, #0
 8018590:	f47f af68 	bne.w	8018464 <_ZN8BulkOnly14HandleUsbErrorEhh+0x20>
                                return MASS_ERR_GENERAL_USB_ERROR;
                }
                count--;
        } // while

        return ((error && !count) ? MASS_ERR_GENERAL_USB_ERROR : MASS_ERR_SUCCESS);
 8018594:	78fb      	ldrb	r3, [r7, #3]
 8018596:	2b00      	cmp	r3, #0
 8018598:	d005      	beq.n	80185a6 <_ZN8BulkOnly14HandleUsbErrorEhh+0x162>
 801859a:	7bfb      	ldrb	r3, [r7, #15]
 801859c:	2b00      	cmp	r3, #0
 801859e:	d102      	bne.n	80185a6 <_ZN8BulkOnly14HandleUsbErrorEhh+0x162>
 80185a0:	f04f 03ff 	mov.w	r3, #255	; 0xff
 80185a4:	e001      	b.n	80185aa <_ZN8BulkOnly14HandleUsbErrorEhh+0x166>
 80185a6:	f04f 0300 	mov.w	r3, #0
}
 80185aa:	4618      	mov	r0, r3
 80185ac:	f107 0710 	add.w	r7, r7, #16
 80185b0:	46bd      	mov	sp, r7
 80185b2:	bd80      	pop	{r7, pc}

080185b4 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh>:
 * @param flags
 * @return
 */
uint8_t BulkOnly::Transaction(CommandBlockWrapper *pcbw,
		uint16_t buf_size, void *buf, uint8_t flags)
{
 80185b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80185b8:	b091      	sub	sp, #68	; 0x44
 80185ba:	af02      	add	r7, sp, #8
 80185bc:	60f8      	str	r0, [r7, #12]
 80185be:	60b9      	str	r1, [r7, #8]
 80185c0:	603b      	str	r3, [r7, #0]
 80185c2:	4613      	mov	r3, r2
 80185c4:	80fb      	strh	r3, [r7, #6]
	uint16_t bytes = (pcbw->dCBWDataTransferLength > buf_size) ? buf_size : pcbw->dCBWDataTransferLength;
 80185c6:	68bb      	ldr	r3, [r7, #8]
 80185c8:	689a      	ldr	r2, [r3, #8]
 80185ca:	88fb      	ldrh	r3, [r7, #6]
 80185cc:	429a      	cmp	r2, r3
 80185ce:	bf38      	it	cc
 80185d0:	4613      	movcc	r3, r2
 80185d2:	b29b      	uxth	r3, r3
 80185d4:	843b      	strh	r3, [r7, #32]
	uint8_t write = (pcbw->bmCBWFlags & MASS_CMD_DIR_IN) != MASS_CMD_DIR_IN;
 80185d6:	68bb      	ldr	r3, [r7, #8]
 80185d8:	7b1b      	ldrb	r3, [r3, #12]
 80185da:	b2db      	uxtb	r3, r3
 80185dc:	ea6f 0303 	mvn.w	r3, r3
 80185e0:	b2db      	uxtb	r3, r3
 80185e2:	ea4f 13d3 	mov.w	r3, r3, lsr #7
 80185e6:	b2db      	uxtb	r3, r3
 80185e8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	uint8_t callback = (flags & MASS_TRANS_FLG_CALLBACK) == MASS_TRANS_FLG_CALLBACK;
 80185ec:	f897 3060 	ldrb.w	r3, [r7, #96]	; 0x60
 80185f0:	f003 0301 	and.w	r3, r3, #1
 80185f4:	2b00      	cmp	r3, #0
 80185f6:	bf0c      	ite	eq
 80185f8:	2300      	moveq	r3, #0
 80185fa:	2301      	movne	r3, #1
 80185fc:	b2db      	uxtb	r3, r3
 80185fe:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
	uint8_t ret = 0;
 8018602:	f04f 0300 	mov.w	r3, #0
 8018606:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	uint8_t usberr;


	CommandStatusWrapper csw; // up here, we allocate ahead to save cpu cycles.
	// Fix reserved bits.
	pcbw->bmReserved1 = 0;
 801860a:	68ba      	ldr	r2, [r7, #8]
 801860c:	7b53      	ldrb	r3, [r2, #13]
 801860e:	f36f 1307 	bfc	r3, #4, #4
 8018612:	7353      	strb	r3, [r2, #13]
	pcbw->bmReserved2 = 0;
 8018614:	68ba      	ldr	r2, [r7, #8]
 8018616:	7b93      	ldrb	r3, [r2, #14]
 8018618:	f36f 1307 	bfc	r3, #4, #4
 801861c:	7393      	strb	r3, [r2, #14]
	ErrorMessage<uint32_t > (PSTR("CBW.dCBWTag"), pcbw->dCBWTag);
 801861e:	68bb      	ldr	r3, [r7, #8]
 8018620:	685b      	ldr	r3, [r3, #4]
 8018622:	f64e 30d4 	movw	r0, #60372	; 0xebd4
 8018626:	f6c0 0001 	movt	r0, #2049	; 0x801
 801862a:	4619      	mov	r1, r3
 801862c:	f000 fc4e 	bl	8018ecc <_Z12ErrorMessageImEvPKcT_>
		*(pt_buf+448)	= (uint8_t)0xF7;
	}
#endif
	//while ((usberr = pUsb->outTransfer(bAddress, epInfo[epDataOutIndex].epAddr, sizeof (CommandBlockWrapper), (uint8_t*)pcbw)) == hrBUSY) delay(1);
	usberr = pUsb->outTransfer(bAddress, epInfo[epDataOutIndex].epAddr,
			sizeof (CommandBlockWrapper), (uint8_t*)pcbw);
 8018630:	68fb      	ldr	r3, [r7, #12]
 8018632:	6899      	ldr	r1, [r3, #8]
 8018634:	68fb      	ldr	r3, [r7, #12]
 8018636:	7b1a      	ldrb	r2, [r3, #12]
 8018638:	68fb      	ldr	r3, [r7, #12]
 801863a:	7fdb      	ldrb	r3, [r3, #31]
 801863c:	68b8      	ldr	r0, [r7, #8]
 801863e:	9000      	str	r0, [sp, #0]
 8018640:	4608      	mov	r0, r1
 8018642:	4611      	mov	r1, r2
 8018644:	461a      	mov	r2, r3
 8018646:	f04f 031f 	mov.w	r3, #31
 801864a:	f7fc f9ef 	bl	8014a2c <_ZN3USB11outTransferEhhtPKh>
 801864e:	4603      	mov	r3, r0
 8018650:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
	USB::toggle_led3();
 8018654:	f7fd fc28 	bl	8015ea8 <_ZN7STM32F2I1a1bE11toggle_led3Ev>
	//xprintf("\ncsw sent");

	ret = HandleUsbError(usberr, epDataOutIndex);
 8018658:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 801865c:	68f8      	ldr	r0, [r7, #12]
 801865e:	4619      	mov	r1, r3
 8018660:	f04f 0202 	mov.w	r2, #2
 8018664:	f7ff feee 	bl	8018444 <_ZN8BulkOnly14HandleUsbErrorEhh>
 8018668:	4603      	mov	r3, r0
 801866a:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	//ret = HandleUsbError(pUsb->outTransfer(bAddress, epInfo[epDataOutIndex].epAddr, sizeof (CommandBlockWrapper), (uint8_t*)pcbw), epDataOutIndex);
	if (ret) {
 801866e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8018672:	2b00      	cmp	r3, #0
 8018674:	d009      	beq.n	801868a <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0xd6>
		ErrorMessage<uint8_t > (PSTR("==================== CBW"), ret);
 8018676:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801867a:	f64e 30e0 	movw	r0, #60384	; 0xebe0
 801867e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018682:	4619      	mov	r1, r3
 8018684:	f000 fbfc 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
 8018688:	e0bf      	b.n	801880a <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x256>
	} else {
		if (bytes) {
 801868a:	8c3b      	ldrh	r3, [r7, #32]
 801868c:	2b00      	cmp	r3, #0
 801868e:	f000 80bc 	beq.w	801880a <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x256>
			if (!write) {
 8018692:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8018696:	2b00      	cmp	r3, #0
 8018698:	f040 808f 	bne.w	80187ba <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x206>
				if (callback) {
 801869c:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 80186a0:	2b00      	cmp	r3, #0
 80186a2:	d06f      	beq.n	8018784 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x1d0>
 80186a4:	466b      	mov	r3, sp
 80186a6:	461e      	mov	r6, r3
						uint8_t rbuf[bytes];
 80186a8:	8c3b      	ldrh	r3, [r7, #32]
 80186aa:	f103 31ff 	add.w	r1, r3, #4294967295
 80186ae:	62b9      	str	r1, [r7, #40]	; 0x28
 80186b0:	4608      	mov	r0, r1
 80186b2:	4602      	mov	r2, r0
 80186b4:	f04f 0300 	mov.w	r3, #0
 80186b8:	f04f 0a01 	mov.w	sl, #1
 80186bc:	f04f 0b00 	mov.w	fp, #0
 80186c0:	eb12 020a 	adds.w	r2, r2, sl
 80186c4:	eb43 030b 	adc.w	r3, r3, fp
 80186c8:	ea4f 7052 	mov.w	r0, r2, lsr #29
 80186cc:	ea4f 09c3 	mov.w	r9, r3, lsl #3
 80186d0:	ea40 0909 	orr.w	r9, r0, r9
 80186d4:	ea4f 08c2 	mov.w	r8, r2, lsl #3
 80186d8:	4608      	mov	r0, r1
 80186da:	4602      	mov	r2, r0
 80186dc:	f04f 0300 	mov.w	r3, #0
 80186e0:	f04f 0801 	mov.w	r8, #1
 80186e4:	f04f 0900 	mov.w	r9, #0
 80186e8:	eb12 0208 	adds.w	r2, r2, r8
 80186ec:	eb43 0309 	adc.w	r3, r3, r9
 80186f0:	ea4f 7052 	mov.w	r0, r2, lsr #29
 80186f4:	ea4f 05c3 	mov.w	r5, r3, lsl #3
 80186f8:	4305      	orrs	r5, r0
 80186fa:	ea4f 04c2 	mov.w	r4, r2, lsl #3
 80186fe:	460b      	mov	r3, r1
 8018700:	f103 0301 	add.w	r3, r3, #1
 8018704:	f103 0307 	add.w	r3, r3, #7
 8018708:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 801870c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8018710:	ebad 0d03 	sub.w	sp, sp, r3
 8018714:	ab02      	add	r3, sp, #8
 8018716:	f103 0300 	add.w	r3, r3, #0
 801871a:	627b      	str	r3, [r7, #36]	; 0x24
						while ((usberr = pUsb->inTransfer(bAddress, epInfo[epDataInIndex].epAddr, &bytes, rbuf)) == hrBUSY) delay_ms(1);
 801871c:	e008      	b.n	8018730 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x17c>
 801871e:	f243 630c 	movw	r3, #13836	; 0x360c
 8018722:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018726:	681b      	ldr	r3, [r3, #0]
 8018728:	685b      	ldr	r3, [r3, #4]
 801872a:	f04f 0001 	mov.w	r0, #1
 801872e:	4798      	blx	r3
 8018730:	68fb      	ldr	r3, [r7, #12]
 8018732:	6898      	ldr	r0, [r3, #8]
 8018734:	68fb      	ldr	r3, [r7, #12]
 8018736:	7b19      	ldrb	r1, [r3, #12]
 8018738:	68fb      	ldr	r3, [r7, #12]
 801873a:	7e9a      	ldrb	r2, [r3, #26]
 801873c:	6a7c      	ldr	r4, [r7, #36]	; 0x24
 801873e:	f107 0320 	add.w	r3, r7, #32
 8018742:	9400      	str	r4, [sp, #0]
 8018744:	f7fc f884 	bl	8014850 <_ZN3USB10inTransferEhhPtPh>
 8018748:	4603      	mov	r3, r0
 801874a:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
 801874e:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8018752:	2b01      	cmp	r3, #1
 8018754:	bf14      	ite	ne
 8018756:	2300      	movne	r3, #0
 8018758:	2301      	moveq	r3, #1
 801875a:	b2db      	uxtb	r3, r3
 801875c:	2b00      	cmp	r3, #0
 801875e:	d1de      	bne.n	801871e <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x16a>
						if (usberr == hrSUCCESS) ((USBReadParser*)buf)->Parse(bytes, rbuf, 0);
 8018760:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8018764:	2b00      	cmp	r3, #0
 8018766:	d10b      	bne.n	8018780 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x1cc>
 8018768:	683b      	ldr	r3, [r7, #0]
 801876a:	681b      	ldr	r3, [r3, #0]
 801876c:	681c      	ldr	r4, [r3, #0]
 801876e:	8c39      	ldrh	r1, [r7, #32]
 8018770:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8018772:	f04f 0300 	mov.w	r3, #0
 8018776:	847b      	strh	r3, [r7, #34]	; 0x22
 8018778:	f107 0322 	add.w	r3, r7, #34	; 0x22
 801877c:	6838      	ldr	r0, [r7, #0]
 801877e:	47a0      	blx	r4
 8018780:	46b5      	mov	sp, r6
 8018782:	e00e      	b.n	80187a2 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x1ee>
				} else {
						//while ((usberr = pUsb->inTransfer(bAddress, epInfo[epDataInIndex].epAddr, &bytes, (uint8_t*)buf)) == hrBUSY) delay(1);
					usberr = pUsb->inTransfer(bAddress, epInfo[epDataInIndex].epAddr, &bytes, (uint8_t*)buf);
 8018784:	68fb      	ldr	r3, [r7, #12]
 8018786:	6898      	ldr	r0, [r3, #8]
 8018788:	68fb      	ldr	r3, [r7, #12]
 801878a:	7b19      	ldrb	r1, [r3, #12]
 801878c:	68fb      	ldr	r3, [r7, #12]
 801878e:	7e9a      	ldrb	r2, [r3, #26]
 8018790:	f107 0320 	add.w	r3, r7, #32
 8018794:	683c      	ldr	r4, [r7, #0]
 8018796:	9400      	str	r4, [sp, #0]
 8018798:	f7fc f85a 	bl	8014850 <_ZN3USB10inTransferEhhPtPh>
 801879c:	4603      	mov	r3, r0
 801879e:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
				}
				ret = HandleUsbError(usberr, epDataInIndex);
 80187a2:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 80187a6:	68f8      	ldr	r0, [r7, #12]
 80187a8:	4619      	mov	r1, r3
 80187aa:	f04f 0201 	mov.w	r2, #1
 80187ae:	f7ff fe49 	bl	8018444 <_ZN8BulkOnly14HandleUsbErrorEhh>
 80187b2:	4603      	mov	r3, r0
 80187b4:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 80187b8:	e01a      	b.n	80187f0 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x23c>
			} else {
				//while ((usberr = pUsb->outTransfer(bAddress, epInfo[epDataOutIndex].epAddr, bytes, (uint8_t*)buf)) == hrBUSY) delay(1);
				usberr = pUsb->outTransfer(bAddress,
						epInfo[epDataOutIndex].epAddr, bytes, (uint8_t*)buf);
 80187ba:	68fb      	ldr	r3, [r7, #12]
 80187bc:	6898      	ldr	r0, [r3, #8]
 80187be:	68fb      	ldr	r3, [r7, #12]
 80187c0:	7b19      	ldrb	r1, [r3, #12]
 80187c2:	68fb      	ldr	r3, [r7, #12]
 80187c4:	7fda      	ldrb	r2, [r3, #31]
 80187c6:	8c3b      	ldrh	r3, [r7, #32]
 80187c8:	683c      	ldr	r4, [r7, #0]
 80187ca:	9400      	str	r4, [sp, #0]
 80187cc:	f7fc f92e 	bl	8014a2c <_ZN3USB11outTransferEhhtPKh>
 80187d0:	4603      	mov	r3, r0
 80187d2:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
				USB::toggle_led3();
 80187d6:	f7fd fb67 	bl	8015ea8 <_ZN7STM32F2I1a1bE11toggle_led3Ev>
				//xprintf("\ndata sent");

				ret = HandleUsbError(usberr, epDataOutIndex);
 80187da:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 80187de:	68f8      	ldr	r0, [r7, #12]
 80187e0:	4619      	mov	r1, r3
 80187e2:	f04f 0202 	mov.w	r2, #2
 80187e6:	f7ff fe2d 	bl	8018444 <_ZN8BulkOnly14HandleUsbErrorEhh>
 80187ea:	4603      	mov	r3, r0
 80187ec:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
			}
			if (ret) {
 80187f0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80187f4:	2b00      	cmp	r3, #0
 80187f6:	d008      	beq.n	801880a <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x256>
				ErrorMessage<uint8_t > (PSTR("==================== DAT"), ret);
 80187f8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80187fc:	f64e 30fc 	movw	r0, #60412	; 0xebfc
 8018800:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018804:	4619      	mov	r1, r3
 8018806:	f000 fb3b 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
		}
	}

	//if (!ret || ret == MASS_ERR_WRITE_STALL || ret == MASS_ERR_STALL) {
	//{	//receive csw
			bytes = sizeof (CommandStatusWrapper);
 801880a:	f04f 030d 	mov.w	r3, #13
 801880e:	843b      	strh	r3, [r7, #32]
			int tries = 2;
 8018810:	f04f 0302 	mov.w	r3, #2
 8018814:	633b      	str	r3, [r7, #48]	; 0x30
			while (tries--)
 8018816:	e020      	b.n	801885a <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x2a6>
			{
				//while ((usberr = pUsb->inTransfer(bAddress, epInfo[epDataInIndex].epAddr, &bytes, (uint8_t*) & csw)) == hrBUSY) delay(1);
				usberr = pUsb->inTransfer(bAddress,
						epInfo[epDataInIndex].epAddr, &bytes, (uint8_t*) & csw);
 8018818:	68fb      	ldr	r3, [r7, #12]
 801881a:	6898      	ldr	r0, [r3, #8]
 801881c:	68fb      	ldr	r3, [r7, #12]
 801881e:	7b19      	ldrb	r1, [r3, #12]
 8018820:	68fb      	ldr	r3, [r7, #12]
 8018822:	7e9a      	ldrb	r2, [r3, #26]
 8018824:	f107 0320 	add.w	r3, r7, #32
 8018828:	f107 0410 	add.w	r4, r7, #16
 801882c:	9400      	str	r4, [sp, #0]
 801882e:	f7fc f80f 	bl	8014850 <_ZN3USB10inTransferEhhPtPh>
 8018832:	4603      	mov	r3, r0
 8018834:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
				USB::toggle_led3();
 8018838:	f7fd fb36 	bl	8015ea8 <_ZN7STM32F2I1a1bE11toggle_led3Ev>
				//xprintf("\ncsw rcv");

				if (!usberr) break;
 801883c:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8018840:	2b00      	cmp	r3, #0
 8018842:	d017      	beq.n	8018874 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x2c0>
				ClearEpHalt(epDataInIndex);
 8018844:	68f8      	ldr	r0, [r7, #12]
 8018846:	f04f 0101 	mov.w	r1, #1
 801884a:	f7ff fbd5 	bl	8017ff8 <_ZN8BulkOnly11ClearEpHaltEh>
				if (tries) ResetRecovery();
 801884e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8018850:	2b00      	cmp	r3, #0
 8018852:	d002      	beq.n	801885a <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x2a6>
 8018854:	68f8      	ldr	r0, [r7, #12]
 8018856:	f7ff fcc1 	bl	80181dc <_ZN8BulkOnly13ResetRecoveryEv>

	//if (!ret || ret == MASS_ERR_WRITE_STALL || ret == MASS_ERR_STALL) {
	//{	//receive csw
			bytes = sizeof (CommandStatusWrapper);
			int tries = 2;
			while (tries--)
 801885a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801885c:	2b00      	cmp	r3, #0
 801885e:	bf0c      	ite	eq
 8018860:	2300      	moveq	r3, #0
 8018862:	2301      	movne	r3, #1
 8018864:	b2db      	uxtb	r3, r3
 8018866:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8018868:	f102 32ff 	add.w	r2, r2, #4294967295
 801886c:	633a      	str	r2, [r7, #48]	; 0x30
 801886e:	2b00      	cmp	r3, #0
 8018870:	d1d2      	bne.n	8018818 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x264>
 8018872:	e000      	b.n	8018876 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x2c2>
				usberr = pUsb->inTransfer(bAddress,
						epInfo[epDataInIndex].epAddr, &bytes, (uint8_t*) & csw);
				USB::toggle_led3();
				//xprintf("\ncsw rcv");

				if (!usberr) break;
 8018874:	bf00      	nop
				ClearEpHalt(epDataInIndex);
				if (tries) ResetRecovery();
			}
			if (!ret)
 8018876:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801887a:	2b00      	cmp	r3, #0
 801887c:	d110      	bne.n	80188a0 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x2ec>
			{
				Notify(PSTR("CBW:\t\tOK\r\n"), 0x80);
 801887e:	f64e 4018 	movw	r0, #60440	; 0xec18
 8018882:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018886:	f04f 0180 	mov.w	r1, #128	; 0x80
 801888a:	f000 fd93 	bl	80193b4 <_Z8E_NotifyPKci>
				Notify(PSTR("Data Stage:\tOK\r\n"), 0x80);
 801888e:	f64e 4024 	movw	r0, #60452	; 0xec24
 8018892:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018896:	f04f 0180 	mov.w	r1, #128	; 0x80
 801889a:	f000 fd8b 	bl	80193b4 <_Z8E_NotifyPKci>
 801889e:	e005      	b.n	80188ac <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x2f8>
			} else {
				// Throw away csw, IT IS NOT OF ANY USE.
				//HandleUsbError(usberr, epDataInIndex);
				ResetRecovery();
 80188a0:	68f8      	ldr	r0, [r7, #12]
 80188a2:	f7ff fc9b 	bl	80181dc <_ZN8BulkOnly13ResetRecoveryEv>
				return ret;
 80188a6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80188aa:	e03f      	b.n	801892c <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x378>
			}
			ret = HandleUsbError(usberr, epDataInIndex);
 80188ac:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 80188b0:	68f8      	ldr	r0, [r7, #12]
 80188b2:	4619      	mov	r1, r3
 80188b4:	f04f 0201 	mov.w	r2, #1
 80188b8:	f7ff fdc4 	bl	8018444 <_ZN8BulkOnly14HandleUsbErrorEhh>
 80188bc:	4603      	mov	r3, r0
 80188be:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
			if (ret) {
 80188c2:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80188c6:	2b00      	cmp	r3, #0
 80188c8:	d008      	beq.n	80188dc <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x328>
				ErrorMessage<uint8_t > (PSTR("==================== CSW"), ret);
 80188ca:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80188ce:	f64e 4038 	movw	r0, #60472	; 0xec38
 80188d2:	f6c0 0001 	movt	r0, #2049	; 0x801
 80188d6:	4619      	mov	r1, r3
 80188d8:	f000 fad2 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
			}
			if (usberr == hrSUCCESS) {
 80188dc:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 80188e0:	2b00      	cmp	r3, #0
 80188e2:	d121      	bne.n	8018928 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x374>
				if (IsValidCSW(&csw, pcbw)) {
 80188e4:	f107 0310 	add.w	r3, r7, #16
 80188e8:	68f8      	ldr	r0, [r7, #12]
 80188ea:	4619      	mov	r1, r3
 80188ec:	68ba      	ldr	r2, [r7, #8]
 80188ee:	f7ff fd77 	bl	80183e0 <_ZN8BulkOnly10IsValidCSWEP20CommandStatusWrapperP23CommandBlockWrapperBase>
 80188f2:	4603      	mov	r3, r0
 80188f4:	2b00      	cmp	r3, #0
 80188f6:	d009      	beq.n	801890c <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x358>
					//ErrorMessage<uint32_t > (PSTR("CSW.dCBWTag"), csw.dCSWTag);
					//ErrorMessage<uint8_t > (PSTR("bCSWStatus"), csw.bCSWStatus);
					//ErrorMessage<uint32_t > (PSTR("dCSWDataResidue"), csw.dCSWDataResidue);
					Notify(PSTR("CSW:\t\tOK\r\n\r\n"), 0x80);
 80188f8:	f64e 4054 	movw	r0, #60500	; 0xec54
 80188fc:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018900:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018904:	f000 fd56 	bl	80193b4 <_Z8E_NotifyPKci>
					return csw.bCSWStatus;
 8018908:	7f3b      	ldrb	r3, [r7, #28]
 801890a:	e00f      	b.n	801892c <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x378>
					// NOTE! Sometimes this is caused by the reported residue being wrong.
					// Get a different device. It isn't compliant, and should have never passed Q&A.
					// I own one... 05e3:0701 Genesys Logic, Inc. USB 2.0 IDE Adapter.
					// Other devices that exhibit this behavior exist in the wild too.
					// Be sure to check for quirks on Linux before reporting a bug. --xxxajk
					Notify(PSTR("Invalid CSW\r\n"), 0x80);
 801890c:	f64e 4064 	movw	r0, #60516	; 0xec64
 8018910:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018914:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018918:	f000 fd4c 	bl	80193b4 <_Z8E_NotifyPKci>
					ResetRecovery();
 801891c:	68f8      	ldr	r0, [r7, #12]
 801891e:	f7ff fc5d 	bl	80181dc <_ZN8BulkOnly13ResetRecoveryEv>
					//return MASS_ERR_SUCCESS;
					return MASS_ERR_INVALID_CSW;
 8018922:	f04f 0307 	mov.w	r3, #7
 8018926:	e001      	b.n	801892c <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x378>
				}
			}
	//}
	return ret;
 8018928:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801892c:	e004      	b.n	8018938 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x384>
 801892e:	e7ff      	b.n	8018930 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x37c>
 8018930:	46b5      	mov	sp, r6
 8018932:	e7ff      	b.n	8018934 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh+0x380>
 8018934:	f004 f8a4 	bl	801ca80 <__cxa_end_cleanup>
}
 8018938:	4618      	mov	r0, r3
 801893a:	f107 073c 	add.w	r7, r7, #60	; 0x3c
 801893e:	46bd      	mov	sp, r7
 8018940:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08018944 <_ZN8BulkOnly9ModeSenseEhhhhhPh>:
 * @param subpage
 * @param len
 * @param pbuf
 * @return
 */
uint8_t BulkOnly::ModeSense(uint8_t lun, uint8_t pc, uint8_t page, uint8_t subpage, uint8_t len, uint8_t * pbuf) {
 8018944:	b580      	push	{r7, lr}
 8018946:	b08c      	sub	sp, #48	; 0x30
 8018948:	af02      	add	r7, sp, #8
 801894a:	6078      	str	r0, [r7, #4]
 801894c:	70f9      	strb	r1, [r7, #3]
 801894e:	70ba      	strb	r2, [r7, #2]
 8018950:	707b      	strb	r3, [r7, #1]
        Notify(PSTR("\r\rModeSense\r\n"), 0x80);
 8018952:	f64e 4074 	movw	r0, #60532	; 0xec74
 8018956:	f6c0 0001 	movt	r0, #2049	; 0x801
 801895a:	f04f 0180 	mov.w	r1, #128	; 0x80
 801895e:	f000 fd29 	bl	80193b4 <_Z8E_NotifyPKci>
        Notify(PSTR("------------\r\n"), 0x80);
 8018962:	f64e 4084 	movw	r0, #60548	; 0xec84
 8018966:	f6c0 0001 	movt	r0, #2049	; 0x801
 801896a:	f04f 0180 	mov.w	r1, #128	; 0x80
 801896e:	f000 fd21 	bl	80193b4 <_Z8E_NotifyPKci>

        CommandBlockWrapper cbw;
        SetCurLUN(lun);
 8018972:	78fb      	ldrb	r3, [r7, #3]
 8018974:	6878      	ldr	r0, [r7, #4]
 8018976:	4619      	mov	r1, r3
 8018978:	f000 f86c 	bl	8018a54 <_ZN8BulkOnly9SetCurLUNEh>

        cbw.dCBWSignature = MASS_CBW_SIGNATURE;
 801897c:	f245 3355 	movw	r3, #21333	; 0x5355
 8018980:	f2c4 3342 	movt	r3, #17218	; 0x4342
 8018984:	60bb      	str	r3, [r7, #8]
        cbw.dCBWTag = ++dCBWTag;
 8018986:	687b      	ldr	r3, [r7, #4]
 8018988:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801898a:	f103 0201 	add.w	r2, r3, #1
 801898e:	687b      	ldr	r3, [r7, #4]
 8018990:	625a      	str	r2, [r3, #36]	; 0x24
 8018992:	687b      	ldr	r3, [r7, #4]
 8018994:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8018996:	60fb      	str	r3, [r7, #12]
        cbw.dCBWDataTransferLength = ((uint32_t)len);
 8018998:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 801899c:	613b      	str	r3, [r7, #16]
        cbw.bmCBWFlags = MASS_CMD_DIR_IN;
 801899e:	f04f 0380 	mov.w	r3, #128	; 0x80
 80189a2:	753b      	strb	r3, [r7, #20]
        cbw.bmCBWLUN = lun;
 80189a4:	78fb      	ldrb	r3, [r7, #3]
 80189a6:	f003 030f 	and.w	r3, r3, #15
 80189aa:	b2da      	uxtb	r2, r3
 80189ac:	7d7b      	ldrb	r3, [r7, #21]
 80189ae:	f362 0303 	bfi	r3, r2, #0, #4
 80189b2:	757b      	strb	r3, [r7, #21]
        cbw.bmCBWCBLength = 6;
 80189b4:	7dbb      	ldrb	r3, [r7, #22]
 80189b6:	f04f 0206 	mov.w	r2, #6
 80189ba:	f362 0303 	bfi	r3, r2, #0, #4
 80189be:	75bb      	strb	r3, [r7, #22]

        for (uint8_t i = 0; i < 16; i++)
 80189c0:	f04f 0300 	mov.w	r3, #0
 80189c4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 80189c8:	e00e      	b.n	80189e8 <_ZN8BulkOnly9ModeSenseEhhhhhPh+0xa4>
                cbw.CBWCB[i] = 0;
 80189ca:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80189ce:	f107 0228 	add.w	r2, r7, #40	; 0x28
 80189d2:	18d3      	adds	r3, r2, r3
 80189d4:	f04f 0200 	mov.w	r2, #0
 80189d8:	f803 2c11 	strb.w	r2, [r3, #-17]
        cbw.dCBWDataTransferLength = ((uint32_t)len);
        cbw.bmCBWFlags = MASS_CMD_DIR_IN;
        cbw.bmCBWLUN = lun;
        cbw.bmCBWCBLength = 6;

        for (uint8_t i = 0; i < 16; i++)
 80189dc:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80189e0:	f103 0301 	add.w	r3, r3, #1
 80189e4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 80189e8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80189ec:	2b0f      	cmp	r3, #15
 80189ee:	bf8c      	ite	hi
 80189f0:	2300      	movhi	r3, #0
 80189f2:	2301      	movls	r3, #1
 80189f4:	b2db      	uxtb	r3, r3
 80189f6:	2b00      	cmp	r3, #0
 80189f8:	d1e7      	bne.n	80189ca <_ZN8BulkOnly9ModeSenseEhhhhhPh+0x86>
                cbw.CBWCB[i] = 0;

        cbw.CBWCB[0] = SCSI_CMD_MODE_SENSE_6;
 80189fa:	f04f 031a 	mov.w	r3, #26
 80189fe:	75fb      	strb	r3, [r7, #23]
        cbw.CBWCB[2] = ((pc << 6) | page);
 8018a00:	78bb      	ldrb	r3, [r7, #2]
 8018a02:	ea4f 1383 	mov.w	r3, r3, lsl #6
 8018a06:	b2da      	uxtb	r2, r3
 8018a08:	787b      	ldrb	r3, [r7, #1]
 8018a0a:	4313      	orrs	r3, r2
 8018a0c:	b2db      	uxtb	r3, r3
 8018a0e:	b2db      	uxtb	r3, r3
 8018a10:	767b      	strb	r3, [r7, #25]
        cbw.CBWCB[3] = subpage;
 8018a12:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8018a16:	76bb      	strb	r3, [r7, #26]
        cbw.CBWCB[4] = len;
 8018a18:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 8018a1c:	76fb      	strb	r3, [r7, #27]

        return HandleSCSIError(Transaction(&cbw, 512, pbuf, 0));
 8018a1e:	f107 0308 	add.w	r3, r7, #8
 8018a22:	f04f 0200 	mov.w	r2, #0
 8018a26:	9200      	str	r2, [sp, #0]
 8018a28:	6878      	ldr	r0, [r7, #4]
 8018a2a:	4619      	mov	r1, r3
 8018a2c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8018a30:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8018a32:	f7ff fdbf 	bl	80185b4 <_ZN8BulkOnly11TransactionEP19CommandBlockWrappertPvh>
 8018a36:	4603      	mov	r3, r0
 8018a38:	6878      	ldr	r0, [r7, #4]
 8018a3a:	4619      	mov	r1, r3
 8018a3c:	f000 f826 	bl	8018a8c <_ZN8BulkOnly15HandleSCSIErrorEh>
 8018a40:	4603      	mov	r3, r0
 8018a42:	e001      	b.n	8018a48 <_ZN8BulkOnly9ModeSenseEhhhhhPh+0x104>
 8018a44:	f004 f81c 	bl	801ca80 <__cxa_end_cleanup>
}
 8018a48:	4618      	mov	r0, r3
 8018a4a:	f107 0728 	add.w	r7, r7, #40	; 0x28
 8018a4e:	46bd      	mov	sp, r7
 8018a50:	bd80      	pop	{r7, pc}
 8018a52:	bf00      	nop

08018a54 <_ZN8BulkOnly9SetCurLUNEh>:
 * For driver use only.
 *
 * @param lun Logical Unit Number
 * @return
 */
uint8_t BulkOnly::SetCurLUN(uint8_t lun) {
 8018a54:	b480      	push	{r7}
 8018a56:	b083      	sub	sp, #12
 8018a58:	af00      	add	r7, sp, #0
 8018a5a:	6078      	str	r0, [r7, #4]
 8018a5c:	460b      	mov	r3, r1
 8018a5e:	70fb      	strb	r3, [r7, #3]
        if (lun > bMaxLUN)
 8018a60:	687b      	ldr	r3, [r7, #4]
 8018a62:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 8018a66:	78fa      	ldrb	r2, [r7, #3]
 8018a68:	429a      	cmp	r2, r3
 8018a6a:	d902      	bls.n	8018a72 <_ZN8BulkOnly9SetCurLUNEh+0x1e>
                return MASS_ERR_INVALID_LUN;
 8018a6c:	f04f 0313 	mov.w	r3, #19
 8018a70:	e005      	b.n	8018a7e <_ZN8BulkOnly9SetCurLUNEh+0x2a>
        bTheLUN = lun;
 8018a72:	687b      	ldr	r3, [r7, #4]
 8018a74:	78fa      	ldrb	r2, [r7, #3]
 8018a76:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
        return MASS_ERR_SUCCESS;
 8018a7a:	f04f 0300 	mov.w	r3, #0
};
 8018a7e:	4618      	mov	r0, r3
 8018a80:	f107 070c 	add.w	r7, r7, #12
 8018a84:	46bd      	mov	sp, r7
 8018a86:	bc80      	pop	{r7}
 8018a88:	4770      	bx	lr
 8018a8a:	bf00      	nop

08018a8c <_ZN8BulkOnly15HandleSCSIErrorEh>:
 * For driver use only.
 *
 * @param status
 * @return
 */
uint8_t BulkOnly::HandleSCSIError(uint8_t status) {
 8018a8c:	b580      	push	{r7, lr}
 8018a8e:	b088      	sub	sp, #32
 8018a90:	af00      	add	r7, sp, #0
 8018a92:	6078      	str	r0, [r7, #4]
 8018a94:	460b      	mov	r3, r1
 8018a96:	70fb      	strb	r3, [r7, #3]
        uint8_t ret = 0;
 8018a98:	f04f 0300 	mov.w	r3, #0
 8018a9c:	76fb      	strb	r3, [r7, #27]

        switch (status) {
 8018a9e:	78fb      	ldrb	r3, [r7, #3]
 8018aa0:	2b01      	cmp	r3, #1
 8018aa2:	d01f      	beq.n	8018ae4 <_ZN8BulkOnly15HandleSCSIErrorEh+0x58>
 8018aa4:	2b02      	cmp	r3, #2
 8018aa6:	d005      	beq.n	8018ab4 <_ZN8BulkOnly15HandleSCSIErrorEh+0x28>
 8018aa8:	2b00      	cmp	r3, #0
 8018aaa:	f040 80c3 	bne.w	8018c34 <_ZN8BulkOnly15HandleSCSIErrorEh+0x1a8>
                case 0: return MASS_ERR_SUCCESS;
 8018aae:	f04f 0300 	mov.w	r3, #0
 8018ab2:	e0d2      	b.n	8018c5a <_ZN8BulkOnly15HandleSCSIErrorEh+0x1ce>
                        //case 4: return MASS_ERR_UNIT_BUSY; // Busy means retry later.
                        // case 0x05/0x14: we stalled out
                        // case 0x15/0x16: we naked out.
                case 2:
                        ErrorMessage<uint8_t > (PSTR("Phase Error"), status);
 8018ab4:	78fb      	ldrb	r3, [r7, #3]
 8018ab6:	f64e 4094 	movw	r0, #60564	; 0xec94
 8018aba:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018abe:	4619      	mov	r1, r3
 8018ac0:	f000 f9de 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                        ErrorMessage<uint8_t > (PSTR("LUN"), bTheLUN);
 8018ac4:	687b      	ldr	r3, [r7, #4]
 8018ac6:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 8018aca:	f64e 40a0 	movw	r0, #60576	; 0xeca0
 8018ace:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018ad2:	4619      	mov	r1, r3
 8018ad4:	f000 f9d4 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                        ResetRecovery();
 8018ad8:	6878      	ldr	r0, [r7, #4]
 8018ada:	f7ff fb7f 	bl	80181dc <_ZN8BulkOnly13ResetRecoveryEv>
                        return MASS_ERR_GENERAL_SCSI_ERROR;
 8018ade:	f04f 03fe 	mov.w	r3, #254	; 0xfe
 8018ae2:	e0ba      	b.n	8018c5a <_ZN8BulkOnly15HandleSCSIErrorEh+0x1ce>
                case 1:
                        ErrorMessage<uint8_t > (PSTR("SCSI Error"), status);
 8018ae4:	78fb      	ldrb	r3, [r7, #3]
 8018ae6:	f64e 40a4 	movw	r0, #60580	; 0xeca4
 8018aea:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018aee:	4619      	mov	r1, r3
 8018af0:	f000 f9c6 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                        ErrorMessage<uint8_t > (PSTR("LUN"), bTheLUN);
 8018af4:	687b      	ldr	r3, [r7, #4]
 8018af6:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 8018afa:	f64e 40a0 	movw	r0, #60576	; 0xeca0
 8018afe:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018b02:	4619      	mov	r1, r3
 8018b04:	f000 f9bc 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                        RequestSenseResponce rsp;

                        ret = RequestSense(bTheLUN, sizeof (RequestSenseResponce), (uint8_t*) & rsp);
 8018b08:	687b      	ldr	r3, [r7, #4]
 8018b0a:	f893 202e 	ldrb.w	r2, [r3, #46]	; 0x2e
 8018b0e:	f107 0308 	add.w	r3, r7, #8
 8018b12:	6878      	ldr	r0, [r7, #4]
 8018b14:	4611      	mov	r1, r2
 8018b16:	f04f 0212 	mov.w	r2, #18
 8018b1a:	f7ff f859 	bl	8017bd0 <_ZN8BulkOnly12RequestSenseEhtPh>
 8018b1e:	4603      	mov	r3, r0
 8018b20:	76fb      	strb	r3, [r7, #27]

                        if (ret) {
 8018b22:	7efb      	ldrb	r3, [r7, #27]
 8018b24:	2b00      	cmp	r3, #0
 8018b26:	d002      	beq.n	8018b2e <_ZN8BulkOnly15HandleSCSIErrorEh+0xa2>
                                //ResetRecovery();
                                return MASS_ERR_GENERAL_SCSI_ERROR;
 8018b28:	f04f 03fe 	mov.w	r3, #254	; 0xfe
 8018b2c:	e095      	b.n	8018c5a <_ZN8BulkOnly15HandleSCSIErrorEh+0x1ce>
                        }
                        ErrorMessage<uint8_t > (PSTR("Response Code"), rsp.bResponseCode);
 8018b2e:	7a3b      	ldrb	r3, [r7, #8]
 8018b30:	f64e 40b0 	movw	r0, #60592	; 0xecb0
 8018b34:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018b38:	4619      	mov	r1, r3
 8018b3a:	f000 f9a1 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                        if (rsp.bResponseCode & 0x80) {
 8018b3e:	7a3b      	ldrb	r3, [r7, #8]
 8018b40:	b2db      	uxtb	r3, r3
 8018b42:	b25b      	sxtb	r3, r3
 8018b44:	2b00      	cmp	r3, #0
 8018b46:	da31      	bge.n	8018bac <_ZN8BulkOnly15HandleSCSIErrorEh+0x120>
                                Notify(PSTR("Information field: "), 0x80);
 8018b48:	f64e 40c0 	movw	r0, #60608	; 0xecc0
 8018b4c:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018b50:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018b54:	f000 fc2e 	bl	80193b4 <_Z8E_NotifyPKci>
                                for (int i = 0; i < 4; i++) {
 8018b58:	f04f 0300 	mov.w	r3, #0
 8018b5c:	61fb      	str	r3, [r7, #28]
 8018b5e:	e015      	b.n	8018b8c <_ZN8BulkOnly15HandleSCSIErrorEh+0x100>
                                        D_PrintHex<uint8_t > (rsp.CmdSpecificInformation[i], 0x80);
 8018b60:	f107 0210 	add.w	r2, r7, #16
 8018b64:	69fb      	ldr	r3, [r7, #28]
 8018b66:	18d3      	adds	r3, r2, r3
 8018b68:	781b      	ldrb	r3, [r3, #0]
 8018b6a:	4618      	mov	r0, r3
 8018b6c:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018b70:	f7fd f98a 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
                                        Notify(PSTR(" "), 0x80);
 8018b74:	f64e 3070 	movw	r0, #60272	; 0xeb70
 8018b78:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018b7c:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018b80:	f000 fc18 	bl	80193b4 <_Z8E_NotifyPKci>
                                return MASS_ERR_GENERAL_SCSI_ERROR;
                        }
                        ErrorMessage<uint8_t > (PSTR("Response Code"), rsp.bResponseCode);
                        if (rsp.bResponseCode & 0x80) {
                                Notify(PSTR("Information field: "), 0x80);
                                for (int i = 0; i < 4; i++) {
 8018b84:	69fb      	ldr	r3, [r7, #28]
 8018b86:	f103 0301 	add.w	r3, r3, #1
 8018b8a:	61fb      	str	r3, [r7, #28]
 8018b8c:	69fb      	ldr	r3, [r7, #28]
 8018b8e:	2b03      	cmp	r3, #3
 8018b90:	bfcc      	ite	gt
 8018b92:	2300      	movgt	r3, #0
 8018b94:	2301      	movle	r3, #1
 8018b96:	b2db      	uxtb	r3, r3
 8018b98:	2b00      	cmp	r3, #0
 8018b9a:	d1e1      	bne.n	8018b60 <_ZN8BulkOnly15HandleSCSIErrorEh+0xd4>
                                        D_PrintHex<uint8_t > (rsp.CmdSpecificInformation[i], 0x80);
                                        Notify(PSTR(" "), 0x80);
                                }
                                Notify(PSTR("\r\n"), 0x80);
 8018b9c:	f64e 10a8 	movw	r0, #59816	; 0xe9a8
 8018ba0:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018ba4:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018ba8:	f000 fc04 	bl	80193b4 <_Z8E_NotifyPKci>
                        }
                        ErrorMessage<uint8_t > (PSTR("Sense Key"), rsp.bmSenseKey);
 8018bac:	7abb      	ldrb	r3, [r7, #10]
 8018bae:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8018bb2:	b2db      	uxtb	r3, r3
 8018bb4:	f64e 40d4 	movw	r0, #60628	; 0xecd4
 8018bb8:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018bbc:	4619      	mov	r1, r3
 8018bbe:	f000 f95f 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                        ErrorMessage<uint8_t > (PSTR("Add Sense Code"), rsp.bAdditionalSenseCode);
 8018bc2:	7d3b      	ldrb	r3, [r7, #20]
 8018bc4:	f64e 40e0 	movw	r0, #60640	; 0xece0
 8018bc8:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018bcc:	4619      	mov	r1, r3
 8018bce:	f000 f957 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                        ErrorMessage<uint8_t > (PSTR("Add Sense Qual"), rsp.bAdditionalSenseQualifier);
 8018bd2:	7d7b      	ldrb	r3, [r7, #21]
 8018bd4:	f64e 40f0 	movw	r0, #60656	; 0xecf0
 8018bd8:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018bdc:	4619      	mov	r1, r3
 8018bde:	f000 f94f 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                        // warning, this is not testing ASQ, only SK and ASC.
                        switch (rsp.bmSenseKey) {
 8018be2:	7abb      	ldrb	r3, [r7, #10]
 8018be4:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8018be8:	b2db      	uxtb	r3, r3
 8018bea:	2b05      	cmp	r3, #5
 8018bec:	d016      	beq.n	8018c1c <_ZN8BulkOnly15HandleSCSIErrorEh+0x190>
 8018bee:	2b06      	cmp	r3, #6
 8018bf0:	d002      	beq.n	8018bf8 <_ZN8BulkOnly15HandleSCSIErrorEh+0x16c>
 8018bf2:	2b02      	cmp	r3, #2
 8018bf4:	d009      	beq.n	8018c0a <_ZN8BulkOnly15HandleSCSIErrorEh+0x17e>
 8018bf6:	e01a      	b.n	8018c2e <_ZN8BulkOnly15HandleSCSIErrorEh+0x1a2>
                                        /* bug...
                                        case 0:
                                                return MASS_ERR_SUCCESS;
                                         */
                                case SCSI_S_UNIT_ATTENTION:
                                        switch (rsp.bAdditionalSenseCode) {
 8018bf8:	7d3b      	ldrb	r3, [r7, #20]
 8018bfa:	2b28      	cmp	r3, #40	; 0x28
 8018bfc:	d102      	bne.n	8018c04 <_ZN8BulkOnly15HandleSCSIErrorEh+0x178>
                                                case SCSI_ASC_MEDIA_CHANGED:
                                                        return MASS_ERR_MEDIA_CHANGED;
 8018bfe:	f04f 030a 	mov.w	r3, #10
 8018c02:	e02a      	b.n	8018c5a <_ZN8BulkOnly15HandleSCSIErrorEh+0x1ce>
                                                default:
                                                        return MASS_ERR_UNIT_NOT_READY;
 8018c04:	f04f 0303 	mov.w	r3, #3
 8018c08:	e027      	b.n	8018c5a <_ZN8BulkOnly15HandleSCSIErrorEh+0x1ce>
                                        }
                                case SCSI_S_NOT_READY:
                                        switch (rsp.bAdditionalSenseCode) {
 8018c0a:	7d3b      	ldrb	r3, [r7, #20]
 8018c0c:	2b3a      	cmp	r3, #58	; 0x3a
 8018c0e:	d102      	bne.n	8018c16 <_ZN8BulkOnly15HandleSCSIErrorEh+0x18a>
                                                case SCSI_ASC_MEDIUM_NOT_PRESENT:
                                                        return MASS_ERR_NO_MEDIA;
 8018c10:	f04f 0308 	mov.w	r3, #8
 8018c14:	e021      	b.n	8018c5a <_ZN8BulkOnly15HandleSCSIErrorEh+0x1ce>
                                                        //return MASS_ERR_SUCCESS;
                                                default:
                                                        return MASS_ERR_UNIT_NOT_READY;
 8018c16:	f04f 0303 	mov.w	r3, #3
 8018c1a:	e01e      	b.n	8018c5a <_ZN8BulkOnly15HandleSCSIErrorEh+0x1ce>
                                        }
                                case SCSI_S_ILLEGAL_REQUEST:
                                        switch (rsp.bAdditionalSenseCode) {
 8018c1c:	7d3b      	ldrb	r3, [r7, #20]
 8018c1e:	2b21      	cmp	r3, #33	; 0x21
 8018c20:	d102      	bne.n	8018c28 <_ZN8BulkOnly15HandleSCSIErrorEh+0x19c>
                                                case SCSI_ASC_LBA_OUT_OF_RANGE:
                                                        return MASS_ERR_BAD_LBA;
 8018c22:	f04f 0309 	mov.w	r3, #9
 8018c26:	e018      	b.n	8018c5a <_ZN8BulkOnly15HandleSCSIErrorEh+0x1ce>
                                                default:
                                                        return MASS_ERR_CMD_NOT_SUPPORTED;
 8018c28:	f04f 0306 	mov.w	r3, #6
 8018c2c:	e015      	b.n	8018c5a <_ZN8BulkOnly15HandleSCSIErrorEh+0x1ce>
                                        }
                                default:
                                        return MASS_ERR_GENERAL_SCSI_ERROR;
 8018c2e:	f04f 03fe 	mov.w	r3, #254	; 0xfe
 8018c32:	e012      	b.n	8018c5a <_ZN8BulkOnly15HandleSCSIErrorEh+0x1ce>
                        }

                default:
                        // Should have been handled already in HandleUsbError.
                        // ResetRecovery();
                        ErrorMessage<uint8_t > (PSTR("Gen SCSI Err"), status);
 8018c34:	78fb      	ldrb	r3, [r7, #3]
 8018c36:	f64e 5000 	movw	r0, #60672	; 0xed00
 8018c3a:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018c3e:	4619      	mov	r1, r3
 8018c40:	f000 f91e 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                        ErrorMessage<uint8_t > (PSTR("LUN"), bTheLUN);
 8018c44:	687b      	ldr	r3, [r7, #4]
 8018c46:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 8018c4a:	f64e 40a0 	movw	r0, #60576	; 0xeca0
 8018c4e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018c52:	4619      	mov	r1, r3
 8018c54:	f000 f914 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
                        return status; //MASS_ERR_GENERAL_SCSI_ERROR;
 8018c58:	78fb      	ldrb	r3, [r7, #3]
 8018c5a:	e001      	b.n	8018c60 <_ZN8BulkOnly15HandleSCSIErrorEh+0x1d4>
 8018c5c:	f003 ff10 	bl	801ca80 <__cxa_end_cleanup>
        } // switch
}
 8018c60:	4618      	mov	r0, r3
 8018c62:	f107 0720 	add.w	r7, r7, #32
 8018c66:	46bd      	mov	sp, r7
 8018c68:	bd80      	pop	{r7, pc}
 8018c6a:	bf00      	nop

08018c6c <_ZN8BulkOnly23PrintEndpointDescriptorEPK23USB_ENDPOINT_DESCRIPTOR>:

/**
 *
 * @param ep_ptr
 */
void BulkOnly::PrintEndpointDescriptor(const USB_ENDPOINT_DESCRIPTOR * ep_ptr) {
 8018c6c:	b580      	push	{r7, lr}
 8018c6e:	b082      	sub	sp, #8
 8018c70:	af00      	add	r7, sp, #0
 8018c72:	6078      	str	r0, [r7, #4]
 8018c74:	6039      	str	r1, [r7, #0]
        Notify(PSTR("Endpoint descriptor:"), 0x80);
 8018c76:	f64e 5010 	movw	r0, #60688	; 0xed10
 8018c7a:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018c7e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018c82:	f000 fb97 	bl	80193b4 <_Z8E_NotifyPKci>
        Notify(PSTR("\r\nLength:\t\t"), 0x80);
 8018c86:	f64e 5028 	movw	r0, #60712	; 0xed28
 8018c8a:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018c8e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018c92:	f000 fb8f 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint8_t > (ep_ptr->bLength, 0x80);
 8018c96:	683b      	ldr	r3, [r7, #0]
 8018c98:	781b      	ldrb	r3, [r3, #0]
 8018c9a:	4618      	mov	r0, r3
 8018c9c:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018ca0:	f7fd f8f2 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
        Notify(PSTR("\r\nType:\t\t"), 0x80);
 8018ca4:	f64e 5034 	movw	r0, #60724	; 0xed34
 8018ca8:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018cac:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018cb0:	f000 fb80 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint8_t > (ep_ptr->bDescriptorType, 0x80);
 8018cb4:	683b      	ldr	r3, [r7, #0]
 8018cb6:	785b      	ldrb	r3, [r3, #1]
 8018cb8:	4618      	mov	r0, r3
 8018cba:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018cbe:	f7fd f8e3 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
        Notify(PSTR("\r\nAddress:\t"), 0x80);
 8018cc2:	f64e 5040 	movw	r0, #60736	; 0xed40
 8018cc6:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018cca:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018cce:	f000 fb71 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint8_t > (ep_ptr->bEndpointAddress, 0x80);
 8018cd2:	683b      	ldr	r3, [r7, #0]
 8018cd4:	789b      	ldrb	r3, [r3, #2]
 8018cd6:	4618      	mov	r0, r3
 8018cd8:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018cdc:	f7fd f8d4 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
        Notify(PSTR("\r\nAttributes:\t"), 0x80);
 8018ce0:	f64e 504c 	movw	r0, #60748	; 0xed4c
 8018ce4:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018ce8:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018cec:	f000 fb62 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint8_t > (ep_ptr->bmAttributes, 0x80);
 8018cf0:	683b      	ldr	r3, [r7, #0]
 8018cf2:	78db      	ldrb	r3, [r3, #3]
 8018cf4:	4618      	mov	r0, r3
 8018cf6:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018cfa:	f7fd f8c5 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
        Notify(PSTR("\r\nMaxPktSize:\t"), 0x80);
 8018cfe:	f64e 505c 	movw	r0, #60764	; 0xed5c
 8018d02:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018d06:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018d0a:	f000 fb53 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint16_t > (ep_ptr->wMaxPacketSize, 0x80);
 8018d0e:	683b      	ldr	r3, [r7, #0]
 8018d10:	889b      	ldrh	r3, [r3, #4]
 8018d12:	b29b      	uxth	r3, r3
 8018d14:	4618      	mov	r0, r3
 8018d16:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018d1a:	f000 f845 	bl	8018da8 <_Z10D_PrintHexItEvT_i>
        Notify(PSTR("\r\nPoll Intrv:\t"), 0x80);
 8018d1e:	f64e 506c 	movw	r0, #60780	; 0xed6c
 8018d22:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018d26:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018d2a:	f000 fb43 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint8_t > (ep_ptr->bInterval, 0x80);
 8018d2e:	683b      	ldr	r3, [r7, #0]
 8018d30:	799b      	ldrb	r3, [r3, #6]
 8018d32:	4618      	mov	r0, r3
 8018d34:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018d38:	f7fd f8a6 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
        Notify(PSTR("\r\n"), 0x80);
 8018d3c:	f64e 10a8 	movw	r0, #59816	; 0xe9a8
 8018d40:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018d44:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018d48:	f000 fb34 	bl	80193b4 <_Z8E_NotifyPKci>
}
 8018d4c:	f107 0708 	add.w	r7, r7, #8
 8018d50:	46bd      	mov	sp, r7
 8018d52:	bd80      	pop	{r7, pc}

08018d54 <_ZN8BulkOnly4ReadEhmthP13USBReadParser>:


////////////////////////////////////////////////////////////////////////////////

/* We won't be needing this... */
uint8_t BulkOnly::Read(uint8_t lun, uint32_t addr, uint16_t bsize, uint8_t blocks, USBReadParser * prs) {
 8018d54:	b480      	push	{r7}
 8018d56:	b085      	sub	sp, #20
 8018d58:	af00      	add	r7, sp, #0
 8018d5a:	60f8      	str	r0, [r7, #12]
 8018d5c:	607a      	str	r2, [r7, #4]
 8018d5e:	460a      	mov	r2, r1
 8018d60:	72fa      	strb	r2, [r7, #11]
 8018d62:	813b      	strh	r3, [r7, #8]
        if (!LUNOk[lun]) return MASS_ERR_NO_MEDIA;
 8018d64:	7afb      	ldrb	r3, [r7, #11]
 8018d66:	68fa      	ldr	r2, [r7, #12]
 8018d68:	18d3      	adds	r3, r2, r3
 8018d6a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8018d6e:	f083 0301 	eor.w	r3, r3, #1
 8018d72:	b2db      	uxtb	r3, r3
 8018d74:	2b00      	cmp	r3, #0
 8018d76:	d002      	beq.n	8018d7e <_ZN8BulkOnly4ReadEhmthP13USBReadParser+0x2a>
 8018d78:	f04f 0308 	mov.w	r3, #8
 8018d7c:	e7ff      	b.n	8018d7e <_ZN8BulkOnly4ReadEhmthP13USBReadParser+0x2a>
        cbw.CBWCB[4] = ((addr >> 8) & 0xff);
        cbw.CBWCB[5] = (addr & 0xff);

        return HandleSCSIError(Transaction(&cbw, bsize, prs, 1));
#endif
}
 8018d7e:	4618      	mov	r0, r3
 8018d80:	f107 0714 	add.w	r7, r7, #20
 8018d84:	46bd      	mov	sp, r7
 8018d86:	bc80      	pop	{r7}
 8018d88:	4770      	bx	lr
 8018d8a:	bf00      	nop

08018d8c <_Z10D_PrintHexImEvT_i>:
                mask >>= 4;
        }
        prn->print((T) val, HEX);
}
#endif
template <class T> void D_PrintHex(T val, int lvl) {
 8018d8c:	b580      	push	{r7, lr}
 8018d8e:	b082      	sub	sp, #8
 8018d90:	af00      	add	r7, sp, #0
 8018d92:	6078      	str	r0, [r7, #4]
 8018d94:	6039      	str	r1, [r7, #0]
#ifdef DEBUG_USB_HOST
	PrintHex<T>(val, lvl);
 8018d96:	6878      	ldr	r0, [r7, #4]
 8018d98:	6839      	ldr	r1, [r7, #0]
 8018d9a:	f000 f8bb 	bl	8018f14 <_Z8PrintHexImEvT_i>
#endif
}
 8018d9e:	f107 0708 	add.w	r7, r7, #8
 8018da2:	46bd      	mov	sp, r7
 8018da4:	bd80      	pop	{r7, pc}
 8018da6:	bf00      	nop

08018da8 <_Z10D_PrintHexItEvT_i>:
                mask >>= 4;
        }
        prn->print((T) val, HEX);
}
#endif
template <class T> void D_PrintHex(T val, int lvl) {
 8018da8:	b580      	push	{r7, lr}
 8018daa:	b082      	sub	sp, #8
 8018dac:	af00      	add	r7, sp, #0
 8018dae:	4603      	mov	r3, r0
 8018db0:	6039      	str	r1, [r7, #0]
 8018db2:	80fb      	strh	r3, [r7, #6]
#ifdef DEBUG_USB_HOST
	PrintHex<T>(val, lvl);
 8018db4:	88fb      	ldrh	r3, [r7, #6]
 8018db6:	4618      	mov	r0, r3
 8018db8:	6839      	ldr	r1, [r7, #0]
 8018dba:	f000 f8e3 	bl	8018f84 <_Z8PrintHexItEvT_i>
#endif
}
 8018dbe:	f107 0708 	add.w	r7, r7, #8
 8018dc2:	46bd      	mov	sp, r7
 8018dc4:	bd80      	pop	{r7, pc}
 8018dc6:	bf00      	nop

08018dc8 <_ZN13USBReadParserC1Ev>:



// Base class for incoming data parser

class USBReadParser {
 8018dc8:	b480      	push	{r7}
 8018dca:	b083      	sub	sp, #12
 8018dcc:	af00      	add	r7, sp, #0
 8018dce:	6078      	str	r0, [r7, #4]
 8018dd0:	687b      	ldr	r3, [r7, #4]
 8018dd2:	4a04      	ldr	r2, [pc, #16]	; (8018de4 <_ZN13USBReadParserC1Ev+0x1c>)
 8018dd4:	601a      	str	r2, [r3, #0]
 8018dd6:	687b      	ldr	r3, [r7, #4]
 8018dd8:	4618      	mov	r0, r3
 8018dda:	f107 070c 	add.w	r7, r7, #12
 8018dde:	46bd      	mov	sp, r7
 8018de0:	bc80      	pop	{r7}
 8018de2:	4770      	bx	lr
 8018de4:	08020598 	.word	0x08020598

08018de8 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EEC1EP17UsbConfigXtracter>:
        ConfigDescParser(UsbConfigXtracter *xtractor);
        virtual void Parse(const uint16_t len, const uint8_t *pbuf, const uint16_t &offset);
};

template <const uint8_t CLASS_ID, const uint8_t SUBCLASS_ID, const uint8_t PROTOCOL_ID, const uint8_t MASK>
ConfigDescParser<CLASS_ID, SUBCLASS_ID, PROTOCOL_ID, MASK>::ConfigDescParser(UsbConfigXtracter *xtractor) :
 8018de8:	b580      	push	{r7, lr}
 8018dea:	b082      	sub	sp, #8
 8018dec:	af00      	add	r7, sp, #0
 8018dee:	6078      	str	r0, [r7, #4]
 8018df0:	6039      	str	r1, [r7, #0]
theXtractor(xtractor),
stateParseDescr(0),
dscrLen(0),
dscrType(0) {
 8018df2:	687b      	ldr	r3, [r7, #4]
 8018df4:	4618      	mov	r0, r3
 8018df6:	f7ff ffe7 	bl	8018dc8 <_ZN13USBReadParserC1Ev>
 8018dfa:	687b      	ldr	r3, [r7, #4]
 8018dfc:	4a1f      	ldr	r2, [pc, #124]	; (8018e7c <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EEC1EP17UsbConfigXtracter+0x94>)
 8018dfe:	601a      	str	r2, [r3, #0]
 8018e00:	687b      	ldr	r3, [r7, #4]
 8018e02:	683a      	ldr	r2, [r7, #0]
 8018e04:	605a      	str	r2, [r3, #4]
 8018e06:	687b      	ldr	r3, [r7, #4]
 8018e08:	f103 0310 	add.w	r3, r3, #16
 8018e0c:	4618      	mov	r0, r3
 8018e0e:	f7fd fb47 	bl	80164a0 <_ZN20MultiByteValueParserC1Ev>
 8018e12:	687b      	ldr	r3, [r7, #4]
 8018e14:	f103 0318 	add.w	r3, r3, #24
 8018e18:	4618      	mov	r0, r3
 8018e1a:	f7fd fb71 	bl	8016500 <_ZN11ByteSkipperC1Ev>
 8018e1e:	687b      	ldr	r3, [r7, #4]
 8018e20:	f04f 0200 	mov.w	r2, #0
 8018e24:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
 8018e28:	687b      	ldr	r3, [r7, #4]
 8018e2a:	f04f 0200 	mov.w	r2, #0
 8018e2e:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
 8018e32:	687b      	ldr	r3, [r7, #4]
 8018e34:	f04f 0200 	mov.w	r2, #0
 8018e38:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
	theBuffer.pValue = varBuffer;
 8018e3c:	687b      	ldr	r3, [r7, #4]
 8018e3e:	f103 0220 	add.w	r2, r3, #32
 8018e42:	687b      	ldr	r3, [r7, #4]
 8018e44:	f8c3 2009 	str.w	r2, [r3, #9]
	valParser.Initialize(&theBuffer);
 8018e48:	687b      	ldr	r3, [r7, #4]
 8018e4a:	f103 0210 	add.w	r2, r3, #16
 8018e4e:	687b      	ldr	r3, [r7, #4]
 8018e50:	f103 0308 	add.w	r3, r3, #8
 8018e54:	4610      	mov	r0, r2
 8018e56:	4619      	mov	r1, r3
 8018e58:	f7fd fb3a 	bl	80164d0 <_ZN20MultiByteValueParser10InitializeEP16MultiValueBuffer>
	theSkipper.Initialize(&theBuffer);
 8018e5c:	687b      	ldr	r3, [r7, #4]
 8018e5e:	f103 0218 	add.w	r2, r3, #24
 8018e62:	687b      	ldr	r3, [r7, #4]
 8018e64:	f103 0308 	add.w	r3, r3, #8
 8018e68:	4610      	mov	r0, r2
 8018e6a:	4619      	mov	r1, r3
 8018e6c:	f7fd fb60 	bl	8016530 <_ZN11ByteSkipper10InitializeEP16MultiValueBuffer>
 8018e70:	687b      	ldr	r3, [r7, #4]
};
 8018e72:	4618      	mov	r0, r3
 8018e74:	f107 0708 	add.w	r7, r7, #8
 8018e78:	46bd      	mov	sp, r7
 8018e7a:	bd80      	pop	{r7, pc}
 8018e7c:	08020538 	.word	0x08020538

08018e80 <_Z12ErrorMessageIhEvPKcT_>:
        Notify(PSTR("\r\n"), level);
#endif
}

template <class ERROR_TYPE>
void ErrorMessage(char const * msg, ERROR_TYPE rcode = 0) {
 8018e80:	b580      	push	{r7, lr}
 8018e82:	b082      	sub	sp, #8
 8018e84:	af00      	add	r7, sp, #0
 8018e86:	6078      	str	r0, [r7, #4]
 8018e88:	460b      	mov	r3, r1
 8018e8a:	70fb      	strb	r3, [r7, #3]
#ifdef DEBUG_USB_HOST
        Notify(msg, 0x80);
 8018e8c:	6878      	ldr	r0, [r7, #4]
 8018e8e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018e92:	f000 fa8f 	bl	80193b4 <_Z8E_NotifyPKci>
        Notify(PSTR(": "), 0x80);
 8018e96:	f64e 507c 	movw	r0, #60796	; 0xed7c
 8018e9a:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018e9e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018ea2:	f000 fa87 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<ERROR_TYPE > (rcode, 0x80);
 8018ea6:	78fb      	ldrb	r3, [r7, #3]
 8018ea8:	4618      	mov	r0, r3
 8018eaa:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018eae:	f7fc ffeb 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
        Notify(PSTR("\r\n"), 0x80);
 8018eb2:	f64e 10a8 	movw	r0, #59816	; 0xe9a8
 8018eb6:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018eba:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018ebe:	f000 fa79 	bl	80193b4 <_Z8E_NotifyPKci>
#endif
}
 8018ec2:	f107 0708 	add.w	r7, r7, #8
 8018ec6:	46bd      	mov	sp, r7
 8018ec8:	bd80      	pop	{r7, pc}
 8018eca:	bf00      	nop

08018ecc <_Z12ErrorMessageImEvPKcT_>:
        Notify(PSTR("\r\n"), level);
#endif
}

template <class ERROR_TYPE>
void ErrorMessage(char const * msg, ERROR_TYPE rcode = 0) {
 8018ecc:	b580      	push	{r7, lr}
 8018ece:	b082      	sub	sp, #8
 8018ed0:	af00      	add	r7, sp, #0
 8018ed2:	6078      	str	r0, [r7, #4]
 8018ed4:	6039      	str	r1, [r7, #0]
#ifdef DEBUG_USB_HOST
        Notify(msg, 0x80);
 8018ed6:	6878      	ldr	r0, [r7, #4]
 8018ed8:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018edc:	f000 fa6a 	bl	80193b4 <_Z8E_NotifyPKci>
        Notify(PSTR(": "), 0x80);
 8018ee0:	f64e 507c 	movw	r0, #60796	; 0xed7c
 8018ee4:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018ee8:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018eec:	f000 fa62 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<ERROR_TYPE > (rcode, 0x80);
 8018ef0:	6838      	ldr	r0, [r7, #0]
 8018ef2:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018ef6:	f7ff ff49 	bl	8018d8c <_Z10D_PrintHexImEvT_i>
        Notify(PSTR("\r\n"), 0x80);
 8018efa:	f64e 10a8 	movw	r0, #59816	; 0xe9a8
 8018efe:	f6c0 0001 	movt	r0, #2049	; 0x801
 8018f02:	f04f 0180 	mov.w	r1, #128	; 0x80
 8018f06:	f000 fa55 	bl	80193b4 <_Z8E_NotifyPKci>
#endif
}
 8018f0a:	f107 0708 	add.w	r7, r7, #8
 8018f0e:	46bd      	mov	sp, r7
 8018f10:	bd80      	pop	{r7, pc}
 8018f12:	bf00      	nop

08018f14 <_Z8PrintHexImEvT_i>:
void E_Notify(uint8_t b, int lvl);
void E_Notify(uint16_t b, int lvl);
void E_Notify(uint32_t b, int lvl);

template <class T>
void PrintHex(T val, int lvl) {
 8018f14:	b580      	push	{r7, lr}
 8018f16:	b084      	sub	sp, #16
 8018f18:	af00      	add	r7, sp, #0
 8018f1a:	6078      	str	r0, [r7, #4]
 8018f1c:	6039      	str	r1, [r7, #0]
	int num_nibbles = sizeof(T) * 2;
 8018f1e:	f04f 0308 	mov.w	r3, #8
 8018f22:	60fb      	str	r3, [r7, #12]

	do {
		char v = 48 + (((val >> (num_nibbles - 1) * 4)) & 0x0f);
 8018f24:	68fb      	ldr	r3, [r7, #12]
 8018f26:	f103 33ff 	add.w	r3, r3, #4294967295
 8018f2a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8018f2e:	687a      	ldr	r2, [r7, #4]
 8018f30:	fa22 f303 	lsr.w	r3, r2, r3
 8018f34:	b2db      	uxtb	r3, r3
 8018f36:	f003 030f 	and.w	r3, r3, #15
 8018f3a:	b2db      	uxtb	r3, r3
 8018f3c:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8018f40:	b2db      	uxtb	r3, r3
 8018f42:	72fb      	strb	r3, [r7, #11]
		if(v > 57) v += 7;
 8018f44:	f997 300b 	ldrsb.w	r3, [r7, #11]
 8018f48:	2b39      	cmp	r3, #57	; 0x39
 8018f4a:	dd04      	ble.n	8018f56 <_Z8PrintHexImEvT_i+0x42>
 8018f4c:	7afb      	ldrb	r3, [r7, #11]
 8018f4e:	f103 0307 	add.w	r3, r3, #7
 8018f52:	b2db      	uxtb	r3, r3
 8018f54:	72fb      	strb	r3, [r7, #11]
		E_Notifyc(v, lvl);
 8018f56:	f997 300b 	ldrsb.w	r3, [r7, #11]
 8018f5a:	4618      	mov	r0, r3
 8018f5c:	6839      	ldr	r1, [r7, #0]
 8018f5e:	f000 fa07 	bl	8019370 <_Z9E_Notifycci>

template <class T>
void PrintHex(T val, int lvl) {
	int num_nibbles = sizeof(T) * 2;

	do {
 8018f62:	68fb      	ldr	r3, [r7, #12]
 8018f64:	f103 33ff 	add.w	r3, r3, #4294967295
 8018f68:	60fb      	str	r3, [r7, #12]
 8018f6a:	68fb      	ldr	r3, [r7, #12]
 8018f6c:	2b00      	cmp	r3, #0
 8018f6e:	bf0c      	ite	eq
 8018f70:	2300      	moveq	r3, #0
 8018f72:	2301      	movne	r3, #1
 8018f74:	b2db      	uxtb	r3, r3
 8018f76:	2b00      	cmp	r3, #0
 8018f78:	d1d4      	bne.n	8018f24 <_Z8PrintHexImEvT_i+0x10>
		char v = 48 + (((val >> (num_nibbles - 1) * 4)) & 0x0f);
		if(v > 57) v += 7;
		E_Notifyc(v, lvl);
	} while(--num_nibbles);
}
 8018f7a:	f107 0710 	add.w	r7, r7, #16
 8018f7e:	46bd      	mov	sp, r7
 8018f80:	bd80      	pop	{r7, pc}
 8018f82:	bf00      	nop

08018f84 <_Z8PrintHexItEvT_i>:
void E_Notify(uint8_t b, int lvl);
void E_Notify(uint16_t b, int lvl);
void E_Notify(uint32_t b, int lvl);

template <class T>
void PrintHex(T val, int lvl) {
 8018f84:	b580      	push	{r7, lr}
 8018f86:	b084      	sub	sp, #16
 8018f88:	af00      	add	r7, sp, #0
 8018f8a:	4603      	mov	r3, r0
 8018f8c:	6039      	str	r1, [r7, #0]
 8018f8e:	80fb      	strh	r3, [r7, #6]
	int num_nibbles = sizeof(T) * 2;
 8018f90:	f04f 0304 	mov.w	r3, #4
 8018f94:	60fb      	str	r3, [r7, #12]

	do {
		char v = 48 + (((val >> (num_nibbles - 1) * 4)) & 0x0f);
 8018f96:	88fa      	ldrh	r2, [r7, #6]
 8018f98:	68fb      	ldr	r3, [r7, #12]
 8018f9a:	f103 33ff 	add.w	r3, r3, #4294967295
 8018f9e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8018fa2:	fa42 f303 	asr.w	r3, r2, r3
 8018fa6:	b2db      	uxtb	r3, r3
 8018fa8:	f003 030f 	and.w	r3, r3, #15
 8018fac:	b2db      	uxtb	r3, r3
 8018fae:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8018fb2:	b2db      	uxtb	r3, r3
 8018fb4:	72fb      	strb	r3, [r7, #11]
		if(v > 57) v += 7;
 8018fb6:	f997 300b 	ldrsb.w	r3, [r7, #11]
 8018fba:	2b39      	cmp	r3, #57	; 0x39
 8018fbc:	dd04      	ble.n	8018fc8 <_Z8PrintHexItEvT_i+0x44>
 8018fbe:	7afb      	ldrb	r3, [r7, #11]
 8018fc0:	f103 0307 	add.w	r3, r3, #7
 8018fc4:	b2db      	uxtb	r3, r3
 8018fc6:	72fb      	strb	r3, [r7, #11]
		E_Notifyc(v, lvl);
 8018fc8:	f997 300b 	ldrsb.w	r3, [r7, #11]
 8018fcc:	4618      	mov	r0, r3
 8018fce:	6839      	ldr	r1, [r7, #0]
 8018fd0:	f000 f9ce 	bl	8019370 <_Z9E_Notifycci>

template <class T>
void PrintHex(T val, int lvl) {
	int num_nibbles = sizeof(T) * 2;

	do {
 8018fd4:	68fb      	ldr	r3, [r7, #12]
 8018fd6:	f103 33ff 	add.w	r3, r3, #4294967295
 8018fda:	60fb      	str	r3, [r7, #12]
 8018fdc:	68fb      	ldr	r3, [r7, #12]
 8018fde:	2b00      	cmp	r3, #0
 8018fe0:	bf0c      	ite	eq
 8018fe2:	2300      	moveq	r3, #0
 8018fe4:	2301      	movne	r3, #1
 8018fe6:	b2db      	uxtb	r3, r3
 8018fe8:	2b00      	cmp	r3, #0
 8018fea:	d1d4      	bne.n	8018f96 <_Z8PrintHexItEvT_i+0x12>
		char v = 48 + (((val >> (num_nibbles - 1) * 4)) & 0x0f);
		if(v > 57) v += 7;
		E_Notifyc(v, lvl);
	} while(--num_nibbles);
}
 8018fec:	f107 0710 	add.w	r7, r7, #16
 8018ff0:	46bd      	mov	sp, r7
 8018ff2:	bd80      	pop	{r7, pc}

08018ff4 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE5ParseEtPKhRKt>:

template <const uint8_t CLASS_ID, const uint8_t SUBCLASS_ID, const uint8_t PROTOCOL_ID, const uint8_t MASK>
void ConfigDescParser<CLASS_ID, SUBCLASS_ID, PROTOCOL_ID, MASK>::Parse(const uint16_t len, const uint8_t *pbuf, const uint16_t &offset) {
 8018ff4:	b580      	push	{r7, lr}
 8018ff6:	b086      	sub	sp, #24
 8018ff8:	af00      	add	r7, sp, #0
 8018ffa:	60f8      	str	r0, [r7, #12]
 8018ffc:	607a      	str	r2, [r7, #4]
 8018ffe:	603b      	str	r3, [r7, #0]
 8019000:	460b      	mov	r3, r1
 8019002:	817b      	strh	r3, [r7, #10]
        uint16_t cntdn = (uint16_t) len;
 8019004:	897b      	ldrh	r3, [r7, #10]
 8019006:	82fb      	strh	r3, [r7, #22]
        uint8_t *p = (uint8_t*) pbuf;
 8019008:	687b      	ldr	r3, [r7, #4]
 801900a:	613b      	str	r3, [r7, #16]

        while(cntdn)
 801900c:	e00e      	b.n	801902c <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE5ParseEtPKhRKt+0x38>
			if(!ParseDescriptor(&p, &cntdn))
 801900e:	f107 0210 	add.w	r2, r7, #16
 8019012:	f107 0316 	add.w	r3, r7, #22
 8019016:	68f8      	ldr	r0, [r7, #12]
 8019018:	4611      	mov	r1, r2
 801901a:	461a      	mov	r2, r3
 801901c:	f000 f816 	bl	801904c <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt>
 8019020:	4603      	mov	r3, r0
 8019022:	f083 0301 	eor.w	r3, r3, #1
 8019026:	b2db      	uxtb	r3, r3
 8019028:	2b00      	cmp	r3, #0
 801902a:	d10a      	bne.n	8019042 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE5ParseEtPKhRKt+0x4e>
template <const uint8_t CLASS_ID, const uint8_t SUBCLASS_ID, const uint8_t PROTOCOL_ID, const uint8_t MASK>
void ConfigDescParser<CLASS_ID, SUBCLASS_ID, PROTOCOL_ID, MASK>::Parse(const uint16_t len, const uint8_t *pbuf, const uint16_t &offset) {
        uint16_t cntdn = (uint16_t) len;
        uint8_t *p = (uint8_t*) pbuf;

        while(cntdn)
 801902c:	8afb      	ldrh	r3, [r7, #22]
 801902e:	2b00      	cmp	r3, #0
 8019030:	bf0c      	ite	eq
 8019032:	2300      	moveq	r3, #0
 8019034:	2301      	movne	r3, #1
 8019036:	b2db      	uxtb	r3, r3
 8019038:	2b00      	cmp	r3, #0
 801903a:	d1e8      	bne.n	801900e <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE5ParseEtPKhRKt+0x1a>
			if(!ParseDescriptor(&p, &cntdn))
				return;
 801903c:	e001      	b.n	8019042 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE5ParseEtPKhRKt+0x4e>
 801903e:	f003 fd1f 	bl	801ca80 <__cxa_end_cleanup>
 8019042:	bf00      	nop
}
 8019044:	f107 0718 	add.w	r7, r7, #24
 8019048:	46bd      	mov	sp, r7
 801904a:	bd80      	pop	{r7, pc}

0801904c <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt>:

/* Parser for the configuration descriptor. Takes values for class, subclass, protocol fields in interface descriptor and
  compare masks for them. When the match is found, calls EndpointXtract passing buffer containing endpoint descriptor */
template <const uint8_t CLASS_ID, const uint8_t SUBCLASS_ID, const uint8_t PROTOCOL_ID, const uint8_t MASK>
bool ConfigDescParser<CLASS_ID, SUBCLASS_ID, PROTOCOL_ID, MASK>::ParseDescriptor(uint8_t **pp, uint16_t *pcntdn) {
 801904c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801904e:	b087      	sub	sp, #28
 8019050:	af02      	add	r7, sp, #8
 8019052:	60f8      	str	r0, [r7, #12]
 8019054:	60b9      	str	r1, [r7, #8]
 8019056:	607a      	str	r2, [r7, #4]
        switch(stateParseDescr) {
 8019058:	68fb      	ldr	r3, [r7, #12]
 801905a:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 801905e:	2b04      	cmp	r3, #4
 8019060:	f200 817e 	bhi.w	8019360 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x314>
 8019064:	a201      	add	r2, pc, #4	; (adr r2, 801906c <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x20>)
 8019066:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801906a:	bf00      	nop
 801906c:	08019081 	.word	0x08019081
 8019070:	080190a7 	.word	0x080190a7
 8019074:	080190ef 	.word	0x080190ef
 8019078:	08019105 	.word	0x08019105
 801907c:	080191e7 	.word	0x080191e7
                case 0:
                        theBuffer.valueSize = 2;
 8019080:	68fb      	ldr	r3, [r7, #12]
 8019082:	f04f 0202 	mov.w	r2, #2
 8019086:	721a      	strb	r2, [r3, #8]
                        valParser.Initialize(&theBuffer);
 8019088:	68fb      	ldr	r3, [r7, #12]
 801908a:	f103 0210 	add.w	r2, r3, #16
 801908e:	68fb      	ldr	r3, [r7, #12]
 8019090:	f103 0308 	add.w	r3, r3, #8
 8019094:	4610      	mov	r0, r2
 8019096:	4619      	mov	r1, r3
 8019098:	f7fd fa1a 	bl	80164d0 <_ZN20MultiByteValueParser10InitializeEP16MultiValueBuffer>
                        stateParseDescr = 1;
 801909c:	68fb      	ldr	r3, [r7, #12]
 801909e:	f04f 0201 	mov.w	r2, #1
 80190a2:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
                case 1:
                        if(!valParser.Parse(pp, pcntdn))
 80190a6:	68fb      	ldr	r3, [r7, #12]
 80190a8:	f103 0310 	add.w	r3, r3, #16
 80190ac:	4618      	mov	r0, r3
 80190ae:	68b9      	ldr	r1, [r7, #8]
 80190b0:	687a      	ldr	r2, [r7, #4]
 80190b2:	f000 fafd 	bl	80196b0 <_ZN20MultiByteValueParser5ParseEPPhPt>
 80190b6:	4603      	mov	r3, r0
 80190b8:	f083 0301 	eor.w	r3, r3, #1
 80190bc:	b2db      	uxtb	r3, r3
 80190be:	2b00      	cmp	r3, #0
 80190c0:	d002      	beq.n	80190c8 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x7c>
                                return false;
 80190c2:	f04f 0300 	mov.w	r3, #0
 80190c6:	e14d      	b.n	8019364 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x318>
                        dscrLen = *((uint8_t*) theBuffer.pValue);
 80190c8:	68fb      	ldr	r3, [r7, #12]
 80190ca:	f8d3 3009 	ldr.w	r3, [r3, #9]
 80190ce:	781a      	ldrb	r2, [r3, #0]
 80190d0:	68fb      	ldr	r3, [r7, #12]
 80190d2:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
                        dscrType = *((uint8_t*) theBuffer.pValue + 1);
 80190d6:	68fb      	ldr	r3, [r7, #12]
 80190d8:	f8d3 3009 	ldr.w	r3, [r3, #9]
 80190dc:	785a      	ldrb	r2, [r3, #1]
 80190de:	68fb      	ldr	r3, [r7, #12]
 80190e0:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
                        stateParseDescr = 2;
 80190e4:	68fb      	ldr	r3, [r7, #12]
 80190e6:	f04f 0202 	mov.w	r2, #2
 80190ea:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
                        // This is a sort of hack. Assuming that two bytes are all ready in the buffer
                        //	the pointer is positioned two bytes ahead in order for the rest of descriptor
                        //	to be read right after the size and the type fields.
                        // This should be used carefully. varBuffer should be used directly to handle data
                        //	in the buffer.
                        theBuffer.pValue = varBuffer + 2;
 80190ee:	68fb      	ldr	r3, [r7, #12]
 80190f0:	f103 0222 	add.w	r2, r3, #34	; 0x22
 80190f4:	68fb      	ldr	r3, [r7, #12]
 80190f6:	f8c3 2009 	str.w	r2, [r3, #9]
                        stateParseDescr = 3;
 80190fa:	68fb      	ldr	r3, [r7, #12]
 80190fc:	f04f 0203 	mov.w	r2, #3
 8019100:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
                case 3:
                        switch(dscrType) {
 8019104:	68fb      	ldr	r3, [r7, #12]
 8019106:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 801910a:	f1a3 0302 	sub.w	r3, r3, #2
 801910e:	2b1f      	cmp	r3, #31
 8019110:	d85a      	bhi.n	80191c8 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x17c>
 8019112:	a201      	add	r2, pc, #4	; (adr r2, 8019118 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0xcc>)
 8019114:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019118:	080191a3 	.word	0x080191a3
 801911c:	080191c9 	.word	0x080191c9
 8019120:	08019199 	.word	0x08019199
 8019124:	080191ad 	.word	0x080191ad
 8019128:	080191c9 	.word	0x080191c9
 801912c:	080191c9 	.word	0x080191c9
 8019130:	080191c9 	.word	0x080191c9
 8019134:	080191c9 	.word	0x080191c9
 8019138:	080191c9 	.word	0x080191c9
 801913c:	080191c9 	.word	0x080191c9
 8019140:	080191c9 	.word	0x080191c9
 8019144:	080191c9 	.word	0x080191c9
 8019148:	080191c9 	.word	0x080191c9
 801914c:	080191c9 	.word	0x080191c9
 8019150:	080191c9 	.word	0x080191c9
 8019154:	080191c9 	.word	0x080191c9
 8019158:	080191c9 	.word	0x080191c9
 801915c:	080191c9 	.word	0x080191c9
 8019160:	080191c9 	.word	0x080191c9
 8019164:	080191c9 	.word	0x080191c9
 8019168:	080191c9 	.word	0x080191c9
 801916c:	080191c9 	.word	0x080191c9
 8019170:	080191c9 	.word	0x080191c9
 8019174:	080191c9 	.word	0x080191c9
 8019178:	080191c9 	.word	0x080191c9
 801917c:	080191c9 	.word	0x080191c9
 8019180:	080191c9 	.word	0x080191c9
 8019184:	080191c9 	.word	0x080191c9
 8019188:	080191c9 	.word	0x080191c9
 801918c:	080191c9 	.word	0x080191c9
 8019190:	080191c9 	.word	0x080191c9
 8019194:	080191b7 	.word	0x080191b7
                                case USB_DESCRIPTOR_INTERFACE:
                                        isGoodInterface = false;
 8019198:	68fb      	ldr	r3, [r7, #12]
 801919a:	f04f 0200 	mov.w	r2, #0
 801919e:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
                                case USB_DESCRIPTOR_CONFIGURATION:
                                        theBuffer.valueSize = sizeof(USB_CONFIGURATION_DESCRIPTOR) - 2;
 80191a2:	68fb      	ldr	r3, [r7, #12]
 80191a4:	f04f 0207 	mov.w	r2, #7
 80191a8:	721a      	strb	r2, [r3, #8]
                                        break;
 80191aa:	e00d      	b.n	80191c8 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x17c>
                                case USB_DESCRIPTOR_ENDPOINT:
                                        theBuffer.valueSize = sizeof(USB_ENDPOINT_DESCRIPTOR) - 2;
 80191ac:	68fb      	ldr	r3, [r7, #12]
 80191ae:	f04f 0205 	mov.w	r2, #5
 80191b2:	721a      	strb	r2, [r3, #8]
                                        break;
 80191b4:	e008      	b.n	80191c8 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x17c>
                                case HID_DESCRIPTOR_HID:
                                        theBuffer.valueSize = dscrLen - 2;
 80191b6:	68fb      	ldr	r3, [r7, #12]
 80191b8:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 80191bc:	f1a3 0302 	sub.w	r3, r3, #2
 80191c0:	b2da      	uxtb	r2, r3
 80191c2:	68fb      	ldr	r3, [r7, #12]
 80191c4:	721a      	strb	r2, [r3, #8]
                                        break;
 80191c6:	bf00      	nop
                        }
                        valParser.Initialize(&theBuffer);
 80191c8:	68fb      	ldr	r3, [r7, #12]
 80191ca:	f103 0210 	add.w	r2, r3, #16
 80191ce:	68fb      	ldr	r3, [r7, #12]
 80191d0:	f103 0308 	add.w	r3, r3, #8
 80191d4:	4610      	mov	r0, r2
 80191d6:	4619      	mov	r1, r3
 80191d8:	f7fd f97a 	bl	80164d0 <_ZN20MultiByteValueParser10InitializeEP16MultiValueBuffer>
                        stateParseDescr = 4;
 80191dc:	68fb      	ldr	r3, [r7, #12]
 80191de:	f04f 0204 	mov.w	r2, #4
 80191e2:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
                case 4:
					switch(dscrType) {
 80191e6:	68fb      	ldr	r3, [r7, #12]
 80191e8:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 80191ec:	2b04      	cmp	r3, #4
 80191ee:	d01d      	beq.n	801922c <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x1e0>
 80191f0:	2b05      	cmp	r3, #5
 80191f2:	d059      	beq.n	80192a8 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x25c>
 80191f4:	2b02      	cmp	r3, #2
 80191f6:	f040 808a 	bne.w	801930e <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x2c2>
							case USB_DESCRIPTOR_CONFIGURATION:
								if(!valParser.Parse(pp, pcntdn))
 80191fa:	68fb      	ldr	r3, [r7, #12]
 80191fc:	f103 0310 	add.w	r3, r3, #16
 8019200:	4618      	mov	r0, r3
 8019202:	68b9      	ldr	r1, [r7, #8]
 8019204:	687a      	ldr	r2, [r7, #4]
 8019206:	f000 fa53 	bl	80196b0 <_ZN20MultiByteValueParser5ParseEPPhPt>
 801920a:	4603      	mov	r3, r0
 801920c:	f083 0301 	eor.w	r3, r3, #1
 8019210:	b2db      	uxtb	r3, r3
 8019212:	2b00      	cmp	r3, #0
 8019214:	d002      	beq.n	801921c <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x1d0>
									return false;
 8019216:	f04f 0300 	mov.w	r3, #0
 801921a:	e0a3      	b.n	8019364 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x318>
								confValue = ((USB_CONFIGURATION_DESCRIPTOR*) varBuffer)->bConfigurationValue;
 801921c:	68fb      	ldr	r3, [r7, #12]
 801921e:	f103 0320 	add.w	r3, r3, #32
 8019222:	795a      	ldrb	r2, [r3, #5]
 8019224:	68fb      	ldr	r3, [r7, #12]
 8019226:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
								break;
 801922a:	e08e      	b.n	801934a <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x2fe>
							case USB_DESCRIPTOR_INTERFACE:
								if(!valParser.Parse(pp, pcntdn))
 801922c:	68fb      	ldr	r3, [r7, #12]
 801922e:	f103 0310 	add.w	r3, r3, #16
 8019232:	4618      	mov	r0, r3
 8019234:	68b9      	ldr	r1, [r7, #8]
 8019236:	687a      	ldr	r2, [r7, #4]
 8019238:	f000 fa3a 	bl	80196b0 <_ZN20MultiByteValueParser5ParseEPPhPt>
 801923c:	4603      	mov	r3, r0
 801923e:	f083 0301 	eor.w	r3, r3, #1
 8019242:	b2db      	uxtb	r3, r3
 8019244:	2b00      	cmp	r3, #0
 8019246:	d002      	beq.n	801924e <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x202>
									return false;
 8019248:	f04f 0300 	mov.w	r3, #0
 801924c:	e08a      	b.n	8019364 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x318>
								if((MASK & CP_MASK_COMPARE_CLASS) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceClass != CLASS_ID)
 801924e:	68fb      	ldr	r3, [r7, #12]
 8019250:	f103 0320 	add.w	r3, r3, #32
 8019254:	795b      	ldrb	r3, [r3, #5]
 8019256:	2b08      	cmp	r3, #8
 8019258:	d170      	bne.n	801933c <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x2f0>
									break;
								if((MASK & CP_MASK_COMPARE_SUBCLASS) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceSubClass != SUBCLASS_ID)
 801925a:	68fb      	ldr	r3, [r7, #12]
 801925c:	f103 0320 	add.w	r3, r3, #32
 8019260:	799b      	ldrb	r3, [r3, #6]
 8019262:	2b06      	cmp	r3, #6
 8019264:	d16c      	bne.n	8019340 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x2f4>
									break;
								if((MASK & CP_MASK_COMPARE_PROTOCOL) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceProtocol != PROTOCOL_ID)
 8019266:	68fb      	ldr	r3, [r7, #12]
 8019268:	f103 0320 	add.w	r3, r3, #32
 801926c:	79db      	ldrb	r3, [r3, #7]
 801926e:	2b50      	cmp	r3, #80	; 0x50
 8019270:	d168      	bne.n	8019344 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x2f8>
									break;

								isGoodInterface = true;
 8019272:	68fb      	ldr	r3, [r7, #12]
 8019274:	f04f 0201 	mov.w	r2, #1
 8019278:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
								ifaceNumber = ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceNumber;
 801927c:	68fb      	ldr	r3, [r7, #12]
 801927e:	f103 0320 	add.w	r3, r3, #32
 8019282:	789a      	ldrb	r2, [r3, #2]
 8019284:	68fb      	ldr	r3, [r7, #12]
 8019286:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
								ifaceAltSet = ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bAlternateSetting;
 801928a:	68fb      	ldr	r3, [r7, #12]
 801928c:	f103 0320 	add.w	r3, r3, #32
 8019290:	78da      	ldrb	r2, [r3, #3]
 8019292:	68fb      	ldr	r3, [r7, #12]
 8019294:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
								protoValue = ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceProtocol;
 8019298:	68fb      	ldr	r3, [r7, #12]
 801929a:	f103 0320 	add.w	r3, r3, #32
 801929e:	79da      	ldrb	r2, [r3, #7]
 80192a0:	68fb      	ldr	r3, [r7, #12]
 80192a2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
								break;
 80192a6:	e050      	b.n	801934a <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x2fe>
							case USB_DESCRIPTOR_ENDPOINT:
								if(!valParser.Parse(pp, pcntdn))
 80192a8:	68fb      	ldr	r3, [r7, #12]
 80192aa:	f103 0310 	add.w	r3, r3, #16
 80192ae:	4618      	mov	r0, r3
 80192b0:	68b9      	ldr	r1, [r7, #8]
 80192b2:	687a      	ldr	r2, [r7, #4]
 80192b4:	f000 f9fc 	bl	80196b0 <_ZN20MultiByteValueParser5ParseEPPhPt>
 80192b8:	4603      	mov	r3, r0
 80192ba:	f083 0301 	eor.w	r3, r3, #1
 80192be:	b2db      	uxtb	r3, r3
 80192c0:	2b00      	cmp	r3, #0
 80192c2:	d002      	beq.n	80192ca <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x27e>
										return false;
 80192c4:	f04f 0300 	mov.w	r3, #0
 80192c8:	e04c      	b.n	8019364 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x318>
								if(isGoodInterface)
 80192ca:	68fb      	ldr	r3, [r7, #12]
 80192cc:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
 80192d0:	2b00      	cmp	r3, #0
 80192d2:	d039      	beq.n	8019348 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x2fc>
									if(theXtractor)
 80192d4:	68fb      	ldr	r3, [r7, #12]
 80192d6:	685b      	ldr	r3, [r3, #4]
 80192d8:	2b00      	cmp	r3, #0
 80192da:	d035      	beq.n	8019348 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x2fc>
										theXtractor->EndpointXtract(confValue, ifaceNumber, ifaceAltSet, protoValue, (USB_ENDPOINT_DESCRIPTOR*) varBuffer);
 80192dc:	68fb      	ldr	r3, [r7, #12]
 80192de:	685b      	ldr	r3, [r3, #4]
 80192e0:	681b      	ldr	r3, [r3, #0]
 80192e2:	681c      	ldr	r4, [r3, #0]
 80192e4:	68fb      	ldr	r3, [r7, #12]
 80192e6:	6858      	ldr	r0, [r3, #4]
 80192e8:	68fb      	ldr	r3, [r7, #12]
 80192ea:	f893 1034 	ldrb.w	r1, [r3, #52]	; 0x34
 80192ee:	68fb      	ldr	r3, [r7, #12]
 80192f0:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
 80192f4:	68fb      	ldr	r3, [r7, #12]
 80192f6:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
 80192fa:	68fd      	ldr	r5, [r7, #12]
 80192fc:	f895 6035 	ldrb.w	r6, [r5, #53]	; 0x35
 8019300:	68fd      	ldr	r5, [r7, #12]
 8019302:	f105 0520 	add.w	r5, r5, #32
 8019306:	9600      	str	r6, [sp, #0]
 8019308:	9501      	str	r5, [sp, #4]
 801930a:	47a0      	blx	r4
								break;
 801930c:	e01c      	b.n	8019348 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x2fc>
								//	if (!valParser.Parse(pp, pcntdn))
								//		return false;
								//	PrintHidDescriptor((const USB_HID_DESCRIPTOR*)varBuffer);
								//	break;
							default:
								if(!theSkipper.Skip(pp, pcntdn, dscrLen - 2))
 801930e:	68fb      	ldr	r3, [r7, #12]
 8019310:	f103 0218 	add.w	r2, r3, #24
 8019314:	68fb      	ldr	r3, [r7, #12]
 8019316:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 801931a:	f1a3 0302 	sub.w	r3, r3, #2
 801931e:	b29b      	uxth	r3, r3
 8019320:	4610      	mov	r0, r2
 8019322:	68b9      	ldr	r1, [r7, #8]
 8019324:	687a      	ldr	r2, [r7, #4]
 8019326:	f7fd f917 	bl	8016558 <_ZN11ByteSkipper4SkipEPPhPtt>
 801932a:	4603      	mov	r3, r0
 801932c:	f083 0301 	eor.w	r3, r3, #1
 8019330:	b2db      	uxtb	r3, r3
 8019332:	2b00      	cmp	r3, #0
 8019334:	d009      	beq.n	801934a <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x2fe>
									return false;
 8019336:	f04f 0300 	mov.w	r3, #0
 801933a:	e013      	b.n	8019364 <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x318>
								break;
							case USB_DESCRIPTOR_INTERFACE:
								if(!valParser.Parse(pp, pcntdn))
									return false;
								if((MASK & CP_MASK_COMPARE_CLASS) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceClass != CLASS_ID)
									break;
 801933c:	bf00      	nop
 801933e:	e004      	b.n	801934a <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x2fe>
								if((MASK & CP_MASK_COMPARE_SUBCLASS) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceSubClass != SUBCLASS_ID)
									break;
 8019340:	bf00      	nop
 8019342:	e002      	b.n	801934a <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x2fe>
								if((MASK & CP_MASK_COMPARE_PROTOCOL) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceProtocol != PROTOCOL_ID)
									break;
 8019344:	bf00      	nop
 8019346:	e000      	b.n	801934a <_ZN16ConfigDescParserILh8ELh6ELh80ELh7EE15ParseDescriptorEPPhPt+0x2fe>
								if(!valParser.Parse(pp, pcntdn))
										return false;
								if(isGoodInterface)
									if(theXtractor)
										theXtractor->EndpointXtract(confValue, ifaceNumber, ifaceAltSet, protoValue, (USB_ENDPOINT_DESCRIPTOR*) varBuffer);
								break;
 8019348:	bf00      	nop
								//	break;
							default:
								if(!theSkipper.Skip(pp, pcntdn, dscrLen - 2))
									return false;
					}
					theBuffer.pValue = varBuffer;
 801934a:	68fb      	ldr	r3, [r7, #12]
 801934c:	f103 0220 	add.w	r2, r3, #32
 8019350:	68fb      	ldr	r3, [r7, #12]
 8019352:	f8c3 2009 	str.w	r2, [r3, #9]
					stateParseDescr = 0;
 8019356:	68fb      	ldr	r3, [r7, #12]
 8019358:	f04f 0200 	mov.w	r2, #0
 801935c:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
        }
        return true;
 8019360:	f04f 0301 	mov.w	r3, #1
}
 8019364:	4618      	mov	r0, r3
 8019366:	f107 0714 	add.w	r7, r7, #20
 801936a:	46bd      	mov	sp, r7
 801936c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801936e:	bf00      	nop

08019370 <_Z9E_Notifycci>:
// 0x80 is the default (i.e. trace) to turn off set this global to something lower.
// this allows for 126 other debugging levels.
// TO-DO: Allow assignment to a different serial port
int UsbDEBUGlvl = 0x80;

void E_Notifyc(char c, int lvl) {
 8019370:	b580      	push	{r7, lr}
 8019372:	b082      	sub	sp, #8
 8019374:	af00      	add	r7, sp, #0
 8019376:	4603      	mov	r3, r0
 8019378:	6039      	str	r1, [r7, #0]
 801937a:	71fb      	strb	r3, [r7, #7]
	if (UsbDEBUGlvl < lvl) return;
 801937c:	f640 03f4 	movw	r3, #2292	; 0x8f4
 8019380:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019384:	681a      	ldr	r2, [r3, #0]
 8019386:	683b      	ldr	r3, [r7, #0]
 8019388:	429a      	cmp	r2, r3
 801938a:	db0e      	blt.n	80193aa <_Z9E_Notifycci+0x3a>
	system_cb->printf("%c", c);
 801938c:	f243 630c 	movw	r3, #13836	; 0x360c
 8019390:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019394:	681b      	ldr	r3, [r3, #0]
 8019396:	68db      	ldr	r3, [r3, #12]
 8019398:	f997 2007 	ldrsb.w	r2, [r7, #7]
 801939c:	f64e 5080 	movw	r0, #60800	; 0xed80
 80193a0:	f6c0 0001 	movt	r0, #2049	; 0x801
 80193a4:	4611      	mov	r1, r2
 80193a6:	4798      	blx	r3
 80193a8:	e000      	b.n	80193ac <_Z9E_Notifycci+0x3c>
// this allows for 126 other debugging levels.
// TO-DO: Allow assignment to a different serial port
int UsbDEBUGlvl = 0x80;

void E_Notifyc(char c, int lvl) {
	if (UsbDEBUGlvl < lvl) return;
 80193aa:	bf00      	nop
	system_cb->printf("%c", c);
}
 80193ac:	f107 0708 	add.w	r7, r7, #8
 80193b0:	46bd      	mov	sp, r7
 80193b2:	bd80      	pop	{r7, pc}

080193b4 <_Z8E_NotifyPKci>:

void E_Notify(char const * msg, int lvl) {
 80193b4:	b580      	push	{r7, lr}
 80193b6:	b082      	sub	sp, #8
 80193b8:	af00      	add	r7, sp, #0
 80193ba:	6078      	str	r0, [r7, #4]
 80193bc:	6039      	str	r1, [r7, #0]
	if (UsbDEBUGlvl < lvl) return;
 80193be:	f640 03f4 	movw	r3, #2292	; 0x8f4
 80193c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80193c6:	681a      	ldr	r2, [r3, #0]
 80193c8:	683b      	ldr	r3, [r7, #0]
 80193ca:	429a      	cmp	r2, r3
 80193cc:	db0f      	blt.n	80193ee <_Z8E_NotifyPKci+0x3a>
	if (!msg) return;
 80193ce:	687b      	ldr	r3, [r7, #4]
 80193d0:	2b00      	cmp	r3, #0
 80193d2:	d00e      	beq.n	80193f2 <_Z8E_NotifyPKci+0x3e>
	//char c;

	system_cb->printf("%s", msg);
 80193d4:	f243 630c 	movw	r3, #13836	; 0x360c
 80193d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80193dc:	681b      	ldr	r3, [r3, #0]
 80193de:	68db      	ldr	r3, [r3, #12]
 80193e0:	f64e 5084 	movw	r0, #60804	; 0xed84
 80193e4:	f6c0 0001 	movt	r0, #2049	; 0x801
 80193e8:	6879      	ldr	r1, [r7, #4]
 80193ea:	4798      	blx	r3
 80193ec:	e002      	b.n	80193f4 <_Z8E_NotifyPKci+0x40>
	if (UsbDEBUGlvl < lvl) return;
	system_cb->printf("%c", c);
}

void E_Notify(char const * msg, int lvl) {
	if (UsbDEBUGlvl < lvl) return;
 80193ee:	bf00      	nop
 80193f0:	e000      	b.n	80193f4 <_Z8E_NotifyPKci+0x40>
	if (!msg) return;
 80193f2:	bf00      	nop
	//char c;

	system_cb->printf("%s", msg);
	//hzx while ((c = pgm_read_byte(msg++))) E_Notifyc(c, lvl);
}
 80193f4:	f107 0708 	add.w	r7, r7, #8
 80193f8:	46bd      	mov	sp, r7
 80193fa:	bd80      	pop	{r7, pc}

080193fc <_Z11E_NotifyStrPKci>:

void E_NotifyStr(char const * msg, int lvl) {
 80193fc:	b580      	push	{r7, lr}
 80193fe:	b082      	sub	sp, #8
 8019400:	af00      	add	r7, sp, #0
 8019402:	6078      	str	r0, [r7, #4]
 8019404:	6039      	str	r1, [r7, #0]
        if (UsbDEBUGlvl < lvl) return;
 8019406:	f640 03f4 	movw	r3, #2292	; 0x8f4
 801940a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801940e:	681a      	ldr	r2, [r3, #0]
 8019410:	683b      	ldr	r3, [r7, #0]
 8019412:	429a      	cmp	r2, r3
 8019414:	db0f      	blt.n	8019436 <_Z11E_NotifyStrPKci+0x3a>
        if (!msg) return;
 8019416:	687b      	ldr	r3, [r7, #4]
 8019418:	2b00      	cmp	r3, #0
 801941a:	d00e      	beq.n	801943a <_Z11E_NotifyStrPKci+0x3e>
        //char c;
        system_cb->printf("%s", msg);
 801941c:	f243 630c 	movw	r3, #13836	; 0x360c
 8019420:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019424:	681b      	ldr	r3, [r3, #0]
 8019426:	68db      	ldr	r3, [r3, #12]
 8019428:	f64e 5084 	movw	r0, #60804	; 0xed84
 801942c:	f6c0 0001 	movt	r0, #2049	; 0x801
 8019430:	6879      	ldr	r1, [r7, #4]
 8019432:	4798      	blx	r3
 8019434:	e002      	b.n	801943c <_Z11E_NotifyStrPKci+0x40>
	system_cb->printf("%s", msg);
	//hzx while ((c = pgm_read_byte(msg++))) E_Notifyc(c, lvl);
}

void E_NotifyStr(char const * msg, int lvl) {
        if (UsbDEBUGlvl < lvl) return;
 8019436:	bf00      	nop
 8019438:	e000      	b.n	801943c <_Z11E_NotifyStrPKci+0x40>
        if (!msg) return;
 801943a:	bf00      	nop
        //char c;
        system_cb->printf("%s", msg);
        //while (c = *msg++) E_Notifyc(c, lvl);
}
 801943c:	f107 0708 	add.w	r7, r7, #8
 8019440:	46bd      	mov	sp, r7
 8019442:	bd80      	pop	{r7, pc}

08019444 <_Z8E_Notifyhi>:

void E_Notify(uint8_t b, int lvl) {
 8019444:	b580      	push	{r7, lr}
 8019446:	b082      	sub	sp, #8
 8019448:	af00      	add	r7, sp, #0
 801944a:	4603      	mov	r3, r0
 801944c:	6039      	str	r1, [r7, #0]
 801944e:	71fb      	strb	r3, [r7, #7]
        if (UsbDEBUGlvl < lvl) return;
 8019450:	f640 03f4 	movw	r3, #2292	; 0x8f4
 8019454:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019458:	681a      	ldr	r2, [r3, #0]
 801945a:	683b      	ldr	r3, [r7, #0]
 801945c:	429a      	cmp	r2, r3
 801945e:	db0d      	blt.n	801947c <_Z8E_Notifyhi+0x38>
        system_cb->printf("0x%X", b);
 8019460:	f243 630c 	movw	r3, #13836	; 0x360c
 8019464:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019468:	681b      	ldr	r3, [r3, #0]
 801946a:	68db      	ldr	r3, [r3, #12]
 801946c:	79fa      	ldrb	r2, [r7, #7]
 801946e:	f64e 5088 	movw	r0, #60808	; 0xed88
 8019472:	f6c0 0001 	movt	r0, #2049	; 0x801
 8019476:	4611      	mov	r1, r2
 8019478:	4798      	blx	r3
 801947a:	e000      	b.n	801947e <_Z8E_Notifyhi+0x3a>
        system_cb->printf("%s", msg);
        //while (c = *msg++) E_Notifyc(c, lvl);
}

void E_Notify(uint8_t b, int lvl) {
        if (UsbDEBUGlvl < lvl) return;
 801947c:	bf00      	nop
        system_cb->printf("0x%X", b);
}
 801947e:	f107 0708 	add.w	r7, r7, #8
 8019482:	46bd      	mov	sp, r7
 8019484:	bd80      	pop	{r7, pc}
 8019486:	bf00      	nop

08019488 <_Z8E_Notifyti>:

void E_Notify(uint16_t b, int lvl) {
 8019488:	b580      	push	{r7, lr}
 801948a:	b082      	sub	sp, #8
 801948c:	af00      	add	r7, sp, #0
 801948e:	4603      	mov	r3, r0
 8019490:	6039      	str	r1, [r7, #0]
 8019492:	80fb      	strh	r3, [r7, #6]
        if (UsbDEBUGlvl < lvl) return;
 8019494:	f640 03f4 	movw	r3, #2292	; 0x8f4
 8019498:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801949c:	681a      	ldr	r2, [r3, #0]
 801949e:	683b      	ldr	r3, [r7, #0]
 80194a0:	429a      	cmp	r2, r3
 80194a2:	db0d      	blt.n	80194c0 <_Z8E_Notifyti+0x38>
        system_cb->printf("0x%X", b);
 80194a4:	f243 630c 	movw	r3, #13836	; 0x360c
 80194a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80194ac:	681b      	ldr	r3, [r3, #0]
 80194ae:	68db      	ldr	r3, [r3, #12]
 80194b0:	88fa      	ldrh	r2, [r7, #6]
 80194b2:	f64e 5088 	movw	r0, #60808	; 0xed88
 80194b6:	f6c0 0001 	movt	r0, #2049	; 0x801
 80194ba:	4611      	mov	r1, r2
 80194bc:	4798      	blx	r3
 80194be:	e000      	b.n	80194c2 <_Z8E_Notifyti+0x3a>
        if (UsbDEBUGlvl < lvl) return;
        system_cb->printf("0x%X", b);
}

void E_Notify(uint16_t b, int lvl) {
        if (UsbDEBUGlvl < lvl) return;
 80194c0:	bf00      	nop
        system_cb->printf("0x%X", b);
}
 80194c2:	f107 0708 	add.w	r7, r7, #8
 80194c6:	46bd      	mov	sp, r7
 80194c8:	bd80      	pop	{r7, pc}
 80194ca:	bf00      	nop

080194cc <_Z8E_Notifymi>:

void E_Notify(uint32_t b, int lvl) {
 80194cc:	b580      	push	{r7, lr}
 80194ce:	b082      	sub	sp, #8
 80194d0:	af00      	add	r7, sp, #0
 80194d2:	6078      	str	r0, [r7, #4]
 80194d4:	6039      	str	r1, [r7, #0]
        if (UsbDEBUGlvl < lvl) return;
 80194d6:	f640 03f4 	movw	r3, #2292	; 0x8f4
 80194da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80194de:	681a      	ldr	r2, [r3, #0]
 80194e0:	683b      	ldr	r3, [r7, #0]
 80194e2:	429a      	cmp	r2, r3
 80194e4:	db0c      	blt.n	8019500 <_Z8E_Notifymi+0x34>
        system_cb->printf("0x%X", b);
 80194e6:	f243 630c 	movw	r3, #13836	; 0x360c
 80194ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80194ee:	681b      	ldr	r3, [r3, #0]
 80194f0:	68db      	ldr	r3, [r3, #12]
 80194f2:	f64e 5088 	movw	r0, #60808	; 0xed88
 80194f6:	f6c0 0001 	movt	r0, #2049	; 0x801
 80194fa:	6879      	ldr	r1, [r7, #4]
 80194fc:	4798      	blx	r3
 80194fe:	e000      	b.n	8019502 <_Z8E_Notifymi+0x36>
        if (UsbDEBUGlvl < lvl) return;
        system_cb->printf("0x%X", b);
}

void E_Notify(uint32_t b, int lvl) {
        if (UsbDEBUGlvl < lvl) return;
 8019500:	bf00      	nop
        system_cb->printf("0x%X", b);
}
 8019502:	f107 0708 	add.w	r7, r7, #8
 8019506:	46bd      	mov	sp, r7
 8019508:	bd80      	pop	{r7, pc}
 801950a:	bf00      	nop

0801950c <_Z8E_Notifydi>:

void E_Notify(double d, int lvl) {
 801950c:	b580      	push	{r7, lr}
 801950e:	b084      	sub	sp, #16
 8019510:	af00      	add	r7, sp, #0
 8019512:	e9c7 0102 	strd	r0, r1, [r7, #8]
 8019516:	607a      	str	r2, [r7, #4]
        if (UsbDEBUGlvl < lvl) return;
 8019518:	f640 03f4 	movw	r3, #2292	; 0x8f4
 801951c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019520:	681a      	ldr	r2, [r3, #0]
 8019522:	687b      	ldr	r3, [r7, #4]
 8019524:	429a      	cmp	r2, r3
 8019526:	db0d      	blt.n	8019544 <_Z8E_Notifydi+0x38>
        system_cb->printf("%f", d);
 8019528:	f243 630c 	movw	r3, #13836	; 0x360c
 801952c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019530:	681b      	ldr	r3, [r3, #0]
 8019532:	68d9      	ldr	r1, [r3, #12]
 8019534:	f64e 5090 	movw	r0, #60816	; 0xed90
 8019538:	f6c0 0001 	movt	r0, #2049	; 0x801
 801953c:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8019540:	4788      	blx	r1
 8019542:	e000      	b.n	8019546 <_Z8E_Notifydi+0x3a>
        if (UsbDEBUGlvl < lvl) return;
        system_cb->printf("0x%X", b);
}

void E_Notify(double d, int lvl) {
        if (UsbDEBUGlvl < lvl) return;
 8019544:	bf00      	nop
        system_cb->printf("%f", d);
}
 8019546:	f107 0710 	add.w	r7, r7, #16
 801954a:	46bd      	mov	sp, r7
 801954c:	bd80      	pop	{r7, pc}
 801954e:	bf00      	nop

08019550 <_Z21NotifyFailGetDevDescrv>:

#ifdef DEBUG_USB_HOST
void NotifyFailGetDevDescr(void) {
 8019550:	b580      	push	{r7, lr}
 8019552:	af00      	add	r7, sp, #0
        Notify(PSTR("\r\ngetDevDescr"), 0x80);
 8019554:	f64e 5094 	movw	r0, #60820	; 0xed94
 8019558:	f6c0 0001 	movt	r0, #2049	; 0x801
 801955c:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019560:	f7ff ff28 	bl	80193b4 <_Z8E_NotifyPKci>
}
 8019564:	bd80      	pop	{r7, pc}
 8019566:	bf00      	nop

08019568 <_Z24NotifyFailSetDevTblEntryv>:

void NotifyFailSetDevTblEntry(void) {
 8019568:	b580      	push	{r7, lr}
 801956a:	af00      	add	r7, sp, #0
        Notify(PSTR("\r\nsetDevTblEn"), 0x80);
 801956c:	f64e 50a4 	movw	r0, #60836	; 0xeda4
 8019570:	f6c0 0001 	movt	r0, #2049	; 0x801
 8019574:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019578:	f7ff ff1c 	bl	80193b4 <_Z8E_NotifyPKci>
}
 801957c:	bd80      	pop	{r7, pc}
 801957e:	bf00      	nop

08019580 <_Z22NotifyFailGetConfDescrv>:
void NotifyFailGetConfDescr(void) {
 8019580:	b580      	push	{r7, lr}
 8019582:	af00      	add	r7, sp, #0
        Notify(PSTR("\r\ngetConf"), 0x80);
 8019584:	f64e 50b4 	movw	r0, #60852	; 0xedb4
 8019588:	f6c0 0001 	movt	r0, #2049	; 0x801
 801958c:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019590:	f7ff ff10 	bl	80193b4 <_Z8E_NotifyPKci>
}
 8019594:	bd80      	pop	{r7, pc}
 8019596:	bf00      	nop

08019598 <_Z22NotifyFailSetConfDescrv>:

void NotifyFailSetConfDescr(void) {
 8019598:	b580      	push	{r7, lr}
 801959a:	af00      	add	r7, sp, #0
        Notify(PSTR("\r\nsetConf"), 0x80);
 801959c:	f64e 50c0 	movw	r0, #60864	; 0xedc0
 80195a0:	f6c0 0001 	movt	r0, #2049	; 0x801
 80195a4:	f04f 0180 	mov.w	r1, #128	; 0x80
 80195a8:	f7ff ff04 	bl	80193b4 <_Z8E_NotifyPKci>
}
 80195ac:	bd80      	pop	{r7, pc}
 80195ae:	bf00      	nop

080195b0 <_Z21NotifyFailGetDevDescrh>:

void NotifyFailGetDevDescr(uint8_t reason) {
 80195b0:	b580      	push	{r7, lr}
 80195b2:	b082      	sub	sp, #8
 80195b4:	af00      	add	r7, sp, #0
 80195b6:	4603      	mov	r3, r0
 80195b8:	71fb      	strb	r3, [r7, #7]
        NotifyFailGetDevDescr();
 80195ba:	f7ff ffc9 	bl	8019550 <_Z21NotifyFailGetDevDescrv>
        NotifyFail(reason);
 80195be:	79fb      	ldrb	r3, [r7, #7]
 80195c0:	4618      	mov	r0, r3
 80195c2:	f000 f85d 	bl	8019680 <_Z10NotifyFailh>
}
 80195c6:	f107 0708 	add.w	r7, r7, #8
 80195ca:	46bd      	mov	sp, r7
 80195cc:	bd80      	pop	{r7, pc}
 80195ce:	bf00      	nop

080195d0 <_Z24NotifyFailSetDevTblEntryh>:

void NotifyFailSetDevTblEntry(uint8_t reason) {
 80195d0:	b580      	push	{r7, lr}
 80195d2:	b082      	sub	sp, #8
 80195d4:	af00      	add	r7, sp, #0
 80195d6:	4603      	mov	r3, r0
 80195d8:	71fb      	strb	r3, [r7, #7]
        NotifyFailSetDevTblEntry();
 80195da:	f7ff ffc5 	bl	8019568 <_Z24NotifyFailSetDevTblEntryv>
        NotifyFail(reason);
 80195de:	79fb      	ldrb	r3, [r7, #7]
 80195e0:	4618      	mov	r0, r3
 80195e2:	f000 f84d 	bl	8019680 <_Z10NotifyFailh>

}
 80195e6:	f107 0708 	add.w	r7, r7, #8
 80195ea:	46bd      	mov	sp, r7
 80195ec:	bd80      	pop	{r7, pc}
 80195ee:	bf00      	nop

080195f0 <_Z22NotifyFailGetConfDescrh>:

void NotifyFailGetConfDescr(uint8_t reason) {
 80195f0:	b580      	push	{r7, lr}
 80195f2:	b082      	sub	sp, #8
 80195f4:	af00      	add	r7, sp, #0
 80195f6:	4603      	mov	r3, r0
 80195f8:	71fb      	strb	r3, [r7, #7]
        NotifyFailGetConfDescr();
 80195fa:	f7ff ffc1 	bl	8019580 <_Z22NotifyFailGetConfDescrv>
        NotifyFail(reason);
 80195fe:	79fb      	ldrb	r3, [r7, #7]
 8019600:	4618      	mov	r0, r3
 8019602:	f000 f83d 	bl	8019680 <_Z10NotifyFailh>
}
 8019606:	f107 0708 	add.w	r7, r7, #8
 801960a:	46bd      	mov	sp, r7
 801960c:	bd80      	pop	{r7, pc}
 801960e:	bf00      	nop

08019610 <_Z22NotifyFailSetConfDescrh>:

void NotifyFailSetConfDescr(uint8_t reason) {
 8019610:	b580      	push	{r7, lr}
 8019612:	b082      	sub	sp, #8
 8019614:	af00      	add	r7, sp, #0
 8019616:	4603      	mov	r3, r0
 8019618:	71fb      	strb	r3, [r7, #7]
        NotifyFailSetConfDescr();
 801961a:	f7ff ffbd 	bl	8019598 <_Z22NotifyFailSetConfDescrv>
        NotifyFail(reason);
 801961e:	79fb      	ldrb	r3, [r7, #7]
 8019620:	4618      	mov	r0, r3
 8019622:	f000 f82d 	bl	8019680 <_Z10NotifyFailh>
}
 8019626:	f107 0708 	add.w	r7, r7, #8
 801962a:	46bd      	mov	sp, r7
 801962c:	bd80      	pop	{r7, pc}
 801962e:	bf00      	nop

08019630 <_Z23NotifyFailUnknownDevicett>:

void NotifyFailUnknownDevice(uint16_t VID, uint16_t PID) {
 8019630:	b580      	push	{r7, lr}
 8019632:	b082      	sub	sp, #8
 8019634:	af00      	add	r7, sp, #0
 8019636:	4602      	mov	r2, r0
 8019638:	460b      	mov	r3, r1
 801963a:	80fa      	strh	r2, [r7, #6]
 801963c:	80bb      	strh	r3, [r7, #4]
        Notify(PSTR("\r\nUnknown Device Connected - VID: "), 0x80);
 801963e:	f64e 50cc 	movw	r0, #60876	; 0xedcc
 8019642:	f6c0 0001 	movt	r0, #2049	; 0x801
 8019646:	f04f 0180 	mov.w	r1, #128	; 0x80
 801964a:	f7ff feb3 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint16_t > (VID, 0x80);
 801964e:	88fb      	ldrh	r3, [r7, #6]
 8019650:	4618      	mov	r0, r3
 8019652:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019656:	f7ff fba7 	bl	8018da8 <_Z10D_PrintHexItEvT_i>
        Notify(PSTR(" PID: "), 0x80);
 801965a:	f64e 50f0 	movw	r0, #60912	; 0xedf0
 801965e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8019662:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019666:	f7ff fea5 	bl	80193b4 <_Z8E_NotifyPKci>
        D_PrintHex<uint16_t > (PID, 0x80);
 801966a:	88bb      	ldrh	r3, [r7, #4]
 801966c:	4618      	mov	r0, r3
 801966e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019672:	f7ff fb99 	bl	8018da8 <_Z10D_PrintHexItEvT_i>
}
 8019676:	f107 0708 	add.w	r7, r7, #8
 801967a:	46bd      	mov	sp, r7
 801967c:	bd80      	pop	{r7, pc}
 801967e:	bf00      	nop

08019680 <_Z10NotifyFailh>:

void NotifyFail(uint8_t rcode) {
 8019680:	b580      	push	{r7, lr}
 8019682:	b082      	sub	sp, #8
 8019684:	af00      	add	r7, sp, #0
 8019686:	4603      	mov	r3, r0
 8019688:	71fb      	strb	r3, [r7, #7]
        D_PrintHex<uint8_t > (rcode, 0x80);
 801968a:	79fb      	ldrb	r3, [r7, #7]
 801968c:	4618      	mov	r0, r3
 801968e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019692:	f7fc fbf9 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
        Notify(PSTR("\r\n"), 0x80);
 8019696:	f64e 50f8 	movw	r0, #60920	; 0xedf8
 801969a:	f6c0 0001 	movt	r0, #2049	; 0x801
 801969e:	f04f 0180 	mov.w	r1, #128	; 0x80
 80196a2:	f7ff fe87 	bl	80193b4 <_Z8E_NotifyPKci>
}
 80196a6:	f107 0708 	add.w	r7, r7, #8
 80196aa:	46bd      	mov	sp, r7
 80196ac:	bd80      	pop	{r7, pc}
 80196ae:	bf00      	nop

080196b0 <_ZN20MultiByteValueParser5ParseEPPhPt>:


#include "parsetools.h"

bool MultiByteValueParser::Parse(uint8_t **pp, uint16_t *pcntdn) {
 80196b0:	b480      	push	{r7}
 80196b2:	b085      	sub	sp, #20
 80196b4:	af00      	add	r7, sp, #0
 80196b6:	60f8      	str	r0, [r7, #12]
 80196b8:	60b9      	str	r1, [r7, #8]
 80196ba:	607a      	str	r2, [r7, #4]
        if (!pBuf) {
 80196bc:	68fb      	ldr	r3, [r7, #12]
 80196be:	681b      	ldr	r3, [r3, #0]
 80196c0:	2b00      	cmp	r3, #0
 80196c2:	d123      	bne.n	801970c <_ZN20MultiByteValueParser5ParseEPPhPt+0x5c>
                //Notify(PSTR("Buffer pointer is NULL!\r\n"), 0x80);
                return false;
 80196c4:	f04f 0300 	mov.w	r3, #0
 80196c8:	e03c      	b.n	8019744 <_ZN20MultiByteValueParser5ParseEPPhPt+0x94>
        }
        for (; countDown && (*pcntdn); countDown--, (*pcntdn)--, (*pp)++)
                pBuf[valueSize - countDown] = (**pp);
 80196ca:	68fb      	ldr	r3, [r7, #12]
 80196cc:	681a      	ldr	r2, [r3, #0]
 80196ce:	68fb      	ldr	r3, [r7, #12]
 80196d0:	795b      	ldrb	r3, [r3, #5]
 80196d2:	4619      	mov	r1, r3
 80196d4:	68fb      	ldr	r3, [r7, #12]
 80196d6:	791b      	ldrb	r3, [r3, #4]
 80196d8:	1acb      	subs	r3, r1, r3
 80196da:	18d3      	adds	r3, r2, r3
 80196dc:	68ba      	ldr	r2, [r7, #8]
 80196de:	6812      	ldr	r2, [r2, #0]
 80196e0:	7812      	ldrb	r2, [r2, #0]
 80196e2:	701a      	strb	r2, [r3, #0]
bool MultiByteValueParser::Parse(uint8_t **pp, uint16_t *pcntdn) {
        if (!pBuf) {
                //Notify(PSTR("Buffer pointer is NULL!\r\n"), 0x80);
                return false;
        }
        for (; countDown && (*pcntdn); countDown--, (*pcntdn)--, (*pp)++)
 80196e4:	68fb      	ldr	r3, [r7, #12]
 80196e6:	791b      	ldrb	r3, [r3, #4]
 80196e8:	f103 33ff 	add.w	r3, r3, #4294967295
 80196ec:	b2da      	uxtb	r2, r3
 80196ee:	68fb      	ldr	r3, [r7, #12]
 80196f0:	711a      	strb	r2, [r3, #4]
 80196f2:	687b      	ldr	r3, [r7, #4]
 80196f4:	881b      	ldrh	r3, [r3, #0]
 80196f6:	f103 33ff 	add.w	r3, r3, #4294967295
 80196fa:	b29a      	uxth	r2, r3
 80196fc:	687b      	ldr	r3, [r7, #4]
 80196fe:	801a      	strh	r2, [r3, #0]
 8019700:	68bb      	ldr	r3, [r7, #8]
 8019702:	681b      	ldr	r3, [r3, #0]
 8019704:	f103 0201 	add.w	r2, r3, #1
 8019708:	68bb      	ldr	r3, [r7, #8]
 801970a:	601a      	str	r2, [r3, #0]
 801970c:	68fb      	ldr	r3, [r7, #12]
 801970e:	791b      	ldrb	r3, [r3, #4]
 8019710:	2b00      	cmp	r3, #0
 8019712:	d006      	beq.n	8019722 <_ZN20MultiByteValueParser5ParseEPPhPt+0x72>
 8019714:	687b      	ldr	r3, [r7, #4]
 8019716:	881b      	ldrh	r3, [r3, #0]
 8019718:	2b00      	cmp	r3, #0
 801971a:	d002      	beq.n	8019722 <_ZN20MultiByteValueParser5ParseEPPhPt+0x72>
 801971c:	f04f 0301 	mov.w	r3, #1
 8019720:	e001      	b.n	8019726 <_ZN20MultiByteValueParser5ParseEPPhPt+0x76>
 8019722:	f04f 0300 	mov.w	r3, #0
 8019726:	2b00      	cmp	r3, #0
 8019728:	d1cf      	bne.n	80196ca <_ZN20MultiByteValueParser5ParseEPPhPt+0x1a>
                pBuf[valueSize - countDown] = (**pp);

        if (countDown)
 801972a:	68fb      	ldr	r3, [r7, #12]
 801972c:	791b      	ldrb	r3, [r3, #4]
 801972e:	2b00      	cmp	r3, #0
 8019730:	d002      	beq.n	8019738 <_ZN20MultiByteValueParser5ParseEPPhPt+0x88>
                return false;
 8019732:	f04f 0300 	mov.w	r3, #0
 8019736:	e005      	b.n	8019744 <_ZN20MultiByteValueParser5ParseEPPhPt+0x94>

        countDown = valueSize;
 8019738:	68fb      	ldr	r3, [r7, #12]
 801973a:	795a      	ldrb	r2, [r3, #5]
 801973c:	68fb      	ldr	r3, [r7, #12]
 801973e:	711a      	strb	r2, [r3, #4]
        return true;
 8019740:	f04f 0301 	mov.w	r3, #1
}
 8019744:	4618      	mov	r0, r3
 8019746:	f107 0714 	add.w	r7, r7, #20
 801974a:	46bd      	mov	sp, r7
 801974c:	bc80      	pop	{r7}
 801974e:	4770      	bx	lr

08019750 <_ZN13PTPListParser5ParseEPPhPtPFvPK16MultiValueBuffermPKvES7_>:

bool PTPListParser::Parse(uint8_t **pp, uint16_t *pcntdn, PTP_ARRAY_EL_FUNC pf, const void *me) {
 8019750:	b580      	push	{r7, lr}
 8019752:	b084      	sub	sp, #16
 8019754:	af00      	add	r7, sp, #0
 8019756:	60f8      	str	r0, [r7, #12]
 8019758:	60b9      	str	r1, [r7, #8]
 801975a:	607a      	str	r2, [r7, #4]
 801975c:	603b      	str	r3, [r7, #0]
        switch (nStage) {
 801975e:	68fb      	ldr	r3, [r7, #12]
 8019760:	781b      	ldrb	r3, [r3, #0]
 8019762:	2b03      	cmp	r3, #3
 8019764:	f200 8093 	bhi.w	801988e <_ZN13PTPListParser5ParseEPPhPtPFvPK16MultiValueBuffermPKvES7_+0x13e>
 8019768:	a201      	add	r2, pc, #4	; (adr r2, 8019770 <_ZN13PTPListParser5ParseEPPhPtPFvPK16MultiValueBuffermPKvES7_+0x20>)
 801976a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801976e:	bf00      	nop
 8019770:	08019781 	.word	0x08019781
 8019774:	080197a5 	.word	0x080197a5
 8019778:	08019803 	.word	0x08019803
 801977c:	08019875 	.word	0x08019875
                case 0:
                        pBuf->valueSize = lenSize;
 8019780:	68fb      	ldr	r3, [r7, #12]
 8019782:	691b      	ldr	r3, [r3, #16]
 8019784:	68fa      	ldr	r2, [r7, #12]
 8019786:	7b12      	ldrb	r2, [r2, #12]
 8019788:	701a      	strb	r2, [r3, #0]
                        theParser.Initialize(pBuf);
 801978a:	68fb      	ldr	r3, [r7, #12]
 801978c:	f103 0214 	add.w	r2, r3, #20
 8019790:	68fb      	ldr	r3, [r7, #12]
 8019792:	691b      	ldr	r3, [r3, #16]
 8019794:	4610      	mov	r0, r2
 8019796:	4619      	mov	r1, r3
 8019798:	f7fc fe9a 	bl	80164d0 <_ZN20MultiByteValueParser10InitializeEP16MultiValueBuffer>
                        nStage = 1;
 801979c:	68fb      	ldr	r3, [r7, #12]
 801979e:	f04f 0201 	mov.w	r2, #1
 80197a2:	701a      	strb	r2, [r3, #0]

                case 1:
                        if (!theParser.Parse(pp, pcntdn))
 80197a4:	68fb      	ldr	r3, [r7, #12]
 80197a6:	f103 0314 	add.w	r3, r3, #20
 80197aa:	4618      	mov	r0, r3
 80197ac:	68b9      	ldr	r1, [r7, #8]
 80197ae:	687a      	ldr	r2, [r7, #4]
 80197b0:	f7ff ff7e 	bl	80196b0 <_ZN20MultiByteValueParser5ParseEPPhPt>
 80197b4:	4603      	mov	r3, r0
 80197b6:	f083 0301 	eor.w	r3, r3, #1
 80197ba:	b2db      	uxtb	r3, r3
 80197bc:	2b00      	cmp	r3, #0
 80197be:	d002      	beq.n	80197c6 <_ZN13PTPListParser5ParseEPPhPtPFvPK16MultiValueBuffermPKvES7_+0x76>
                                return false;
 80197c0:	f04f 0300 	mov.w	r3, #0
 80197c4:	e065      	b.n	8019892 <_ZN13PTPListParser5ParseEPPhPtPFvPK16MultiValueBuffermPKvES7_+0x142>

                        arLen = 0;
 80197c6:	68fb      	ldr	r3, [r7, #12]
 80197c8:	f04f 0200 	mov.w	r2, #0
 80197cc:	605a      	str	r2, [r3, #4]
                        arLen = (pBuf->valueSize >= 4) ? *((uint32_t*)pBuf->pValue) : (uint32_t)(*((uint16_t*)pBuf->pValue));
 80197ce:	68fb      	ldr	r3, [r7, #12]
 80197d0:	691b      	ldr	r3, [r3, #16]
 80197d2:	781b      	ldrb	r3, [r3, #0]
 80197d4:	2b03      	cmp	r3, #3
 80197d6:	d905      	bls.n	80197e4 <_ZN13PTPListParser5ParseEPPhPtPFvPK16MultiValueBuffermPKvES7_+0x94>
 80197d8:	68fb      	ldr	r3, [r7, #12]
 80197da:	691b      	ldr	r3, [r3, #16]
 80197dc:	f8d3 3001 	ldr.w	r3, [r3, #1]
 80197e0:	681b      	ldr	r3, [r3, #0]
 80197e2:	e004      	b.n	80197ee <_ZN13PTPListParser5ParseEPPhPtPFvPK16MultiValueBuffermPKvES7_+0x9e>
 80197e4:	68fb      	ldr	r3, [r7, #12]
 80197e6:	691b      	ldr	r3, [r3, #16]
 80197e8:	f8d3 3001 	ldr.w	r3, [r3, #1]
 80197ec:	881b      	ldrh	r3, [r3, #0]
 80197ee:	68fa      	ldr	r2, [r7, #12]
 80197f0:	6053      	str	r3, [r2, #4]
                        arLenCntdn = arLen;
 80197f2:	68fb      	ldr	r3, [r7, #12]
 80197f4:	685a      	ldr	r2, [r3, #4]
 80197f6:	68fb      	ldr	r3, [r7, #12]
 80197f8:	609a      	str	r2, [r3, #8]
                        nStage = 2;
 80197fa:	68fb      	ldr	r3, [r7, #12]
 80197fc:	f04f 0202 	mov.w	r2, #2
 8019800:	701a      	strb	r2, [r3, #0]

                case 2:
                        pBuf->valueSize = valSize;
 8019802:	68fb      	ldr	r3, [r7, #12]
 8019804:	691b      	ldr	r3, [r3, #16]
 8019806:	68fa      	ldr	r2, [r7, #12]
 8019808:	7b52      	ldrb	r2, [r2, #13]
 801980a:	701a      	strb	r2, [r3, #0]
                        theParser.Initialize(pBuf);
 801980c:	68fb      	ldr	r3, [r7, #12]
 801980e:	f103 0214 	add.w	r2, r3, #20
 8019812:	68fb      	ldr	r3, [r7, #12]
 8019814:	691b      	ldr	r3, [r3, #16]
 8019816:	4610      	mov	r0, r2
 8019818:	4619      	mov	r1, r3
 801981a:	f7fc fe59 	bl	80164d0 <_ZN20MultiByteValueParser10InitializeEP16MultiValueBuffer>
                        nStage = 3;
 801981e:	68fb      	ldr	r3, [r7, #12]
 8019820:	f04f 0203 	mov.w	r2, #3
 8019824:	701a      	strb	r2, [r3, #0]

                case 3:
                        for (; arLenCntdn; arLenCntdn--) {
 8019826:	e025      	b.n	8019874 <_ZN13PTPListParser5ParseEPPhPtPFvPK16MultiValueBuffermPKvES7_+0x124>
                                if (!theParser.Parse(pp, pcntdn))
 8019828:	68fb      	ldr	r3, [r7, #12]
 801982a:	f103 0314 	add.w	r3, r3, #20
 801982e:	4618      	mov	r0, r3
 8019830:	68b9      	ldr	r1, [r7, #8]
 8019832:	687a      	ldr	r2, [r7, #4]
 8019834:	f7ff ff3c 	bl	80196b0 <_ZN20MultiByteValueParser5ParseEPPhPt>
 8019838:	4603      	mov	r3, r0
 801983a:	f083 0301 	eor.w	r3, r3, #1
 801983e:	b2db      	uxtb	r3, r3
 8019840:	2b00      	cmp	r3, #0
 8019842:	d002      	beq.n	801984a <_ZN13PTPListParser5ParseEPPhPtPFvPK16MultiValueBuffermPKvES7_+0xfa>
                                        return false;
 8019844:	f04f 0300 	mov.w	r3, #0
 8019848:	e023      	b.n	8019892 <_ZN13PTPListParser5ParseEPPhPtPFvPK16MultiValueBuffermPKvES7_+0x142>

                                if (pf)
 801984a:	683b      	ldr	r3, [r7, #0]
 801984c:	2b00      	cmp	r3, #0
 801984e:	d00b      	beq.n	8019868 <_ZN13PTPListParser5ParseEPPhPtPFvPK16MultiValueBuffermPKvES7_+0x118>
                                        pf(pBuf, (arLen - arLenCntdn), me);
 8019850:	68fb      	ldr	r3, [r7, #12]
 8019852:	6919      	ldr	r1, [r3, #16]
 8019854:	68fb      	ldr	r3, [r7, #12]
 8019856:	685a      	ldr	r2, [r3, #4]
 8019858:	68fb      	ldr	r3, [r7, #12]
 801985a:	689b      	ldr	r3, [r3, #8]
 801985c:	1ad2      	subs	r2, r2, r3
 801985e:	683b      	ldr	r3, [r7, #0]
 8019860:	4608      	mov	r0, r1
 8019862:	4611      	mov	r1, r2
 8019864:	69ba      	ldr	r2, [r7, #24]
 8019866:	4798      	blx	r3
                        pBuf->valueSize = valSize;
                        theParser.Initialize(pBuf);
                        nStage = 3;

                case 3:
                        for (; arLenCntdn; arLenCntdn--) {
 8019868:	68fb      	ldr	r3, [r7, #12]
 801986a:	689b      	ldr	r3, [r3, #8]
 801986c:	f103 32ff 	add.w	r2, r3, #4294967295
 8019870:	68fb      	ldr	r3, [r7, #12]
 8019872:	609a      	str	r2, [r3, #8]
 8019874:	68fb      	ldr	r3, [r7, #12]
 8019876:	689b      	ldr	r3, [r3, #8]
 8019878:	2b00      	cmp	r3, #0
 801987a:	bf0c      	ite	eq
 801987c:	2300      	moveq	r3, #0
 801987e:	2301      	movne	r3, #1
 8019880:	b2db      	uxtb	r3, r3
 8019882:	2b00      	cmp	r3, #0
 8019884:	d1d0      	bne.n	8019828 <_ZN13PTPListParser5ParseEPPhPtPFvPK16MultiValueBuffermPKvES7_+0xd8>

                                if (pf)
                                        pf(pBuf, (arLen - arLenCntdn), me);
                        }

                        nStage = 0;
 8019886:	68fb      	ldr	r3, [r7, #12]
 8019888:	f04f 0200 	mov.w	r2, #0
 801988c:	701a      	strb	r2, [r3, #0]
        }
        return true;
 801988e:	f04f 0301 	mov.w	r3, #1
}
 8019892:	4618      	mov	r0, r3
 8019894:	f107 0710 	add.w	r7, r7, #16
 8019898:	46bd      	mov	sp, r7
 801989a:	bd80      	pop	{r7, pc}

0801989c <_ZN3USB13SetHubPreMaskEv>:

public:
        USB();	//USB_OTG_CORE_HANDLE *pDev);
        bool bGlobalPollEnable;	// global switch for polling

        void SetHubPreMask() {
 801989c:	b480      	push	{r7}
 801989e:	b083      	sub	sp, #12
 80198a0:	af00      	add	r7, sp, #0
 80198a2:	6078      	str	r0, [r7, #4]
                bmHubPre |= bmHUBPRE;
 80198a4:	687b      	ldr	r3, [r7, #4]
 80198a6:	f893 30bc 	ldrb.w	r3, [r3, #188]	; 0xbc
 80198aa:	f043 0304 	orr.w	r3, r3, #4
 80198ae:	b2da      	uxtb	r2, r3
 80198b0:	687b      	ldr	r3, [r7, #4]
 80198b2:	f883 20bc 	strb.w	r2, [r3, #188]	; 0xbc
        };
 80198b6:	f107 070c 	add.w	r7, r7, #12
 80198ba:	46bd      	mov	sp, r7
 80198bc:	bc80      	pop	{r7}
 80198be:	4770      	bx	lr

080198c0 <_ZN6USBHub10GetAddressEv>:

        virtual uint8_t Init(uint8_t parent, uint8_t port, bool lowspeed);
        virtual uint8_t Release();
        virtual uint8_t Poll();
        virtual void ResetHubPort(uint8_t port);
        virtual uint8_t GetAddress() {
 80198c0:	b480      	push	{r7}
 80198c2:	b083      	sub	sp, #12
 80198c4:	af00      	add	r7, sp, #0
 80198c6:	6078      	str	r0, [r7, #4]
			return bAddress;
 80198c8:	687b      	ldr	r3, [r7, #4]
 80198ca:	7c9b      	ldrb	r3, [r3, #18]
        };
 80198cc:	4618      	mov	r0, r3
 80198ce:	f107 070c 	add.w	r7, r7, #12
 80198d2:	46bd      	mov	sp, r7
 80198d4:	bc80      	pop	{r7}
 80198d6:	4770      	bx	lr

080198d8 <_ZN6USBHub10DEVCLASSOKEh>:
        virtual uint8_t DEVCLASSOK(uint8_t klass) { return (klass == USB_CLASS_HUB); }
 80198d8:	b480      	push	{r7}
 80198da:	b083      	sub	sp, #12
 80198dc:	af00      	add	r7, sp, #0
 80198de:	6078      	str	r0, [r7, #4]
 80198e0:	460b      	mov	r3, r1
 80198e2:	70fb      	strb	r3, [r7, #3]
 80198e4:	78fb      	ldrb	r3, [r7, #3]
 80198e6:	2b09      	cmp	r3, #9
 80198e8:	bf14      	ite	ne
 80198ea:	2300      	movne	r3, #0
 80198ec:	2301      	moveq	r3, #1
 80198ee:	b2db      	uxtb	r3, r3
 80198f0:	4618      	mov	r0, r3
 80198f2:	f107 070c 	add.w	r7, r7, #12
 80198f6:	46bd      	mov	sp, r7
 80198f8:	bc80      	pop	{r7}
 80198fa:	4770      	bx	lr

080198fc <_ZN6USBHub16ClearPortFeatureEhhh>:
inline uint8_t USBHub::ClearHubFeature(uint8_t fid) {
        return( pUsb->ctrlReq(bAddress, 0, bmREQ_CLEAR_HUB_FEATURE, USB_REQUEST_CLEAR_FEATURE, fid, 0, 0, 0, 0, NULL, NULL));
}
// Clear Port Feature

inline uint8_t USBHub::ClearPortFeature(uint8_t fid, uint8_t port, uint8_t sel) {
 80198fc:	b580      	push	{r7, lr}
 80198fe:	b08a      	sub	sp, #40	; 0x28
 8019900:	af08      	add	r7, sp, #32
 8019902:	6078      	str	r0, [r7, #4]
 8019904:	70f9      	strb	r1, [r7, #3]
 8019906:	70ba      	strb	r2, [r7, #2]
 8019908:	707b      	strb	r3, [r7, #1]
        return( pUsb->ctrlReq(bAddress, 0, bmREQ_CLEAR_PORT_FEATURE, USB_REQUEST_CLEAR_FEATURE, fid, 0, ((0x0000 | port) | (sel << 8)), 0, 0, NULL, NULL));
 801990a:	687b      	ldr	r3, [r7, #4]
 801990c:	685a      	ldr	r2, [r3, #4]
 801990e:	687b      	ldr	r3, [r7, #4]
 8019910:	7c9b      	ldrb	r3, [r3, #18]
 8019912:	78b9      	ldrb	r1, [r7, #2]
 8019914:	b288      	uxth	r0, r1
 8019916:	7879      	ldrb	r1, [r7, #1]
 8019918:	ea4f 2101 	mov.w	r1, r1, lsl #8
 801991c:	b289      	uxth	r1, r1
 801991e:	4301      	orrs	r1, r0
 8019920:	b289      	uxth	r1, r1
 8019922:	b289      	uxth	r1, r1
 8019924:	f04f 0001 	mov.w	r0, #1
 8019928:	9000      	str	r0, [sp, #0]
 801992a:	78f8      	ldrb	r0, [r7, #3]
 801992c:	9001      	str	r0, [sp, #4]
 801992e:	f04f 0000 	mov.w	r0, #0
 8019932:	9002      	str	r0, [sp, #8]
 8019934:	9103      	str	r1, [sp, #12]
 8019936:	f04f 0100 	mov.w	r1, #0
 801993a:	9104      	str	r1, [sp, #16]
 801993c:	f04f 0100 	mov.w	r1, #0
 8019940:	9105      	str	r1, [sp, #20]
 8019942:	f04f 0100 	mov.w	r1, #0
 8019946:	9106      	str	r1, [sp, #24]
 8019948:	f04f 0100 	mov.w	r1, #0
 801994c:	9107      	str	r1, [sp, #28]
 801994e:	4610      	mov	r0, r2
 8019950:	4619      	mov	r1, r3
 8019952:	f04f 0200 	mov.w	r2, #0
 8019956:	f04f 0323 	mov.w	r3, #35	; 0x23
 801995a:	f7fa fea3 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 801995e:	4603      	mov	r3, r0
}
 8019960:	4618      	mov	r0, r3
 8019962:	f107 0708 	add.w	r7, r7, #8
 8019966:	46bd      	mov	sp, r7
 8019968:	bd80      	pop	{r7, pc}
 801996a:	bf00      	nop

0801996c <_ZN6USBHub16GetHubDescriptorEhtPh>:
// Get Hub Descriptor

inline uint8_t USBHub::GetHubDescriptor(uint8_t index, uint16_t nbytes, uint8_t *dataptr) {
 801996c:	b580      	push	{r7, lr}
 801996e:	b08c      	sub	sp, #48	; 0x30
 8019970:	af08      	add	r7, sp, #32
 8019972:	60f8      	str	r0, [r7, #12]
 8019974:	607b      	str	r3, [r7, #4]
 8019976:	460b      	mov	r3, r1
 8019978:	72fb      	strb	r3, [r7, #11]
 801997a:	4613      	mov	r3, r2
 801997c:	813b      	strh	r3, [r7, #8]
        return( pUsb->ctrlReq(bAddress, 0, bmREQ_GET_HUB_DESCRIPTOR, USB_REQUEST_GET_DESCRIPTOR, index, 0x29, 0, nbytes, nbytes, dataptr, NULL));
 801997e:	68fb      	ldr	r3, [r7, #12]
 8019980:	685a      	ldr	r2, [r3, #4]
 8019982:	68fb      	ldr	r3, [r7, #12]
 8019984:	7c9b      	ldrb	r3, [r3, #18]
 8019986:	f04f 0106 	mov.w	r1, #6
 801998a:	9100      	str	r1, [sp, #0]
 801998c:	7af9      	ldrb	r1, [r7, #11]
 801998e:	9101      	str	r1, [sp, #4]
 8019990:	f04f 0129 	mov.w	r1, #41	; 0x29
 8019994:	9102      	str	r1, [sp, #8]
 8019996:	f04f 0100 	mov.w	r1, #0
 801999a:	9103      	str	r1, [sp, #12]
 801999c:	8939      	ldrh	r1, [r7, #8]
 801999e:	9104      	str	r1, [sp, #16]
 80199a0:	8939      	ldrh	r1, [r7, #8]
 80199a2:	9105      	str	r1, [sp, #20]
 80199a4:	6879      	ldr	r1, [r7, #4]
 80199a6:	9106      	str	r1, [sp, #24]
 80199a8:	f04f 0100 	mov.w	r1, #0
 80199ac:	9107      	str	r1, [sp, #28]
 80199ae:	4610      	mov	r0, r2
 80199b0:	4619      	mov	r1, r3
 80199b2:	f04f 0200 	mov.w	r2, #0
 80199b6:	f04f 03a0 	mov.w	r3, #160	; 0xa0
 80199ba:	f7fa fe73 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 80199be:	4603      	mov	r3, r0
}
 80199c0:	4618      	mov	r0, r3
 80199c2:	f107 0710 	add.w	r7, r7, #16
 80199c6:	46bd      	mov	sp, r7
 80199c8:	bd80      	pop	{r7, pc}
 80199ca:	bf00      	nop

080199cc <_ZN6USBHub13GetPortStatusEhtPh>:
inline uint8_t USBHub::GetHubStatus(uint16_t nbytes, uint8_t* dataptr) {
        return( pUsb->ctrlReq(bAddress, 0, bmREQ_GET_HUB_STATUS, USB_REQUEST_GET_STATUS, 0, 0, 0x0000, nbytes, nbytes, dataptr, NULL));
}
// Get Port Status

inline uint8_t USBHub::GetPortStatus(uint8_t port, uint16_t nbytes, uint8_t* dataptr) {
 80199cc:	b580      	push	{r7, lr}
 80199ce:	b08c      	sub	sp, #48	; 0x30
 80199d0:	af08      	add	r7, sp, #32
 80199d2:	60f8      	str	r0, [r7, #12]
 80199d4:	607b      	str	r3, [r7, #4]
 80199d6:	460b      	mov	r3, r1
 80199d8:	72fb      	strb	r3, [r7, #11]
 80199da:	4613      	mov	r3, r2
 80199dc:	813b      	strh	r3, [r7, #8]
        return( pUsb->ctrlReq(bAddress, 0, bmREQ_GET_PORT_STATUS, USB_REQUEST_GET_STATUS, 0, 0, port, nbytes, nbytes, dataptr, NULL));
 80199de:	68fb      	ldr	r3, [r7, #12]
 80199e0:	685a      	ldr	r2, [r3, #4]
 80199e2:	68fb      	ldr	r3, [r7, #12]
 80199e4:	7c9b      	ldrb	r3, [r3, #18]
 80199e6:	7af9      	ldrb	r1, [r7, #11]
 80199e8:	b289      	uxth	r1, r1
 80199ea:	f04f 0000 	mov.w	r0, #0
 80199ee:	9000      	str	r0, [sp, #0]
 80199f0:	f04f 0000 	mov.w	r0, #0
 80199f4:	9001      	str	r0, [sp, #4]
 80199f6:	f04f 0000 	mov.w	r0, #0
 80199fa:	9002      	str	r0, [sp, #8]
 80199fc:	9103      	str	r1, [sp, #12]
 80199fe:	8939      	ldrh	r1, [r7, #8]
 8019a00:	9104      	str	r1, [sp, #16]
 8019a02:	8939      	ldrh	r1, [r7, #8]
 8019a04:	9105      	str	r1, [sp, #20]
 8019a06:	6879      	ldr	r1, [r7, #4]
 8019a08:	9106      	str	r1, [sp, #24]
 8019a0a:	f04f 0100 	mov.w	r1, #0
 8019a0e:	9107      	str	r1, [sp, #28]
 8019a10:	4610      	mov	r0, r2
 8019a12:	4619      	mov	r1, r3
 8019a14:	f04f 0200 	mov.w	r2, #0
 8019a18:	f04f 03a3 	mov.w	r3, #163	; 0xa3
 8019a1c:	f7fa fe42 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 8019a20:	4603      	mov	r3, r0
}
 8019a22:	4618      	mov	r0, r3
 8019a24:	f107 0710 	add.w	r7, r7, #16
 8019a28:	46bd      	mov	sp, r7
 8019a2a:	bd80      	pop	{r7, pc}

08019a2c <_ZN6USBHub14SetPortFeatureEhhh>:
inline uint8_t USBHub::SetHubFeature(uint8_t fid) {
        return( pUsb->ctrlReq(bAddress, 0, bmREQ_SET_HUB_FEATURE, USB_REQUEST_SET_FEATURE, fid, 0, 0, 0, 0, NULL, NULL));
}
// Set Port Feature

inline uint8_t USBHub::SetPortFeature(uint8_t fid, uint8_t port, uint8_t sel) {
 8019a2c:	b580      	push	{r7, lr}
 8019a2e:	b08a      	sub	sp, #40	; 0x28
 8019a30:	af08      	add	r7, sp, #32
 8019a32:	6078      	str	r0, [r7, #4]
 8019a34:	70f9      	strb	r1, [r7, #3]
 8019a36:	70ba      	strb	r2, [r7, #2]
 8019a38:	707b      	strb	r3, [r7, #1]
        return( pUsb->ctrlReq(bAddress, 0, bmREQ_SET_PORT_FEATURE, USB_REQUEST_SET_FEATURE, fid, 0, (((0x0000 | sel) << 8) | port), 0, 0, NULL, NULL));
 8019a3a:	687b      	ldr	r3, [r7, #4]
 8019a3c:	685a      	ldr	r2, [r3, #4]
 8019a3e:	687b      	ldr	r3, [r7, #4]
 8019a40:	7c9b      	ldrb	r3, [r3, #18]
 8019a42:	7879      	ldrb	r1, [r7, #1]
 8019a44:	ea4f 2101 	mov.w	r1, r1, lsl #8
 8019a48:	b288      	uxth	r0, r1
 8019a4a:	78b9      	ldrb	r1, [r7, #2]
 8019a4c:	b289      	uxth	r1, r1
 8019a4e:	4301      	orrs	r1, r0
 8019a50:	b289      	uxth	r1, r1
 8019a52:	b289      	uxth	r1, r1
 8019a54:	f04f 0003 	mov.w	r0, #3
 8019a58:	9000      	str	r0, [sp, #0]
 8019a5a:	78f8      	ldrb	r0, [r7, #3]
 8019a5c:	9001      	str	r0, [sp, #4]
 8019a5e:	f04f 0000 	mov.w	r0, #0
 8019a62:	9002      	str	r0, [sp, #8]
 8019a64:	9103      	str	r1, [sp, #12]
 8019a66:	f04f 0100 	mov.w	r1, #0
 8019a6a:	9104      	str	r1, [sp, #16]
 8019a6c:	f04f 0100 	mov.w	r1, #0
 8019a70:	9105      	str	r1, [sp, #20]
 8019a72:	f04f 0100 	mov.w	r1, #0
 8019a76:	9106      	str	r1, [sp, #24]
 8019a78:	f04f 0100 	mov.w	r1, #0
 8019a7c:	9107      	str	r1, [sp, #28]
 8019a7e:	4610      	mov	r0, r2
 8019a80:	4619      	mov	r1, r3
 8019a82:	f04f 0200 	mov.w	r2, #0
 8019a86:	f04f 0323 	mov.w	r3, #35	; 0x23
 8019a8a:	f7fa fe0b 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 8019a8e:	4603      	mov	r3, r0
}
 8019a90:	4618      	mov	r0, r3
 8019a92:	f107 0708 	add.w	r7, r7, #8
 8019a96:	46bd      	mov	sp, r7
 8019a98:	bd80      	pop	{r7, pc}
 8019a9a:	bf00      	nop

08019a9c <_ZN6USBHubC1EP3USB>:

#include "usbhub.h"

bool USBHub::bResetInitiated = false;

USBHub::USBHub(USB *p) :
 8019a9c:	b580      	push	{r7, lr}
 8019a9e:	b082      	sub	sp, #8
 8019aa0:	af00      	add	r7, sp, #0
 8019aa2:	6078      	str	r0, [r7, #4]
 8019aa4:	6039      	str	r1, [r7, #0]
pUsb(p),
bAddress(0),
bNbrPorts(0),
//bInitState(0),
qNextPollTime(0),
bPollEnable(false) {
 8019aa6:	687b      	ldr	r3, [r7, #4]
 8019aa8:	4618      	mov	r0, r3
 8019aaa:	f7fd f955 	bl	8016d58 <_ZN15USBDeviceConfigC1Ev>
 8019aae:	687b      	ldr	r3, [r7, #4]
 8019ab0:	4a2d      	ldr	r2, [pc, #180]	; (8019b68 <_ZN6USBHubC1EP3USB+0xcc>)
 8019ab2:	601a      	str	r2, [r3, #0]
 8019ab4:	687b      	ldr	r3, [r7, #4]
 8019ab6:	683a      	ldr	r2, [r7, #0]
 8019ab8:	605a      	str	r2, [r3, #4]
 8019aba:	687b      	ldr	r3, [r7, #4]
 8019abc:	f04f 0200 	mov.w	r2, #0
 8019ac0:	749a      	strb	r2, [r3, #18]
 8019ac2:	687b      	ldr	r3, [r7, #4]
 8019ac4:	f04f 0200 	mov.w	r2, #0
 8019ac8:	74da      	strb	r2, [r3, #19]
 8019aca:	687b      	ldr	r3, [r7, #4]
 8019acc:	f04f 0200 	mov.w	r2, #0
 8019ad0:	615a      	str	r2, [r3, #20]
 8019ad2:	687b      	ldr	r3, [r7, #4]
 8019ad4:	f04f 0200 	mov.w	r2, #0
 8019ad8:	761a      	strb	r2, [r3, #24]
	epInfo[0].epAddr = 0;
 8019ada:	687b      	ldr	r3, [r7, #4]
 8019adc:	f04f 0200 	mov.w	r2, #0
 8019ae0:	721a      	strb	r2, [r3, #8]
	epInfo[0].maxPktSize = 8;
 8019ae2:	687b      	ldr	r3, [r7, #4]
 8019ae4:	f04f 0208 	mov.w	r2, #8
 8019ae8:	725a      	strb	r2, [r3, #9]
	epInfo[0].epAttribs = 0;
 8019aea:	687b      	ldr	r3, [r7, #4]
 8019aec:	f04f 0200 	mov.w	r2, #0
 8019af0:	731a      	strb	r2, [r3, #12]
	epInfo[0].bmNakPower = USB_NAK_MAX_POWER;
 8019af2:	687a      	ldr	r2, [r7, #4]
 8019af4:	7b13      	ldrb	r3, [r2, #12]
 8019af6:	f04f 010f 	mov.w	r1, #15
 8019afa:	f361 0387 	bfi	r3, r1, #2, #6
 8019afe:	7313      	strb	r3, [r2, #12]
	epInfo[0].hcNumber = 0;
 8019b00:	687b      	ldr	r3, [r7, #4]
 8019b02:	f04f 0200 	mov.w	r2, #0
 8019b06:	72da      	strb	r2, [r3, #11]
	epInfo[0].hcDevAddr = 0;
 8019b08:	687b      	ldr	r3, [r7, #4]
 8019b0a:	f04f 0200 	mov.w	r2, #0
 8019b0e:	729a      	strb	r2, [r3, #10]

	epInfo[1].epAddr = 1;
 8019b10:	687b      	ldr	r3, [r7, #4]
 8019b12:	f04f 0201 	mov.w	r2, #1
 8019b16:	735a      	strb	r2, [r3, #13]
	epInfo[1].maxPktSize = 8; //kludge
 8019b18:	687b      	ldr	r3, [r7, #4]
 8019b1a:	f04f 0208 	mov.w	r2, #8
 8019b1e:	739a      	strb	r2, [r3, #14]
	epInfo[1].epAttribs = 0;
 8019b20:	687b      	ldr	r3, [r7, #4]
 8019b22:	f04f 0200 	mov.w	r2, #0
 8019b26:	745a      	strb	r2, [r3, #17]
	epInfo[1].bmNakPower = USB_NAK_NOWAIT;
 8019b28:	687a      	ldr	r2, [r7, #4]
 8019b2a:	7c53      	ldrb	r3, [r2, #17]
 8019b2c:	f04f 0101 	mov.w	r1, #1
 8019b30:	f361 0387 	bfi	r3, r1, #2, #6
 8019b34:	7453      	strb	r3, [r2, #17]
	epInfo[1].hcNumber = 0;
 8019b36:	687b      	ldr	r3, [r7, #4]
 8019b38:	f04f 0200 	mov.w	r2, #0
 8019b3c:	741a      	strb	r2, [r3, #16]
	epInfo[1].hcDevAddr = 0;
 8019b3e:	687b      	ldr	r3, [r7, #4]
 8019b40:	f04f 0200 	mov.w	r2, #0
 8019b44:	73da      	strb	r2, [r3, #15]

	if (pUsb)
 8019b46:	687b      	ldr	r3, [r7, #4]
 8019b48:	685b      	ldr	r3, [r3, #4]
 8019b4a:	2b00      	cmp	r3, #0
 8019b4c:	d006      	beq.n	8019b5c <_ZN6USBHubC1EP3USB+0xc0>
		pUsb->RegisterDeviceClass(this);
 8019b4e:	687b      	ldr	r3, [r7, #4]
 8019b50:	685a      	ldr	r2, [r3, #4]
 8019b52:	687b      	ldr	r3, [r7, #4]
 8019b54:	4610      	mov	r0, r2
 8019b56:	4619      	mov	r1, r3
 8019b58:	f7fc fc6e 	bl	8016438 <_ZN3USB19RegisterDeviceClassEP15USBDeviceConfig>
}
 8019b5c:	687b      	ldr	r3, [r7, #4]
 8019b5e:	4618      	mov	r0, r3
 8019b60:	f107 0708 	add.w	r7, r7, #8
 8019b64:	46bd      	mov	sp, r7
 8019b66:	bd80      	pop	{r7, pc}
 8019b68:	08020680 	.word	0x08020680

08019b6c <_ZN6USBHub4InitEhhb>:

uint8_t USBHub::Init(uint8_t parent, uint8_t port, bool lowspeed) {
 8019b6c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8019b6e:	b09d      	sub	sp, #116	; 0x74
 8019b70:	af06      	add	r7, sp, #24
 8019b72:	6078      	str	r0, [r7, #4]
 8019b74:	70f9      	strb	r1, [r7, #3]
 8019b76:	70ba      	strb	r2, [r7, #2]
 8019b78:	707b      	strb	r3, [r7, #1]
	uint8_t buf[32];
	uint8_t rcode;
	UsbDevice *p = NULL;
 8019b7a:	f04f 0300 	mov.w	r3, #0
 8019b7e:	653b      	str	r3, [r7, #80]	; 0x50
	EpInfo *oldep_ptr = NULL;
 8019b80:	f04f 0300 	mov.w	r3, #0
 8019b84:	64fb      	str	r3, [r7, #76]	; 0x4c
	uint8_t len = 0;
 8019b86:	f04f 0300 	mov.w	r3, #0
 8019b8a:	f887 3056 	strb.w	r3, [r7, #86]	; 0x56
	uint16_t cd_len = 0;
 8019b8e:	f04f 0300 	mov.w	r3, #0
 8019b92:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a

	USBTRACE("\r\nHub Init Start ");
 8019b96:	f64e 50fc 	movw	r0, #60924	; 0xedfc
 8019b9a:	f6c0 0001 	movt	r0, #2049	; 0x801
 8019b9e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019ba2:	f7ff fc07 	bl	80193b4 <_Z8E_NotifyPKci>
	//D_PrintHex<uint8_t > (bInitState, 0x80);

	AddressPool &addrPool = pUsb->GetAddressPool();
 8019ba6:	687b      	ldr	r3, [r7, #4]
 8019ba8:	685b      	ldr	r3, [r3, #4]
 8019baa:	4618      	mov	r0, r3
 8019bac:	f7fa fc34 	bl	8014418 <_ZN3USB14GetAddressPoolEv>
 8019bb0:	6478      	str	r0, [r7, #68]	; 0x44

//switch (bInitState) {
//        case 0:
	if (bAddress)
 8019bb2:	687b      	ldr	r3, [r7, #4]
 8019bb4:	7c9b      	ldrb	r3, [r3, #18]
 8019bb6:	2b00      	cmp	r3, #0
 8019bb8:	d002      	beq.n	8019bc0 <_ZN6USBHub4InitEhhb+0x54>
		return USB_ERROR_CLASS_INSTANCE_ALREADY_IN_USE;
 8019bba:	f04f 03d9 	mov.w	r3, #217	; 0xd9
 8019bbe:	e225      	b.n	801a00c <_ZN6USBHub4InitEhhb+0x4a0>

	// Get pointer to pseudo device with address 0 assigned
	p = addrPool.GetUsbDevicePtr(0);
 8019bc0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019bc2:	681b      	ldr	r3, [r3, #0]
 8019bc4:	681b      	ldr	r3, [r3, #0]
 8019bc6:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8019bc8:	f04f 0100 	mov.w	r1, #0
 8019bcc:	4798      	blx	r3
 8019bce:	4603      	mov	r3, r0
 8019bd0:	653b      	str	r3, [r7, #80]	; 0x50

	if (!p)
 8019bd2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019bd4:	2b00      	cmp	r3, #0
 8019bd6:	d102      	bne.n	8019bde <_ZN6USBHub4InitEhhb+0x72>
		return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
 8019bd8:	f04f 03d6 	mov.w	r3, #214	; 0xd6
 8019bdc:	e216      	b.n	801a00c <_ZN6USBHub4InitEhhb+0x4a0>

	if (!p->epinfo)
 8019bde:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019be0:	681b      	ldr	r3, [r3, #0]
 8019be2:	2b00      	cmp	r3, #0
 8019be4:	d102      	bne.n	8019bec <_ZN6USBHub4InitEhhb+0x80>
		return USB_ERROR_EPINFO_IS_NULL;
 8019be6:	f04f 03d7 	mov.w	r3, #215	; 0xd7
 8019bea:	e20f      	b.n	801a00c <_ZN6USBHub4InitEhhb+0x4a0>

	// Save old pointer to EP_RECORD of address 0
	oldep_ptr = p->epinfo;
 8019bec:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019bee:	681b      	ldr	r3, [r3, #0]
 8019bf0:	64fb      	str	r3, [r7, #76]	; 0x4c

	// Temporary assign new pointer to epInfo to p->epinfo in order to avoid toggle inconsistence
	p->epinfo = epInfo;
 8019bf2:	687b      	ldr	r3, [r7, #4]
 8019bf4:	f103 0208 	add.w	r2, r3, #8
 8019bf8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019bfa:	601a      	str	r2, [r3, #0]

	// still use mother's host channel
	p->epinfo->hcNumber = oldep_ptr->hcNumber;
 8019bfc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019bfe:	681b      	ldr	r3, [r3, #0]
 8019c00:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8019c02:	78d2      	ldrb	r2, [r2, #3]
 8019c04:	70da      	strb	r2, [r3, #3]

	p->lowspeed = lowspeed;
 8019c06:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019c08:	787a      	ldrb	r2, [r7, #1]
 8019c0a:	719a      	strb	r2, [r3, #6]

	// Get device descriptor
	rcode = pUsb->getDevDescr(0, 0, 8, (uint8_t*)buf);
 8019c0c:	687b      	ldr	r3, [r7, #4]
 8019c0e:	685b      	ldr	r3, [r3, #4]
 8019c10:	f107 020c 	add.w	r2, r7, #12
 8019c14:	9200      	str	r2, [sp, #0]
 8019c16:	4618      	mov	r0, r3
 8019c18:	f04f 0100 	mov.w	r1, #0
 8019c1c:	f04f 0200 	mov.w	r2, #0
 8019c20:	f04f 0308 	mov.w	r3, #8
 8019c24:	f7fb ff62 	bl	8015aec <_ZN3USB11getDevDescrEhhtPh>
 8019c28:	4603      	mov	r3, r0
 8019c2a:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

	p->lowspeed = false;
 8019c2e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019c30:	f04f 0200 	mov.w	r2, #0
 8019c34:	719a      	strb	r2, [r3, #6]

	if (!rcode)
 8019c36:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8019c3a:	2b00      	cmp	r3, #0
 8019c3c:	d105      	bne.n	8019c4a <_ZN6USBHub4InitEhhb+0xde>
		len = (buf[0] > 32) ? 32 : buf[0];
 8019c3e:	7b3b      	ldrb	r3, [r7, #12]
 8019c40:	2b20      	cmp	r3, #32
 8019c42:	bf28      	it	cs
 8019c44:	2320      	movcs	r3, #32
 8019c46:	f887 3056 	strb.w	r3, [r7, #86]	; 0x56

	if (rcode) {
 8019c4a:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8019c4e:	2b00      	cmp	r3, #0
 8019c50:	d005      	beq.n	8019c5e <_ZN6USBHub4InitEhhb+0xf2>
		// Restore p->epinfo
		p->epinfo = oldep_ptr;
 8019c52:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019c54:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8019c56:	601a      	str	r2, [r3, #0]
		return rcode;
 8019c58:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8019c5c:	e1d6      	b.n	801a00c <_ZN6USBHub4InitEhhb+0x4a0>
	}

	// Extract device class from device descriptor
	// If device class is not a hub return
	if (((USB_DEVICE_DESCRIPTOR*)buf)->bDeviceClass != 0x09)
 8019c5e:	f107 030c 	add.w	r3, r7, #12
 8019c62:	791b      	ldrb	r3, [r3, #4]
 8019c64:	2b09      	cmp	r3, #9
 8019c66:	d002      	beq.n	8019c6e <_ZN6USBHub4InitEhhb+0x102>
		return USB_DEV_CONFIG_ERROR_DEVICE_NOT_SUPPORTED;
 8019c68:	f04f 03d1 	mov.w	r3, #209	; 0xd1
 8019c6c:	e1ce      	b.n	801a00c <_ZN6USBHub4InitEhhb+0x4a0>

	// Allocate new address according to device class
	bAddress = addrPool.AllocAddress(parent, (((USB_DEVICE_DESCRIPTOR*)buf)->bDeviceClass == 0x09) ? true : false, port);
 8019c6e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019c70:	681b      	ldr	r3, [r3, #0]
 8019c72:	f103 0304 	add.w	r3, r3, #4
 8019c76:	681c      	ldr	r4, [r3, #0]
 8019c78:	f107 030c 	add.w	r3, r7, #12
 8019c7c:	791b      	ldrb	r3, [r3, #4]
 8019c7e:	2b09      	cmp	r3, #9
 8019c80:	bf14      	ite	ne
 8019c82:	2300      	movne	r3, #0
 8019c84:	2301      	moveq	r3, #1
 8019c86:	b2da      	uxtb	r2, r3
 8019c88:	78f9      	ldrb	r1, [r7, #3]
 8019c8a:	78bb      	ldrb	r3, [r7, #2]
 8019c8c:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8019c8e:	47a0      	blx	r4
 8019c90:	4603      	mov	r3, r0
 8019c92:	461a      	mov	r2, r3
 8019c94:	687b      	ldr	r3, [r7, #4]
 8019c96:	749a      	strb	r2, [r3, #18]

	if (!bAddress)
 8019c98:	687b      	ldr	r3, [r7, #4]
 8019c9a:	7c9b      	ldrb	r3, [r3, #18]
 8019c9c:	2b00      	cmp	r3, #0
 8019c9e:	d102      	bne.n	8019ca6 <_ZN6USBHub4InitEhhb+0x13a>
		return USB_ERROR_OUT_OF_ADDRESS_SPACE_IN_POOL;
 8019ca0:	f04f 03d4 	mov.w	r3, #212	; 0xd4
 8019ca4:	e1b2      	b.n	801a00c <_ZN6USBHub4InitEhhb+0x4a0>

	// Extract Max Packet Size from the device descriptor
	epInfo[0].maxPktSize = ((USB_DEVICE_DESCRIPTOR*)buf)->bMaxPacketSize0;
 8019ca6:	f107 030c 	add.w	r3, r7, #12
 8019caa:	79da      	ldrb	r2, [r3, #7]
 8019cac:	687b      	ldr	r3, [r7, #4]
 8019cae:	725a      	strb	r2, [r3, #9]

	// Assign new address to the device
	rcode = pUsb->setAddr(0, 0, bAddress);
 8019cb0:	687b      	ldr	r3, [r7, #4]
 8019cb2:	685a      	ldr	r2, [r3, #4]
 8019cb4:	687b      	ldr	r3, [r7, #4]
 8019cb6:	7c9b      	ldrb	r3, [r3, #18]
 8019cb8:	4610      	mov	r0, r2
 8019cba:	f04f 0100 	mov.w	r1, #0
 8019cbe:	f04f 0200 	mov.w	r2, #0
 8019cc2:	f7fc f803 	bl	8015ccc <_ZN3USB7setAddrEhhh>
 8019cc6:	4603      	mov	r3, r0
 8019cc8:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

	if (rcode) {
 8019ccc:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8019cd0:	2b00      	cmp	r3, #0
 8019cd2:	d013      	beq.n	8019cfc <_ZN6USBHub4InitEhhb+0x190>
		// Restore p->epinfo
		p->epinfo = oldep_ptr;
 8019cd4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019cd6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8019cd8:	601a      	str	r2, [r3, #0]
		addrPool.FreeAddress(bAddress);
 8019cda:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019cdc:	681b      	ldr	r3, [r3, #0]
 8019cde:	f103 0308 	add.w	r3, r3, #8
 8019ce2:	681b      	ldr	r3, [r3, #0]
 8019ce4:	687a      	ldr	r2, [r7, #4]
 8019ce6:	7c92      	ldrb	r2, [r2, #18]
 8019ce8:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8019cea:	4611      	mov	r1, r2
 8019cec:	4798      	blx	r3
		bAddress = 0;
 8019cee:	687b      	ldr	r3, [r7, #4]
 8019cf0:	f04f 0200 	mov.w	r2, #0
 8019cf4:	749a      	strb	r2, [r3, #18]
		return rcode;
 8019cf6:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8019cfa:	e187      	b.n	801a00c <_ZN6USBHub4InitEhhb+0x4a0>
	}

	USBTRACE2("\r\nHub address:0x%x", bAddress);
 8019cfc:	f64e 6010 	movw	r0, #60944	; 0xee10
 8019d00:	f6c0 0001 	movt	r0, #2049	; 0x801
 8019d04:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019d08:	f7ff fb54 	bl	80193b4 <_Z8E_NotifyPKci>
 8019d0c:	687b      	ldr	r3, [r7, #4]
 8019d0e:	7c9b      	ldrb	r3, [r3, #18]
 8019d10:	4618      	mov	r0, r3
 8019d12:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019d16:	f7fc f8b7 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 8019d1a:	f64e 6024 	movw	r0, #60964	; 0xee24
 8019d1e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8019d22:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019d26:	f7ff fb45 	bl	80193b4 <_Z8E_NotifyPKci>
//TODO: the hcNumOut/hcNumIn are flushed by below restore code.
//should be careful if next xfer will use correct hc.
	// Restore p->epinfo
	p->epinfo = oldep_ptr;
 8019d2a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019d2c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8019d2e:	601a      	str	r2, [r3, #0]

	// we need to assign hcnumber for this new bAddress(0x41)
	p = addrPool.GetUsbDevicePtr(bAddress);
 8019d30:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019d32:	681b      	ldr	r3, [r3, #0]
 8019d34:	681b      	ldr	r3, [r3, #0]
 8019d36:	687a      	ldr	r2, [r7, #4]
 8019d38:	7c92      	ldrb	r2, [r2, #18]
 8019d3a:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8019d3c:	4611      	mov	r1, r2
 8019d3e:	4798      	blx	r3
 8019d40:	4603      	mov	r3, r0
 8019d42:	653b      	str	r3, [r7, #80]	; 0x50
	p->epinfo->hcNumber = epInfo[0].hcNumber;
 8019d44:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019d46:	681b      	ldr	r3, [r3, #0]
 8019d48:	687a      	ldr	r2, [r7, #4]
 8019d4a:	7ad2      	ldrb	r2, [r2, #11]
 8019d4c:	70da      	strb	r2, [r3, #3]
	p->epinfo->maxPktSize = epInfo[0].maxPktSize;
 8019d4e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019d50:	681b      	ldr	r3, [r3, #0]
 8019d52:	687a      	ldr	r2, [r7, #4]
 8019d54:	7a52      	ldrb	r2, [r2, #9]
 8019d56:	705a      	strb	r2, [r3, #1]

	if (len)
 8019d58:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 8019d5c:	2b00      	cmp	r3, #0
 8019d5e:	d012      	beq.n	8019d86 <_ZN6USBHub4InitEhhb+0x21a>
		rcode = pUsb->getDevDescr(bAddress, 0, len, (uint8_t*)buf);
 8019d60:	687b      	ldr	r3, [r7, #4]
 8019d62:	6859      	ldr	r1, [r3, #4]
 8019d64:	687b      	ldr	r3, [r7, #4]
 8019d66:	7c9a      	ldrb	r2, [r3, #18]
 8019d68:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 8019d6c:	b29b      	uxth	r3, r3
 8019d6e:	f107 000c 	add.w	r0, r7, #12
 8019d72:	9000      	str	r0, [sp, #0]
 8019d74:	4608      	mov	r0, r1
 8019d76:	4611      	mov	r1, r2
 8019d78:	f04f 0200 	mov.w	r2, #0
 8019d7c:	f7fb feb6 	bl	8015aec <_ZN3USB11getDevDescrEhhtPh>
 8019d80:	4603      	mov	r3, r0
 8019d82:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

	if (rcode)
 8019d86:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8019d8a:	2b00      	cmp	r3, #0
 8019d8c:	f040 811a 	bne.w	8019fc4 <_ZN6USBHub4InitEhhb+0x458>
		goto FailGetDevDescr;

	// Assign epInfo to epinfo pointer
	rcode = pUsb->setEpInfoEntry(bAddress, 2, epInfo);
 8019d90:	687b      	ldr	r3, [r7, #4]
 8019d92:	6859      	ldr	r1, [r3, #4]
 8019d94:	687b      	ldr	r3, [r7, #4]
 8019d96:	7c9a      	ldrb	r2, [r3, #18]
 8019d98:	687b      	ldr	r3, [r7, #4]
 8019d9a:	f103 0308 	add.w	r3, r3, #8
 8019d9e:	4608      	mov	r0, r1
 8019da0:	4611      	mov	r1, r2
 8019da2:	f04f 0202 	mov.w	r2, #2
 8019da6:	f7fa fbf5 	bl	8014594 <_ZN3USB14setEpInfoEntryEhhP6EpInfo>
 8019daa:	4603      	mov	r3, r0
 8019dac:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

	if (rcode)
 8019db0:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8019db4:	2b00      	cmp	r3, #0
 8019db6:	f040 8107 	bne.w	8019fc8 <_ZN6USBHub4InitEhhb+0x45c>

//                bInitState = 1;

//        case 1:
	// Get hub descriptor
	rcode = GetHubDescriptor(0, 8, buf);
 8019dba:	f107 030c 	add.w	r3, r7, #12
 8019dbe:	6878      	ldr	r0, [r7, #4]
 8019dc0:	f04f 0100 	mov.w	r1, #0
 8019dc4:	f04f 0208 	mov.w	r2, #8
 8019dc8:	f7ff fdd0 	bl	801996c <_ZN6USBHub16GetHubDescriptorEhtPh>
 8019dcc:	4603      	mov	r3, r0
 8019dce:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

	if (rcode)
 8019dd2:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8019dd6:	2b00      	cmp	r3, #0
 8019dd8:	f040 80f8 	bne.w	8019fcc <_ZN6USBHub4InitEhhb+0x460>
		goto FailGetHubDescr;

	// Save number of ports for future use
	bNbrPorts = ((HubDescriptor*)buf)->bNbrPorts;
 8019ddc:	f107 030c 	add.w	r3, r7, #12
 8019de0:	789a      	ldrb	r2, [r3, #2]
 8019de2:	687b      	ldr	r3, [r7, #4]
 8019de4:	74da      	strb	r2, [r3, #19]

//                bInitState = 2;

//        case 2:
	// Read configuration Descriptor in Order To Obtain Proper Configuration Value
	rcode = pUsb->getConfDescr(bAddress, 0, 8, 0, buf);
 8019de6:	687b      	ldr	r3, [r7, #4]
 8019de8:	685a      	ldr	r2, [r3, #4]
 8019dea:	687b      	ldr	r3, [r7, #4]
 8019dec:	7c9b      	ldrb	r3, [r3, #18]
 8019dee:	f04f 0100 	mov.w	r1, #0
 8019df2:	9100      	str	r1, [sp, #0]
 8019df4:	f107 010c 	add.w	r1, r7, #12
 8019df8:	9101      	str	r1, [sp, #4]
 8019dfa:	4610      	mov	r0, r2
 8019dfc:	4619      	mov	r1, r3
 8019dfe:	f04f 0200 	mov.w	r2, #0
 8019e02:	f04f 0308 	mov.w	r3, #8
 8019e06:	f7fb fe9d 	bl	8015b44 <_ZN3USB12getConfDescrEhhthPh>
 8019e0a:	4603      	mov	r3, r0
 8019e0c:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

	if (!rcode) {
 8019e10:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8019e14:	2b00      	cmp	r3, #0
 8019e16:	d11d      	bne.n	8019e54 <_ZN6USBHub4InitEhhb+0x2e8>
		cd_len = ((USB_CONFIGURATION_DESCRIPTOR*)buf)->wTotalLength;
 8019e18:	f107 030c 	add.w	r3, r7, #12
 8019e1c:	789a      	ldrb	r2, [r3, #2]
 8019e1e:	78db      	ldrb	r3, [r3, #3]
 8019e20:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8019e24:	4313      	orrs	r3, r2
 8019e26:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
		rcode = pUsb->getConfDescr(bAddress, 0, cd_len, 0, buf);
 8019e2a:	687b      	ldr	r3, [r7, #4]
 8019e2c:	6859      	ldr	r1, [r3, #4]
 8019e2e:	687b      	ldr	r3, [r7, #4]
 8019e30:	7c9a      	ldrb	r2, [r3, #18]
 8019e32:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
 8019e36:	f04f 0000 	mov.w	r0, #0
 8019e3a:	9000      	str	r0, [sp, #0]
 8019e3c:	f107 000c 	add.w	r0, r7, #12
 8019e40:	9001      	str	r0, [sp, #4]
 8019e42:	4608      	mov	r0, r1
 8019e44:	4611      	mov	r1, r2
 8019e46:	f04f 0200 	mov.w	r2, #0
 8019e4a:	f7fb fe7b 	bl	8015b44 <_ZN3USB12getConfDescrEhhthPh>
 8019e4e:	4603      	mov	r3, r0
 8019e50:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
	}
	if (rcode)
 8019e54:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8019e58:	2b00      	cmp	r3, #0
 8019e5a:	f040 80b9 	bne.w	8019fd0 <_ZN6USBHub4InitEhhb+0x464>
	// The following code is of no practical use in real life applications.
	// It only intended for the usb protocol sniffer to properly parse hub-class requests.
{
	uint8_t buf2[24];

	rcode = pUsb->getConfDescr(bAddress, 0, buf[0], 0, buf2);
 8019e5e:	687b      	ldr	r3, [r7, #4]
 8019e60:	6859      	ldr	r1, [r3, #4]
 8019e62:	687b      	ldr	r3, [r7, #4]
 8019e64:	7c9a      	ldrb	r2, [r3, #18]
 8019e66:	7b3b      	ldrb	r3, [r7, #12]
 8019e68:	f04f 0000 	mov.w	r0, #0
 8019e6c:	9000      	str	r0, [sp, #0]
 8019e6e:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8019e72:	9001      	str	r0, [sp, #4]
 8019e74:	4608      	mov	r0, r1
 8019e76:	4611      	mov	r1, r2
 8019e78:	f04f 0200 	mov.w	r2, #0
 8019e7c:	f7fb fe62 	bl	8015b44 <_ZN3USB12getConfDescrEhhthPh>
 8019e80:	4603      	mov	r3, r0
 8019e82:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

	if (rcode)
 8019e86:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8019e8a:	2b00      	cmp	r3, #0
 8019e8c:	f040 80a4 	bne.w	8019fd8 <_ZN6USBHub4InitEhhb+0x46c>
		goto FailGetConfDescr;
}

	// Set Configuration Value
	rcode = pUsb->setConf(bAddress, 0, buf[5]);
 8019e90:	687b      	ldr	r3, [r7, #4]
 8019e92:	6859      	ldr	r1, [r3, #4]
 8019e94:	687b      	ldr	r3, [r7, #4]
 8019e96:	7c9a      	ldrb	r2, [r3, #18]
 8019e98:	7c7b      	ldrb	r3, [r7, #17]
 8019e9a:	4608      	mov	r0, r1
 8019e9c:	4611      	mov	r1, r2
 8019e9e:	f04f 0200 	mov.w	r2, #0
 8019ea2:	f7fb ff41 	bl	8015d28 <_ZN3USB7setConfEhhh>
 8019ea6:	4603      	mov	r3, r0
 8019ea8:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

	if (rcode)
 8019eac:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8019eb0:	2b00      	cmp	r3, #0
 8019eb2:	f040 808f 	bne.w	8019fd4 <_ZN6USBHub4InitEhhb+0x468>

//                bInitState = 3;

//        case 3:
	// Power on all ports
	for (uint8_t j = 1; j <= bNbrPorts; j++)
 8019eb6:	f04f 0301 	mov.w	r3, #1
 8019eba:	f887 3055 	strb.w	r3, [r7, #85]	; 0x55
 8019ebe:	e00f      	b.n	8019ee0 <_ZN6USBHub4InitEhhb+0x374>
		SetPortFeature(HUB_FEATURE_PORT_POWER, j, 0); //HubPortPowerOn(j);
 8019ec0:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 8019ec4:	6878      	ldr	r0, [r7, #4]
 8019ec6:	f04f 0108 	mov.w	r1, #8
 8019eca:	461a      	mov	r2, r3
 8019ecc:	f04f 0300 	mov.w	r3, #0
 8019ed0:	f7ff fdac 	bl	8019a2c <_ZN6USBHub14SetPortFeatureEhhh>

//                bInitState = 3;

//        case 3:
	// Power on all ports
	for (uint8_t j = 1; j <= bNbrPorts; j++)
 8019ed4:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 8019ed8:	f103 0301 	add.w	r3, r3, #1
 8019edc:	f887 3055 	strb.w	r3, [r7, #85]	; 0x55
 8019ee0:	687b      	ldr	r3, [r7, #4]
 8019ee2:	7cdb      	ldrb	r3, [r3, #19]
 8019ee4:	f897 2055 	ldrb.w	r2, [r7, #85]	; 0x55
 8019ee8:	429a      	cmp	r2, r3
 8019eea:	bf8c      	ite	hi
 8019eec:	2300      	movhi	r3, #0
 8019eee:	2301      	movls	r3, #1
 8019ef0:	b2db      	uxtb	r3, r3
 8019ef2:	2b00      	cmp	r3, #0
 8019ef4:	d1e4      	bne.n	8019ec0 <_ZN6USBHub4InitEhhb+0x354>
		SetPortFeature(HUB_FEATURE_PORT_POWER, j, 0); //HubPortPowerOn(j);

	pUsb->SetHubPreMask();
 8019ef6:	687b      	ldr	r3, [r7, #4]
 8019ef8:	685b      	ldr	r3, [r3, #4]
 8019efa:	4618      	mov	r0, r3
 8019efc:	f7ff fcce 	bl	801989c <_ZN3USB13SetHubPreMaskEv>
	bPollEnable = true;
 8019f00:	687b      	ldr	r3, [r7, #4]
 8019f02:	f04f 0201 	mov.w	r2, #1
 8019f06:	761a      	strb	r2, [r3, #24]

	epInfo[1].epAddr = buf[20];
 8019f08:	f897 2020 	ldrb.w	r2, [r7, #32]
 8019f0c:	687b      	ldr	r3, [r7, #4]
 8019f0e:	735a      	strb	r2, [r3, #13]

	// Assign epInfo to epinfo pointer
	rcode = pUsb->setEpInfoEntry(bAddress, 2, epInfo);
 8019f10:	687b      	ldr	r3, [r7, #4]
 8019f12:	6859      	ldr	r1, [r3, #4]
 8019f14:	687b      	ldr	r3, [r7, #4]
 8019f16:	7c9a      	ldrb	r2, [r3, #18]
 8019f18:	687b      	ldr	r3, [r7, #4]
 8019f1a:	f103 0308 	add.w	r3, r3, #8
 8019f1e:	4608      	mov	r0, r1
 8019f20:	4611      	mov	r1, r2
 8019f22:	f04f 0202 	mov.w	r2, #2
 8019f26:	f7fa fb35 	bl	8014594 <_ZN3USB14setEpInfoEntryEhhP6EpInfo>
 8019f2a:	4603      	mov	r3, r0
 8019f2c:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

	epInfo[1].hcNumIn = 0xF & (usbhost_cb->device_added_cb(
			bAddress, lowspeed, epInfo[1].bmNakPower,
			0, 0, 0,
			epInfo[1].epAddr, epInfo[1].maxPktSize, eEpTypeInterrupt));
 8019f30:	f243 6310 	movw	r3, #13840	; 0x3610
 8019f34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019f38:	681b      	ldr	r3, [r3, #0]
 8019f3a:	695c      	ldr	r4, [r3, #20]
 8019f3c:	687b      	ldr	r3, [r7, #4]
 8019f3e:	7c99      	ldrb	r1, [r3, #18]
 8019f40:	787a      	ldrb	r2, [r7, #1]
 8019f42:	687b      	ldr	r3, [r7, #4]
 8019f44:	7c5b      	ldrb	r3, [r3, #17]
 8019f46:	f3c3 0385 	ubfx	r3, r3, #2, #6
 8019f4a:	b2db      	uxtb	r3, r3
 8019f4c:	6878      	ldr	r0, [r7, #4]
 8019f4e:	7b45      	ldrb	r5, [r0, #13]
 8019f50:	6878      	ldr	r0, [r7, #4]
 8019f52:	7b80      	ldrb	r0, [r0, #14]
 8019f54:	f04f 0600 	mov.w	r6, #0
 8019f58:	9600      	str	r6, [sp, #0]
 8019f5a:	f04f 0600 	mov.w	r6, #0
 8019f5e:	9601      	str	r6, [sp, #4]
 8019f60:	9502      	str	r5, [sp, #8]
 8019f62:	9003      	str	r0, [sp, #12]
 8019f64:	f04f 0003 	mov.w	r0, #3
 8019f68:	9004      	str	r0, [sp, #16]
 8019f6a:	4608      	mov	r0, r1
 8019f6c:	4611      	mov	r1, r2
 8019f6e:	461a      	mov	r2, r3
 8019f70:	f04f 0300 	mov.w	r3, #0
 8019f74:	47a0      	blx	r4
 8019f76:	4603      	mov	r3, r0
 8019f78:	b2db      	uxtb	r3, r3
 8019f7a:	f003 030f 	and.w	r3, r3, #15
 8019f7e:	b2d9      	uxtb	r1, r3
 8019f80:	687a      	ldr	r2, [r7, #4]
 8019f82:	7c13      	ldrb	r3, [r2, #16]
 8019f84:	f361 0303 	bfi	r3, r1, #0, #4
 8019f88:	7413      	strb	r3, [r2, #16]
	//pUsb->coreConfig->host.hc[epInfo[1].hcNumIn].toggle_in = 0x0;

//                bInitState = 0;
//}
	//bInitState = 0;
	USBTRACE2("\nHub Pipe in = %d (EP_TYPE_INTR)", epInfo[1].hcNumIn);
 8019f8a:	f64e 6028 	movw	r0, #60968	; 0xee28
 8019f8e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8019f92:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019f96:	f7ff fa0d 	bl	80193b4 <_Z8E_NotifyPKci>
 8019f9a:	687b      	ldr	r3, [r7, #4]
 8019f9c:	7c1b      	ldrb	r3, [r3, #16]
 8019f9e:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8019fa2:	b2db      	uxtb	r3, r3
 8019fa4:	4618      	mov	r0, r3
 8019fa6:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019faa:	f7fb ff6d 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 8019fae:	f64e 6024 	movw	r0, #60964	; 0xee24
 8019fb2:	f6c0 0001 	movt	r0, #2049	; 0x801
 8019fb6:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019fba:	f7ff f9fb 	bl	80193b4 <_Z8E_NotifyPKci>

	//USBTRACE("...OK\r\n");
	return 0;
 8019fbe:	f04f 0300 	mov.w	r3, #0
 8019fc2:	e023      	b.n	801a00c <_ZN6USBHub4InitEhhb+0x4a0>

	if (len)
		rcode = pUsb->getDevDescr(bAddress, 0, len, (uint8_t*)buf);

	if (rcode)
		goto FailGetDevDescr;
 8019fc4:	bf00      	nop
	//USBTRACE("...OK\r\n");
	return 0;

	// Oleg, No debugging?? -- xxxajk
FailGetDevDescr:
	goto Fail;
 8019fc6:	e008      	b.n	8019fda <_ZN6USBHub4InitEhhb+0x46e>

	// Assign epInfo to epinfo pointer
	rcode = pUsb->setEpInfoEntry(bAddress, 2, epInfo);

	if (rcode)
			goto FailSetDevTblEntry;
 8019fc8:	bf00      	nop
	// Oleg, No debugging?? -- xxxajk
FailGetDevDescr:
	goto Fail;

FailSetDevTblEntry:
	goto Fail;
 8019fca:	e006      	b.n	8019fda <_ZN6USBHub4InitEhhb+0x46e>
//        case 1:
	// Get hub descriptor
	rcode = GetHubDescriptor(0, 8, buf);

	if (rcode)
		goto FailGetHubDescr;
 8019fcc:	bf00      	nop

FailSetDevTblEntry:
	goto Fail;

FailGetHubDescr:
	goto Fail;
 8019fce:	e004      	b.n	8019fda <_ZN6USBHub4InitEhhb+0x46e>
	if (!rcode) {
		cd_len = ((USB_CONFIGURATION_DESCRIPTOR*)buf)->wTotalLength;
		rcode = pUsb->getConfDescr(bAddress, 0, cd_len, 0, buf);
	}
	if (rcode)
		goto FailGetConfDescr;
 8019fd0:	bf00      	nop

FailGetHubDescr:
	goto Fail;

FailGetConfDescr:
	goto Fail;
 8019fd2:	e001      	b.n	8019fd8 <_ZN6USBHub4InitEhhb+0x46c>

	// Set Configuration Value
	rcode = pUsb->setConf(bAddress, 0, buf[5]);

	if (rcode)
		goto FailSetConfDescr;
 8019fd4:	bf00      	nop

FailGetConfDescr:
	goto Fail;

FailSetConfDescr:
	goto Fail;
 8019fd6:	e000      	b.n	8019fda <_ZN6USBHub4InitEhhb+0x46e>

FailGetHubDescr:
	goto Fail;

FailGetConfDescr:
	goto Fail;
 8019fd8:	bf00      	nop

FailSetConfDescr:
	goto Fail;

Fail:
	USBTRACE2("...FAIL\r\n", rcode);
 8019fda:	f64e 604c 	movw	r0, #61004	; 0xee4c
 8019fde:	f6c0 0001 	movt	r0, #2049	; 0x801
 8019fe2:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019fe6:	f7ff f9e5 	bl	80193b4 <_Z8E_NotifyPKci>
 8019fea:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8019fee:	4618      	mov	r0, r3
 8019ff0:	f04f 0180 	mov.w	r1, #128	; 0x80
 8019ff4:	f7fb ff48 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 8019ff8:	f64e 6024 	movw	r0, #60964	; 0xee24
 8019ffc:	f6c0 0001 	movt	r0, #2049	; 0x801
 801a000:	f04f 0180 	mov.w	r1, #128	; 0x80
 801a004:	f7ff f9d6 	bl	80193b4 <_Z8E_NotifyPKci>
	return rcode;
 801a008:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801a00c:	e002      	b.n	801a014 <_ZN6USBHub4InitEhhb+0x4a8>
 801a00e:	e7ff      	b.n	801a010 <_ZN6USBHub4InitEhhb+0x4a4>
 801a010:	f002 fd36 	bl	801ca80 <__cxa_end_cleanup>
}
 801a014:	4618      	mov	r0, r3
 801a016:	f107 075c 	add.w	r7, r7, #92	; 0x5c
 801a01a:	46bd      	mov	sp, r7
 801a01c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801a01e:	bf00      	nop

0801a020 <_ZN6USBHub7ReleaseEv>:

uint8_t USBHub::Release() {
 801a020:	b580      	push	{r7, lr}
 801a022:	b082      	sub	sp, #8
 801a024:	af00      	add	r7, sp, #0
 801a026:	6078      	str	r0, [r7, #4]
	if(epInfo[1].hcNumber != 0) {	// HC0&HC1 are taken by control pipe.
 801a028:	687b      	ldr	r3, [r7, #4]
 801a02a:	7c1b      	ldrb	r3, [r3, #16]
 801a02c:	2b00      	cmp	r3, #0
 801a02e:	d00c      	beq.n	801a04a <_ZN6USBHub7ReleaseEv+0x2a>
		//USB_OTG_HC_Halt(pUsb->coreConfig, epInfo[1].hcNumIn);
		//USBH_Free_Channel(pUsb->coreConfig, epInfo[1].hcNumIn);
		usbhost_cb->device_removed_cb(epInfo[1].hcNumIn);
 801a030:	f243 6310 	movw	r3, #13840	; 0x3610
 801a034:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a038:	681b      	ldr	r3, [r3, #0]
 801a03a:	699b      	ldr	r3, [r3, #24]
 801a03c:	687a      	ldr	r2, [r7, #4]
 801a03e:	7c12      	ldrb	r2, [r2, #16]
 801a040:	f3c2 0203 	ubfx	r2, r2, #0, #4
 801a044:	b2d2      	uxtb	r2, r2
 801a046:	4610      	mov	r0, r2
 801a048:	4798      	blx	r3
	}
	//todo: we need un-install epInfo either.
	epInfo[1].hcNumber = 0;
 801a04a:	687b      	ldr	r3, [r7, #4]
 801a04c:	f04f 0200 	mov.w	r2, #0
 801a050:	741a      	strb	r2, [r3, #16]

	epInfo[1].hcDevAddr = 0;
 801a052:	687b      	ldr	r3, [r7, #4]
 801a054:	f04f 0200 	mov.w	r2, #0
 801a058:	73da      	strb	r2, [r3, #15]
	pUsb->GetAddressPool().FreeAddress(bAddress);
 801a05a:	687b      	ldr	r3, [r7, #4]
 801a05c:	685b      	ldr	r3, [r3, #4]
 801a05e:	4618      	mov	r0, r3
 801a060:	f7fa f9da 	bl	8014418 <_ZN3USB14GetAddressPoolEv>
 801a064:	4603      	mov	r3, r0
 801a066:	681a      	ldr	r2, [r3, #0]
 801a068:	f102 0208 	add.w	r2, r2, #8
 801a06c:	6812      	ldr	r2, [r2, #0]
 801a06e:	6879      	ldr	r1, [r7, #4]
 801a070:	7c89      	ldrb	r1, [r1, #18]
 801a072:	4618      	mov	r0, r3
 801a074:	4790      	blx	r2

	if (bAddress == 0x41)
 801a076:	687b      	ldr	r3, [r7, #4]
 801a078:	7c9b      	ldrb	r3, [r3, #18]
 801a07a:	2b41      	cmp	r3, #65	; 0x41
 801a07c:	d104      	bne.n	801a088 <_ZN6USBHub7ReleaseEv+0x68>
		pUsb->SetHubPreMask();
 801a07e:	687b      	ldr	r3, [r7, #4]
 801a080:	685b      	ldr	r3, [r3, #4]
 801a082:	4618      	mov	r0, r3
 801a084:	f7ff fc0a 	bl	801989c <_ZN3USB13SetHubPreMaskEv>

	bAddress = 0;
 801a088:	687b      	ldr	r3, [r7, #4]
 801a08a:	f04f 0200 	mov.w	r2, #0
 801a08e:	749a      	strb	r2, [r3, #18]
	bNbrPorts = 0;
 801a090:	687b      	ldr	r3, [r7, #4]
 801a092:	f04f 0200 	mov.w	r2, #0
 801a096:	74da      	strb	r2, [r3, #19]
	qNextPollTime = 0;
 801a098:	687b      	ldr	r3, [r7, #4]
 801a09a:	f04f 0200 	mov.w	r2, #0
 801a09e:	615a      	str	r2, [r3, #20]
	bPollEnable = false;
 801a0a0:	687b      	ldr	r3, [r7, #4]
 801a0a2:	f04f 0200 	mov.w	r2, #0
 801a0a6:	761a      	strb	r2, [r3, #24]
	return 0;
 801a0a8:	f04f 0300 	mov.w	r3, #0
}
 801a0ac:	4618      	mov	r0, r3
 801a0ae:	f107 0708 	add.w	r7, r7, #8
 801a0b2:	46bd      	mov	sp, r7
 801a0b4:	bd80      	pop	{r7, pc}
 801a0b6:	bf00      	nop

0801a0b8 <_ZN6USBHub4PollEv>:

uint8_t USBHub::Poll() {
 801a0b8:	b580      	push	{r7, lr}
 801a0ba:	b084      	sub	sp, #16
 801a0bc:	af00      	add	r7, sp, #0
 801a0be:	6078      	str	r0, [r7, #4]
	uint8_t rcode = 0;
 801a0c0:	f04f 0300 	mov.w	r3, #0
 801a0c4:	73fb      	strb	r3, [r7, #15]

	if (!bPollEnable)
 801a0c6:	687b      	ldr	r3, [r7, #4]
 801a0c8:	7e1b      	ldrb	r3, [r3, #24]
 801a0ca:	f083 0301 	eor.w	r3, r3, #1
 801a0ce:	b2db      	uxtb	r3, r3
 801a0d0:	2b00      	cmp	r3, #0
 801a0d2:	d002      	beq.n	801a0da <_ZN6USBHub4PollEv+0x22>
		return 0;
 801a0d4:	f04f 0300 	mov.w	r3, #0
 801a0d8:	e024      	b.n	801a124 <_ZN6USBHub4PollEv+0x6c>

	if (((long)(millis() - qNextPollTime) >= 0L))
 801a0da:	f243 630c 	movw	r3, #13836	; 0x360c
 801a0de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a0e2:	681b      	ldr	r3, [r3, #0]
 801a0e4:	689b      	ldr	r3, [r3, #8]
 801a0e6:	4798      	blx	r3
 801a0e8:	4603      	mov	r3, r0
 801a0ea:	461a      	mov	r2, r3
 801a0ec:	687b      	ldr	r3, [r7, #4]
 801a0ee:	695b      	ldr	r3, [r3, #20]
 801a0f0:	1ad3      	subs	r3, r2, r3
 801a0f2:	ea6f 0303 	mvn.w	r3, r3
 801a0f6:	ea4f 73d3 	mov.w	r3, r3, lsr #31
 801a0fa:	b2db      	uxtb	r3, r3
 801a0fc:	2b00      	cmp	r3, #0
 801a0fe:	d010      	beq.n	801a122 <_ZN6USBHub4PollEv+0x6a>
	{
		rcode = CheckHubStatus();
 801a100:	6878      	ldr	r0, [r7, #4]
 801a102:	f000 f815 	bl	801a130 <_ZN6USBHub14CheckHubStatusEv>
 801a106:	4603      	mov	r3, r0
 801a108:	73fb      	strb	r3, [r7, #15]
		qNextPollTime = millis() + 100;
 801a10a:	f243 630c 	movw	r3, #13836	; 0x360c
 801a10e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a112:	681b      	ldr	r3, [r3, #0]
 801a114:	689b      	ldr	r3, [r3, #8]
 801a116:	4798      	blx	r3
 801a118:	4603      	mov	r3, r0
 801a11a:	f103 0264 	add.w	r2, r3, #100	; 0x64
 801a11e:	687b      	ldr	r3, [r7, #4]
 801a120:	615a      	str	r2, [r3, #20]
	}
	return rcode;
 801a122:	7bfb      	ldrb	r3, [r7, #15]
}
 801a124:	4618      	mov	r0, r3
 801a126:	f107 0710 	add.w	r7, r7, #16
 801a12a:	46bd      	mov	sp, r7
 801a12c:	bd80      	pop	{r7, pc}
 801a12e:	bf00      	nop

0801a130 <_ZN6USBHub14CheckHubStatusEv>:

uint8_t USBHub::CheckHubStatus() {
 801a130:	b590      	push	{r4, r7, lr}
 801a132:	b08b      	sub	sp, #44	; 0x2c
 801a134:	af02      	add	r7, sp, #8
 801a136:	6078      	str	r0, [r7, #4]
        uint8_t rcode;
        uint8_t buf[8];
        uint16_t read = 1;
 801a138:	f04f 0301 	mov.w	r3, #1
 801a13c:	827b      	strh	r3, [r7, #18]

        rcode = pUsb->inTransfer(bAddress, epInfo[1].epAddr, &read, buf);
 801a13e:	687b      	ldr	r3, [r7, #4]
 801a140:	6858      	ldr	r0, [r3, #4]
 801a142:	687b      	ldr	r3, [r7, #4]
 801a144:	7c99      	ldrb	r1, [r3, #18]
 801a146:	687b      	ldr	r3, [r7, #4]
 801a148:	7b5a      	ldrb	r2, [r3, #13]
 801a14a:	f107 0312 	add.w	r3, r7, #18
 801a14e:	f107 0414 	add.w	r4, r7, #20
 801a152:	9400      	str	r4, [sp, #0]
 801a154:	f7fa fb7c 	bl	8014850 <_ZN3USB10inTransferEhhPtPh>
 801a158:	4603      	mov	r3, r0
 801a15a:	773b      	strb	r3, [r7, #28]
        if(rcode != hrSUCCESS) {
        	//USB::toggle_led3();
        }
        if (rcode)
 801a15c:	7f3b      	ldrb	r3, [r7, #28]
 801a15e:	2b00      	cmp	r3, #0
 801a160:	d001      	beq.n	801a166 <_ZN6USBHub14CheckHubStatusEv+0x36>
			return rcode;
 801a162:	7f3b      	ldrb	r3, [r7, #28]
 801a164:	e08d      	b.n	801a282 <_ZN6USBHub14CheckHubStatusEv+0x152>
        //        	USB_HOST_SERIAL.print("GetHubStatus Error");
        //        	USB_HOST_SERIAL.println(rcode, HEX);
        //        	return rcode;
        //        }
        //}
        for (uint8_t port = 1, mask = 0x02; port < 8; mask <<= 1, port++) {
 801a166:	f04f 0301 	mov.w	r3, #1
 801a16a:	77fb      	strb	r3, [r7, #31]
 801a16c:	f04f 0302 	mov.w	r3, #2
 801a170:	77bb      	strb	r3, [r7, #30]
 801a172:	e033      	b.n	801a1dc <_ZN6USBHub14CheckHubStatusEv+0xac>
			if (buf[0] & mask) {
 801a174:	7d3a      	ldrb	r2, [r7, #20]
 801a176:	7fbb      	ldrb	r3, [r7, #30]
 801a178:	4013      	ands	r3, r2
 801a17a:	b2db      	uxtb	r3, r3
 801a17c:	2b00      	cmp	r3, #0
 801a17e:	d025      	beq.n	801a1cc <_ZN6USBHub14CheckHubStatusEv+0x9c>
				HubEvent evt;
				evt.bmEvent = 0;
 801a180:	f04f 0300 	mov.w	r3, #0
 801a184:	60fb      	str	r3, [r7, #12]

				rcode = GetPortStatus(port, 4, evt.evtBuff);
 801a186:	7ffa      	ldrb	r2, [r7, #31]
 801a188:	f107 030c 	add.w	r3, r7, #12
 801a18c:	6878      	ldr	r0, [r7, #4]
 801a18e:	4611      	mov	r1, r2
 801a190:	f04f 0204 	mov.w	r2, #4
 801a194:	f7ff fc1a 	bl	80199cc <_ZN6USBHub13GetPortStatusEhtPh>
 801a198:	4603      	mov	r3, r0
 801a19a:	773b      	strb	r3, [r7, #28]

				if (rcode)
 801a19c:	7f3b      	ldrb	r3, [r7, #28]
 801a19e:	2b00      	cmp	r3, #0
 801a1a0:	d114      	bne.n	801a1cc <_ZN6USBHub14CheckHubStatusEv+0x9c>
					continue;

				rcode = PortStatusChange(port, evt);
 801a1a2:	7ffa      	ldrb	r2, [r7, #31]
 801a1a4:	f107 030c 	add.w	r3, r7, #12
 801a1a8:	6878      	ldr	r0, [r7, #4]
 801a1aa:	4611      	mov	r1, r2
 801a1ac:	461a      	mov	r2, r3
 801a1ae:	f000 f8f3 	bl	801a398 <_ZN6USBHub16PortStatusChangeEhR8HubEvent>
 801a1b2:	4603      	mov	r3, r0
 801a1b4:	773b      	strb	r3, [r7, #28]

				if (rcode == HUB_ERROR_PORT_HAS_BEEN_RESET)
 801a1b6:	7f3b      	ldrb	r3, [r7, #28]
 801a1b8:	2bb1      	cmp	r3, #177	; 0xb1
 801a1ba:	d102      	bne.n	801a1c2 <_ZN6USBHub14CheckHubStatusEv+0x92>
					return 0;
 801a1bc:	f04f 0300 	mov.w	r3, #0
 801a1c0:	e05f      	b.n	801a282 <_ZN6USBHub14CheckHubStatusEv+0x152>

				if (rcode)
 801a1c2:	7f3b      	ldrb	r3, [r7, #28]
 801a1c4:	2b00      	cmp	r3, #0
 801a1c6:	d001      	beq.n	801a1cc <_ZN6USBHub14CheckHubStatusEv+0x9c>
					return rcode;
 801a1c8:	7f3b      	ldrb	r3, [r7, #28]
 801a1ca:	e05a      	b.n	801a282 <_ZN6USBHub14CheckHubStatusEv+0x152>
        //        	USB_HOST_SERIAL.print("GetHubStatus Error");
        //        	USB_HOST_SERIAL.println(rcode, HEX);
        //        	return rcode;
        //        }
        //}
        for (uint8_t port = 1, mask = 0x02; port < 8; mask <<= 1, port++) {
 801a1cc:	7fbb      	ldrb	r3, [r7, #30]
 801a1ce:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801a1d2:	77bb      	strb	r3, [r7, #30]
 801a1d4:	7ffb      	ldrb	r3, [r7, #31]
 801a1d6:	f103 0301 	add.w	r3, r3, #1
 801a1da:	77fb      	strb	r3, [r7, #31]
 801a1dc:	7ffb      	ldrb	r3, [r7, #31]
 801a1de:	2b07      	cmp	r3, #7
 801a1e0:	bf8c      	ite	hi
 801a1e2:	2300      	movhi	r3, #0
 801a1e4:	2301      	movls	r3, #1
 801a1e6:	b2db      	uxtb	r3, r3
 801a1e8:	2b00      	cmp	r3, #0
 801a1ea:	d1c3      	bne.n	801a174 <_ZN6USBHub14CheckHubStatusEv+0x44>
				if (rcode)
					return rcode;
			}
        } // for

        for (uint8_t port = 1; port <= bNbrPorts; port++) {
 801a1ec:	f04f 0301 	mov.w	r3, #1
 801a1f0:	777b      	strb	r3, [r7, #29]
 801a1f2:	e03a      	b.n	801a26a <_ZN6USBHub14CheckHubStatusEv+0x13a>
                HubEvent evt;
                evt.bmEvent = 0;
 801a1f4:	f04f 0300 	mov.w	r3, #0
 801a1f8:	60bb      	str	r3, [r7, #8]

                rcode = GetPortStatus(port, 4, evt.evtBuff);
 801a1fa:	7f7a      	ldrb	r2, [r7, #29]
 801a1fc:	f107 0308 	add.w	r3, r7, #8
 801a200:	6878      	ldr	r0, [r7, #4]
 801a202:	4611      	mov	r1, r2
 801a204:	f04f 0204 	mov.w	r2, #4
 801a208:	f7ff fbe0 	bl	80199cc <_ZN6USBHub13GetPortStatusEhtPh>
 801a20c:	4603      	mov	r3, r0
 801a20e:	773b      	strb	r3, [r7, #28]

                if (rcode)
 801a210:	7f3b      	ldrb	r3, [r7, #28]
 801a212:	2b00      	cmp	r3, #0
 801a214:	d122      	bne.n	801a25c <_ZN6USBHub14CheckHubStatusEv+0x12c>
					continue;

                if ((evt.bmStatus & bmHUB_PORT_STATE_CHECK_DISABLED) != bmHUB_PORT_STATE_DISABLED)
 801a216:	893b      	ldrh	r3, [r7, #8]
 801a218:	461a      	mov	r2, r3
 801a21a:	f240 1307 	movw	r3, #263	; 0x107
 801a21e:	4013      	ands	r3, r2
 801a220:	f240 1201 	movw	r2, #257	; 0x101
 801a224:	4293      	cmp	r3, r2
 801a226:	d11b      	bne.n	801a260 <_ZN6USBHub14CheckHubStatusEv+0x130>
					continue;

                // Emulate connection event for the port
                evt.bmChange |= bmHUB_PORT_STATUS_C_PORT_CONNECTION;
 801a228:	897b      	ldrh	r3, [r7, #10]
 801a22a:	f043 0301 	orr.w	r3, r3, #1
 801a22e:	b29b      	uxth	r3, r3
 801a230:	817b      	strh	r3, [r7, #10]

                rcode = PortStatusChange(port, evt);
 801a232:	7f7a      	ldrb	r2, [r7, #29]
 801a234:	f107 0308 	add.w	r3, r7, #8
 801a238:	6878      	ldr	r0, [r7, #4]
 801a23a:	4611      	mov	r1, r2
 801a23c:	461a      	mov	r2, r3
 801a23e:	f000 f8ab 	bl	801a398 <_ZN6USBHub16PortStatusChangeEhR8HubEvent>
 801a242:	4603      	mov	r3, r0
 801a244:	773b      	strb	r3, [r7, #28]

                if (rcode == HUB_ERROR_PORT_HAS_BEEN_RESET)
 801a246:	7f3b      	ldrb	r3, [r7, #28]
 801a248:	2bb1      	cmp	r3, #177	; 0xb1
 801a24a:	d102      	bne.n	801a252 <_ZN6USBHub14CheckHubStatusEv+0x122>
                        return 0;
 801a24c:	f04f 0300 	mov.w	r3, #0
 801a250:	e017      	b.n	801a282 <_ZN6USBHub14CheckHubStatusEv+0x152>

                if (rcode)
 801a252:	7f3b      	ldrb	r3, [r7, #28]
 801a254:	2b00      	cmp	r3, #0
 801a256:	d004      	beq.n	801a262 <_ZN6USBHub14CheckHubStatusEv+0x132>
                        return rcode;
 801a258:	7f3b      	ldrb	r3, [r7, #28]
 801a25a:	e012      	b.n	801a282 <_ZN6USBHub14CheckHubStatusEv+0x152>
                evt.bmEvent = 0;

                rcode = GetPortStatus(port, 4, evt.evtBuff);

                if (rcode)
					continue;
 801a25c:	bf00      	nop
 801a25e:	e000      	b.n	801a262 <_ZN6USBHub14CheckHubStatusEv+0x132>

                if ((evt.bmStatus & bmHUB_PORT_STATE_CHECK_DISABLED) != bmHUB_PORT_STATE_DISABLED)
					continue;
 801a260:	bf00      	nop
				if (rcode)
					return rcode;
			}
        } // for

        for (uint8_t port = 1; port <= bNbrPorts; port++) {
 801a262:	7f7b      	ldrb	r3, [r7, #29]
 801a264:	f103 0301 	add.w	r3, r3, #1
 801a268:	777b      	strb	r3, [r7, #29]
 801a26a:	687b      	ldr	r3, [r7, #4]
 801a26c:	7cdb      	ldrb	r3, [r3, #19]
 801a26e:	7f7a      	ldrb	r2, [r7, #29]
 801a270:	429a      	cmp	r2, r3
 801a272:	bf8c      	ite	hi
 801a274:	2300      	movhi	r3, #0
 801a276:	2301      	movls	r3, #1
 801a278:	b2db      	uxtb	r3, r3
 801a27a:	2b00      	cmp	r3, #0
 801a27c:	d1ba      	bne.n	801a1f4 <_ZN6USBHub14CheckHubStatusEv+0xc4>
                        return 0;

                if (rcode)
                        return rcode;
        } // for
        return 0;
 801a27e:	f04f 0300 	mov.w	r3, #0
 801a282:	e003      	b.n	801a28c <_ZN6USBHub14CheckHubStatusEv+0x15c>
 801a284:	e000      	b.n	801a288 <_ZN6USBHub14CheckHubStatusEv+0x158>
 801a286:	e7ff      	b.n	801a288 <_ZN6USBHub14CheckHubStatusEv+0x158>
 801a288:	f002 fbfa 	bl	801ca80 <__cxa_end_cleanup>
}
 801a28c:	4618      	mov	r0, r3
 801a28e:	f107 0724 	add.w	r7, r7, #36	; 0x24
 801a292:	46bd      	mov	sp, r7
 801a294:	bd90      	pop	{r4, r7, pc}
 801a296:	bf00      	nop

0801a298 <_ZN6USBHub12ResetHubPortEh>:

void USBHub::ResetHubPort(uint8_t port) {
 801a298:	b580      	push	{r7, lr}
 801a29a:	b086      	sub	sp, #24
 801a29c:	af00      	add	r7, sp, #0
 801a29e:	6078      	str	r0, [r7, #4]
 801a2a0:	460b      	mov	r3, r1
 801a2a2:	70fb      	strb	r3, [r7, #3]
        HubEvent evt;
        evt.bmEvent = 0;
 801a2a4:	f04f 0300 	mov.w	r3, #0
 801a2a8:	60fb      	str	r3, [r7, #12]
        uint8_t rcode;

        ClearPortFeature(HUB_FEATURE_C_PORT_ENABLE, port, 0);
 801a2aa:	78fb      	ldrb	r3, [r7, #3]
 801a2ac:	6878      	ldr	r0, [r7, #4]
 801a2ae:	f04f 0111 	mov.w	r1, #17
 801a2b2:	461a      	mov	r2, r3
 801a2b4:	f04f 0300 	mov.w	r3, #0
 801a2b8:	f7ff fb20 	bl	80198fc <_ZN6USBHub16ClearPortFeatureEhhh>
        ClearPortFeature(HUB_FEATURE_C_PORT_CONNECTION, port, 0);
 801a2bc:	78fb      	ldrb	r3, [r7, #3]
 801a2be:	6878      	ldr	r0, [r7, #4]
 801a2c0:	f04f 0110 	mov.w	r1, #16
 801a2c4:	461a      	mov	r2, r3
 801a2c6:	f04f 0300 	mov.w	r3, #0
 801a2ca:	f7ff fb17 	bl	80198fc <_ZN6USBHub16ClearPortFeatureEhhh>
        SetPortFeature(HUB_FEATURE_PORT_RESET, port, 0);
 801a2ce:	78fb      	ldrb	r3, [r7, #3]
 801a2d0:	6878      	ldr	r0, [r7, #4]
 801a2d2:	f04f 0104 	mov.w	r1, #4
 801a2d6:	461a      	mov	r2, r3
 801a2d8:	f04f 0300 	mov.w	r3, #0
 801a2dc:	f7ff fba6 	bl	8019a2c <_ZN6USBHub14SetPortFeatureEhhh>


        for (int i = 0; i < 3; i++) {
 801a2e0:	f04f 0300 	mov.w	r3, #0
 801a2e4:	617b      	str	r3, [r7, #20]
 801a2e6:	e028      	b.n	801a33a <_ZN6USBHub12ResetHubPortEh+0xa2>
                rcode = GetPortStatus(port, 4, evt.evtBuff);
 801a2e8:	78fa      	ldrb	r2, [r7, #3]
 801a2ea:	f107 030c 	add.w	r3, r7, #12
 801a2ee:	6878      	ldr	r0, [r7, #4]
 801a2f0:	4611      	mov	r1, r2
 801a2f2:	f04f 0204 	mov.w	r2, #4
 801a2f6:	f7ff fb69 	bl	80199cc <_ZN6USBHub13GetPortStatusEhtPh>
 801a2fa:	4603      	mov	r3, r0
 801a2fc:	74fb      	strb	r3, [r7, #19]
                if (rcode) break; // Some kind of error, bail.
 801a2fe:	7cfb      	ldrb	r3, [r7, #19]
 801a300:	2b00      	cmp	r3, #0
 801a302:	d123      	bne.n	801a34c <_ZN6USBHub12ResetHubPortEh+0xb4>
                if (evt.bmEvent == bmHUB_PORT_EVENT_RESET_COMPLETE || evt.bmEvent == bmHUB_PORT_EVENT_LS_RESET_COMPLETE) {
 801a304:	68fa      	ldr	r2, [r7, #12]
 801a306:	f240 1303 	movw	r3, #259	; 0x103
 801a30a:	f2c0 0310 	movt	r3, #16
 801a30e:	429a      	cmp	r2, r3
 801a310:	d01e      	beq.n	801a350 <_ZN6USBHub12ResetHubPortEh+0xb8>
 801a312:	68fa      	ldr	r2, [r7, #12]
 801a314:	f240 3303 	movw	r3, #771	; 0x303
 801a318:	f2c0 0310 	movt	r3, #16
 801a31c:	429a      	cmp	r2, r3
 801a31e:	d017      	beq.n	801a350 <_ZN6USBHub12ResetHubPortEh+0xb8>
                        break;
                }
                delay_ms(100); // simulate polling.
 801a320:	f243 630c 	movw	r3, #13836	; 0x360c
 801a324:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a328:	681b      	ldr	r3, [r3, #0]
 801a32a:	685b      	ldr	r3, [r3, #4]
 801a32c:	f04f 0064 	mov.w	r0, #100	; 0x64
 801a330:	4798      	blx	r3
        ClearPortFeature(HUB_FEATURE_C_PORT_ENABLE, port, 0);
        ClearPortFeature(HUB_FEATURE_C_PORT_CONNECTION, port, 0);
        SetPortFeature(HUB_FEATURE_PORT_RESET, port, 0);


        for (int i = 0; i < 3; i++) {
 801a332:	697b      	ldr	r3, [r7, #20]
 801a334:	f103 0301 	add.w	r3, r3, #1
 801a338:	617b      	str	r3, [r7, #20]
 801a33a:	697b      	ldr	r3, [r7, #20]
 801a33c:	2b02      	cmp	r3, #2
 801a33e:	bfcc      	ite	gt
 801a340:	2300      	movgt	r3, #0
 801a342:	2301      	movle	r3, #1
 801a344:	b2db      	uxtb	r3, r3
 801a346:	2b00      	cmp	r3, #0
 801a348:	d1ce      	bne.n	801a2e8 <_ZN6USBHub12ResetHubPortEh+0x50>
 801a34a:	e002      	b.n	801a352 <_ZN6USBHub12ResetHubPortEh+0xba>
                rcode = GetPortStatus(port, 4, evt.evtBuff);
                if (rcode) break; // Some kind of error, bail.
 801a34c:	bf00      	nop
 801a34e:	e000      	b.n	801a352 <_ZN6USBHub12ResetHubPortEh+0xba>
                if (evt.bmEvent == bmHUB_PORT_EVENT_RESET_COMPLETE || evt.bmEvent == bmHUB_PORT_EVENT_LS_RESET_COMPLETE) {
                        break;
 801a350:	bf00      	nop
                }
                delay_ms(100); // simulate polling.
        }
        ClearPortFeature(HUB_FEATURE_C_PORT_RESET, port, 0);
 801a352:	78fb      	ldrb	r3, [r7, #3]
 801a354:	6878      	ldr	r0, [r7, #4]
 801a356:	f04f 0114 	mov.w	r1, #20
 801a35a:	461a      	mov	r2, r3
 801a35c:	f04f 0300 	mov.w	r3, #0
 801a360:	f7ff facc 	bl	80198fc <_ZN6USBHub16ClearPortFeatureEhhh>
        ClearPortFeature(HUB_FEATURE_C_PORT_CONNECTION, port, 0);
 801a364:	78fb      	ldrb	r3, [r7, #3]
 801a366:	6878      	ldr	r0, [r7, #4]
 801a368:	f04f 0110 	mov.w	r1, #16
 801a36c:	461a      	mov	r2, r3
 801a36e:	f04f 0300 	mov.w	r3, #0
 801a372:	f7ff fac3 	bl	80198fc <_ZN6USBHub16ClearPortFeatureEhhh>
        delay_ms(20);
 801a376:	f243 630c 	movw	r3, #13836	; 0x360c
 801a37a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a37e:	681b      	ldr	r3, [r3, #0]
 801a380:	685b      	ldr	r3, [r3, #4]
 801a382:	f04f 0014 	mov.w	r0, #20
 801a386:	4798      	blx	r3
}
 801a388:	e001      	b.n	801a38e <_ZN6USBHub12ResetHubPortEh+0xf6>
 801a38a:	f002 fb79 	bl	801ca80 <__cxa_end_cleanup>
 801a38e:	f107 0718 	add.w	r7, r7, #24
 801a392:	46bd      	mov	sp, r7
 801a394:	bd80      	pop	{r7, pc}
 801a396:	bf00      	nop

0801a398 <_ZN6USBHub16PortStatusChangeEhR8HubEvent>:

uint8_t USBHub::PortStatusChange(uint8_t port, HubEvent &evt) {
 801a398:	b580      	push	{r7, lr}
 801a39a:	b086      	sub	sp, #24
 801a39c:	af00      	add	r7, sp, #0
 801a39e:	60f8      	str	r0, [r7, #12]
 801a3a0:	460b      	mov	r3, r1
 801a3a2:	607a      	str	r2, [r7, #4]
 801a3a4:	72fb      	strb	r3, [r7, #11]
        switch (evt.bmEvent) {
 801a3a6:	687b      	ldr	r3, [r7, #4]
 801a3a8:	681b      	ldr	r3, [r3, #0]
 801a3aa:	f240 3201 	movw	r2, #769	; 0x301
 801a3ae:	f2c0 0201 	movt	r2, #1
 801a3b2:	4293      	cmp	r3, r2
 801a3b4:	d01f      	beq.n	801a3f6 <_ZN6USBHub16PortStatusChangeEhR8HubEvent+0x5e>
 801a3b6:	f240 3201 	movw	r2, #769	; 0x301
 801a3ba:	f2c0 0201 	movt	r2, #1
 801a3be:	4293      	cmp	r3, r2
 801a3c0:	d80c      	bhi.n	801a3dc <_ZN6USBHub16PortStatusChangeEhR8HubEvent+0x44>
 801a3c2:	f44f 7280 	mov.w	r2, #256	; 0x100
 801a3c6:	f2c0 0201 	movt	r2, #1
 801a3ca:	4293      	cmp	r3, r2
 801a3cc:	d042      	beq.n	801a454 <_ZN6USBHub16PortStatusChangeEhR8HubEvent+0xbc>
 801a3ce:	f240 1201 	movw	r2, #257	; 0x101
 801a3d2:	f2c0 0201 	movt	r2, #1
 801a3d6:	4293      	cmp	r3, r2
 801a3d8:	d00d      	beq.n	801a3f6 <_ZN6USBHub16PortStatusChangeEhR8HubEvent+0x5e>
 801a3da:	e0af      	b.n	801a53c <_ZN6USBHub16PortStatusChangeEhR8HubEvent+0x1a4>
 801a3dc:	f240 1203 	movw	r2, #259	; 0x103
 801a3e0:	f2c0 0210 	movt	r2, #16
 801a3e4:	4293      	cmp	r3, r2
 801a3e6:	d070      	beq.n	801a4ca <_ZN6USBHub16PortStatusChangeEhR8HubEvent+0x132>
 801a3e8:	f240 3203 	movw	r2, #771	; 0x303
 801a3ec:	f2c0 0210 	movt	r2, #16
 801a3f0:	4293      	cmp	r3, r2
 801a3f2:	d06a      	beq.n	801a4ca <_ZN6USBHub16PortStatusChangeEhR8HubEvent+0x132>
 801a3f4:	e0a2      	b.n	801a53c <_ZN6USBHub16PortStatusChangeEhR8HubEvent+0x1a4>
                        // Device connected event
                case bmHUB_PORT_EVENT_CONNECT:
                case bmHUB_PORT_EVENT_LS_CONNECT:
                        if (bResetInitiated)
 801a3f6:	f640 4368 	movw	r3, #3176	; 0xc68
 801a3fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a3fe:	781b      	ldrb	r3, [r3, #0]
 801a400:	2b00      	cmp	r3, #0
 801a402:	d002      	beq.n	801a40a <_ZN6USBHub16PortStatusChangeEhR8HubEvent+0x72>
                                return 0;
 801a404:	f04f 0300 	mov.w	r3, #0
 801a408:	e09a      	b.n	801a540 <_ZN6USBHub16PortStatusChangeEhR8HubEvent+0x1a8>

                        ClearPortFeature(HUB_FEATURE_C_PORT_ENABLE, port, 0);
 801a40a:	7afb      	ldrb	r3, [r7, #11]
 801a40c:	68f8      	ldr	r0, [r7, #12]
 801a40e:	f04f 0111 	mov.w	r1, #17
 801a412:	461a      	mov	r2, r3
 801a414:	f04f 0300 	mov.w	r3, #0
 801a418:	f7ff fa70 	bl	80198fc <_ZN6USBHub16ClearPortFeatureEhhh>
                        ClearPortFeature(HUB_FEATURE_C_PORT_CONNECTION, port, 0);
 801a41c:	7afb      	ldrb	r3, [r7, #11]
 801a41e:	68f8      	ldr	r0, [r7, #12]
 801a420:	f04f 0110 	mov.w	r1, #16
 801a424:	461a      	mov	r2, r3
 801a426:	f04f 0300 	mov.w	r3, #0
 801a42a:	f7ff fa67 	bl	80198fc <_ZN6USBHub16ClearPortFeatureEhhh>
                        SetPortFeature(HUB_FEATURE_PORT_RESET, port, 0);
 801a42e:	7afb      	ldrb	r3, [r7, #11]
 801a430:	68f8      	ldr	r0, [r7, #12]
 801a432:	f04f 0104 	mov.w	r1, #4
 801a436:	461a      	mov	r2, r3
 801a438:	f04f 0300 	mov.w	r3, #0
 801a43c:	f7ff faf6 	bl	8019a2c <_ZN6USBHub14SetPortFeatureEhhh>
                        bResetInitiated = true;
 801a440:	f640 4368 	movw	r3, #3176	; 0xc68
 801a444:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a448:	f04f 0201 	mov.w	r2, #1
 801a44c:	701a      	strb	r2, [r3, #0]
                        return HUB_ERROR_PORT_HAS_BEEN_RESET;
 801a44e:	f04f 03b1 	mov.w	r3, #177	; 0xb1
 801a452:	e075      	b.n	801a540 <_ZN6USBHub16PortStatusChangeEhR8HubEvent+0x1a8>

                        // Device disconnected event
                case bmHUB_PORT_EVENT_DISCONNECT:
                        ClearPortFeature(HUB_FEATURE_C_PORT_ENABLE, port, 0);
 801a454:	7afb      	ldrb	r3, [r7, #11]
 801a456:	68f8      	ldr	r0, [r7, #12]
 801a458:	f04f 0111 	mov.w	r1, #17
 801a45c:	461a      	mov	r2, r3
 801a45e:	f04f 0300 	mov.w	r3, #0
 801a462:	f7ff fa4b 	bl	80198fc <_ZN6USBHub16ClearPortFeatureEhhh>
                        ClearPortFeature(HUB_FEATURE_C_PORT_CONNECTION, port, 0);
 801a466:	7afb      	ldrb	r3, [r7, #11]
 801a468:	68f8      	ldr	r0, [r7, #12]
 801a46a:	f04f 0110 	mov.w	r1, #16
 801a46e:	461a      	mov	r2, r3
 801a470:	f04f 0300 	mov.w	r3, #0
 801a474:	f7ff fa42 	bl	80198fc <_ZN6USBHub16ClearPortFeatureEhhh>
                        bResetInitiated = false;
 801a478:	f640 4368 	movw	r3, #3176	; 0xc68
 801a47c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a480:	f04f 0200 	mov.w	r2, #0
 801a484:	701a      	strb	r2, [r3, #0]

                        UsbDeviceAddress a;
                        a.devAddress = 0;	// var init first
 801a486:	f04f 0300 	mov.w	r3, #0
 801a48a:	753b      	strb	r3, [r7, #20]
                        a.bmHub = 0;
 801a48c:	7d3b      	ldrb	r3, [r7, #20]
 801a48e:	f36f 1386 	bfc	r3, #6, #1
 801a492:	753b      	strb	r3, [r7, #20]
                        a.bmParent = bAddress;
 801a494:	68fb      	ldr	r3, [r7, #12]
 801a496:	7c9b      	ldrb	r3, [r3, #18]
 801a498:	f003 0307 	and.w	r3, r3, #7
 801a49c:	b2da      	uxtb	r2, r3
 801a49e:	7d3b      	ldrb	r3, [r7, #20]
 801a4a0:	f362 03c5 	bfi	r3, r2, #3, #3
 801a4a4:	753b      	strb	r3, [r7, #20]
                        a.bmAddress = port;
 801a4a6:	7afb      	ldrb	r3, [r7, #11]
 801a4a8:	f003 0307 	and.w	r3, r3, #7
 801a4ac:	b2da      	uxtb	r2, r3
 801a4ae:	7d3b      	ldrb	r3, [r7, #20]
 801a4b0:	f362 0302 	bfi	r3, r2, #0, #3
 801a4b4:	753b      	strb	r3, [r7, #20]
                        pUsb->ReleaseDevice(a.devAddress);
 801a4b6:	68fb      	ldr	r3, [r7, #12]
 801a4b8:	685a      	ldr	r2, [r3, #4]
 801a4ba:	7d3b      	ldrb	r3, [r7, #20]
 801a4bc:	4610      	mov	r0, r2
 801a4be:	4619      	mov	r1, r3
 801a4c0:	f7fb faae 	bl	8015a20 <_ZN3USB13ReleaseDeviceEh>
                        return 0;
 801a4c4:	f04f 0300 	mov.w	r3, #0
 801a4c8:	e03a      	b.n	801a540 <_ZN6USBHub16PortStatusChangeEhR8HubEvent+0x1a8>

                        // Reset complete event
                case bmHUB_PORT_EVENT_RESET_COMPLETE:
                case bmHUB_PORT_EVENT_LS_RESET_COMPLETE:
                        ClearPortFeature(HUB_FEATURE_C_PORT_RESET, port, 0);
 801a4ca:	7afb      	ldrb	r3, [r7, #11]
 801a4cc:	68f8      	ldr	r0, [r7, #12]
 801a4ce:	f04f 0114 	mov.w	r1, #20
 801a4d2:	461a      	mov	r2, r3
 801a4d4:	f04f 0300 	mov.w	r3, #0
 801a4d8:	f7ff fa10 	bl	80198fc <_ZN6USBHub16ClearPortFeatureEhhh>
                        ClearPortFeature(HUB_FEATURE_C_PORT_CONNECTION, port, 0);
 801a4dc:	7afb      	ldrb	r3, [r7, #11]
 801a4de:	68f8      	ldr	r0, [r7, #12]
 801a4e0:	f04f 0110 	mov.w	r1, #16
 801a4e4:	461a      	mov	r2, r3
 801a4e6:	f04f 0300 	mov.w	r3, #0
 801a4ea:	f7ff fa07 	bl	80198fc <_ZN6USBHub16ClearPortFeatureEhhh>

                        delay_ms(20);
 801a4ee:	f243 630c 	movw	r3, #13836	; 0x360c
 801a4f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a4f6:	681b      	ldr	r3, [r3, #0]
 801a4f8:	685b      	ldr	r3, [r3, #4]
 801a4fa:	f04f 0014 	mov.w	r0, #20
 801a4fe:	4798      	blx	r3

                        a.devAddress = bAddress;
 801a500:	68fb      	ldr	r3, [r7, #12]
 801a502:	7c9b      	ldrb	r3, [r3, #18]
 801a504:	753b      	strb	r3, [r7, #20]

                        pUsb->Configuring(a.bmAddress, port, (evt.bmStatus & bmHUB_PORT_STATUS_PORT_LOW_SPEED));
 801a506:	68fb      	ldr	r3, [r7, #12]
 801a508:	6858      	ldr	r0, [r3, #4]
 801a50a:	7d3b      	ldrb	r3, [r7, #20]
 801a50c:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801a510:	b2db      	uxtb	r3, r3
 801a512:	4619      	mov	r1, r3
 801a514:	687b      	ldr	r3, [r7, #4]
 801a516:	881b      	ldrh	r3, [r3, #0]
 801a518:	b29b      	uxth	r3, r3
 801a51a:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801a51e:	2b00      	cmp	r3, #0
 801a520:	bf0c      	ite	eq
 801a522:	2300      	moveq	r3, #0
 801a524:	2301      	movne	r3, #1
 801a526:	b2db      	uxtb	r3, r3
 801a528:	7afa      	ldrb	r2, [r7, #11]
 801a52a:	f7fb f855 	bl	80155d8 <_ZN3USB11ConfiguringEhhb>
                        bResetInitiated = false;
 801a52e:	f640 4368 	movw	r3, #3176	; 0xc68
 801a532:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a536:	f04f 0200 	mov.w	r2, #0
 801a53a:	701a      	strb	r2, [r3, #0]
                        break;

        } // switch (evt.bmEvent)
        return 0;
 801a53c:	f04f 0300 	mov.w	r3, #0
 801a540:	e001      	b.n	801a546 <_ZN6USBHub16PortStatusChangeEhR8HubEvent+0x1ae>
 801a542:	f002 fa9d 	bl	801ca80 <__cxa_end_cleanup>
}
 801a546:	4618      	mov	r0, r3
 801a548:	f107 0718 	add.w	r7, r7, #24
 801a54c:	46bd      	mov	sp, r7
 801a54e:	bd80      	pop	{r7, pc}

0801a550 <_Z18PrintHubPortStatusP6USBHubhhb>:

void PrintHubPortStatus(USBHub *hubptr, uint8_t addr, uint8_t port, bool print_changes) {
 801a550:	b580      	push	{r7, lr}
 801a552:	b084      	sub	sp, #16
 801a554:	af00      	add	r7, sp, #0
 801a556:	6078      	str	r0, [r7, #4]
 801a558:	70f9      	strb	r1, [r7, #3]
 801a55a:	70ba      	strb	r2, [r7, #2]
 801a55c:	707b      	strb	r3, [r7, #1]
        uint8_t rcode = 0;
 801a55e:	f04f 0300 	mov.w	r3, #0
 801a562:	73fb      	strb	r3, [r7, #15]
        HubEvent evt;

        rcode = hubptr->GetPortStatus(port, 4, evt.evtBuff);
 801a564:	78ba      	ldrb	r2, [r7, #2]
 801a566:	f107 0308 	add.w	r3, r7, #8
 801a56a:	6878      	ldr	r0, [r7, #4]
 801a56c:	4611      	mov	r1, r2
 801a56e:	f04f 0204 	mov.w	r2, #4
 801a572:	f7ff fa2b 	bl	80199cc <_ZN6USBHub13GetPortStatusEhtPh>
 801a576:	4603      	mov	r3, r0
 801a578:	73fb      	strb	r3, [r7, #15]

        if (rcode) {
 801a57a:	7bfb      	ldrb	r3, [r7, #15]
 801a57c:	2b00      	cmp	r3, #0
 801a57e:	d107      	bne.n	801a590 <_Z18PrintHubPortStatusP6USBHubhhb+0x40>
        USB_HOST_SERIAL.print("TEST:\t\t");
        USB_HOST_SERIAL.println((evt.bmStatus & bmHUB_PORT_STATUS_PORT_TEST) > 0, DEC);
        USB_HOST_SERIAL.print("INDICATOR:\t");
        USB_HOST_SERIAL.println((evt.bmStatus & bmHUB_PORT_STATUS_PORT_INDICATOR) > 0, DEC);
*/
        if (!print_changes)
 801a580:	787b      	ldrb	r3, [r7, #1]
 801a582:	f083 0301 	eor.w	r3, r3, #1
 801a586:	b2db      	uxtb	r3, r3
 801a588:	2b00      	cmp	r3, #0
 801a58a:	e001      	b.n	801a590 <_Z18PrintHubPortStatusP6USBHubhhb+0x40>
 801a58c:	f002 fa78 	bl	801ca80 <__cxa_end_cleanup>
        USB_HOST_SERIAL.println((evt.bmChange & bmHUB_PORT_STATUS_C_PORT_SUSPEND) > 0, DEC);
        USB_HOST_SERIAL.print("OVER_CURRENT:\t");
        USB_HOST_SERIAL.println((evt.bmChange & bmHUB_PORT_STATUS_C_PORT_OVER_CURRENT) > 0, DEC);
        USB_HOST_SERIAL.print("RESET:\t\t");
        USB_HOST_SERIAL.println((evt.bmChange & bmHUB_PORT_STATUS_C_PORT_RESET) > 0, DEC);*/
}
 801a590:	f107 0710 	add.w	r7, r7, #16
 801a594:	46bd      	mov	sp, r7
 801a596:	bd80      	pop	{r7, pc}

0801a598 <_ZN10USBPrinter10GetAddressEv>:

    // USBDeviceConfig implementation
	virtual uint8_t Init(uint8_t parent, uint8_t port, bool lowspeed);
    virtual uint8_t Release();
    virtual uint8_t Poll();
    virtual uint8_t GetAddress() { return bAddress; };
 801a598:	b480      	push	{r7}
 801a59a:	b083      	sub	sp, #12
 801a59c:	af00      	add	r7, sp, #0
 801a59e:	6078      	str	r0, [r7, #4]
 801a5a0:	687b      	ldr	r3, [r7, #4]
 801a5a2:	7edb      	ldrb	r3, [r3, #27]
 801a5a4:	4618      	mov	r0, r3
 801a5a6:	f107 070c 	add.w	r7, r7, #12
 801a5aa:	46bd      	mov	sp, r7
 801a5ac:	bc80      	pop	{r7}
 801a5ae:	4770      	bx	lr

0801a5b0 <_ZN10USBPrinter10DEVCLASSOKEh>:

    // UsbConfigXtracter implementation
    virtual void EndpointXtract(uint8_t conf, uint8_t iface, uint8_t alt, uint8_t proto, const USB_ENDPOINT_DESCRIPTOR *ep);

    virtual uint8_t DEVCLASSOK(uint8_t klass) { return (klass == USB_CLASS_PRINTER); }
 801a5b0:	b480      	push	{r7}
 801a5b2:	b083      	sub	sp, #12
 801a5b4:	af00      	add	r7, sp, #0
 801a5b6:	6078      	str	r0, [r7, #4]
 801a5b8:	460b      	mov	r3, r1
 801a5ba:	70fb      	strb	r3, [r7, #3]
 801a5bc:	78fb      	ldrb	r3, [r7, #3]
 801a5be:	2b07      	cmp	r3, #7
 801a5c0:	bf14      	ite	ne
 801a5c2:	2300      	movne	r3, #0
 801a5c4:	2301      	moveq	r3, #1
 801a5c6:	b2db      	uxtb	r3, r3
 801a5c8:	4618      	mov	r0, r3
 801a5ca:	f107 070c 	add.w	r7, r7, #12
 801a5ce:	46bd      	mov	sp, r7
 801a5d0:	bc80      	pop	{r7}
 801a5d2:	4770      	bx	lr

0801a5d4 <_ZN10USBPrinterC1EP3USB>:
#include "usbprinter.h"

const uint8_t USBPrinter::epDataInIndex = 2;
const uint8_t USBPrinter::epDataOutIndex = 1;

USBPrinter::USBPrinter(USB *p) :
 801a5d4:	b580      	push	{r7, lr}
 801a5d6:	b082      	sub	sp, #8
 801a5d8:	af00      	add	r7, sp, #0
 801a5da:	6078      	str	r0, [r7, #4]
 801a5dc:	6039      	str	r1, [r7, #0]
pUsb(p),
bAddress(0),
bConfNum(0),
bNumEP(1),
qNextPollTime(0),
bPollEnable(false)
 801a5de:	687b      	ldr	r3, [r7, #4]
 801a5e0:	4618      	mov	r0, r3
 801a5e2:	f7fc fbb9 	bl	8016d58 <_ZN15USBDeviceConfigC1Ev>
 801a5e6:	687b      	ldr	r3, [r7, #4]
 801a5e8:	f103 0304 	add.w	r3, r3, #4
 801a5ec:	4618      	mov	r0, r3
 801a5ee:	f7fc fbc3 	bl	8016d78 <_ZN17UsbConfigXtracterC1Ev>
 801a5f2:	687b      	ldr	r3, [r7, #4]
 801a5f4:	4a18      	ldr	r2, [pc, #96]	; (801a658 <_ZN10USBPrinterC1EP3USB+0x84>)
 801a5f6:	601a      	str	r2, [r3, #0]
 801a5f8:	687b      	ldr	r3, [r7, #4]
 801a5fa:	4a18      	ldr	r2, [pc, #96]	; (801a65c <_ZN10USBPrinterC1EP3USB+0x88>)
 801a5fc:	605a      	str	r2, [r3, #4]
 801a5fe:	687b      	ldr	r3, [r7, #4]
 801a600:	683a      	ldr	r2, [r7, #0]
 801a602:	609a      	str	r2, [r3, #8]
 801a604:	687b      	ldr	r3, [r7, #4]
 801a606:	f04f 0200 	mov.w	r2, #0
 801a60a:	76da      	strb	r2, [r3, #27]
 801a60c:	687b      	ldr	r3, [r7, #4]
 801a60e:	f04f 0200 	mov.w	r2, #0
 801a612:	771a      	strb	r2, [r3, #28]
 801a614:	687b      	ldr	r3, [r7, #4]
 801a616:	f04f 0201 	mov.w	r2, #1
 801a61a:	775a      	strb	r2, [r3, #29]
 801a61c:	687b      	ldr	r3, [r7, #4]
 801a61e:	f04f 0200 	mov.w	r2, #0
 801a622:	621a      	str	r2, [r3, #32]
 801a624:	687b      	ldr	r3, [r7, #4]
 801a626:	f04f 0200 	mov.w	r2, #0
 801a62a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
//current_state(1),
//last_state(0),
//isOnline(0)
{
	ClearAllEP();
 801a62e:	6878      	ldr	r0, [r7, #4]
 801a630:	f000 f86c 	bl	801a70c <_ZN10USBPrinter10ClearAllEPEv>

	if(pUsb)
 801a634:	687b      	ldr	r3, [r7, #4]
 801a636:	689b      	ldr	r3, [r3, #8]
 801a638:	2b00      	cmp	r3, #0
 801a63a:	d006      	beq.n	801a64a <_ZN10USBPrinterC1EP3USB+0x76>
		pUsb->RegisterDeviceClass(this);
 801a63c:	687b      	ldr	r3, [r7, #4]
 801a63e:	689a      	ldr	r2, [r3, #8]
 801a640:	687b      	ldr	r3, [r7, #4]
 801a642:	4610      	mov	r0, r2
 801a644:	4619      	mov	r1, r3
 801a646:	f7fb fef7 	bl	8016438 <_ZN3USB19RegisterDeviceClassEP15USBDeviceConfig>

}
 801a64a:	687b      	ldr	r3, [r7, #4]
 801a64c:	4618      	mov	r0, r3
 801a64e:	f107 0708 	add.w	r7, r7, #8
 801a652:	46bd      	mov	sp, r7
 801a654:	bd80      	pop	{r7, pc}
 801a656:	bf00      	nop
 801a658:	080206e0 	.word	0x080206e0
 801a65c:	08020714 	.word	0x08020714

0801a660 <_ZN10USBPrinterD1Ev>:

USBPrinter::~USBPrinter() {
 801a660:	b580      	push	{r7, lr}
 801a662:	b082      	sub	sp, #8
 801a664:	af00      	add	r7, sp, #0
 801a666:	6078      	str	r0, [r7, #4]
 801a668:	687b      	ldr	r3, [r7, #4]
 801a66a:	4a0a      	ldr	r2, [pc, #40]	; (801a694 <_ZN10USBPrinterD1Ev+0x34>)
 801a66c:	601a      	str	r2, [r3, #0]
 801a66e:	687b      	ldr	r3, [r7, #4]
 801a670:	4a09      	ldr	r2, [pc, #36]	; (801a698 <_ZN10USBPrinterD1Ev+0x38>)
 801a672:	605a      	str	r2, [r3, #4]
	// TODO Auto-generated destructor stub
}
 801a674:	f04f 0300 	mov.w	r3, #0
 801a678:	f003 0301 	and.w	r3, r3, #1
 801a67c:	2b00      	cmp	r3, #0
 801a67e:	d002      	beq.n	801a686 <_ZN10USBPrinterD1Ev+0x26>
 801a680:	6878      	ldr	r0, [r7, #4]
 801a682:	f002 f9f9 	bl	801ca78 <_ZdlPv>
 801a686:	687b      	ldr	r3, [r7, #4]
 801a688:	4618      	mov	r0, r3
 801a68a:	f107 0708 	add.w	r7, r7, #8
 801a68e:	46bd      	mov	sp, r7
 801a690:	bd80      	pop	{r7, pc}
 801a692:	bf00      	nop
 801a694:	080206e0 	.word	0x080206e0
 801a698:	08020714 	.word	0x08020714

0801a69c <_ZN10USBPrinterD0Ev>:
	if(pUsb)
		pUsb->RegisterDeviceClass(this);

}

USBPrinter::~USBPrinter() {
 801a69c:	b580      	push	{r7, lr}
 801a69e:	b082      	sub	sp, #8
 801a6a0:	af00      	add	r7, sp, #0
 801a6a2:	6078      	str	r0, [r7, #4]
	// TODO Auto-generated destructor stub
}
 801a6a4:	6878      	ldr	r0, [r7, #4]
 801a6a6:	f7ff ffdb 	bl	801a660 <_ZN10USBPrinterD1Ev>
 801a6aa:	6878      	ldr	r0, [r7, #4]
 801a6ac:	f002 f9e4 	bl	801ca78 <_ZdlPv>
 801a6b0:	687b      	ldr	r3, [r7, #4]
 801a6b2:	4618      	mov	r0, r3
 801a6b4:	f107 0708 	add.w	r7, r7, #8
 801a6b8:	46bd      	mov	sp, r7
 801a6ba:	bd80      	pop	{r7, pc}

0801a6bc <_ZN10USBPrinter9BulkWriteEPht>:

uint8_t USBPrinter::BulkWrite(uint8_t *buf, uint16_t nbytes)
{
 801a6bc:	b590      	push	{r4, r7, lr}
 801a6be:	b089      	sub	sp, #36	; 0x24
 801a6c0:	af02      	add	r7, sp, #8
 801a6c2:	60f8      	str	r0, [r7, #12]
 801a6c4:	60b9      	str	r1, [r7, #8]
 801a6c6:	4613      	mov	r3, r2
 801a6c8:	80fb      	strh	r3, [r7, #6]
	uint8_t rcode = 0;
 801a6ca:	f04f 0300 	mov.w	r3, #0
 801a6ce:	75fb      	strb	r3, [r7, #23]

	rcode = pUsb->outTransfer(bAddress, epInfo[epDataOutIndex].epAddr, nbytes, buf);
 801a6d0:	68fb      	ldr	r3, [r7, #12]
 801a6d2:	6898      	ldr	r0, [r3, #8]
 801a6d4:	68fb      	ldr	r3, [r7, #12]
 801a6d6:	7ed9      	ldrb	r1, [r3, #27]
 801a6d8:	68fb      	ldr	r3, [r7, #12]
 801a6da:	7c5a      	ldrb	r2, [r3, #17]
 801a6dc:	88fb      	ldrh	r3, [r7, #6]
 801a6de:	68bc      	ldr	r4, [r7, #8]
 801a6e0:	9400      	str	r4, [sp, #0]
 801a6e2:	f7fa f9a3 	bl	8014a2c <_ZN3USB11outTransferEhhtPKh>
 801a6e6:	4603      	mov	r3, r0
 801a6e8:	75fb      	strb	r3, [r7, #23]
	if(rcode)
 801a6ea:	7dfb      	ldrb	r3, [r7, #23]
 801a6ec:	2b00      	cmp	r3, #0
 801a6ee:	d007      	beq.n	801a700 <_ZN10USBPrinter9BulkWriteEPht+0x44>
		ErrorMessage<uint8_t > (PSTR("printer write error : "), rcode);
 801a6f0:	7dfb      	ldrb	r3, [r7, #23]
 801a6f2:	f64e 6058 	movw	r0, #61016	; 0xee58
 801a6f6:	f6c0 0001 	movt	r0, #2049	; 0x801
 801a6fa:	4619      	mov	r1, r3
 801a6fc:	f7fe fbc0 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>

	return rcode;
 801a700:	7dfb      	ldrb	r3, [r7, #23]
}
 801a702:	4618      	mov	r0, r3
 801a704:	f107 071c 	add.w	r7, r7, #28
 801a708:	46bd      	mov	sp, r7
 801a70a:	bd90      	pop	{r4, r7, pc}

0801a70c <_ZN10USBPrinter10ClearAllEPEv>:

/*
 * Clear local EP[0:2], and reset member variables.
 */
uint8_t USBPrinter::ClearAllEP(void)
{
 801a70c:	b480      	push	{r7}
 801a70e:	b085      	sub	sp, #20
 801a710:	af00      	add	r7, sp, #0
 801a712:	6078      	str	r0, [r7, #4]
	for(int i = 0; i < USB_PRINTER_MAX_ENDPOINTS; i++)
 801a714:	f04f 0300 	mov.w	r3, #0
 801a718:	60fb      	str	r3, [r7, #12]
 801a71a:	e042      	b.n	801a7a2 <_ZN10USBPrinter10ClearAllEPEv+0x96>
	{
		epInfo[i].epAddr = 0;
 801a71c:	6879      	ldr	r1, [r7, #4]
 801a71e:	68fa      	ldr	r2, [r7, #12]
 801a720:	4613      	mov	r3, r2
 801a722:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801a726:	189b      	adds	r3, r3, r2
 801a728:	18cb      	adds	r3, r1, r3
 801a72a:	f103 0308 	add.w	r3, r3, #8
 801a72e:	f04f 0200 	mov.w	r2, #0
 801a732:	711a      	strb	r2, [r3, #4]
		epInfo[i].maxPktSize = 8;
 801a734:	6879      	ldr	r1, [r7, #4]
 801a736:	68fa      	ldr	r2, [r7, #12]
 801a738:	4613      	mov	r3, r2
 801a73a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801a73e:	189b      	adds	r3, r3, r2
 801a740:	18cb      	adds	r3, r1, r3
 801a742:	f103 0308 	add.w	r3, r3, #8
 801a746:	f04f 0208 	mov.w	r2, #8
 801a74a:	715a      	strb	r2, [r3, #5]
		epInfo[i].epAttribs = 0;
 801a74c:	6879      	ldr	r1, [r7, #4]
 801a74e:	68fa      	ldr	r2, [r7, #12]
 801a750:	4613      	mov	r3, r2
 801a752:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801a756:	189b      	adds	r3, r3, r2
 801a758:	18cb      	adds	r3, r1, r3
 801a75a:	f103 0308 	add.w	r3, r3, #8
 801a75e:	f04f 0200 	mov.w	r2, #0
 801a762:	721a      	strb	r2, [r3, #8]
		epInfo[i].bmNakPower = USB_NAK_DEFAULT;
 801a764:	6879      	ldr	r1, [r7, #4]
 801a766:	68fa      	ldr	r2, [r7, #12]
 801a768:	4613      	mov	r3, r2
 801a76a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801a76e:	189b      	adds	r3, r3, r2
 801a770:	18cb      	adds	r3, r1, r3
 801a772:	f103 0208 	add.w	r2, r3, #8
 801a776:	7a13      	ldrb	r3, [r2, #8]
 801a778:	f04f 010e 	mov.w	r1, #14
 801a77c:	f361 0387 	bfi	r3, r1, #2, #6
 801a780:	7213      	strb	r3, [r2, #8]
		epInfo[i].hcNumber = 0;
 801a782:	6879      	ldr	r1, [r7, #4]
 801a784:	68fa      	ldr	r2, [r7, #12]
 801a786:	4613      	mov	r3, r2
 801a788:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801a78c:	189b      	adds	r3, r3, r2
 801a78e:	18cb      	adds	r3, r1, r3
 801a790:	f103 0308 	add.w	r3, r3, #8
 801a794:	f04f 0200 	mov.w	r2, #0
 801a798:	71da      	strb	r2, [r3, #7]
/*
 * Clear local EP[0:2], and reset member variables.
 */
uint8_t USBPrinter::ClearAllEP(void)
{
	for(int i = 0; i < USB_PRINTER_MAX_ENDPOINTS; i++)
 801a79a:	68fb      	ldr	r3, [r7, #12]
 801a79c:	f103 0301 	add.w	r3, r3, #1
 801a7a0:	60fb      	str	r3, [r7, #12]
 801a7a2:	68fb      	ldr	r3, [r7, #12]
 801a7a4:	2b02      	cmp	r3, #2
 801a7a6:	bfcc      	ite	gt
 801a7a8:	2300      	movgt	r3, #0
 801a7aa:	2301      	movle	r3, #1
 801a7ac:	b2db      	uxtb	r3, r3
 801a7ae:	2b00      	cmp	r3, #0
 801a7b0:	d1b4      	bne.n	801a71c <_ZN10USBPrinter10ClearAllEPEv+0x10>
		epInfo[i].maxPktSize = 8;
		epInfo[i].epAttribs = 0;
		epInfo[i].bmNakPower = USB_NAK_DEFAULT;
		epInfo[i].hcNumber = 0;
	}
	bAddress = 0;
 801a7b2:	687b      	ldr	r3, [r7, #4]
 801a7b4:	f04f 0200 	mov.w	r2, #0
 801a7b8:	76da      	strb	r2, [r3, #27]
	bConfNum = 0;
 801a7ba:	687b      	ldr	r3, [r7, #4]
 801a7bc:	f04f 0200 	mov.w	r2, #0
 801a7c0:	771a      	strb	r2, [r3, #28]
	bNumEP = 1;
 801a7c2:	687b      	ldr	r3, [r7, #4]
 801a7c4:	f04f 0201 	mov.w	r2, #1
 801a7c8:	775a      	strb	r2, [r3, #29]
	qNextPollTime = 0;
 801a7ca:	687b      	ldr	r3, [r7, #4]
 801a7cc:	f04f 0200 	mov.w	r2, #0
 801a7d0:	621a      	str	r2, [r3, #32]
	bPollEnable = false;
 801a7d2:	687b      	ldr	r3, [r7, #4]
 801a7d4:	f04f 0200 	mov.w	r2, #0
 801a7d8:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

	return 0;
 801a7dc:	f04f 0300 	mov.w	r3, #0
}
 801a7e0:	4618      	mov	r0, r3
 801a7e2:	f107 0714 	add.w	r7, r7, #20
 801a7e6:	46bd      	mov	sp, r7
 801a7e8:	bc80      	pop	{r7}
 801a7ea:	4770      	bx	lr

0801a7ec <_ZN10USBPrinter11GetDeviceIDEPh>:
 * 					 content is starting from buf[2]
 *
 * @return 0 - Operation successful
 */
uint8_t USBPrinter::GetDeviceID(uint8_t *buf)
{
 801a7ec:	b580      	push	{r7, lr}
 801a7ee:	b08c      	sub	sp, #48	; 0x30
 801a7f0:	af08      	add	r7, sp, #32
 801a7f2:	6078      	str	r0, [r7, #4]
 801a7f4:	6039      	str	r1, [r7, #0]
			0,
			0x0000,
			USB_PRINTER_DEVICE_ID_MAX_SIZE,
			USB_PRINTER_DEVICE_ID_MAX_SIZE,
			buf,
			NULL);
 801a7f6:	687b      	ldr	r3, [r7, #4]
 801a7f8:	689a      	ldr	r2, [r3, #8]
 801a7fa:	687b      	ldr	r3, [r7, #4]
 801a7fc:	7edb      	ldrb	r3, [r3, #27]
 801a7fe:	f04f 0100 	mov.w	r1, #0
 801a802:	9100      	str	r1, [sp, #0]
 801a804:	f04f 0100 	mov.w	r1, #0
 801a808:	9101      	str	r1, [sp, #4]
 801a80a:	f04f 0100 	mov.w	r1, #0
 801a80e:	9102      	str	r1, [sp, #8]
 801a810:	f04f 0100 	mov.w	r1, #0
 801a814:	9103      	str	r1, [sp, #12]
 801a816:	f240 1131 	movw	r1, #305	; 0x131
 801a81a:	9104      	str	r1, [sp, #16]
 801a81c:	f240 1131 	movw	r1, #305	; 0x131
 801a820:	9105      	str	r1, [sp, #20]
 801a822:	6839      	ldr	r1, [r7, #0]
 801a824:	9106      	str	r1, [sp, #24]
 801a826:	f04f 0100 	mov.w	r1, #0
 801a82a:	9107      	str	r1, [sp, #28]
 801a82c:	4610      	mov	r0, r2
 801a82e:	4619      	mov	r1, r3
 801a830:	f04f 0200 	mov.w	r2, #0
 801a834:	f04f 03a1 	mov.w	r3, #161	; 0xa1
 801a838:	f7f9 ff34 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 801a83c:	4603      	mov	r3, r0
 801a83e:	73fb      	strb	r3, [r7, #15]

	return ret;
 801a840:	7bfb      	ldrb	r3, [r7, #15]
}
 801a842:	4618      	mov	r0, r3
 801a844:	f107 0710 	add.w	r7, r7, #16
 801a848:	46bd      	mov	sp, r7
 801a84a:	bd80      	pop	{r7, pc}

0801a84c <_ZN10USBPrinter13GetPortStatusEPh>:
 * @param[out] buf - The returned result of printer status
 *
 * @return 0 - Operation successful
 */
uint8_t USBPrinter::GetPortStatus(uint8_t *buf)
{
 801a84c:	b580      	push	{r7, lr}
 801a84e:	b08c      	sub	sp, #48	; 0x30
 801a850:	af08      	add	r7, sp, #32
 801a852:	6078      	str	r0, [r7, #4]
 801a854:	6039      	str	r1, [r7, #0]
				0,
				0x0000,
				1,
				1,
				buf,
				NULL);
 801a856:	687b      	ldr	r3, [r7, #4]
 801a858:	689a      	ldr	r2, [r3, #8]
 801a85a:	687b      	ldr	r3, [r7, #4]
 801a85c:	7edb      	ldrb	r3, [r3, #27]
 801a85e:	f04f 0101 	mov.w	r1, #1
 801a862:	9100      	str	r1, [sp, #0]
 801a864:	f04f 0100 	mov.w	r1, #0
 801a868:	9101      	str	r1, [sp, #4]
 801a86a:	f04f 0100 	mov.w	r1, #0
 801a86e:	9102      	str	r1, [sp, #8]
 801a870:	f04f 0100 	mov.w	r1, #0
 801a874:	9103      	str	r1, [sp, #12]
 801a876:	f04f 0101 	mov.w	r1, #1
 801a87a:	9104      	str	r1, [sp, #16]
 801a87c:	f04f 0101 	mov.w	r1, #1
 801a880:	9105      	str	r1, [sp, #20]
 801a882:	6839      	ldr	r1, [r7, #0]
 801a884:	9106      	str	r1, [sp, #24]
 801a886:	f04f 0100 	mov.w	r1, #0
 801a88a:	9107      	str	r1, [sp, #28]
 801a88c:	4610      	mov	r0, r2
 801a88e:	4619      	mov	r1, r3
 801a890:	f04f 0200 	mov.w	r2, #0
 801a894:	f04f 03a1 	mov.w	r3, #161	; 0xa1
 801a898:	f7f9 ff04 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 801a89c:	4603      	mov	r3, r0
 801a89e:	73fb      	strb	r3, [r7, #15]

	return ret;
 801a8a0:	7bfb      	ldrb	r3, [r7, #15]
}
 801a8a2:	4618      	mov	r0, r3
 801a8a4:	f107 0710 	add.w	r7, r7, #16
 801a8a8:	46bd      	mov	sp, r7
 801a8aa:	bd80      	pop	{r7, pc}

0801a8ac <_ZN10USBPrinter9SoftResetEv>:
 * configuration.
 *
 * @return 0 - Operation successful
 */
uint8_t USBPrinter::SoftReset(void)
{
 801a8ac:	b580      	push	{r7, lr}
 801a8ae:	b08c      	sub	sp, #48	; 0x30
 801a8b0:	af08      	add	r7, sp, #32
 801a8b2:	6078      	str	r0, [r7, #4]
			0,
			0x0000,
			0,
			0,
			NULL,
			NULL);
 801a8b4:	687b      	ldr	r3, [r7, #4]
 801a8b6:	689a      	ldr	r2, [r3, #8]
 801a8b8:	687b      	ldr	r3, [r7, #4]
 801a8ba:	7edb      	ldrb	r3, [r3, #27]
 801a8bc:	f04f 0102 	mov.w	r1, #2
 801a8c0:	9100      	str	r1, [sp, #0]
 801a8c2:	f04f 0100 	mov.w	r1, #0
 801a8c6:	9101      	str	r1, [sp, #4]
 801a8c8:	f04f 0100 	mov.w	r1, #0
 801a8cc:	9102      	str	r1, [sp, #8]
 801a8ce:	f04f 0100 	mov.w	r1, #0
 801a8d2:	9103      	str	r1, [sp, #12]
 801a8d4:	f04f 0100 	mov.w	r1, #0
 801a8d8:	9104      	str	r1, [sp, #16]
 801a8da:	f04f 0100 	mov.w	r1, #0
 801a8de:	9105      	str	r1, [sp, #20]
 801a8e0:	f04f 0100 	mov.w	r1, #0
 801a8e4:	9106      	str	r1, [sp, #24]
 801a8e6:	f04f 0100 	mov.w	r1, #0
 801a8ea:	9107      	str	r1, [sp, #28]
 801a8ec:	4610      	mov	r0, r2
 801a8ee:	4619      	mov	r1, r3
 801a8f0:	f04f 0200 	mov.w	r2, #0
 801a8f4:	f04f 0321 	mov.w	r3, #33	; 0x21
 801a8f8:	f7f9 fed4 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 801a8fc:	4603      	mov	r3, r0
 801a8fe:	73fb      	strb	r3, [r7, #15]

	return ret;
 801a900:	7bfb      	ldrb	r3, [r7, #15]
}
 801a902:	4618      	mov	r0, r3
 801a904:	f107 0710 	add.w	r7, r7, #16
 801a908:	46bd      	mov	sp, r7
 801a90a:	bd80      	pop	{r7, pc}

0801a90c <_ZN10USBPrinter4InitEhhb>:

uint8_t USBPrinter::Init(uint8_t parent, uint8_t port, bool lowspeed)
{
 801a90c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801a90e:	b0ed      	sub	sp, #436	; 0x1b4
 801a910:	af06      	add	r7, sp, #24
 801a912:	f107 0404 	add.w	r4, r7, #4
 801a916:	6020      	str	r0, [r4, #0]
 801a918:	4608      	mov	r0, r1
 801a91a:	4611      	mov	r1, r2
 801a91c:	461a      	mov	r2, r3
 801a91e:	f107 0303 	add.w	r3, r7, #3
 801a922:	7018      	strb	r0, [r3, #0]
 801a924:	f107 0302 	add.w	r3, r7, #2
 801a928:	7019      	strb	r1, [r3, #0]
 801a92a:	f107 0301 	add.w	r3, r7, #1
 801a92e:	701a      	strb	r2, [r3, #0]
	const uint8_t constBufSize = sizeof(USB_DEVICE_DESCRIPTOR);
 801a930:	f04f 0312 	mov.w	r3, #18
 801a934:	f887 3195 	strb.w	r3, [r7, #405]	; 0x195
	uint8_t buf[constBufSize];
	uint8_t buf_dev_id[USB_PRINTER_DEVICE_ID_MAX_SIZE] = { 0 };
 801a938:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801a93c:	461a      	mov	r2, r3
 801a93e:	f240 1331 	movw	r3, #305	; 0x131
 801a942:	4610      	mov	r0, r2
 801a944:	f04f 0100 	mov.w	r1, #0
 801a948:	461a      	mov	r2, r3
 801a94a:	f7f7 fb03 	bl	8011f54 <memset>
	uint8_t rcode;
	uint8_t ep_no;
	UsbDevice *p = NULL;
 801a94e:	f04f 0300 	mov.w	r3, #0
 801a952:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
	EpInfo *oldep_ptr = NULL;
 801a956:	f04f 0300 	mov.w	r3, #0
 801a95a:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
	uint8_t num_of_conf; 						// number of configurations

	USBTRACE("\r\nPrinter Init Start");
 801a95e:	f64e 6070 	movw	r0, #61040	; 0xee70
 801a962:	f6c0 0001 	movt	r0, #2049	; 0x801
 801a966:	f04f 0180 	mov.w	r1, #128	; 0x80
 801a96a:	f7fe fd23 	bl	80193b4 <_Z8E_NotifyPKci>

    AddressPool &addrPool =
    		pUsb->GetAddressPool();				// get memory address of USB device address pool
 801a96e:	f107 0304 	add.w	r3, r7, #4
 801a972:	681b      	ldr	r3, [r3, #0]
 801a974:	689b      	ldr	r3, [r3, #8]
 801a976:	4618      	mov	r0, r3
 801a978:	f7f9 fd4e 	bl	8014418 <_ZN3USB14GetAddressPoolEv>
 801a97c:	f8c7 0188 	str.w	r0, [r7, #392]	; 0x188

	if(bAddress)
 801a980:	f107 0304 	add.w	r3, r7, #4
 801a984:	681b      	ldr	r3, [r3, #0]
 801a986:	7edb      	ldrb	r3, [r3, #27]
 801a988:	2b00      	cmp	r3, #0
 801a98a:	d002      	beq.n	801a992 <_ZN10USBPrinter4InitEhhb+0x86>
		return USB_ERROR_CLASS_INSTANCE_ALREADY_IN_USE;
 801a98c:	f04f 03d9 	mov.w	r3, #217	; 0xd9
 801a990:	e2fb      	b.n	801af8a <_ZN10USBPrinter4InitEhhb+0x67e>

	p = addrPool.GetUsbDevicePtr(0);			// Get pointer to pseudo device with address 0 assigned
 801a992:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801a996:	681b      	ldr	r3, [r3, #0]
 801a998:	681b      	ldr	r3, [r3, #0]
 801a99a:	f8d7 0188 	ldr.w	r0, [r7, #392]	; 0x188
 801a99e:	f04f 0100 	mov.w	r1, #0
 801a9a2:	4798      	blx	r3
 801a9a4:	4603      	mov	r3, r0
 801a9a6:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190

    if (!p)
 801a9aa:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801a9ae:	2b00      	cmp	r3, #0
 801a9b0:	d102      	bne.n	801a9b8 <_ZN10USBPrinter4InitEhhb+0xac>
		return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
 801a9b2:	f04f 03d6 	mov.w	r3, #214	; 0xd6
 801a9b6:	e2e8      	b.n	801af8a <_ZN10USBPrinter4InitEhhb+0x67e>

	if(!p->epinfo) {
 801a9b8:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801a9bc:	681b      	ldr	r3, [r3, #0]
 801a9be:	2b00      	cmp	r3, #0
 801a9c0:	d10a      	bne.n	801a9d8 <_ZN10USBPrinter4InitEhhb+0xcc>
		USBTRACE("epinfo\r\n");
 801a9c2:	f64e 6088 	movw	r0, #61064	; 0xee88
 801a9c6:	f6c0 0001 	movt	r0, #2049	; 0x801
 801a9ca:	f04f 0180 	mov.w	r1, #128	; 0x80
 801a9ce:	f7fe fcf1 	bl	80193b4 <_Z8E_NotifyPKci>
		return USB_ERROR_EPINFO_IS_NULL;
 801a9d2:	f04f 03d7 	mov.w	r3, #215	; 0xd7
 801a9d6:	e2d8      	b.n	801af8a <_ZN10USBPrinter4InitEhhb+0x67e>
	}

	/* Get device descriptor */
	oldep_ptr = p->epinfo;						// Save old pointer to EP_RECORD of address 0
 801a9d8:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801a9dc:	681b      	ldr	r3, [r3, #0]
 801a9de:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
	p->epinfo = epInfo;							// Temporary assign new pointer to epInfo to p->epinfo in order to avoid toggle inconsistence
 801a9e2:	f107 0304 	add.w	r3, r7, #4
 801a9e6:	681b      	ldr	r3, [r3, #0]
 801a9e8:	f103 020c 	add.w	r2, r3, #12
 801a9ec:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801a9f0:	601a      	str	r2, [r3, #0]
	p->epinfo->hcNumber = oldep_ptr->hcNumber;	// still use mother's host channel
 801a9f2:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801a9f6:	681b      	ldr	r3, [r3, #0]
 801a9f8:	f8d7 218c 	ldr.w	r2, [r7, #396]	; 0x18c
 801a9fc:	78d2      	ldrb	r2, [r2, #3]
 801a9fe:	70da      	strb	r2, [r3, #3]
	p->lowspeed = lowspeed;
 801aa00:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801aa04:	f107 0201 	add.w	r2, r7, #1
 801aa08:	7812      	ldrb	r2, [r2, #0]
 801aa0a:	719a      	strb	r2, [r3, #6]
	rcode = pUsb->getDevDescr(0, 0, 8, (uint8_t*) buf);
 801aa0c:	f107 0304 	add.w	r3, r7, #4
 801aa10:	681b      	ldr	r3, [r3, #0]
 801aa12:	689b      	ldr	r3, [r3, #8]
 801aa14:	f507 72ba 	add.w	r2, r7, #372	; 0x174
 801aa18:	9200      	str	r2, [sp, #0]
 801aa1a:	4618      	mov	r0, r3
 801aa1c:	f04f 0100 	mov.w	r1, #0
 801aa20:	f04f 0200 	mov.w	r2, #0
 801aa24:	f04f 0308 	mov.w	r3, #8
 801aa28:	f7fb f860 	bl	8015aec <_ZN3USB11getDevDescrEhhtPh>
 801aa2c:	4603      	mov	r3, r0
 801aa2e:	f887 3197 	strb.w	r3, [r7, #407]	; 0x197
	if(!rcode) {
 801aa32:	f897 3197 	ldrb.w	r3, [r7, #407]	; 0x197
 801aa36:	2b00      	cmp	r3, #0
 801aa38:	d119      	bne.n	801aa6e <_ZN10USBPrinter4InitEhhb+0x162>
		p->epinfo->maxPktSize = (uint8_t)((USB_DEVICE_DESCRIPTOR*)buf)->bMaxPacketSize0;	// = epInfo[0].maxPktSize
 801aa3a:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801aa3e:	681b      	ldr	r3, [r3, #0]
 801aa40:	f507 72ba 	add.w	r2, r7, #372	; 0x174
 801aa44:	79d2      	ldrb	r2, [r2, #7]
 801aa46:	705a      	strb	r2, [r3, #1]
    	rcode = pUsb->getDevDescr(0, 0, sizeof (USB_DEVICE_DESCRIPTOR), (uint8_t*)buf); 	// Get device descriptor - addr, ep, nbytes, data
 801aa48:	f107 0304 	add.w	r3, r7, #4
 801aa4c:	681b      	ldr	r3, [r3, #0]
 801aa4e:	689b      	ldr	r3, [r3, #8]
 801aa50:	f507 72ba 	add.w	r2, r7, #372	; 0x174
 801aa54:	9200      	str	r2, [sp, #0]
 801aa56:	4618      	mov	r0, r3
 801aa58:	f04f 0100 	mov.w	r1, #0
 801aa5c:	f04f 0200 	mov.w	r2, #0
 801aa60:	f04f 0312 	mov.w	r3, #18
 801aa64:	f7fb f842 	bl	8015aec <_ZN3USB11getDevDescrEhhtPh>
 801aa68:	4603      	mov	r3, r0
 801aa6a:	f887 3197 	strb.w	r3, [r7, #407]	; 0x197
	}
    p->epinfo = oldep_ptr;    					// Restore p->epinfo
 801aa6e:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801aa72:	f8d7 218c 	ldr.w	r2, [r7, #396]	; 0x18c
 801aa76:	601a      	str	r2, [r3, #0]
    if(rcode)
 801aa78:	f897 3197 	ldrb.w	r3, [r7, #407]	; 0x197
 801aa7c:	2b00      	cmp	r3, #0
 801aa7e:	f040 825a 	bne.w	801af36 <_ZN10USBPrinter4InitEhhb+0x62a>
    	goto FailGetDevDescr;
	num_of_conf = (uint8_t)((USB_DEVICE_DESCRIPTOR*)buf)->bNumConfigurations;
 801aa82:	f507 73ba 	add.w	r3, r7, #372	; 0x174
 801aa86:	7c5b      	ldrb	r3, [r3, #17]
 801aa88:	f887 3187 	strb.w	r3, [r7, #391]	; 0x187
	USBTRACE2("NC:", num_of_conf);
 801aa8c:	f64e 6094 	movw	r0, #61076	; 0xee94
 801aa90:	f6c0 0001 	movt	r0, #2049	; 0x801
 801aa94:	f04f 0180 	mov.w	r1, #128	; 0x80
 801aa98:	f7fe fc8c 	bl	80193b4 <_Z8E_NotifyPKci>
 801aa9c:	f897 3187 	ldrb.w	r3, [r7, #391]	; 0x187
 801aaa0:	4618      	mov	r0, r3
 801aaa2:	f04f 0180 	mov.w	r1, #128	; 0x80
 801aaa6:	f7fb f9ef 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801aaaa:	f64e 6098 	movw	r0, #61080	; 0xee98
 801aaae:	f6c0 0001 	movt	r0, #2049	; 0x801
 801aab2:	f04f 0180 	mov.w	r1, #128	; 0x80
 801aab6:	f7fe fc7d 	bl	80193b4 <_Z8E_NotifyPKci>

    /* Allocate new address */
    bAddress = addrPool.AllocAddress(parent, false, port);
 801aaba:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801aabe:	681b      	ldr	r3, [r3, #0]
 801aac0:	f103 0304 	add.w	r3, r3, #4
 801aac4:	681c      	ldr	r4, [r3, #0]
 801aac6:	f107 0303 	add.w	r3, r7, #3
 801aaca:	781a      	ldrb	r2, [r3, #0]
 801aacc:	f107 0302 	add.w	r3, r7, #2
 801aad0:	781b      	ldrb	r3, [r3, #0]
 801aad2:	f8d7 0188 	ldr.w	r0, [r7, #392]	; 0x188
 801aad6:	4611      	mov	r1, r2
 801aad8:	f04f 0200 	mov.w	r2, #0
 801aadc:	47a0      	blx	r4
 801aade:	4603      	mov	r3, r0
 801aae0:	461a      	mov	r2, r3
 801aae2:	f107 0304 	add.w	r3, r7, #4
 801aae6:	681b      	ldr	r3, [r3, #0]
 801aae8:	76da      	strb	r2, [r3, #27]
    if (!bAddress)
 801aaea:	f107 0304 	add.w	r3, r7, #4
 801aaee:	681b      	ldr	r3, [r3, #0]
 801aaf0:	7edb      	ldrb	r3, [r3, #27]
 801aaf2:	2b00      	cmp	r3, #0
 801aaf4:	d102      	bne.n	801aafc <_ZN10USBPrinter4InitEhhb+0x1f0>
		return USB_ERROR_OUT_OF_ADDRESS_SPACE_IN_POOL;
 801aaf6:	f04f 03d4 	mov.w	r3, #212	; 0xd4
 801aafa:	e246      	b.n	801af8a <_ZN10USBPrinter4InitEhhb+0x67e>

    /* Assign new address */
    rcode = pUsb->setAddr(0, 0, bAddress);
 801aafc:	f107 0304 	add.w	r3, r7, #4
 801ab00:	681b      	ldr	r3, [r3, #0]
 801ab02:	689a      	ldr	r2, [r3, #8]
 801ab04:	f107 0304 	add.w	r3, r7, #4
 801ab08:	681b      	ldr	r3, [r3, #0]
 801ab0a:	7edb      	ldrb	r3, [r3, #27]
 801ab0c:	4610      	mov	r0, r2
 801ab0e:	f04f 0100 	mov.w	r1, #0
 801ab12:	f04f 0200 	mov.w	r2, #0
 801ab16:	f7fb f8d9 	bl	8015ccc <_ZN3USB7setAddrEhhh>
 801ab1a:	4603      	mov	r3, r0
 801ab1c:	f887 3197 	strb.w	r3, [r7, #407]	; 0x197
    if (rcode) {
 801ab20:	f897 3197 	ldrb.w	r3, [r7, #407]	; 0x197
 801ab24:	2b00      	cmp	r3, #0
 801ab26:	d032      	beq.n	801ab8e <_ZN10USBPrinter4InitEhhb+0x282>
		p->lowspeed = false;
 801ab28:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801ab2c:	f04f 0200 	mov.w	r2, #0
 801ab30:	719a      	strb	r2, [r3, #6]
		addrPool.FreeAddress(bAddress);
 801ab32:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801ab36:	681b      	ldr	r3, [r3, #0]
 801ab38:	f103 0308 	add.w	r3, r3, #8
 801ab3c:	681b      	ldr	r3, [r3, #0]
 801ab3e:	f107 0204 	add.w	r2, r7, #4
 801ab42:	6812      	ldr	r2, [r2, #0]
 801ab44:	7ed2      	ldrb	r2, [r2, #27]
 801ab46:	f8d7 0188 	ldr.w	r0, [r7, #392]	; 0x188
 801ab4a:	4611      	mov	r1, r2
 801ab4c:	4798      	blx	r3
		bAddress = 0;
 801ab4e:	f107 0304 	add.w	r3, r7, #4
 801ab52:	681b      	ldr	r3, [r3, #0]
 801ab54:	f04f 0200 	mov.w	r2, #0
 801ab58:	76da      	strb	r2, [r3, #27]
		USBTRACE2("setAddr:", rcode);
 801ab5a:	f64e 609c 	movw	r0, #61084	; 0xee9c
 801ab5e:	f6c0 0001 	movt	r0, #2049	; 0x801
 801ab62:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ab66:	f7fe fc25 	bl	80193b4 <_Z8E_NotifyPKci>
 801ab6a:	f897 3197 	ldrb.w	r3, [r7, #407]	; 0x197
 801ab6e:	4618      	mov	r0, r3
 801ab70:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ab74:	f7fb f988 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801ab78:	f64e 6098 	movw	r0, #61080	; 0xee98
 801ab7c:	f6c0 0001 	movt	r0, #2049	; 0x801
 801ab80:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ab84:	f7fe fc16 	bl	80193b4 <_Z8E_NotifyPKci>
		return rcode;
 801ab88:	f897 3197 	ldrb.w	r3, [r7, #407]	; 0x197
 801ab8c:	e1fd      	b.n	801af8a <_ZN10USBPrinter4InitEhhb+0x67e>
    }
	USBTRACE2("Printer Addr:", bAddress);
 801ab8e:	f64e 60a8 	movw	r0, #61096	; 0xeea8
 801ab92:	f6c0 0001 	movt	r0, #2049	; 0x801
 801ab96:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ab9a:	f7fe fc0b 	bl	80193b4 <_Z8E_NotifyPKci>
 801ab9e:	f107 0304 	add.w	r3, r7, #4
 801aba2:	681b      	ldr	r3, [r3, #0]
 801aba4:	7edb      	ldrb	r3, [r3, #27]
 801aba6:	4618      	mov	r0, r3
 801aba8:	f04f 0180 	mov.w	r1, #128	; 0x80
 801abac:	f7fb f96c 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801abb0:	f64e 6098 	movw	r0, #61080	; 0xee98
 801abb4:	f6c0 0001 	movt	r0, #2049	; 0x801
 801abb8:	f04f 0180 	mov.w	r1, #128	; 0x80
 801abbc:	f7fe fbfa 	bl	80193b4 <_Z8E_NotifyPKci>
	p->lowspeed = false;
 801abc0:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801abc4:	f04f 0200 	mov.w	r2, #0
 801abc8:	719a      	strb	r2, [r3, #6]

	p = addrPool.GetUsbDevicePtr(bAddress);
 801abca:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801abce:	681b      	ldr	r3, [r3, #0]
 801abd0:	681b      	ldr	r3, [r3, #0]
 801abd2:	f107 0204 	add.w	r2, r7, #4
 801abd6:	6812      	ldr	r2, [r2, #0]
 801abd8:	7ed2      	ldrb	r2, [r2, #27]
 801abda:	f8d7 0188 	ldr.w	r0, [r7, #392]	; 0x188
 801abde:	4611      	mov	r1, r2
 801abe0:	4798      	blx	r3
 801abe2:	4603      	mov	r3, r0
 801abe4:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
	if(!p)
 801abe8:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801abec:	2b00      	cmp	r3, #0
 801abee:	d102      	bne.n	801abf6 <_ZN10USBPrinter4InitEhhb+0x2ea>
		return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
 801abf0:	f04f 03d6 	mov.w	r3, #214	; 0xd6
 801abf4:	e1c9      	b.n	801af8a <_ZN10USBPrinter4InitEhhb+0x67e>
	p->lowspeed = lowspeed;
 801abf6:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801abfa:	f107 0201 	add.w	r2, r7, #1
 801abfe:	7812      	ldrb	r2, [r2, #0]
 801ac00:	719a      	strb	r2, [r3, #6]
	rcode = pUsb->setEpInfoEntry(bAddress, 1, epInfo);	// Assign epInfo to epinfo pointer
 801ac02:	f107 0304 	add.w	r3, r7, #4
 801ac06:	681b      	ldr	r3, [r3, #0]
 801ac08:	6899      	ldr	r1, [r3, #8]
 801ac0a:	f107 0304 	add.w	r3, r7, #4
 801ac0e:	681b      	ldr	r3, [r3, #0]
 801ac10:	7eda      	ldrb	r2, [r3, #27]
 801ac12:	f107 0304 	add.w	r3, r7, #4
 801ac16:	681b      	ldr	r3, [r3, #0]
 801ac18:	f103 030c 	add.w	r3, r3, #12
 801ac1c:	4608      	mov	r0, r1
 801ac1e:	4611      	mov	r1, r2
 801ac20:	f04f 0201 	mov.w	r2, #1
 801ac24:	f7f9 fcb6 	bl	8014594 <_ZN3USB14setEpInfoEntryEhhP6EpInfo>
 801ac28:	4603      	mov	r3, r0
 801ac2a:	f887 3197 	strb.w	r3, [r7, #407]	; 0x197
	if(rcode)
 801ac2e:	f897 3197 	ldrb.w	r3, [r7, #407]	; 0x197
 801ac32:	2b00      	cmp	r3, #0
 801ac34:	f040 8183 	bne.w	801af3e <_ZN10USBPrinter4InitEhhb+0x632>
		goto FailSetDevTblEntry;

	/* Get device configurations */
	for(uint8_t i = 0; i < num_of_conf; i++) {
 801ac38:	f04f 0300 	mov.w	r3, #0
 801ac3c:	f887 3196 	strb.w	r3, [r7, #406]	; 0x196
 801ac40:	e031      	b.n	801aca6 <_ZN10USBPrinter4InitEhhb+0x39a>
		ConfigDescParser<
				USB_CLASS_PRINTER,
				USB_PRINTER_INTF_SUBCLASS,
				USB_PRINTER_INTF_PROTOCOL_BIDIR,
				CP_MASK_COMPARE_ALL> UsbPrinterParser(this);
 801ac42:	f107 0304 	add.w	r3, r7, #4
 801ac46:	681b      	ldr	r3, [r3, #0]
 801ac48:	f103 0304 	add.w	r3, r3, #4
 801ac4c:	f107 0208 	add.w	r2, r7, #8
 801ac50:	4610      	mov	r0, r2
 801ac52:	4619      	mov	r1, r3
 801ac54:	f000 fa72 	bl	801b13c <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EEC1EP17UsbConfigXtracter>

		rcode = pUsb->getConfDescr(bAddress, 0, i, &UsbPrinterParser);
 801ac58:	f107 0304 	add.w	r3, r7, #4
 801ac5c:	681b      	ldr	r3, [r3, #0]
 801ac5e:	6899      	ldr	r1, [r3, #8]
 801ac60:	f107 0304 	add.w	r3, r7, #4
 801ac64:	681b      	ldr	r3, [r3, #0]
 801ac66:	7eda      	ldrb	r2, [r3, #27]
 801ac68:	f897 3196 	ldrb.w	r3, [r7, #406]	; 0x196
 801ac6c:	f107 0008 	add.w	r0, r7, #8
 801ac70:	9000      	str	r0, [sp, #0]
 801ac72:	4608      	mov	r0, r1
 801ac74:	4611      	mov	r1, r2
 801ac76:	f04f 0200 	mov.w	r2, #0
 801ac7a:	f7fa ff8d 	bl	8015b98 <_ZN3USB12getConfDescrEhhhP13USBReadParser>
 801ac7e:	4603      	mov	r3, r0
 801ac80:	f887 3197 	strb.w	r3, [r7, #407]	; 0x197
		if (rcode)
 801ac84:	f897 3197 	ldrb.w	r3, [r7, #407]	; 0x197
 801ac88:	2b00      	cmp	r3, #0
 801ac8a:	f040 815c 	bne.w	801af46 <_ZN10USBPrinter4InitEhhb+0x63a>
			goto FailGetConfDescr;
		if(bNumEP > 1)
 801ac8e:	f107 0304 	add.w	r3, r7, #4
 801ac92:	681b      	ldr	r3, [r3, #0]
 801ac94:	7f5b      	ldrb	r3, [r3, #29]
 801ac96:	2b01      	cmp	r3, #1
 801ac98:	d810      	bhi.n	801acbc <_ZN10USBPrinter4InitEhhb+0x3b0>
	rcode = pUsb->setEpInfoEntry(bAddress, 1, epInfo);	// Assign epInfo to epinfo pointer
	if(rcode)
		goto FailSetDevTblEntry;

	/* Get device configurations */
	for(uint8_t i = 0; i < num_of_conf; i++) {
 801ac9a:	f897 3196 	ldrb.w	r3, [r7, #406]	; 0x196
 801ac9e:	f103 0301 	add.w	r3, r3, #1
 801aca2:	f887 3196 	strb.w	r3, [r7, #406]	; 0x196
 801aca6:	f897 2196 	ldrb.w	r2, [r7, #406]	; 0x196
 801acaa:	f897 3187 	ldrb.w	r3, [r7, #391]	; 0x187
 801acae:	429a      	cmp	r2, r3
 801acb0:	bf2c      	ite	cs
 801acb2:	2300      	movcs	r3, #0
 801acb4:	2301      	movcc	r3, #1
 801acb6:	b2db      	uxtb	r3, r3
 801acb8:	2b00      	cmp	r3, #0
 801acba:	d1c2      	bne.n	801ac42 <_ZN10USBPrinter4InitEhhb+0x336>
		if (rcode)
			goto FailGetConfDescr;
		if(bNumEP > 1)
			break;
	}
	if(bNumEP < 3) {
 801acbc:	f107 0304 	add.w	r3, r7, #4
 801acc0:	681b      	ldr	r3, [r3, #0]
 801acc2:	7f5b      	ldrb	r3, [r3, #29]
 801acc4:	2b02      	cmp	r3, #2
 801acc6:	d81d      	bhi.n	801ad04 <_ZN10USBPrinter4InitEhhb+0x3f8>
    	USBTRACE2("Printer not supported, bNumEP:", bNumEP);
 801acc8:	f64e 60b8 	movw	r0, #61112	; 0xeeb8
 801accc:	f6c0 0001 	movt	r0, #2049	; 0x801
 801acd0:	f04f 0180 	mov.w	r1, #128	; 0x80
 801acd4:	f7fe fb6e 	bl	80193b4 <_Z8E_NotifyPKci>
 801acd8:	f107 0304 	add.w	r3, r7, #4
 801acdc:	681b      	ldr	r3, [r3, #0]
 801acde:	7f5b      	ldrb	r3, [r3, #29]
 801ace0:	4618      	mov	r0, r3
 801ace2:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ace6:	f7fb f8cf 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801acea:	f64e 6098 	movw	r0, #61080	; 0xee98
 801acee:	f6c0 0001 	movt	r0, #2049	; 0x801
 801acf2:	f04f 0180 	mov.w	r1, #128	; 0x80
 801acf6:	f7fe fb5d 	bl	80193b4 <_Z8E_NotifyPKci>
		rcode = USB_DEV_CONFIG_ERROR_DEVICE_NOT_SUPPORTED;
 801acfa:	f04f 03d1 	mov.w	r3, #209	; 0xd1
 801acfe:	f887 3197 	strb.w	r3, [r7, #407]	; 0x197
		goto Fail;
 801ad02:	e130      	b.n	801af66 <_ZN10USBPrinter4InitEhhb+0x65a>
	}
    pUsb->setEpInfoEntry(bAddress, bNumEP, epInfo);	    // Assign epInfo to epinfo pointer
 801ad04:	f107 0304 	add.w	r3, r7, #4
 801ad08:	681b      	ldr	r3, [r3, #0]
 801ad0a:	6898      	ldr	r0, [r3, #8]
 801ad0c:	f107 0304 	add.w	r3, r7, #4
 801ad10:	681b      	ldr	r3, [r3, #0]
 801ad12:	7ed9      	ldrb	r1, [r3, #27]
 801ad14:	f107 0304 	add.w	r3, r7, #4
 801ad18:	681b      	ldr	r3, [r3, #0]
 801ad1a:	7f5a      	ldrb	r2, [r3, #29]
 801ad1c:	f107 0304 	add.w	r3, r7, #4
 801ad20:	681b      	ldr	r3, [r3, #0]
 801ad22:	f103 030c 	add.w	r3, r3, #12
 801ad26:	f7f9 fc35 	bl	8014594 <_ZN3USB14setEpInfoEntryEhhP6EpInfo>

    /* Set configuration value */
    rcode = pUsb->setConf(bAddress, 0, bConfNum);
 801ad2a:	f107 0304 	add.w	r3, r7, #4
 801ad2e:	681b      	ldr	r3, [r3, #0]
 801ad30:	6899      	ldr	r1, [r3, #8]
 801ad32:	f107 0304 	add.w	r3, r7, #4
 801ad36:	681b      	ldr	r3, [r3, #0]
 801ad38:	7eda      	ldrb	r2, [r3, #27]
 801ad3a:	f107 0304 	add.w	r3, r7, #4
 801ad3e:	681b      	ldr	r3, [r3, #0]
 801ad40:	7f1b      	ldrb	r3, [r3, #28]
 801ad42:	4608      	mov	r0, r1
 801ad44:	4611      	mov	r1, r2
 801ad46:	f04f 0200 	mov.w	r2, #0
 801ad4a:	f7fa ffed 	bl	8015d28 <_ZN3USB7setConfEhhh>
 801ad4e:	4603      	mov	r3, r0
 801ad50:	f887 3197 	strb.w	r3, [r7, #407]	; 0x197
    if (rcode)
 801ad54:	f897 3197 	ldrb.w	r3, [r7, #407]	; 0x197
 801ad58:	2b00      	cmp	r3, #0
 801ad5a:	f040 80f7 	bne.w	801af4c <_ZN10USBPrinter4InitEhhb+0x640>
		goto FailSetConfDescr;

    USBTRACE("USB Printer configured\r\n");
 801ad5e:	f64e 60d8 	movw	r0, #61144	; 0xeed8
 801ad62:	f6c0 0001 	movt	r0, #2049	; 0x801
 801ad66:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ad6a:	f7fe fb23 	bl	80193b4 <_Z8E_NotifyPKci>

	ep_no = usbhost_cb->device_added_cb(bAddress, lowspeed, epInfo[1].bmNakPower,
			epInfo[1].epAddr, epInfo[1].maxPktSize, eEpTypeBulk,
			epInfo[2].epAddr, epInfo[2].maxPktSize, eEpTypeBulk);
 801ad6e:	f243 6310 	movw	r3, #13840	; 0x3610
 801ad72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ad76:	681b      	ldr	r3, [r3, #0]
 801ad78:	695c      	ldr	r4, [r3, #20]
 801ad7a:	f107 0304 	add.w	r3, r7, #4
 801ad7e:	681b      	ldr	r3, [r3, #0]
 801ad80:	7ed8      	ldrb	r0, [r3, #27]
 801ad82:	f107 0301 	add.w	r3, r7, #1
 801ad86:	7819      	ldrb	r1, [r3, #0]
 801ad88:	f107 0304 	add.w	r3, r7, #4
 801ad8c:	681b      	ldr	r3, [r3, #0]
 801ad8e:	7d5b      	ldrb	r3, [r3, #21]
 801ad90:	f3c3 0385 	ubfx	r3, r3, #2, #6
 801ad94:	b2db      	uxtb	r3, r3
 801ad96:	461a      	mov	r2, r3
 801ad98:	f107 0304 	add.w	r3, r7, #4
 801ad9c:	681b      	ldr	r3, [r3, #0]
 801ad9e:	7c5b      	ldrb	r3, [r3, #17]
 801ada0:	f107 0504 	add.w	r5, r7, #4
 801ada4:	682d      	ldr	r5, [r5, #0]
 801ada6:	f895 e012 	ldrb.w	lr, [r5, #18]
 801adaa:	f107 0504 	add.w	r5, r7, #4
 801adae:	682d      	ldr	r5, [r5, #0]
 801adb0:	7dae      	ldrb	r6, [r5, #22]
 801adb2:	f107 0504 	add.w	r5, r7, #4
 801adb6:	682d      	ldr	r5, [r5, #0]
 801adb8:	7ded      	ldrb	r5, [r5, #23]
 801adba:	f8cd e000 	str.w	lr, [sp]
 801adbe:	f04f 0e02 	mov.w	lr, #2
 801adc2:	f8cd e004 	str.w	lr, [sp, #4]
 801adc6:	9602      	str	r6, [sp, #8]
 801adc8:	9503      	str	r5, [sp, #12]
 801adca:	f04f 0502 	mov.w	r5, #2
 801adce:	9504      	str	r5, [sp, #16]
 801add0:	47a0      	blx	r4
 801add2:	4603      	mov	r3, r0
 801add4:	f887 3186 	strb.w	r3, [r7, #390]	; 0x186

    epInfo[1].hcNumOut = (ep_no >> 4) & 0xF;	//USBH_Alloc_Channel(pUsb->coreConfig, epInfo[1].epAddr);	//Out, addr = 0x01
 801add8:	f897 3186 	ldrb.w	r3, [r7, #390]	; 0x186
 801addc:	ea4f 1313 	mov.w	r3, r3, lsr #4
 801ade0:	b2db      	uxtb	r3, r3
 801ade2:	f003 030f 	and.w	r3, r3, #15
 801ade6:	b2d9      	uxtb	r1, r3
 801ade8:	f107 0304 	add.w	r3, r7, #4
 801adec:	681a      	ldr	r2, [r3, #0]
 801adee:	7d13      	ldrb	r3, [r2, #20]
 801adf0:	f361 1307 	bfi	r3, r1, #4, #4
 801adf4:	7513      	strb	r3, [r2, #20]
    epInfo[2].hcNumIn = ep_no & 0xF;	// USBH_Alloc_Channel(pUsb->coreConfig, epInfo[2].epAddr);		//In, addr = 0x82
 801adf6:	f897 3186 	ldrb.w	r3, [r7, #390]	; 0x186
 801adfa:	f003 030f 	and.w	r3, r3, #15
 801adfe:	b2d9      	uxtb	r1, r3
 801ae00:	f107 0304 	add.w	r3, r7, #4
 801ae04:	681a      	ldr	r2, [r3, #0]
 801ae06:	7e53      	ldrb	r3, [r2, #25]
 801ae08:	f361 0303 	bfi	r3, r1, #0, #4
 801ae0c:	7653      	strb	r3, [r2, #25]
    //USBH_Open_Channel(pUsb->coreConfig, epInfo[1].hcNumOut, bAddress,
    //		(lowspeed)?bmLOWSPEED:bmFULLSPEED, EP_TYPE_BULK, epInfo[1].maxPktSize);
    //USBH_Open_Channel(pUsb->coreConfig, epInfo[2].hcNumIn, bAddress,
    //		(lowspeed)?bmLOWSPEED:bmFULLSPEED, EP_TYPE_BULK, epInfo[2].maxPktSize);
    USBTRACE2("\nPrinter Pipe EP1 out = %x, ", epInfo[1].hcNumOut);
 801ae0e:	f64e 60f4 	movw	r0, #61172	; 0xeef4
 801ae12:	f6c0 0001 	movt	r0, #2049	; 0x801
 801ae16:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ae1a:	f7fe facb 	bl	80193b4 <_Z8E_NotifyPKci>
 801ae1e:	f107 0304 	add.w	r3, r7, #4
 801ae22:	681b      	ldr	r3, [r3, #0]
 801ae24:	7d1b      	ldrb	r3, [r3, #20]
 801ae26:	f3c3 1303 	ubfx	r3, r3, #4, #4
 801ae2a:	b2db      	uxtb	r3, r3
 801ae2c:	4618      	mov	r0, r3
 801ae2e:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ae32:	f7fb f829 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801ae36:	f64e 6098 	movw	r0, #61080	; 0xee98
 801ae3a:	f6c0 0001 	movt	r0, #2049	; 0x801
 801ae3e:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ae42:	f7fe fab7 	bl	80193b4 <_Z8E_NotifyPKci>
    USBTRACE2("addr = 0x%x(0x01)", epInfo[1].epAddr);
 801ae46:	f64e 7014 	movw	r0, #61204	; 0xef14
 801ae4a:	f6c0 0001 	movt	r0, #2049	; 0x801
 801ae4e:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ae52:	f7fe faaf 	bl	80193b4 <_Z8E_NotifyPKci>
 801ae56:	f107 0304 	add.w	r3, r7, #4
 801ae5a:	681b      	ldr	r3, [r3, #0]
 801ae5c:	7c5b      	ldrb	r3, [r3, #17]
 801ae5e:	4618      	mov	r0, r3
 801ae60:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ae64:	f7fb f810 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801ae68:	f64e 6098 	movw	r0, #61080	; 0xee98
 801ae6c:	f6c0 0001 	movt	r0, #2049	; 0x801
 801ae70:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ae74:	f7fe fa9e 	bl	80193b4 <_Z8E_NotifyPKci>
    USBTRACE2("\nPrinter Pipe EP2 int = %x, ", epInfo[2].hcNumIn);
 801ae78:	f64e 7028 	movw	r0, #61224	; 0xef28
 801ae7c:	f6c0 0001 	movt	r0, #2049	; 0x801
 801ae80:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ae84:	f7fe fa96 	bl	80193b4 <_Z8E_NotifyPKci>
 801ae88:	f107 0304 	add.w	r3, r7, #4
 801ae8c:	681b      	ldr	r3, [r3, #0]
 801ae8e:	7e5b      	ldrb	r3, [r3, #25]
 801ae90:	f3c3 0303 	ubfx	r3, r3, #0, #4
 801ae94:	b2db      	uxtb	r3, r3
 801ae96:	4618      	mov	r0, r3
 801ae98:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ae9c:	f7fa fff4 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801aea0:	f64e 6098 	movw	r0, #61080	; 0xee98
 801aea4:	f6c0 0001 	movt	r0, #2049	; 0x801
 801aea8:	f04f 0180 	mov.w	r1, #128	; 0x80
 801aeac:	f7fe fa82 	bl	80193b4 <_Z8E_NotifyPKci>
    USBTRACE2("addr = 0x%x(0x82)", epInfo[2].epAddr);
 801aeb0:	f64e 7048 	movw	r0, #61256	; 0xef48
 801aeb4:	f6c0 0001 	movt	r0, #2049	; 0x801
 801aeb8:	f04f 0180 	mov.w	r1, #128	; 0x80
 801aebc:	f7fe fa7a 	bl	80193b4 <_Z8E_NotifyPKci>
 801aec0:	f107 0304 	add.w	r3, r7, #4
 801aec4:	681b      	ldr	r3, [r3, #0]
 801aec6:	7d9b      	ldrb	r3, [r3, #22]
 801aec8:	4618      	mov	r0, r3
 801aeca:	f04f 0180 	mov.w	r1, #128	; 0x80
 801aece:	f7fa ffdb 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801aed2:	f64e 6098 	movw	r0, #61080	; 0xee98
 801aed6:	f6c0 0001 	movt	r0, #2049	; 0x801
 801aeda:	f04f 0180 	mov.w	r1, #128	; 0x80
 801aede:	f7fe fa69 	bl	80193b4 <_Z8E_NotifyPKci>

    /* Get device ID */
    rcode = GetDeviceID((uint8_t*)buf_dev_id);
 801aee2:	f107 0204 	add.w	r2, r7, #4
 801aee6:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801aeea:	6810      	ldr	r0, [r2, #0]
 801aeec:	4619      	mov	r1, r3
 801aeee:	f7ff fc7d 	bl	801a7ec <_ZN10USBPrinter11GetDeviceIDEPh>
 801aef2:	4603      	mov	r3, r0
 801aef4:	f887 3197 	strb.w	r3, [r7, #407]	; 0x197
    if(rcode)
 801aef8:	f897 3197 	ldrb.w	r3, [r7, #407]	; 0x197
 801aefc:	2b00      	cmp	r3, #0
 801aefe:	d129      	bne.n	801af54 <_ZN10USBPrinter4InitEhhb+0x648>
    	goto FailGetDevId;

	USBTRACE("\nDev id : ");
 801af00:	f64e 705c 	movw	r0, #61276	; 0xef5c
 801af04:	f6c0 0001 	movt	r0, #2049	; 0x801
 801af08:	f04f 0180 	mov.w	r1, #128	; 0x80
 801af0c:	f7fe fa52 	bl	80193b4 <_Z8E_NotifyPKci>
	D_PrintHex<uint32_t>((uint32_t)&buf_dev_id[2], 0x80);
 801af10:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801af14:	f103 0302 	add.w	r3, r3, #2
 801af18:	4618      	mov	r0, r3
 801af1a:	f04f 0180 	mov.w	r1, #128	; 0x80
 801af1e:	f7fd ff35 	bl	8018d8c <_Z10D_PrintHexImEvT_i>

    /* todo : Setup high level printer driver */


    bPollEnable = true;
 801af22:	f107 0304 	add.w	r3, r7, #4
 801af26:	681b      	ldr	r3, [r3, #0]
 801af28:	f04f 0201 	mov.w	r2, #1
 801af2c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
    return 0;
 801af30:	f04f 0300 	mov.w	r3, #0
 801af34:	e029      	b.n	801af8a <_ZN10USBPrinter4InitEhhb+0x67e>
		p->epinfo->maxPktSize = (uint8_t)((USB_DEVICE_DESCRIPTOR*)buf)->bMaxPacketSize0;	// = epInfo[0].maxPktSize
    	rcode = pUsb->getDevDescr(0, 0, sizeof (USB_DEVICE_DESCRIPTOR), (uint8_t*)buf); 	// Get device descriptor - addr, ep, nbytes, data
	}
    p->epinfo = oldep_ptr;    					// Restore p->epinfo
    if(rcode)
    	goto FailGetDevDescr;
 801af36:	bf00      	nop
    return 0;

    /* diagnostic messages */
FailGetDevDescr:
#ifdef DEBUG_USB_HOST
	NotifyFailGetDevDescr();
 801af38:	f7fe fb0a 	bl	8019550 <_Z21NotifyFailGetDevDescrv>
	goto Fail;
 801af3c:	e013      	b.n	801af66 <_ZN10USBPrinter4InitEhhb+0x65a>
	if(!p)
		return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
	p->lowspeed = lowspeed;
	rcode = pUsb->setEpInfoEntry(bAddress, 1, epInfo);	// Assign epInfo to epinfo pointer
	if(rcode)
		goto FailSetDevTblEntry;
 801af3e:	bf00      	nop
	goto Fail;
#endif

FailSetDevTblEntry:
#ifdef DEBUG_USB_HOST
	NotifyFailSetDevTblEntry();
 801af40:	f7fe fb12 	bl	8019568 <_Z24NotifyFailSetDevTblEntryv>
	goto Fail;
 801af44:	e00f      	b.n	801af66 <_ZN10USBPrinter4InitEhhb+0x65a>
#endif

FailGetConfDescr:
#ifdef DEBUG_USB_HOST
	NotifyFailGetConfDescr();
 801af46:	f7fe fb1b 	bl	8019580 <_Z22NotifyFailGetConfDescrv>
	goto Fail;
 801af4a:	e00c      	b.n	801af66 <_ZN10USBPrinter4InitEhhb+0x65a>
    pUsb->setEpInfoEntry(bAddress, bNumEP, epInfo);	    // Assign epInfo to epinfo pointer

    /* Set configuration value */
    rcode = pUsb->setConf(bAddress, 0, bConfNum);
    if (rcode)
		goto FailSetConfDescr;
 801af4c:	bf00      	nop
	goto Fail;
#endif

FailSetConfDescr:
#ifdef DEBUG_USB_HOST
	NotifyFailSetConfDescr();
 801af4e:	f7fe fb23 	bl	8019598 <_Z22NotifyFailSetConfDescrv>
	goto Fail;
 801af52:	e008      	b.n	801af66 <_ZN10USBPrinter4InitEhhb+0x65a>
    USBTRACE2("addr = 0x%x(0x82)", epInfo[2].epAddr);

    /* Get device ID */
    rcode = GetDeviceID((uint8_t*)buf_dev_id);
    if(rcode)
    	goto FailGetDevId;
 801af54:	bf00      	nop
	goto Fail;
#endif

FailGetDevId:
#ifdef DEBUG_USB_HOST
	USBTRACE("GetDevId:");
 801af56:	f64e 7068 	movw	r0, #61288	; 0xef68
 801af5a:	f6c0 0001 	movt	r0, #2049	; 0x801
 801af5e:	f04f 0180 	mov.w	r1, #128	; 0x80
 801af62:	f7fe fa27 	bl	80193b4 <_Z8E_NotifyPKci>
#endif

Fail:
#ifdef DEBUG_USB_HOST
	NotifyFail(rcode);
 801af66:	f897 3197 	ldrb.w	r3, [r7, #407]	; 0x197
 801af6a:	4618      	mov	r0, r3
 801af6c:	f7fe fb88 	bl	8019680 <_Z10NotifyFailh>
#endif
	Release();
 801af70:	f107 0304 	add.w	r3, r7, #4
 801af74:	681b      	ldr	r3, [r3, #0]
 801af76:	681b      	ldr	r3, [r3, #0]
 801af78:	f103 0308 	add.w	r3, r3, #8
 801af7c:	681b      	ldr	r3, [r3, #0]
 801af7e:	f107 0204 	add.w	r2, r7, #4
 801af82:	6810      	ldr	r0, [r2, #0]
 801af84:	4798      	blx	r3
    return rcode;
 801af86:	f897 3197 	ldrb.w	r3, [r7, #407]	; 0x197
 801af8a:	e002      	b.n	801af92 <_ZN10USBPrinter4InitEhhb+0x686>
 801af8c:	e7ff      	b.n	801af8e <_ZN10USBPrinter4InitEhhb+0x682>
 801af8e:	f001 fd77 	bl	801ca80 <__cxa_end_cleanup>
}
 801af92:	4618      	mov	r0, r3
 801af94:	f507 77ce 	add.w	r7, r7, #412	; 0x19c
 801af98:	46bd      	mov	sp, r7
 801af9a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801af9c <_ZN10USBPrinter7ReleaseEv>:

uint8_t USBPrinter::Release()
{
 801af9c:	b580      	push	{r7, lr}
 801af9e:	b082      	sub	sp, #8
 801afa0:	af00      	add	r7, sp, #0
 801afa2:	6078      	str	r0, [r7, #4]
	if(epInfo[1].hcNumber != 0)
 801afa4:	687b      	ldr	r3, [r7, #4]
 801afa6:	7d1b      	ldrb	r3, [r3, #20]
 801afa8:	2b00      	cmp	r3, #0
 801afaa:	d00c      	beq.n	801afc6 <_ZN10USBPrinter7ReleaseEv+0x2a>
	{	// HC0&HC1 are taken by control pipe.
		//USB_OTG_HC_Halt(pUsb->coreConfig, epInfo[1].hcNumOut);
		//USBH_Free_Channel(pUsb->coreConfig, epInfo[1].hcNumOut);
		usbhost_cb->device_removed_cb(epInfo[1].hcNumOut);
 801afac:	f243 6310 	movw	r3, #13840	; 0x3610
 801afb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801afb4:	681b      	ldr	r3, [r3, #0]
 801afb6:	699b      	ldr	r3, [r3, #24]
 801afb8:	687a      	ldr	r2, [r7, #4]
 801afba:	7d12      	ldrb	r2, [r2, #20]
 801afbc:	f3c2 1203 	ubfx	r2, r2, #4, #4
 801afc0:	b2d2      	uxtb	r2, r2
 801afc2:	4610      	mov	r0, r2
 801afc4:	4798      	blx	r3
	}

	if(epInfo[2].hcNumber != 0)
 801afc6:	687b      	ldr	r3, [r7, #4]
 801afc8:	7e5b      	ldrb	r3, [r3, #25]
 801afca:	2b00      	cmp	r3, #0
 801afcc:	d00c      	beq.n	801afe8 <_ZN10USBPrinter7ReleaseEv+0x4c>
	{
		//USB_OTG_HC_Halt(pUsb->coreConfig, epInfo[2].hcNumIn);
		//USBH_Free_Channel(pUsb->coreConfig, epInfo[2].hcNumIn);
		usbhost_cb->device_removed_cb(epInfo[2].hcNumIn);
 801afce:	f243 6310 	movw	r3, #13840	; 0x3610
 801afd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801afd6:	681b      	ldr	r3, [r3, #0]
 801afd8:	699b      	ldr	r3, [r3, #24]
 801afda:	687a      	ldr	r2, [r7, #4]
 801afdc:	7e52      	ldrb	r2, [r2, #25]
 801afde:	f3c2 0203 	ubfx	r2, r2, #0, #4
 801afe2:	b2d2      	uxtb	r2, r2
 801afe4:	4610      	mov	r0, r2
 801afe6:	4798      	blx	r3
	}

	ClearAllEP();
 801afe8:	6878      	ldr	r0, [r7, #4]
 801afea:	f7ff fb8f 	bl	801a70c <_ZN10USBPrinter10ClearAllEPEv>
	pUsb->GetAddressPool().FreeAddress(bAddress);
 801afee:	687b      	ldr	r3, [r7, #4]
 801aff0:	689b      	ldr	r3, [r3, #8]
 801aff2:	4618      	mov	r0, r3
 801aff4:	f7f9 fa10 	bl	8014418 <_ZN3USB14GetAddressPoolEv>
 801aff8:	4603      	mov	r3, r0
 801affa:	681a      	ldr	r2, [r3, #0]
 801affc:	f102 0208 	add.w	r2, r2, #8
 801b000:	6812      	ldr	r2, [r2, #0]
 801b002:	6879      	ldr	r1, [r7, #4]
 801b004:	7ec9      	ldrb	r1, [r1, #27]
 801b006:	4618      	mov	r0, r3
 801b008:	4790      	blx	r2

	return 0;
 801b00a:	f04f 0300 	mov.w	r3, #0
}
 801b00e:	4618      	mov	r0, r3
 801b010:	f107 0708 	add.w	r7, r7, #8
 801b014:	46bd      	mov	sp, r7
 801b016:	bd80      	pop	{r7, pc}

0801b018 <_ZN10USBPrinter4PollEv>:
uint8_t USBPrinter::Poll()
{
 801b018:	b580      	push	{r7, lr}
 801b01a:	b084      	sub	sp, #16
 801b01c:	af00      	add	r7, sp, #0
 801b01e:	6078      	str	r0, [r7, #4]
	uint8_t rcode = 0;
 801b020:	f04f 0300 	mov.w	r3, #0
 801b024:	73fb      	strb	r3, [r7, #15]

	if(!bPollEnable)
 801b026:	687b      	ldr	r3, [r7, #4]
 801b028:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801b02c:	f083 0301 	eor.w	r3, r3, #1
 801b030:	b2db      	uxtb	r3, r3
 801b032:	2b00      	cmp	r3, #0
 801b034:	d002      	beq.n	801b03c <_ZN10USBPrinter4PollEv+0x24>
		return 0;
 801b036:	f04f 0300 	mov.w	r3, #0
 801b03a:	e01f      	b.n	801b07c <_ZN10USBPrinter4PollEv+0x64>

	if((long)(millis() - qNextPollTime) >= 0L) {
 801b03c:	f243 630c 	movw	r3, #13836	; 0x360c
 801b040:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b044:	681b      	ldr	r3, [r3, #0]
 801b046:	689b      	ldr	r3, [r3, #8]
 801b048:	4798      	blx	r3
 801b04a:	4603      	mov	r3, r0
 801b04c:	461a      	mov	r2, r3
 801b04e:	687b      	ldr	r3, [r7, #4]
 801b050:	6a1b      	ldr	r3, [r3, #32]
 801b052:	1ad3      	subs	r3, r2, r3
 801b054:	ea6f 0303 	mvn.w	r3, r3
 801b058:	ea4f 73d3 	mov.w	r3, r3, lsr #31
 801b05c:	b2db      	uxtb	r3, r3
 801b05e:	2b00      	cmp	r3, #0
 801b060:	d00b      	beq.n	801b07a <_ZN10USBPrinter4PollEv+0x62>
		//rcode = CheckPrinterStatus();
		qNextPollTime = millis() + 1000;
 801b062:	f243 630c 	movw	r3, #13836	; 0x360c
 801b066:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b06a:	681b      	ldr	r3, [r3, #0]
 801b06c:	689b      	ldr	r3, [r3, #8]
 801b06e:	4798      	blx	r3
 801b070:	4603      	mov	r3, r0
 801b072:	f503 727a 	add.w	r2, r3, #1000	; 0x3e8
 801b076:	687b      	ldr	r3, [r7, #4]
 801b078:	621a      	str	r2, [r3, #32]
	}

	return rcode;
 801b07a:	7bfb      	ldrb	r3, [r7, #15]
}
 801b07c:	4618      	mov	r0, r3
 801b07e:	f107 0710 	add.w	r7, r7, #16
 801b082:	46bd      	mov	sp, r7
 801b084:	bd80      	pop	{r7, pc}
 801b086:	bf00      	nop

0801b088 <_ZN10USBPrinter14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR>:

void USBPrinter::EndpointXtract(uint8_t conf, uint8_t iface, uint8_t alt, uint8_t proto, const USB_ENDPOINT_DESCRIPTOR *pep)
{
 801b088:	b480      	push	{r7}
 801b08a:	b085      	sub	sp, #20
 801b08c:	af00      	add	r7, sp, #0
 801b08e:	6078      	str	r0, [r7, #4]
 801b090:	70f9      	strb	r1, [r7, #3]
 801b092:	70ba      	strb	r2, [r7, #2]
 801b094:	707b      	strb	r3, [r7, #1]
	uint8_t index;
	bConfNum = conf;
 801b096:	687b      	ldr	r3, [r7, #4]
 801b098:	78fa      	ldrb	r2, [r7, #3]
 801b09a:	771a      	strb	r2, [r3, #28]

    if((pep->bmAttributes & 0x02) == 2) {
 801b09c:	69fb      	ldr	r3, [r7, #28]
 801b09e:	78db      	ldrb	r3, [r3, #3]
 801b0a0:	f003 0302 	and.w	r3, r3, #2
 801b0a4:	2b00      	cmp	r3, #0
 801b0a6:	d040      	beq.n	801b12a <_ZN10USBPrinter14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR+0xa2>
		index = ((pep->bEndpointAddress & 0x80) == 0x80) ? epDataInIndex : epDataOutIndex;
 801b0a8:	69fb      	ldr	r3, [r7, #28]
 801b0aa:	789b      	ldrb	r3, [r3, #2]
 801b0ac:	b2db      	uxtb	r3, r3
 801b0ae:	b25b      	sxtb	r3, r3
 801b0b0:	2b00      	cmp	r3, #0
 801b0b2:	da05      	bge.n	801b0c0 <_ZN10USBPrinter14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR+0x38>
 801b0b4:	f240 63c0 	movw	r3, #1728	; 0x6c0
 801b0b8:	f6c0 0302 	movt	r3, #2050	; 0x802
 801b0bc:	781b      	ldrb	r3, [r3, #0]
 801b0be:	e004      	b.n	801b0ca <_ZN10USBPrinter14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR+0x42>
 801b0c0:	f240 63c1 	movw	r3, #1729	; 0x6c1
 801b0c4:	f6c0 0302 	movt	r3, #2050	; 0x802
 801b0c8:	781b      	ldrb	r3, [r3, #0]
 801b0ca:	73fb      	strb	r3, [r7, #15]
		// Fill in the endpoint info structure
		epInfo[index].epAddr = pep->bEndpointAddress;	//(pep->bEndpointAddress & 0x0F);
 801b0cc:	7bfa      	ldrb	r2, [r7, #15]
 801b0ce:	69fb      	ldr	r3, [r7, #28]
 801b0d0:	7899      	ldrb	r1, [r3, #2]
 801b0d2:	6878      	ldr	r0, [r7, #4]
 801b0d4:	4613      	mov	r3, r2
 801b0d6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b0da:	189b      	adds	r3, r3, r2
 801b0dc:	18c3      	adds	r3, r0, r3
 801b0de:	f103 0308 	add.w	r3, r3, #8
 801b0e2:	460a      	mov	r2, r1
 801b0e4:	711a      	strb	r2, [r3, #4]
		epInfo[index].maxPktSize = (uint8_t)pep->wMaxPacketSize;
 801b0e6:	7bfa      	ldrb	r2, [r7, #15]
 801b0e8:	69fb      	ldr	r3, [r7, #28]
 801b0ea:	889b      	ldrh	r3, [r3, #4]
 801b0ec:	b29b      	uxth	r3, r3
 801b0ee:	b2d9      	uxtb	r1, r3
 801b0f0:	6878      	ldr	r0, [r7, #4]
 801b0f2:	4613      	mov	r3, r2
 801b0f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b0f8:	189b      	adds	r3, r3, r2
 801b0fa:	18c3      	adds	r3, r0, r3
 801b0fc:	f103 0308 	add.w	r3, r3, #8
 801b100:	460a      	mov	r2, r1
 801b102:	715a      	strb	r2, [r3, #5]
		epInfo[index].epAttribs = 0;
 801b104:	7bfa      	ldrb	r2, [r7, #15]
 801b106:	6879      	ldr	r1, [r7, #4]
 801b108:	4613      	mov	r3, r2
 801b10a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b10e:	189b      	adds	r3, r3, r2
 801b110:	18cb      	adds	r3, r1, r3
 801b112:	f103 0308 	add.w	r3, r3, #8
 801b116:	f04f 0200 	mov.w	r2, #0
 801b11a:	721a      	strb	r2, [r3, #8]

		bNumEP++;
 801b11c:	687b      	ldr	r3, [r7, #4]
 801b11e:	7f5b      	ldrb	r3, [r3, #29]
 801b120:	f103 0301 	add.w	r3, r3, #1
 801b124:	b2da      	uxtb	r2, r3
 801b126:	687b      	ldr	r3, [r7, #4]
 801b128:	775a      	strb	r2, [r3, #29]

		//PrintEndpointDescriptor(pep);
    }
}
 801b12a:	f107 0714 	add.w	r7, r7, #20
 801b12e:	46bd      	mov	sp, r7
 801b130:	bc80      	pop	{r7}
 801b132:	4770      	bx	lr

0801b134 <_ZThn4_N10USBPrinter14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR>:
 801b134:	f1a0 0004 	sub.w	r0, r0, #4
 801b138:	f7ff bfa6 	b.w	801b088 <_ZN10USBPrinter14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR>

0801b13c <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EEC1EP17UsbConfigXtracter>:
        ConfigDescParser(UsbConfigXtracter *xtractor);
        virtual void Parse(const uint16_t len, const uint8_t *pbuf, const uint16_t &offset);
};

template <const uint8_t CLASS_ID, const uint8_t SUBCLASS_ID, const uint8_t PROTOCOL_ID, const uint8_t MASK>
ConfigDescParser<CLASS_ID, SUBCLASS_ID, PROTOCOL_ID, MASK>::ConfigDescParser(UsbConfigXtracter *xtractor) :
 801b13c:	b580      	push	{r7, lr}
 801b13e:	b082      	sub	sp, #8
 801b140:	af00      	add	r7, sp, #0
 801b142:	6078      	str	r0, [r7, #4]
 801b144:	6039      	str	r1, [r7, #0]
theXtractor(xtractor),
stateParseDescr(0),
dscrLen(0),
dscrType(0) {
 801b146:	687b      	ldr	r3, [r7, #4]
 801b148:	4618      	mov	r0, r3
 801b14a:	f7fd fe3d 	bl	8018dc8 <_ZN13USBReadParserC1Ev>
 801b14e:	687b      	ldr	r3, [r7, #4]
 801b150:	4a1f      	ldr	r2, [pc, #124]	; (801b1d0 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EEC1EP17UsbConfigXtracter+0x94>)
 801b152:	601a      	str	r2, [r3, #0]
 801b154:	687b      	ldr	r3, [r7, #4]
 801b156:	683a      	ldr	r2, [r7, #0]
 801b158:	605a      	str	r2, [r3, #4]
 801b15a:	687b      	ldr	r3, [r7, #4]
 801b15c:	f103 0310 	add.w	r3, r3, #16
 801b160:	4618      	mov	r0, r3
 801b162:	f7fb f99d 	bl	80164a0 <_ZN20MultiByteValueParserC1Ev>
 801b166:	687b      	ldr	r3, [r7, #4]
 801b168:	f103 0318 	add.w	r3, r3, #24
 801b16c:	4618      	mov	r0, r3
 801b16e:	f7fb f9c7 	bl	8016500 <_ZN11ByteSkipperC1Ev>
 801b172:	687b      	ldr	r3, [r7, #4]
 801b174:	f04f 0200 	mov.w	r2, #0
 801b178:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
 801b17c:	687b      	ldr	r3, [r7, #4]
 801b17e:	f04f 0200 	mov.w	r2, #0
 801b182:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
 801b186:	687b      	ldr	r3, [r7, #4]
 801b188:	f04f 0200 	mov.w	r2, #0
 801b18c:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
	theBuffer.pValue = varBuffer;
 801b190:	687b      	ldr	r3, [r7, #4]
 801b192:	f103 0220 	add.w	r2, r3, #32
 801b196:	687b      	ldr	r3, [r7, #4]
 801b198:	f8c3 2009 	str.w	r2, [r3, #9]
	valParser.Initialize(&theBuffer);
 801b19c:	687b      	ldr	r3, [r7, #4]
 801b19e:	f103 0210 	add.w	r2, r3, #16
 801b1a2:	687b      	ldr	r3, [r7, #4]
 801b1a4:	f103 0308 	add.w	r3, r3, #8
 801b1a8:	4610      	mov	r0, r2
 801b1aa:	4619      	mov	r1, r3
 801b1ac:	f7fb f990 	bl	80164d0 <_ZN20MultiByteValueParser10InitializeEP16MultiValueBuffer>
	theSkipper.Initialize(&theBuffer);
 801b1b0:	687b      	ldr	r3, [r7, #4]
 801b1b2:	f103 0218 	add.w	r2, r3, #24
 801b1b6:	687b      	ldr	r3, [r7, #4]
 801b1b8:	f103 0308 	add.w	r3, r3, #8
 801b1bc:	4610      	mov	r0, r2
 801b1be:	4619      	mov	r1, r3
 801b1c0:	f7fb f9b6 	bl	8016530 <_ZN11ByteSkipper10InitializeEP16MultiValueBuffer>
 801b1c4:	687b      	ldr	r3, [r7, #4]
};
 801b1c6:	4618      	mov	r0, r3
 801b1c8:	f107 0708 	add.w	r7, r7, #8
 801b1cc:	46bd      	mov	sp, r7
 801b1ce:	bd80      	pop	{r7, pc}
 801b1d0:	080206d0 	.word	0x080206d0

0801b1d4 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE5ParseEtPKhRKt>:

template <const uint8_t CLASS_ID, const uint8_t SUBCLASS_ID, const uint8_t PROTOCOL_ID, const uint8_t MASK>
void ConfigDescParser<CLASS_ID, SUBCLASS_ID, PROTOCOL_ID, MASK>::Parse(const uint16_t len, const uint8_t *pbuf, const uint16_t &offset) {
 801b1d4:	b580      	push	{r7, lr}
 801b1d6:	b086      	sub	sp, #24
 801b1d8:	af00      	add	r7, sp, #0
 801b1da:	60f8      	str	r0, [r7, #12]
 801b1dc:	607a      	str	r2, [r7, #4]
 801b1de:	603b      	str	r3, [r7, #0]
 801b1e0:	460b      	mov	r3, r1
 801b1e2:	817b      	strh	r3, [r7, #10]
        uint16_t cntdn = (uint16_t) len;
 801b1e4:	897b      	ldrh	r3, [r7, #10]
 801b1e6:	82fb      	strh	r3, [r7, #22]
        uint8_t *p = (uint8_t*) pbuf;
 801b1e8:	687b      	ldr	r3, [r7, #4]
 801b1ea:	613b      	str	r3, [r7, #16]

        while(cntdn)
 801b1ec:	e00e      	b.n	801b20c <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE5ParseEtPKhRKt+0x38>
			if(!ParseDescriptor(&p, &cntdn))
 801b1ee:	f107 0210 	add.w	r2, r7, #16
 801b1f2:	f107 0316 	add.w	r3, r7, #22
 801b1f6:	68f8      	ldr	r0, [r7, #12]
 801b1f8:	4611      	mov	r1, r2
 801b1fa:	461a      	mov	r2, r3
 801b1fc:	f000 f816 	bl	801b22c <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt>
 801b200:	4603      	mov	r3, r0
 801b202:	f083 0301 	eor.w	r3, r3, #1
 801b206:	b2db      	uxtb	r3, r3
 801b208:	2b00      	cmp	r3, #0
 801b20a:	d10a      	bne.n	801b222 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE5ParseEtPKhRKt+0x4e>
template <const uint8_t CLASS_ID, const uint8_t SUBCLASS_ID, const uint8_t PROTOCOL_ID, const uint8_t MASK>
void ConfigDescParser<CLASS_ID, SUBCLASS_ID, PROTOCOL_ID, MASK>::Parse(const uint16_t len, const uint8_t *pbuf, const uint16_t &offset) {
        uint16_t cntdn = (uint16_t) len;
        uint8_t *p = (uint8_t*) pbuf;

        while(cntdn)
 801b20c:	8afb      	ldrh	r3, [r7, #22]
 801b20e:	2b00      	cmp	r3, #0
 801b210:	bf0c      	ite	eq
 801b212:	2300      	moveq	r3, #0
 801b214:	2301      	movne	r3, #1
 801b216:	b2db      	uxtb	r3, r3
 801b218:	2b00      	cmp	r3, #0
 801b21a:	d1e8      	bne.n	801b1ee <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE5ParseEtPKhRKt+0x1a>
			if(!ParseDescriptor(&p, &cntdn))
				return;
 801b21c:	e001      	b.n	801b222 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE5ParseEtPKhRKt+0x4e>
 801b21e:	f001 fc2f 	bl	801ca80 <__cxa_end_cleanup>
 801b222:	bf00      	nop
}
 801b224:	f107 0718 	add.w	r7, r7, #24
 801b228:	46bd      	mov	sp, r7
 801b22a:	bd80      	pop	{r7, pc}

0801b22c <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt>:

/* Parser for the configuration descriptor. Takes values for class, subclass, protocol fields in interface descriptor and
  compare masks for them. When the match is found, calls EndpointXtract passing buffer containing endpoint descriptor */
template <const uint8_t CLASS_ID, const uint8_t SUBCLASS_ID, const uint8_t PROTOCOL_ID, const uint8_t MASK>
bool ConfigDescParser<CLASS_ID, SUBCLASS_ID, PROTOCOL_ID, MASK>::ParseDescriptor(uint8_t **pp, uint16_t *pcntdn) {
 801b22c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801b22e:	b087      	sub	sp, #28
 801b230:	af02      	add	r7, sp, #8
 801b232:	60f8      	str	r0, [r7, #12]
 801b234:	60b9      	str	r1, [r7, #8]
 801b236:	607a      	str	r2, [r7, #4]
        switch(stateParseDescr) {
 801b238:	68fb      	ldr	r3, [r7, #12]
 801b23a:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 801b23e:	2b04      	cmp	r3, #4
 801b240:	f200 817e 	bhi.w	801b540 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x314>
 801b244:	a201      	add	r2, pc, #4	; (adr r2, 801b24c <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x20>)
 801b246:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801b24a:	bf00      	nop
 801b24c:	0801b261 	.word	0x0801b261
 801b250:	0801b287 	.word	0x0801b287
 801b254:	0801b2cf 	.word	0x0801b2cf
 801b258:	0801b2e5 	.word	0x0801b2e5
 801b25c:	0801b3c7 	.word	0x0801b3c7
                case 0:
                        theBuffer.valueSize = 2;
 801b260:	68fb      	ldr	r3, [r7, #12]
 801b262:	f04f 0202 	mov.w	r2, #2
 801b266:	721a      	strb	r2, [r3, #8]
                        valParser.Initialize(&theBuffer);
 801b268:	68fb      	ldr	r3, [r7, #12]
 801b26a:	f103 0210 	add.w	r2, r3, #16
 801b26e:	68fb      	ldr	r3, [r7, #12]
 801b270:	f103 0308 	add.w	r3, r3, #8
 801b274:	4610      	mov	r0, r2
 801b276:	4619      	mov	r1, r3
 801b278:	f7fb f92a 	bl	80164d0 <_ZN20MultiByteValueParser10InitializeEP16MultiValueBuffer>
                        stateParseDescr = 1;
 801b27c:	68fb      	ldr	r3, [r7, #12]
 801b27e:	f04f 0201 	mov.w	r2, #1
 801b282:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
                case 1:
                        if(!valParser.Parse(pp, pcntdn))
 801b286:	68fb      	ldr	r3, [r7, #12]
 801b288:	f103 0310 	add.w	r3, r3, #16
 801b28c:	4618      	mov	r0, r3
 801b28e:	68b9      	ldr	r1, [r7, #8]
 801b290:	687a      	ldr	r2, [r7, #4]
 801b292:	f7fe fa0d 	bl	80196b0 <_ZN20MultiByteValueParser5ParseEPPhPt>
 801b296:	4603      	mov	r3, r0
 801b298:	f083 0301 	eor.w	r3, r3, #1
 801b29c:	b2db      	uxtb	r3, r3
 801b29e:	2b00      	cmp	r3, #0
 801b2a0:	d002      	beq.n	801b2a8 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x7c>
                                return false;
 801b2a2:	f04f 0300 	mov.w	r3, #0
 801b2a6:	e14d      	b.n	801b544 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x318>
                        dscrLen = *((uint8_t*) theBuffer.pValue);
 801b2a8:	68fb      	ldr	r3, [r7, #12]
 801b2aa:	f8d3 3009 	ldr.w	r3, [r3, #9]
 801b2ae:	781a      	ldrb	r2, [r3, #0]
 801b2b0:	68fb      	ldr	r3, [r7, #12]
 801b2b2:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
                        dscrType = *((uint8_t*) theBuffer.pValue + 1);
 801b2b6:	68fb      	ldr	r3, [r7, #12]
 801b2b8:	f8d3 3009 	ldr.w	r3, [r3, #9]
 801b2bc:	785a      	ldrb	r2, [r3, #1]
 801b2be:	68fb      	ldr	r3, [r7, #12]
 801b2c0:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
                        stateParseDescr = 2;
 801b2c4:	68fb      	ldr	r3, [r7, #12]
 801b2c6:	f04f 0202 	mov.w	r2, #2
 801b2ca:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
                        // This is a sort of hack. Assuming that two bytes are all ready in the buffer
                        //	the pointer is positioned two bytes ahead in order for the rest of descriptor
                        //	to be read right after the size and the type fields.
                        // This should be used carefully. varBuffer should be used directly to handle data
                        //	in the buffer.
                        theBuffer.pValue = varBuffer + 2;
 801b2ce:	68fb      	ldr	r3, [r7, #12]
 801b2d0:	f103 0222 	add.w	r2, r3, #34	; 0x22
 801b2d4:	68fb      	ldr	r3, [r7, #12]
 801b2d6:	f8c3 2009 	str.w	r2, [r3, #9]
                        stateParseDescr = 3;
 801b2da:	68fb      	ldr	r3, [r7, #12]
 801b2dc:	f04f 0203 	mov.w	r2, #3
 801b2e0:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
                case 3:
                        switch(dscrType) {
 801b2e4:	68fb      	ldr	r3, [r7, #12]
 801b2e6:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 801b2ea:	f1a3 0302 	sub.w	r3, r3, #2
 801b2ee:	2b1f      	cmp	r3, #31
 801b2f0:	d85a      	bhi.n	801b3a8 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x17c>
 801b2f2:	a201      	add	r2, pc, #4	; (adr r2, 801b2f8 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0xcc>)
 801b2f4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801b2f8:	0801b383 	.word	0x0801b383
 801b2fc:	0801b3a9 	.word	0x0801b3a9
 801b300:	0801b379 	.word	0x0801b379
 801b304:	0801b38d 	.word	0x0801b38d
 801b308:	0801b3a9 	.word	0x0801b3a9
 801b30c:	0801b3a9 	.word	0x0801b3a9
 801b310:	0801b3a9 	.word	0x0801b3a9
 801b314:	0801b3a9 	.word	0x0801b3a9
 801b318:	0801b3a9 	.word	0x0801b3a9
 801b31c:	0801b3a9 	.word	0x0801b3a9
 801b320:	0801b3a9 	.word	0x0801b3a9
 801b324:	0801b3a9 	.word	0x0801b3a9
 801b328:	0801b3a9 	.word	0x0801b3a9
 801b32c:	0801b3a9 	.word	0x0801b3a9
 801b330:	0801b3a9 	.word	0x0801b3a9
 801b334:	0801b3a9 	.word	0x0801b3a9
 801b338:	0801b3a9 	.word	0x0801b3a9
 801b33c:	0801b3a9 	.word	0x0801b3a9
 801b340:	0801b3a9 	.word	0x0801b3a9
 801b344:	0801b3a9 	.word	0x0801b3a9
 801b348:	0801b3a9 	.word	0x0801b3a9
 801b34c:	0801b3a9 	.word	0x0801b3a9
 801b350:	0801b3a9 	.word	0x0801b3a9
 801b354:	0801b3a9 	.word	0x0801b3a9
 801b358:	0801b3a9 	.word	0x0801b3a9
 801b35c:	0801b3a9 	.word	0x0801b3a9
 801b360:	0801b3a9 	.word	0x0801b3a9
 801b364:	0801b3a9 	.word	0x0801b3a9
 801b368:	0801b3a9 	.word	0x0801b3a9
 801b36c:	0801b3a9 	.word	0x0801b3a9
 801b370:	0801b3a9 	.word	0x0801b3a9
 801b374:	0801b397 	.word	0x0801b397
                                case USB_DESCRIPTOR_INTERFACE:
                                        isGoodInterface = false;
 801b378:	68fb      	ldr	r3, [r7, #12]
 801b37a:	f04f 0200 	mov.w	r2, #0
 801b37e:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
                                case USB_DESCRIPTOR_CONFIGURATION:
                                        theBuffer.valueSize = sizeof(USB_CONFIGURATION_DESCRIPTOR) - 2;
 801b382:	68fb      	ldr	r3, [r7, #12]
 801b384:	f04f 0207 	mov.w	r2, #7
 801b388:	721a      	strb	r2, [r3, #8]
                                        break;
 801b38a:	e00d      	b.n	801b3a8 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x17c>
                                case USB_DESCRIPTOR_ENDPOINT:
                                        theBuffer.valueSize = sizeof(USB_ENDPOINT_DESCRIPTOR) - 2;
 801b38c:	68fb      	ldr	r3, [r7, #12]
 801b38e:	f04f 0205 	mov.w	r2, #5
 801b392:	721a      	strb	r2, [r3, #8]
                                        break;
 801b394:	e008      	b.n	801b3a8 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x17c>
                                case HID_DESCRIPTOR_HID:
                                        theBuffer.valueSize = dscrLen - 2;
 801b396:	68fb      	ldr	r3, [r7, #12]
 801b398:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 801b39c:	f1a3 0302 	sub.w	r3, r3, #2
 801b3a0:	b2da      	uxtb	r2, r3
 801b3a2:	68fb      	ldr	r3, [r7, #12]
 801b3a4:	721a      	strb	r2, [r3, #8]
                                        break;
 801b3a6:	bf00      	nop
                        }
                        valParser.Initialize(&theBuffer);
 801b3a8:	68fb      	ldr	r3, [r7, #12]
 801b3aa:	f103 0210 	add.w	r2, r3, #16
 801b3ae:	68fb      	ldr	r3, [r7, #12]
 801b3b0:	f103 0308 	add.w	r3, r3, #8
 801b3b4:	4610      	mov	r0, r2
 801b3b6:	4619      	mov	r1, r3
 801b3b8:	f7fb f88a 	bl	80164d0 <_ZN20MultiByteValueParser10InitializeEP16MultiValueBuffer>
                        stateParseDescr = 4;
 801b3bc:	68fb      	ldr	r3, [r7, #12]
 801b3be:	f04f 0204 	mov.w	r2, #4
 801b3c2:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
                case 4:
					switch(dscrType) {
 801b3c6:	68fb      	ldr	r3, [r7, #12]
 801b3c8:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 801b3cc:	2b04      	cmp	r3, #4
 801b3ce:	d01d      	beq.n	801b40c <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x1e0>
 801b3d0:	2b05      	cmp	r3, #5
 801b3d2:	d059      	beq.n	801b488 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x25c>
 801b3d4:	2b02      	cmp	r3, #2
 801b3d6:	f040 808a 	bne.w	801b4ee <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x2c2>
							case USB_DESCRIPTOR_CONFIGURATION:
								if(!valParser.Parse(pp, pcntdn))
 801b3da:	68fb      	ldr	r3, [r7, #12]
 801b3dc:	f103 0310 	add.w	r3, r3, #16
 801b3e0:	4618      	mov	r0, r3
 801b3e2:	68b9      	ldr	r1, [r7, #8]
 801b3e4:	687a      	ldr	r2, [r7, #4]
 801b3e6:	f7fe f963 	bl	80196b0 <_ZN20MultiByteValueParser5ParseEPPhPt>
 801b3ea:	4603      	mov	r3, r0
 801b3ec:	f083 0301 	eor.w	r3, r3, #1
 801b3f0:	b2db      	uxtb	r3, r3
 801b3f2:	2b00      	cmp	r3, #0
 801b3f4:	d002      	beq.n	801b3fc <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x1d0>
									return false;
 801b3f6:	f04f 0300 	mov.w	r3, #0
 801b3fa:	e0a3      	b.n	801b544 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x318>
								confValue = ((USB_CONFIGURATION_DESCRIPTOR*) varBuffer)->bConfigurationValue;
 801b3fc:	68fb      	ldr	r3, [r7, #12]
 801b3fe:	f103 0320 	add.w	r3, r3, #32
 801b402:	795a      	ldrb	r2, [r3, #5]
 801b404:	68fb      	ldr	r3, [r7, #12]
 801b406:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
								break;
 801b40a:	e08e      	b.n	801b52a <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x2fe>
							case USB_DESCRIPTOR_INTERFACE:
								if(!valParser.Parse(pp, pcntdn))
 801b40c:	68fb      	ldr	r3, [r7, #12]
 801b40e:	f103 0310 	add.w	r3, r3, #16
 801b412:	4618      	mov	r0, r3
 801b414:	68b9      	ldr	r1, [r7, #8]
 801b416:	687a      	ldr	r2, [r7, #4]
 801b418:	f7fe f94a 	bl	80196b0 <_ZN20MultiByteValueParser5ParseEPPhPt>
 801b41c:	4603      	mov	r3, r0
 801b41e:	f083 0301 	eor.w	r3, r3, #1
 801b422:	b2db      	uxtb	r3, r3
 801b424:	2b00      	cmp	r3, #0
 801b426:	d002      	beq.n	801b42e <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x202>
									return false;
 801b428:	f04f 0300 	mov.w	r3, #0
 801b42c:	e08a      	b.n	801b544 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x318>
								if((MASK & CP_MASK_COMPARE_CLASS) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceClass != CLASS_ID)
 801b42e:	68fb      	ldr	r3, [r7, #12]
 801b430:	f103 0320 	add.w	r3, r3, #32
 801b434:	795b      	ldrb	r3, [r3, #5]
 801b436:	2b07      	cmp	r3, #7
 801b438:	d170      	bne.n	801b51c <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x2f0>
									break;
								if((MASK & CP_MASK_COMPARE_SUBCLASS) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceSubClass != SUBCLASS_ID)
 801b43a:	68fb      	ldr	r3, [r7, #12]
 801b43c:	f103 0320 	add.w	r3, r3, #32
 801b440:	799b      	ldrb	r3, [r3, #6]
 801b442:	2b01      	cmp	r3, #1
 801b444:	d16c      	bne.n	801b520 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x2f4>
									break;
								if((MASK & CP_MASK_COMPARE_PROTOCOL) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceProtocol != PROTOCOL_ID)
 801b446:	68fb      	ldr	r3, [r7, #12]
 801b448:	f103 0320 	add.w	r3, r3, #32
 801b44c:	79db      	ldrb	r3, [r3, #7]
 801b44e:	2b02      	cmp	r3, #2
 801b450:	d168      	bne.n	801b524 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x2f8>
									break;

								isGoodInterface = true;
 801b452:	68fb      	ldr	r3, [r7, #12]
 801b454:	f04f 0201 	mov.w	r2, #1
 801b458:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
								ifaceNumber = ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceNumber;
 801b45c:	68fb      	ldr	r3, [r7, #12]
 801b45e:	f103 0320 	add.w	r3, r3, #32
 801b462:	789a      	ldrb	r2, [r3, #2]
 801b464:	68fb      	ldr	r3, [r7, #12]
 801b466:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
								ifaceAltSet = ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bAlternateSetting;
 801b46a:	68fb      	ldr	r3, [r7, #12]
 801b46c:	f103 0320 	add.w	r3, r3, #32
 801b470:	78da      	ldrb	r2, [r3, #3]
 801b472:	68fb      	ldr	r3, [r7, #12]
 801b474:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
								protoValue = ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceProtocol;
 801b478:	68fb      	ldr	r3, [r7, #12]
 801b47a:	f103 0320 	add.w	r3, r3, #32
 801b47e:	79da      	ldrb	r2, [r3, #7]
 801b480:	68fb      	ldr	r3, [r7, #12]
 801b482:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
								break;
 801b486:	e050      	b.n	801b52a <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x2fe>
							case USB_DESCRIPTOR_ENDPOINT:
								if(!valParser.Parse(pp, pcntdn))
 801b488:	68fb      	ldr	r3, [r7, #12]
 801b48a:	f103 0310 	add.w	r3, r3, #16
 801b48e:	4618      	mov	r0, r3
 801b490:	68b9      	ldr	r1, [r7, #8]
 801b492:	687a      	ldr	r2, [r7, #4]
 801b494:	f7fe f90c 	bl	80196b0 <_ZN20MultiByteValueParser5ParseEPPhPt>
 801b498:	4603      	mov	r3, r0
 801b49a:	f083 0301 	eor.w	r3, r3, #1
 801b49e:	b2db      	uxtb	r3, r3
 801b4a0:	2b00      	cmp	r3, #0
 801b4a2:	d002      	beq.n	801b4aa <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x27e>
										return false;
 801b4a4:	f04f 0300 	mov.w	r3, #0
 801b4a8:	e04c      	b.n	801b544 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x318>
								if(isGoodInterface)
 801b4aa:	68fb      	ldr	r3, [r7, #12]
 801b4ac:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
 801b4b0:	2b00      	cmp	r3, #0
 801b4b2:	d039      	beq.n	801b528 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x2fc>
									if(theXtractor)
 801b4b4:	68fb      	ldr	r3, [r7, #12]
 801b4b6:	685b      	ldr	r3, [r3, #4]
 801b4b8:	2b00      	cmp	r3, #0
 801b4ba:	d035      	beq.n	801b528 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x2fc>
										theXtractor->EndpointXtract(confValue, ifaceNumber, ifaceAltSet, protoValue, (USB_ENDPOINT_DESCRIPTOR*) varBuffer);
 801b4bc:	68fb      	ldr	r3, [r7, #12]
 801b4be:	685b      	ldr	r3, [r3, #4]
 801b4c0:	681b      	ldr	r3, [r3, #0]
 801b4c2:	681c      	ldr	r4, [r3, #0]
 801b4c4:	68fb      	ldr	r3, [r7, #12]
 801b4c6:	6858      	ldr	r0, [r3, #4]
 801b4c8:	68fb      	ldr	r3, [r7, #12]
 801b4ca:	f893 1034 	ldrb.w	r1, [r3, #52]	; 0x34
 801b4ce:	68fb      	ldr	r3, [r7, #12]
 801b4d0:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
 801b4d4:	68fb      	ldr	r3, [r7, #12]
 801b4d6:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
 801b4da:	68fd      	ldr	r5, [r7, #12]
 801b4dc:	f895 6035 	ldrb.w	r6, [r5, #53]	; 0x35
 801b4e0:	68fd      	ldr	r5, [r7, #12]
 801b4e2:	f105 0520 	add.w	r5, r5, #32
 801b4e6:	9600      	str	r6, [sp, #0]
 801b4e8:	9501      	str	r5, [sp, #4]
 801b4ea:	47a0      	blx	r4
								break;
 801b4ec:	e01c      	b.n	801b528 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x2fc>
								//	if (!valParser.Parse(pp, pcntdn))
								//		return false;
								//	PrintHidDescriptor((const USB_HID_DESCRIPTOR*)varBuffer);
								//	break;
							default:
								if(!theSkipper.Skip(pp, pcntdn, dscrLen - 2))
 801b4ee:	68fb      	ldr	r3, [r7, #12]
 801b4f0:	f103 0218 	add.w	r2, r3, #24
 801b4f4:	68fb      	ldr	r3, [r7, #12]
 801b4f6:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 801b4fa:	f1a3 0302 	sub.w	r3, r3, #2
 801b4fe:	b29b      	uxth	r3, r3
 801b500:	4610      	mov	r0, r2
 801b502:	68b9      	ldr	r1, [r7, #8]
 801b504:	687a      	ldr	r2, [r7, #4]
 801b506:	f7fb f827 	bl	8016558 <_ZN11ByteSkipper4SkipEPPhPtt>
 801b50a:	4603      	mov	r3, r0
 801b50c:	f083 0301 	eor.w	r3, r3, #1
 801b510:	b2db      	uxtb	r3, r3
 801b512:	2b00      	cmp	r3, #0
 801b514:	d009      	beq.n	801b52a <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x2fe>
									return false;
 801b516:	f04f 0300 	mov.w	r3, #0
 801b51a:	e013      	b.n	801b544 <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x318>
								break;
							case USB_DESCRIPTOR_INTERFACE:
								if(!valParser.Parse(pp, pcntdn))
									return false;
								if((MASK & CP_MASK_COMPARE_CLASS) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceClass != CLASS_ID)
									break;
 801b51c:	bf00      	nop
 801b51e:	e004      	b.n	801b52a <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x2fe>
								if((MASK & CP_MASK_COMPARE_SUBCLASS) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceSubClass != SUBCLASS_ID)
									break;
 801b520:	bf00      	nop
 801b522:	e002      	b.n	801b52a <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x2fe>
								if((MASK & CP_MASK_COMPARE_PROTOCOL) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceProtocol != PROTOCOL_ID)
									break;
 801b524:	bf00      	nop
 801b526:	e000      	b.n	801b52a <_ZN16ConfigDescParserILh7ELh1ELh2ELh7EE15ParseDescriptorEPPhPt+0x2fe>
								if(!valParser.Parse(pp, pcntdn))
										return false;
								if(isGoodInterface)
									if(theXtractor)
										theXtractor->EndpointXtract(confValue, ifaceNumber, ifaceAltSet, protoValue, (USB_ENDPOINT_DESCRIPTOR*) varBuffer);
								break;
 801b528:	bf00      	nop
								//	break;
							default:
								if(!theSkipper.Skip(pp, pcntdn, dscrLen - 2))
									return false;
					}
					theBuffer.pValue = varBuffer;
 801b52a:	68fb      	ldr	r3, [r7, #12]
 801b52c:	f103 0220 	add.w	r2, r3, #32
 801b530:	68fb      	ldr	r3, [r7, #12]
 801b532:	f8c3 2009 	str.w	r2, [r3, #9]
					stateParseDescr = 0;
 801b536:	68fb      	ldr	r3, [r7, #12]
 801b538:	f04f 0200 	mov.w	r2, #0
 801b53c:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
        }
        return true;
 801b540:	f04f 0301 	mov.w	r3, #1
}
 801b544:	4618      	mov	r0, r3
 801b546:	f107 0714 	add.w	r7, r7, #20
 801b54a:	46bd      	mov	sp, r7
 801b54c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801b54e:	bf00      	nop

0801b550 <_ZN9FTDIAsync6OnInitEP4FTDI>:
public:
    virtual uint8_t OnInit(FTDI *pftdi);
};

uint8_t FTDIAsync::OnInit(FTDI *pftdi)
{
 801b550:	b580      	push	{r7, lr}
 801b552:	b084      	sub	sp, #16
 801b554:	af00      	add	r7, sp, #0
 801b556:	6078      	str	r0, [r7, #4]
 801b558:	6039      	str	r1, [r7, #0]
    uint8_t rcode = 0;
 801b55a:	f04f 0300 	mov.w	r3, #0
 801b55e:	73fb      	strb	r3, [r7, #15]

    rcode = pftdi->SetBaudRate(pftdi->baudrate);	//115200);
 801b560:	683b      	ldr	r3, [r7, #0]
 801b562:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801b564:	6838      	ldr	r0, [r7, #0]
 801b566:	4619      	mov	r1, r3
 801b568:	f000 fdf8 	bl	801c15c <_ZN4FTDI11SetBaudRateEm>
 801b56c:	4603      	mov	r3, r0
 801b56e:	73fb      	strb	r3, [r7, #15]

    if (rcode)
 801b570:	7bfb      	ldrb	r3, [r7, #15]
 801b572:	2b00      	cmp	r3, #0
 801b574:	d009      	beq.n	801b58a <_ZN9FTDIAsync6OnInitEP4FTDI+0x3a>
    {
        ErrorMessage<uint8_t>(PSTR("SetBaudRate"), rcode);
 801b576:	7bfb      	ldrb	r3, [r7, #15]
 801b578:	f64e 7078 	movw	r0, #61304	; 0xef78
 801b57c:	f6c0 0001 	movt	r0, #2049	; 0x801
 801b580:	4619      	mov	r1, r3
 801b582:	f7fd fc7d 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
        return rcode;
 801b586:	7bfb      	ldrb	r3, [r7, #15]
 801b588:	e018      	b.n	801b5bc <_ZN9FTDIAsync6OnInitEP4FTDI+0x6c>
    }
    rcode = pftdi->SetFlowControl(pftdi->flow_control);	//FTDI_SIO_DISABLE_FLOW_CTRL);
 801b58a:	683b      	ldr	r3, [r7, #0]
 801b58c:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 801b58e:	b2db      	uxtb	r3, r3
 801b590:	6838      	ldr	r0, [r7, #0]
 801b592:	4619      	mov	r1, r3
 801b594:	f04f 0211 	mov.w	r2, #17
 801b598:	f04f 0313 	mov.w	r3, #19
 801b59c:	f000 fedc 	bl	801c358 <_ZN4FTDI14SetFlowControlEhhh>
 801b5a0:	4603      	mov	r3, r0
 801b5a2:	73fb      	strb	r3, [r7, #15]

    if (rcode)
 801b5a4:	7bfb      	ldrb	r3, [r7, #15]
 801b5a6:	2b00      	cmp	r3, #0
 801b5a8:	d007      	beq.n	801b5ba <_ZN9FTDIAsync6OnInitEP4FTDI+0x6a>
        ErrorMessage<uint8_t>(PSTR("SetFlowControl"), rcode);
 801b5aa:	7bfb      	ldrb	r3, [r7, #15]
 801b5ac:	f64e 7084 	movw	r0, #61316	; 0xef84
 801b5b0:	f6c0 0001 	movt	r0, #2049	; 0x801
 801b5b4:	4619      	mov	r1, r3
 801b5b6:	f7fd fc63 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>

    return rcode;
 801b5ba:	7bfb      	ldrb	r3, [r7, #15]
}
 801b5bc:	4618      	mov	r0, r3
 801b5be:	f107 0710 	add.w	r7, r7, #16
 801b5c2:	46bd      	mov	sp, r7
 801b5c4:	bd80      	pop	{r7, pc}
 801b5c6:	bf00      	nop

0801b5c8 <_Z15cdc_check_stateh>:

void cdc_check_state(uint8_t state)
{
 801b5c8:	b580      	push	{r7, lr}
 801b5ca:	b082      	sub	sp, #8
 801b5cc:	af00      	add	r7, sp, #0
 801b5ce:	4603      	mov	r3, r0
 801b5d0:	71fb      	strb	r3, [r7, #7]
	static uint8_t current_state = 0;
	static uint8_t last_state = 0;

	current_state = state;
 801b5d2:	f640 4371 	movw	r3, #3185	; 0xc71
 801b5d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b5da:	79fa      	ldrb	r2, [r7, #7]
 801b5dc:	701a      	strb	r2, [r3, #0]
	if(current_state != last_state)
 801b5de:	f640 4371 	movw	r3, #3185	; 0xc71
 801b5e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b5e6:	781a      	ldrb	r2, [r3, #0]
 801b5e8:	f640 4372 	movw	r3, #3186	; 0xc72
 801b5ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b5f0:	781b      	ldrb	r3, [r3, #0]
 801b5f2:	429a      	cmp	r2, r3
 801b5f4:	d017      	beq.n	801b626 <_Z15cdc_check_stateh+0x5e>
	{
		if(current_state == USB_STATE_DETACHED)
 801b5f6:	f640 4371 	movw	r3, #3185	; 0xc71
 801b5fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b5fe:	781b      	ldrb	r3, [r3, #0]
 801b600:	2b10      	cmp	r3, #16
 801b602:	d106      	bne.n	801b612 <_Z15cdc_check_stateh+0x4a>
		{
			isOnline = 0;
 801b604:	f640 4370 	movw	r3, #3184	; 0xc70
 801b608:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b60c:	f04f 0200 	mov.w	r2, #0
 801b610:	701a      	strb	r2, [r3, #0]
			//if(gpUart[e_uart_2] == this)
			//	gpUart[e_uart_2] = NULL;
		}

		last_state = current_state;
 801b612:	f640 4371 	movw	r3, #3185	; 0xc71
 801b616:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b61a:	781a      	ldrb	r2, [r3, #0]
 801b61c:	f640 4372 	movw	r3, #3186	; 0xc72
 801b620:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b624:	701a      	strb	r2, [r3, #0]
	}
	if(!isOnline && mpFtdi != NULL && mpFtdi->GetAddress() != 0)
 801b626:	f640 4370 	movw	r3, #3184	; 0xc70
 801b62a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b62e:	781b      	ldrb	r3, [r3, #0]
 801b630:	2b00      	cmp	r3, #0
 801b632:	d11c      	bne.n	801b66e <_Z15cdc_check_stateh+0xa6>
 801b634:	f640 436c 	movw	r3, #3180	; 0xc6c
 801b638:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b63c:	681b      	ldr	r3, [r3, #0]
 801b63e:	2b00      	cmp	r3, #0
 801b640:	d015      	beq.n	801b66e <_Z15cdc_check_stateh+0xa6>
 801b642:	f640 436c 	movw	r3, #3180	; 0xc6c
 801b646:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b64a:	681b      	ldr	r3, [r3, #0]
 801b64c:	681b      	ldr	r3, [r3, #0]
 801b64e:	f103 0310 	add.w	r3, r3, #16
 801b652:	681a      	ldr	r2, [r3, #0]
 801b654:	f640 436c 	movw	r3, #3180	; 0xc6c
 801b658:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b65c:	681b      	ldr	r3, [r3, #0]
 801b65e:	4618      	mov	r0, r3
 801b660:	4790      	blx	r2
 801b662:	4603      	mov	r3, r0
 801b664:	2b00      	cmp	r3, #0
 801b666:	d002      	beq.n	801b66e <_Z15cdc_check_stateh+0xa6>
 801b668:	f04f 0301 	mov.w	r3, #1
 801b66c:	e001      	b.n	801b672 <_Z15cdc_check_stateh+0xaa>
 801b66e:	f04f 0300 	mov.w	r3, #0
 801b672:	2b00      	cmp	r3, #0
 801b674:	d006      	beq.n	801b684 <_Z15cdc_check_stateh+0xbc>
	{
		isOnline = 1;
 801b676:	f640 4370 	movw	r3, #3184	; 0xc70
 801b67a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b67e:	f04f 0201 	mov.w	r2, #1
 801b682:	701a      	strb	r2, [r3, #0]
	}
	//if(isOnline)
	//{
	//	handle_RxTxFifo(0x3);
	//}
}
 801b684:	f107 0708 	add.w	r7, r7, #8
 801b688:	46bd      	mov	sp, r7
 801b68a:	bd80      	pop	{r7, pc}

0801b68c <_ZN13FTDIAsyncOperC1Ev>:
#define FTDI_SIO_RI_MASK					0x40
#define FTDI_SIO_RLSD_MASK					0x80

class FTDI;

class FTDIAsyncOper
 801b68c:	b480      	push	{r7}
 801b68e:	b083      	sub	sp, #12
 801b690:	af00      	add	r7, sp, #0
 801b692:	6078      	str	r0, [r7, #4]
 801b694:	687b      	ldr	r3, [r7, #4]
 801b696:	4a04      	ldr	r2, [pc, #16]	; (801b6a8 <_ZN13FTDIAsyncOperC1Ev+0x1c>)
 801b698:	601a      	str	r2, [r3, #0]
 801b69a:	687b      	ldr	r3, [r7, #4]
 801b69c:	4618      	mov	r0, r3
 801b69e:	f107 070c 	add.w	r7, r7, #12
 801b6a2:	46bd      	mov	sp, r7
 801b6a4:	bc80      	pop	{r7}
 801b6a6:	4770      	bx	lr
 801b6a8:	08020798 	.word	0x08020798

0801b6ac <_ZN9FTDIAsyncC1Ev>:
extern USB Usb;

static FTDI *mpFtdi = NULL;
static uint8_t isOnline = 0;

class FTDIAsync : public FTDIAsyncOper
 801b6ac:	b580      	push	{r7, lr}
 801b6ae:	b082      	sub	sp, #8
 801b6b0:	af00      	add	r7, sp, #0
 801b6b2:	6078      	str	r0, [r7, #4]
 801b6b4:	687b      	ldr	r3, [r7, #4]
 801b6b6:	4618      	mov	r0, r3
 801b6b8:	f7ff ffe8 	bl	801b68c <_ZN13FTDIAsyncOperC1Ev>
 801b6bc:	687b      	ldr	r3, [r7, #4]
 801b6be:	4a04      	ldr	r2, [pc, #16]	; (801b6d0 <_ZN9FTDIAsyncC1Ev+0x24>)
 801b6c0:	601a      	str	r2, [r3, #0]
 801b6c2:	687b      	ldr	r3, [r7, #4]
 801b6c4:	4618      	mov	r0, r3
 801b6c6:	f107 0708 	add.w	r7, r7, #8
 801b6ca:	46bd      	mov	sp, r7
 801b6cc:	bd80      	pop	{r7, pc}
 801b6ce:	bf00      	nop
 801b6d0:	08020788 	.word	0x08020788

0801b6d4 <libuhs_class_cdc_init>:
	//}
}
extern "C" {	// class cdc api

void libuhs_class_cdc_init(uint32_t baudrate, uint8_t flow_control)
{
 801b6d4:	b590      	push	{r4, r7, lr}
 801b6d6:	b085      	sub	sp, #20
 801b6d8:	af00      	add	r7, sp, #0
 801b6da:	6078      	str	r0, [r7, #4]
 801b6dc:	460b      	mov	r3, r1
 801b6de:	70fb      	strb	r3, [r7, #3]
	/* --- CDC FTDI class --- */
	if(mpFtdi == NULL)
 801b6e0:	f640 436c 	movw	r3, #3180	; 0xc6c
 801b6e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b6e8:	681b      	ldr	r3, [r3, #0]
 801b6ea:	2b00      	cmp	r3, #0
 801b6ec:	d134      	bne.n	801b758 <libuhs_class_cdc_init+0x84>
	{
		FTDIAsync *pFtdiAsync = new FTDIAsync();
 801b6ee:	f04f 0004 	mov.w	r0, #4
 801b6f2:	f001 fdf5 	bl	801d2e0 <_Znwj>
 801b6f6:	4603      	mov	r3, r0
 801b6f8:	461c      	mov	r4, r3
 801b6fa:	f04f 0300 	mov.w	r3, #0
 801b6fe:	6023      	str	r3, [r4, #0]
 801b700:	4620      	mov	r0, r4
 801b702:	f7ff ffd3 	bl	801b6ac <_ZN9FTDIAsyncC1Ev>
 801b706:	60fc      	str	r4, [r7, #12]
		mpFtdi = new FTDI(&Usb, pFtdiAsync);
 801b708:	f04f 0038 	mov.w	r0, #56	; 0x38
 801b70c:	f001 fde8 	bl	801d2e0 <_Znwj>
 801b710:	4603      	mov	r3, r0
 801b712:	461c      	mov	r4, r3
 801b714:	4620      	mov	r0, r4
 801b716:	f640 3184 	movw	r1, #2948	; 0xb84
 801b71a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801b71e:	68fa      	ldr	r2, [r7, #12]
 801b720:	f000 f89a 	bl	801b858 <_ZN4FTDIC1EP3USBP13FTDIAsyncOper>
 801b724:	f640 436c 	movw	r3, #3180	; 0xc6c
 801b728:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b72c:	601c      	str	r4, [r3, #0]
		mpFtdi->baudrate = baudrate;
 801b72e:	f640 436c 	movw	r3, #3180	; 0xc6c
 801b732:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b736:	681b      	ldr	r3, [r3, #0]
 801b738:	687a      	ldr	r2, [r7, #4]
 801b73a:	631a      	str	r2, [r3, #48]	; 0x30
		mpFtdi->flow_control = flow_control;
 801b73c:	f640 436c 	movw	r3, #3180	; 0xc6c
 801b740:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b744:	681b      	ldr	r3, [r3, #0]
 801b746:	78fa      	ldrb	r2, [r7, #3]
 801b748:	b292      	uxth	r2, r2
 801b74a:	869a      	strh	r2, [r3, #52]	; 0x34
 801b74c:	e005      	b.n	801b75a <libuhs_class_cdc_init+0x86>
{
	/* --- CDC FTDI class --- */
	if(mpFtdi == NULL)
	{
		FTDIAsync *pFtdiAsync = new FTDIAsync();
		mpFtdi = new FTDI(&Usb, pFtdiAsync);
 801b74e:	4620      	mov	r0, r4
 801b750:	f001 f992 	bl	801ca78 <_ZdlPv>
 801b754:	f001 f994 	bl	801ca80 <__cxa_end_cleanup>
		mpFtdi->baudrate = baudrate;
		mpFtdi->flow_control = flow_control;
	}
}
 801b758:	bf00      	nop
 801b75a:	f107 0714 	add.w	r7, r7, #20
 801b75e:	46bd      	mov	sp, r7
 801b760:	bd90      	pop	{r4, r7, pc}
 801b762:	bf00      	nop

0801b764 <libuhs_class_cdc_deinit>:

void libuhs_class_cdc_deinit(void)
{
 801b764:	b598      	push	{r3, r4, r7, lr}
 801b766:	af00      	add	r7, sp, #0
	if(mpFtdi != NULL)
 801b768:	f640 436c 	movw	r3, #3180	; 0xc6c
 801b76c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b770:	681b      	ldr	r3, [r3, #0]
 801b772:	2b00      	cmp	r3, #0
 801b774:	d00c      	beq.n	801b790 <libuhs_class_cdc_deinit+0x2c>
	{
		delete mpFtdi;
 801b776:	f640 436c 	movw	r3, #3180	; 0xc6c
 801b77a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b77e:	681c      	ldr	r4, [r3, #0]
 801b780:	2c00      	cmp	r4, #0
 801b782:	d005      	beq.n	801b790 <libuhs_class_cdc_deinit+0x2c>
 801b784:	4620      	mov	r0, r4
 801b786:	f000 f905 	bl	801b994 <_ZN4FTDID1Ev>
 801b78a:	4620      	mov	r0, r4
 801b78c:	f001 f974 	bl	801ca78 <_ZdlPv>
	}
}
 801b790:	bd98      	pop	{r3, r4, r7, pc}
 801b792:	bf00      	nop

0801b794 <libuhs_class_cdc_receive_data>:

uint8_t libuhs_class_cdc_receive_data(uint16_t *bytes_rcvd, uint8_t *dataptr)
{
 801b794:	b580      	push	{r7, lr}
 801b796:	b082      	sub	sp, #8
 801b798:	af00      	add	r7, sp, #0
 801b79a:	6078      	str	r0, [r7, #4]
 801b79c:	6039      	str	r1, [r7, #0]
	if(mpFtdi != NULL)
 801b79e:	f640 436c 	movw	r3, #3180	; 0xc6c
 801b7a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b7a6:	681b      	ldr	r3, [r3, #0]
 801b7a8:	2b00      	cmp	r3, #0
 801b7aa:	d00b      	beq.n	801b7c4 <libuhs_class_cdc_receive_data+0x30>
		return mpFtdi->RcvData(bytes_rcvd, dataptr);
 801b7ac:	f640 436c 	movw	r3, #3180	; 0xc6c
 801b7b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b7b4:	681b      	ldr	r3, [r3, #0]
 801b7b6:	4618      	mov	r0, r3
 801b7b8:	6879      	ldr	r1, [r7, #4]
 801b7ba:	683a      	ldr	r2, [r7, #0]
 801b7bc:	f000 fe30 	bl	801c420 <_ZN4FTDI7RcvDataEPtPh>
 801b7c0:	4603      	mov	r3, r0
 801b7c2:	e7ff      	b.n	801b7c4 <libuhs_class_cdc_receive_data+0x30>
}
 801b7c4:	4618      	mov	r0, r3
 801b7c6:	f107 0708 	add.w	r7, r7, #8
 801b7ca:	46bd      	mov	sp, r7
 801b7cc:	bd80      	pop	{r7, pc}
 801b7ce:	bf00      	nop

0801b7d0 <libuhs_class_cdc_send_data>:

uint8_t libuhs_class_cdc_send_data(uint16_t nbytes, const uint8_t *dataptr)
{
 801b7d0:	b580      	push	{r7, lr}
 801b7d2:	b082      	sub	sp, #8
 801b7d4:	af00      	add	r7, sp, #0
 801b7d6:	4603      	mov	r3, r0
 801b7d8:	6039      	str	r1, [r7, #0]
 801b7da:	80fb      	strh	r3, [r7, #6]
	if(mpFtdi != NULL)
 801b7dc:	f640 436c 	movw	r3, #3180	; 0xc6c
 801b7e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b7e4:	681b      	ldr	r3, [r3, #0]
 801b7e6:	2b00      	cmp	r3, #0
 801b7e8:	d00c      	beq.n	801b804 <libuhs_class_cdc_send_data+0x34>
		return mpFtdi->SndData(nbytes, dataptr);
 801b7ea:	f640 436c 	movw	r3, #3180	; 0xc6c
 801b7ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b7f2:	681a      	ldr	r2, [r3, #0]
 801b7f4:	88fb      	ldrh	r3, [r7, #6]
 801b7f6:	4610      	mov	r0, r2
 801b7f8:	4619      	mov	r1, r3
 801b7fa:	683a      	ldr	r2, [r7, #0]
 801b7fc:	f000 fe2c 	bl	801c458 <_ZN4FTDI7SndDataEtPKh>
 801b800:	4603      	mov	r3, r0
 801b802:	e7ff      	b.n	801b804 <libuhs_class_cdc_send_data+0x34>
}
 801b804:	4618      	mov	r0, r3
 801b806:	f107 0708 	add.w	r7, r7, #8
 801b80a:	46bd      	mov	sp, r7
 801b80c:	bd80      	pop	{r7, pc}
 801b80e:	bf00      	nop

0801b810 <libuhs_class_cdc_is_ready>:

uint8_t libuhs_class_cdc_is_ready(void)
{
 801b810:	b480      	push	{r7}
 801b812:	af00      	add	r7, sp, #0
	return isOnline;
 801b814:	f640 4370 	movw	r3, #3184	; 0xc70
 801b818:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b81c:	781b      	ldrb	r3, [r3, #0]
}
 801b81e:	4618      	mov	r0, r3
 801b820:	46bd      	mov	sp, r7
 801b822:	bc80      	pop	{r7}
 801b824:	4770      	bx	lr
 801b826:	bf00      	nop

0801b828 <_ZN4FTDI10GetAddressEv>:
	// USBDeviceConfig implementation
	virtual uint8_t Init(uint8_t parent, uint8_t port, bool lowspeed);
	virtual uint8_t Release();
	virtual uint8_t Poll();

	virtual uint8_t GetAddress() {
 801b828:	b480      	push	{r7}
 801b82a:	b083      	sub	sp, #12
 801b82c:	af00      	add	r7, sp, #0
 801b82e:	6078      	str	r0, [r7, #4]
		return bAddress;
 801b830:	687b      	ldr	r3, [r7, #4]
 801b832:	7c1b      	ldrb	r3, [r3, #16]
	};
 801b834:	4618      	mov	r0, r3
 801b836:	f107 070c 	add.w	r7, r7, #12
 801b83a:	46bd      	mov	sp, r7
 801b83c:	bc80      	pop	{r7}
 801b83e:	4770      	bx	lr

0801b840 <_ZN4FTDI7isReadyEv>:

	virtual bool isReady() {
 801b840:	b480      	push	{r7}
 801b842:	b083      	sub	sp, #12
 801b844:	af00      	add	r7, sp, #0
 801b846:	6078      	str	r0, [r7, #4]
		return ready;
 801b848:	687b      	ldr	r3, [r7, #4]
 801b84a:	7d1b      	ldrb	r3, [r3, #20]
	};
 801b84c:	4618      	mov	r0, r3
 801b84e:	f107 070c 	add.w	r7, r7, #12
 801b852:	46bd      	mov	sp, r7
 801b854:	bc80      	pop	{r7}
 801b856:	4770      	bx	lr

0801b858 <_ZN4FTDIC1EP3USBP13FTDIAsyncOper>:

const uint8_t FTDI::epDataInIndex = 1;
const uint8_t FTDI::epDataOutIndex = 2;
const uint8_t FTDI::epInterruptInIndex = 3;

FTDI::FTDI(USB *p, FTDIAsyncOper *pasync) :
 801b858:	b580      	push	{r7, lr}
 801b85a:	b086      	sub	sp, #24
 801b85c:	af00      	add	r7, sp, #0
 801b85e:	60f8      	str	r0, [r7, #12]
 801b860:	60b9      	str	r1, [r7, #8]
 801b862:	607a      	str	r2, [r7, #4]
bAddress(0),
bNumEP(1),
ready(false),
wFTDIType(0),
baudrate(115200),
flow_control(0)
 801b864:	68fb      	ldr	r3, [r7, #12]
 801b866:	4618      	mov	r0, r3
 801b868:	f7fb fa76 	bl	8016d58 <_ZN15USBDeviceConfigC1Ev>
 801b86c:	68fb      	ldr	r3, [r7, #12]
 801b86e:	f103 0304 	add.w	r3, r3, #4
 801b872:	4618      	mov	r0, r3
 801b874:	f7fb fa80 	bl	8016d78 <_ZN17UsbConfigXtracterC1Ev>
 801b878:	68fb      	ldr	r3, [r7, #12]
 801b87a:	4a44      	ldr	r2, [pc, #272]	; (801b98c <_ZN4FTDIC1EP3USBP13FTDIAsyncOper+0x134>)
 801b87c:	601a      	str	r2, [r3, #0]
 801b87e:	68fb      	ldr	r3, [r7, #12]
 801b880:	4a43      	ldr	r2, [pc, #268]	; (801b990 <_ZN4FTDIC1EP3USBP13FTDIAsyncOper+0x138>)
 801b882:	605a      	str	r2, [r3, #4]
 801b884:	68fb      	ldr	r3, [r7, #12]
 801b886:	687a      	ldr	r2, [r7, #4]
 801b888:	609a      	str	r2, [r3, #8]
 801b88a:	68fb      	ldr	r3, [r7, #12]
 801b88c:	68ba      	ldr	r2, [r7, #8]
 801b88e:	60da      	str	r2, [r3, #12]
 801b890:	68fb      	ldr	r3, [r7, #12]
 801b892:	f04f 0200 	mov.w	r2, #0
 801b896:	741a      	strb	r2, [r3, #16]
 801b898:	68fb      	ldr	r3, [r7, #12]
 801b89a:	f04f 0201 	mov.w	r2, #1
 801b89e:	74da      	strb	r2, [r3, #19]
 801b8a0:	68fb      	ldr	r3, [r7, #12]
 801b8a2:	f04f 0200 	mov.w	r2, #0
 801b8a6:	751a      	strb	r2, [r3, #20]
 801b8a8:	68fb      	ldr	r3, [r7, #12]
 801b8aa:	f04f 0200 	mov.w	r2, #0
 801b8ae:	83da      	strh	r2, [r3, #30]
 801b8b0:	68fb      	ldr	r3, [r7, #12]
 801b8b2:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 801b8b6:	631a      	str	r2, [r3, #48]	; 0x30
 801b8b8:	68fb      	ldr	r3, [r7, #12]
 801b8ba:	f04f 0200 	mov.w	r2, #0
 801b8be:	869a      	strh	r2, [r3, #52]	; 0x34
{
	for (uint8_t i = 0; i < FTDI_MAX_ENDPOINTS; i++)
 801b8c0:	f04f 0300 	mov.w	r3, #0
 801b8c4:	75fb      	strb	r3, [r7, #23]
 801b8c6:	e048      	b.n	801b95a <_ZN4FTDIC1EP3USBP13FTDIAsyncOper+0x102>
	{
		epInfo[i].epAddr = 0;
 801b8c8:	7dfa      	ldrb	r2, [r7, #23]
 801b8ca:	68f9      	ldr	r1, [r7, #12]
 801b8cc:	4613      	mov	r3, r2
 801b8ce:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b8d2:	189b      	adds	r3, r3, r2
 801b8d4:	18cb      	adds	r3, r1, r3
 801b8d6:	f103 0320 	add.w	r3, r3, #32
 801b8da:	f04f 0200 	mov.w	r2, #0
 801b8de:	701a      	strb	r2, [r3, #0]
		epInfo[i].maxPktSize = (i) ? 0 : 8;
 801b8e0:	7df9      	ldrb	r1, [r7, #23]
 801b8e2:	7dfb      	ldrb	r3, [r7, #23]
 801b8e4:	2b00      	cmp	r3, #0
 801b8e6:	d002      	beq.n	801b8ee <_ZN4FTDIC1EP3USBP13FTDIAsyncOper+0x96>
 801b8e8:	f04f 0200 	mov.w	r2, #0
 801b8ec:	e001      	b.n	801b8f2 <_ZN4FTDIC1EP3USBP13FTDIAsyncOper+0x9a>
 801b8ee:	f04f 0208 	mov.w	r2, #8
 801b8f2:	68f8      	ldr	r0, [r7, #12]
 801b8f4:	460b      	mov	r3, r1
 801b8f6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b8fa:	185b      	adds	r3, r3, r1
 801b8fc:	18c3      	adds	r3, r0, r3
 801b8fe:	f103 0320 	add.w	r3, r3, #32
 801b902:	705a      	strb	r2, [r3, #1]
		epInfo[i].epAttribs = 0;
 801b904:	7dfa      	ldrb	r2, [r7, #23]
 801b906:	68f9      	ldr	r1, [r7, #12]
 801b908:	4613      	mov	r3, r2
 801b90a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b90e:	189b      	adds	r3, r3, r2
 801b910:	18cb      	adds	r3, r1, r3
 801b912:	f103 0320 	add.w	r3, r3, #32
 801b916:	f04f 0200 	mov.w	r2, #0
 801b91a:	711a      	strb	r2, [r3, #4]

		//if (!i)
		epInfo[i].bmNakPower = USB_NAK_MAX_POWER;
 801b91c:	7dfa      	ldrb	r2, [r7, #23]
 801b91e:	68f9      	ldr	r1, [r7, #12]
 801b920:	4613      	mov	r3, r2
 801b922:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b926:	189b      	adds	r3, r3, r2
 801b928:	18cb      	adds	r3, r1, r3
 801b92a:	f103 0220 	add.w	r2, r3, #32
 801b92e:	7913      	ldrb	r3, [r2, #4]
 801b930:	f04f 010f 	mov.w	r1, #15
 801b934:	f361 0387 	bfi	r3, r1, #2, #6
 801b938:	7113      	strb	r3, [r2, #4]
		epInfo[i].hcNumber = 0;
 801b93a:	7dfa      	ldrb	r2, [r7, #23]
 801b93c:	68f9      	ldr	r1, [r7, #12]
 801b93e:	4613      	mov	r3, r2
 801b940:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b944:	189b      	adds	r3, r3, r2
 801b946:	18cb      	adds	r3, r1, r3
 801b948:	f103 0320 	add.w	r3, r3, #32
 801b94c:	f04f 0200 	mov.w	r2, #0
 801b950:	70da      	strb	r2, [r3, #3]
ready(false),
wFTDIType(0),
baudrate(115200),
flow_control(0)
{
	for (uint8_t i = 0; i < FTDI_MAX_ENDPOINTS; i++)
 801b952:	7dfb      	ldrb	r3, [r7, #23]
 801b954:	f103 0301 	add.w	r3, r3, #1
 801b958:	75fb      	strb	r3, [r7, #23]
 801b95a:	7dfb      	ldrb	r3, [r7, #23]
 801b95c:	2b02      	cmp	r3, #2
 801b95e:	bf8c      	ite	hi
 801b960:	2300      	movhi	r3, #0
 801b962:	2301      	movls	r3, #1
 801b964:	b2db      	uxtb	r3, r3
 801b966:	2b00      	cmp	r3, #0
 801b968:	d1ae      	bne.n	801b8c8 <_ZN4FTDIC1EP3USBP13FTDIAsyncOper+0x70>

		//if (!i)
		epInfo[i].bmNakPower = USB_NAK_MAX_POWER;
		epInfo[i].hcNumber = 0;
	}
	if (pUsb)
 801b96a:	68fb      	ldr	r3, [r7, #12]
 801b96c:	68db      	ldr	r3, [r3, #12]
 801b96e:	2b00      	cmp	r3, #0
 801b970:	d006      	beq.n	801b980 <_ZN4FTDIC1EP3USBP13FTDIAsyncOper+0x128>
		pUsb->RegisterDeviceClass(this);
 801b972:	68fb      	ldr	r3, [r7, #12]
 801b974:	68da      	ldr	r2, [r3, #12]
 801b976:	68fb      	ldr	r3, [r7, #12]
 801b978:	4610      	mov	r0, r2
 801b97a:	4619      	mov	r1, r3
 801b97c:	f7fa fd5c 	bl	8016438 <_ZN3USB19RegisterDeviceClassEP15USBDeviceConfig>
}
 801b980:	68fb      	ldr	r3, [r7, #12]
 801b982:	4618      	mov	r0, r3
 801b984:	f107 0718 	add.w	r7, r7, #24
 801b988:	46bd      	mov	sp, r7
 801b98a:	bd80      	pop	{r7, pc}
 801b98c:	080207f0 	.word	0x080207f0
 801b990:	08020820 	.word	0x08020820

0801b994 <_ZN4FTDID1Ev>:

FTDI::~FTDI()
 801b994:	b580      	push	{r7, lr}
 801b996:	b082      	sub	sp, #8
 801b998:	af00      	add	r7, sp, #0
 801b99a:	6078      	str	r0, [r7, #4]
 801b99c:	687b      	ldr	r3, [r7, #4]
 801b99e:	4a0a      	ldr	r2, [pc, #40]	; (801b9c8 <_ZN4FTDID1Ev+0x34>)
 801b9a0:	601a      	str	r2, [r3, #0]
 801b9a2:	687b      	ldr	r3, [r7, #4]
 801b9a4:	4a09      	ldr	r2, [pc, #36]	; (801b9cc <_ZN4FTDID1Ev+0x38>)
 801b9a6:	605a      	str	r2, [r3, #4]
{
	if(pAsync != NULL)
 801b9a8:	687b      	ldr	r3, [r7, #4]
 801b9aa:	689b      	ldr	r3, [r3, #8]
 801b9ac:	2b00      	cmp	r3, #0
 801b9ae:	d004      	beq.n	801b9ba <_ZN4FTDID1Ev+0x26>
		delete pAsync;
 801b9b0:	687b      	ldr	r3, [r7, #4]
 801b9b2:	689b      	ldr	r3, [r3, #8]
 801b9b4:	4618      	mov	r0, r3
 801b9b6:	f001 f85f 	bl	801ca78 <_ZdlPv>
}
 801b9ba:	687b      	ldr	r3, [r7, #4]
 801b9bc:	4618      	mov	r0, r3
 801b9be:	f107 0708 	add.w	r7, r7, #8
 801b9c2:	46bd      	mov	sp, r7
 801b9c4:	bd80      	pop	{r7, pc}
 801b9c6:	bf00      	nop
 801b9c8:	080207f0 	.word	0x080207f0
 801b9cc:	08020820 	.word	0x08020820

0801b9d0 <_ZN4FTDI4InitEhhb>:
uint8_t FTDI::Init(uint8_t parent, uint8_t port, bool lowspeed) {
 801b9d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 801b9d2:	b0a1      	sub	sp, #132	; 0x84
 801b9d4:	af06      	add	r7, sp, #24
 801b9d6:	6078      	str	r0, [r7, #4]
 801b9d8:	70f9      	strb	r1, [r7, #3]
 801b9da:	70ba      	strb	r2, [r7, #2]
 801b9dc:	707b      	strb	r3, [r7, #1]
	const uint8_t constBufSize = sizeof (USB_DEVICE_DESCRIPTOR);
 801b9de:	f04f 0312 	mov.w	r3, #18
 801b9e2:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65

	uint8_t buf[constBufSize];
	uint8_t rcode;
	UsbDevice *p = NULL;
 801b9e6:	f04f 0300 	mov.w	r3, #0
 801b9ea:	663b      	str	r3, [r7, #96]	; 0x60
	EpInfo *oldep_ptr = NULL;
 801b9ec:	f04f 0300 	mov.w	r3, #0
 801b9f0:	65fb      	str	r3, [r7, #92]	; 0x5c
	//uint8_t		len = 0;
	//uint16_t	cd_len = 0;
	uint8_t ep_no = 0;
 801b9f2:	f04f 0300 	mov.w	r3, #0
 801b9f6:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b

	uint8_t num_of_conf; // number of configurations
	//uint8_t		num_of_intf;	// number of interfaces

	AddressPool &addrPool = pUsb->GetAddressPool();
 801b9fa:	687b      	ldr	r3, [r7, #4]
 801b9fc:	68db      	ldr	r3, [r3, #12]
 801b9fe:	4618      	mov	r0, r3
 801ba00:	f7f8 fd0a 	bl	8014418 <_ZN3USB14GetAddressPoolEv>
 801ba04:	6578      	str	r0, [r7, #84]	; 0x54

	USBTRACE("FTDI Init\r\n");
 801ba06:	f64e 709c 	movw	r0, #61340	; 0xef9c
 801ba0a:	f6c0 0001 	movt	r0, #2049	; 0x801
 801ba0e:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ba12:	f7fd fccf 	bl	80193b4 <_Z8E_NotifyPKci>

	if (bAddress)
 801ba16:	687b      	ldr	r3, [r7, #4]
 801ba18:	7c1b      	ldrb	r3, [r3, #16]
 801ba1a:	2b00      	cmp	r3, #0
 801ba1c:	d002      	beq.n	801ba24 <_ZN4FTDI4InitEhhb+0x54>
		return USB_ERROR_CLASS_INSTANCE_ALREADY_IN_USE;
 801ba1e:	f04f 03d9 	mov.w	r3, #217	; 0xd9
 801ba22:	e29b      	b.n	801bf5c <_ZN4FTDI4InitEhhb+0x58c>

	// Get pointer to pseudo device with address 0 assigned
	p = addrPool.GetUsbDevicePtr(0);
 801ba24:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801ba26:	681b      	ldr	r3, [r3, #0]
 801ba28:	681b      	ldr	r3, [r3, #0]
 801ba2a:	6d78      	ldr	r0, [r7, #84]	; 0x54
 801ba2c:	f04f 0100 	mov.w	r1, #0
 801ba30:	4798      	blx	r3
 801ba32:	4603      	mov	r3, r0
 801ba34:	663b      	str	r3, [r7, #96]	; 0x60

	if (!p)
 801ba36:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ba38:	2b00      	cmp	r3, #0
 801ba3a:	d102      	bne.n	801ba42 <_ZN4FTDI4InitEhhb+0x72>
		return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
 801ba3c:	f04f 03d6 	mov.w	r3, #214	; 0xd6
 801ba40:	e28c      	b.n	801bf5c <_ZN4FTDI4InitEhhb+0x58c>

	if (!p->epinfo) {
 801ba42:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ba44:	681b      	ldr	r3, [r3, #0]
 801ba46:	2b00      	cmp	r3, #0
 801ba48:	d10a      	bne.n	801ba60 <_ZN4FTDI4InitEhhb+0x90>
		USBTRACE("epinfo\r\n");
 801ba4a:	f64e 70a8 	movw	r0, #61352	; 0xefa8
 801ba4e:	f6c0 0001 	movt	r0, #2049	; 0x801
 801ba52:	f04f 0180 	mov.w	r1, #128	; 0x80
 801ba56:	f7fd fcad 	bl	80193b4 <_Z8E_NotifyPKci>
		return USB_ERROR_EPINFO_IS_NULL;
 801ba5a:	f04f 03d7 	mov.w	r3, #215	; 0xd7
 801ba5e:	e27d      	b.n	801bf5c <_ZN4FTDI4InitEhhb+0x58c>
	}

	// Save old pointer to EP_RECORD of address 0
	oldep_ptr = p->epinfo;
 801ba60:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ba62:	681b      	ldr	r3, [r3, #0]
 801ba64:	65fb      	str	r3, [r7, #92]	; 0x5c

	// Temporary assign new pointer to epInfo to p->epinfo in order to avoid toggle inconsistence
	p->epinfo = epInfo;
 801ba66:	687b      	ldr	r3, [r7, #4]
 801ba68:	f103 0220 	add.w	r2, r3, #32
 801ba6c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ba6e:	601a      	str	r2, [r3, #0]
	p->epinfo->hcNumber = oldep_ptr->hcNumber;	// still use mother's host channel
 801ba70:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ba72:	681b      	ldr	r3, [r3, #0]
 801ba74:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801ba76:	78d2      	ldrb	r2, [r2, #3]
 801ba78:	70da      	strb	r2, [r3, #3]
	p->lowspeed = lowspeed;
 801ba7a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ba7c:	787a      	ldrb	r2, [r7, #1]
 801ba7e:	719a      	strb	r2, [r3, #6]

	// Get device descriptor
	rcode = pUsb->getDevDescr(0, 0, sizeof (USB_DEVICE_DESCRIPTOR), (uint8_t*)buf);
 801ba80:	687b      	ldr	r3, [r7, #4]
 801ba82:	68db      	ldr	r3, [r3, #12]
 801ba84:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801ba88:	9200      	str	r2, [sp, #0]
 801ba8a:	4618      	mov	r0, r3
 801ba8c:	f04f 0100 	mov.w	r1, #0
 801ba90:	f04f 0200 	mov.w	r2, #0
 801ba94:	f04f 0312 	mov.w	r3, #18
 801ba98:	f7fa f828 	bl	8015aec <_ZN3USB11getDevDescrEhhtPh>
 801ba9c:	4603      	mov	r3, r0
 801ba9e:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67

	// Restore p->epinfo
	p->epinfo = oldep_ptr;
 801baa2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801baa4:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801baa6:	601a      	str	r2, [r3, #0]

	if (rcode)
 801baa8:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801baac:	2b00      	cmp	r3, #0
 801baae:	f040 822f 	bne.w	801bf10 <_ZN4FTDI4InitEhhb+0x540>
		goto FailGetDevDescr;

	if (((USB_DEVICE_DESCRIPTOR*)buf)->idVendor != FTDI_VID || ((USB_DEVICE_DESCRIPTOR*)buf)->idProduct != FTDI_PID)
 801bab2:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801bab6:	891b      	ldrh	r3, [r3, #8]
 801bab8:	b29a      	uxth	r2, r3
 801baba:	f240 4303 	movw	r3, #1027	; 0x403
 801babe:	429a      	cmp	r2, r3
 801bac0:	d107      	bne.n	801bad2 <_ZN4FTDI4InitEhhb+0x102>
 801bac2:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801bac6:	895b      	ldrh	r3, [r3, #10]
 801bac8:	b29a      	uxth	r2, r3
 801baca:	f246 0301 	movw	r3, #24577	; 0x6001
 801bace:	429a      	cmp	r2, r3
 801bad0:	d002      	beq.n	801bad8 <_ZN4FTDI4InitEhhb+0x108>
		return USB_DEV_CONFIG_ERROR_DEVICE_NOT_SUPPORTED;
 801bad2:	f04f 03d1 	mov.w	r3, #209	; 0xd1
 801bad6:	e241      	b.n	801bf5c <_ZN4FTDI4InitEhhb+0x58c>

	// Save type of FTDI chip
	wFTDIType = ((USB_DEVICE_DESCRIPTOR*)buf)->bcdDevice;
 801bad8:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801badc:	899b      	ldrh	r3, [r3, #12]
 801bade:	b29a      	uxth	r2, r3
 801bae0:	687b      	ldr	r3, [r7, #4]
 801bae2:	83da      	strh	r2, [r3, #30]

	// Allocate new address according to device class
	bAddress = addrPool.AllocAddress(parent, false, port);
 801bae4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bae6:	681b      	ldr	r3, [r3, #0]
 801bae8:	f103 0304 	add.w	r3, r3, #4
 801baec:	681c      	ldr	r4, [r3, #0]
 801baee:	78fa      	ldrb	r2, [r7, #3]
 801baf0:	78bb      	ldrb	r3, [r7, #2]
 801baf2:	6d78      	ldr	r0, [r7, #84]	; 0x54
 801baf4:	4611      	mov	r1, r2
 801baf6:	f04f 0200 	mov.w	r2, #0
 801bafa:	47a0      	blx	r4
 801bafc:	4603      	mov	r3, r0
 801bafe:	461a      	mov	r2, r3
 801bb00:	687b      	ldr	r3, [r7, #4]
 801bb02:	741a      	strb	r2, [r3, #16]

	if (!bAddress)
 801bb04:	687b      	ldr	r3, [r7, #4]
 801bb06:	7c1b      	ldrb	r3, [r3, #16]
 801bb08:	2b00      	cmp	r3, #0
 801bb0a:	d102      	bne.n	801bb12 <_ZN4FTDI4InitEhhb+0x142>
		return USB_ERROR_OUT_OF_ADDRESS_SPACE_IN_POOL;
 801bb0c:	f04f 03d4 	mov.w	r3, #212	; 0xd4
 801bb10:	e224      	b.n	801bf5c <_ZN4FTDI4InitEhhb+0x58c>

	// Extract Max Packet Size from the device descriptor
	epInfo[0].maxPktSize = (uint8_t)((USB_DEVICE_DESCRIPTOR*)buf)->bMaxPacketSize0;
 801bb12:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801bb16:	79da      	ldrb	r2, [r3, #7]
 801bb18:	687b      	ldr	r3, [r7, #4]
 801bb1a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

	// Assign new address to the device
	rcode = pUsb->setAddr(0, 0, bAddress);
 801bb1e:	687b      	ldr	r3, [r7, #4]
 801bb20:	68da      	ldr	r2, [r3, #12]
 801bb22:	687b      	ldr	r3, [r7, #4]
 801bb24:	7c1b      	ldrb	r3, [r3, #16]
 801bb26:	4610      	mov	r0, r2
 801bb28:	f04f 0100 	mov.w	r1, #0
 801bb2c:	f04f 0200 	mov.w	r2, #0
 801bb30:	f7fa f8cc 	bl	8015ccc <_ZN3USB7setAddrEhhh>
 801bb34:	4603      	mov	r3, r0
 801bb36:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67

	if (rcode) {
 801bb3a:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801bb3e:	2b00      	cmp	r3, #0
 801bb40:	d02b      	beq.n	801bb9a <_ZN4FTDI4InitEhhb+0x1ca>
		p->lowspeed = false;
 801bb42:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801bb44:	f04f 0200 	mov.w	r2, #0
 801bb48:	719a      	strb	r2, [r3, #6]
		addrPool.FreeAddress(bAddress);
 801bb4a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bb4c:	681b      	ldr	r3, [r3, #0]
 801bb4e:	f103 0308 	add.w	r3, r3, #8
 801bb52:	681b      	ldr	r3, [r3, #0]
 801bb54:	687a      	ldr	r2, [r7, #4]
 801bb56:	7c12      	ldrb	r2, [r2, #16]
 801bb58:	6d78      	ldr	r0, [r7, #84]	; 0x54
 801bb5a:	4611      	mov	r1, r2
 801bb5c:	4798      	blx	r3
		bAddress = 0;
 801bb5e:	687b      	ldr	r3, [r7, #4]
 801bb60:	f04f 0200 	mov.w	r2, #0
 801bb64:	741a      	strb	r2, [r3, #16]
		USBTRACE2("setAddr:", rcode);
 801bb66:	f64e 70b4 	movw	r0, #61364	; 0xefb4
 801bb6a:	f6c0 0001 	movt	r0, #2049	; 0x801
 801bb6e:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bb72:	f7fd fc1f 	bl	80193b4 <_Z8E_NotifyPKci>
 801bb76:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801bb7a:	4618      	mov	r0, r3
 801bb7c:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bb80:	f7fa f982 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801bb84:	f64e 70c0 	movw	r0, #61376	; 0xefc0
 801bb88:	f6c0 0001 	movt	r0, #2049	; 0x801
 801bb8c:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bb90:	f7fd fc10 	bl	80193b4 <_Z8E_NotifyPKci>
		return rcode;
 801bb94:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801bb98:	e1e0      	b.n	801bf5c <_ZN4FTDI4InitEhhb+0x58c>
	}

	USBTRACE2("Addr:", bAddress);
 801bb9a:	f64e 70c4 	movw	r0, #61380	; 0xefc4
 801bb9e:	f6c0 0001 	movt	r0, #2049	; 0x801
 801bba2:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bba6:	f7fd fc05 	bl	80193b4 <_Z8E_NotifyPKci>
 801bbaa:	687b      	ldr	r3, [r7, #4]
 801bbac:	7c1b      	ldrb	r3, [r3, #16]
 801bbae:	4618      	mov	r0, r3
 801bbb0:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bbb4:	f7fa f968 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801bbb8:	f64e 70c0 	movw	r0, #61376	; 0xefc0
 801bbbc:	f6c0 0001 	movt	r0, #2049	; 0x801
 801bbc0:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bbc4:	f7fd fbf6 	bl	80193b4 <_Z8E_NotifyPKci>

	p->lowspeed = false;
 801bbc8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801bbca:	f04f 0200 	mov.w	r2, #0
 801bbce:	719a      	strb	r2, [r3, #6]

	p = addrPool.GetUsbDevicePtr(bAddress);
 801bbd0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bbd2:	681b      	ldr	r3, [r3, #0]
 801bbd4:	681b      	ldr	r3, [r3, #0]
 801bbd6:	687a      	ldr	r2, [r7, #4]
 801bbd8:	7c12      	ldrb	r2, [r2, #16]
 801bbda:	6d78      	ldr	r0, [r7, #84]	; 0x54
 801bbdc:	4611      	mov	r1, r2
 801bbde:	4798      	blx	r3
 801bbe0:	4603      	mov	r3, r0
 801bbe2:	663b      	str	r3, [r7, #96]	; 0x60

	if (!p)
 801bbe4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801bbe6:	2b00      	cmp	r3, #0
 801bbe8:	d102      	bne.n	801bbf0 <_ZN4FTDI4InitEhhb+0x220>
			return USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
 801bbea:	f04f 03d6 	mov.w	r3, #214	; 0xd6
 801bbee:	e1b5      	b.n	801bf5c <_ZN4FTDI4InitEhhb+0x58c>

	p->lowspeed = lowspeed;
 801bbf0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801bbf2:	787a      	ldrb	r2, [r7, #1]
 801bbf4:	719a      	strb	r2, [r3, #6]

	num_of_conf = ((USB_DEVICE_DESCRIPTOR*)buf)->bNumConfigurations;
 801bbf6:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801bbfa:	7c5b      	ldrb	r3, [r3, #17]
 801bbfc:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53

	// Assign epInfo to epinfo pointer
	rcode = pUsb->setEpInfoEntry(bAddress, 1, epInfo);
 801bc00:	687b      	ldr	r3, [r7, #4]
 801bc02:	68d9      	ldr	r1, [r3, #12]
 801bc04:	687b      	ldr	r3, [r7, #4]
 801bc06:	7c1a      	ldrb	r2, [r3, #16]
 801bc08:	687b      	ldr	r3, [r7, #4]
 801bc0a:	f103 0320 	add.w	r3, r3, #32
 801bc0e:	4608      	mov	r0, r1
 801bc10:	4611      	mov	r1, r2
 801bc12:	f04f 0201 	mov.w	r2, #1
 801bc16:	f7f8 fcbd 	bl	8014594 <_ZN3USB14setEpInfoEntryEhhP6EpInfo>
 801bc1a:	4603      	mov	r3, r0
 801bc1c:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67

	if (rcode)
 801bc20:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801bc24:	2b00      	cmp	r3, #0
 801bc26:	f040 8177 	bne.w	801bf18 <_ZN4FTDI4InitEhhb+0x548>
		goto FailSetDevTblEntry;

	USBTRACE2("NC:", num_of_conf);
 801bc2a:	f64e 70cc 	movw	r0, #61388	; 0xefcc
 801bc2e:	f6c0 0001 	movt	r0, #2049	; 0x801
 801bc32:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bc36:	f7fd fbbd 	bl	80193b4 <_Z8E_NotifyPKci>
 801bc3a:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 801bc3e:	4618      	mov	r0, r3
 801bc40:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bc44:	f7fa f920 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801bc48:	f64e 70c0 	movw	r0, #61376	; 0xefc0
 801bc4c:	f6c0 0001 	movt	r0, #2049	; 0x801
 801bc50:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bc54:	f7fd fbae 	bl	80193b4 <_Z8E_NotifyPKci>

	for (uint8_t i = 0; i < num_of_conf; i++) {
 801bc58:	f04f 0300 	mov.w	r3, #0
 801bc5c:	f887 3066 	strb.w	r3, [r7, #102]	; 0x66
 801bc60:	e029      	b.n	801bcb6 <_ZN4FTDI4InitEhhb+0x2e6>
		//HexDumper<USBReadParser, uint16_t, uint16_t> HexDump;
		ConfigDescParser < 0xFF, 0xFF, 0xFF, CP_MASK_COMPARE_ALL> confDescrParser(this);
 801bc62:	687b      	ldr	r3, [r7, #4]
 801bc64:	f103 0304 	add.w	r3, r3, #4
 801bc68:	f107 0208 	add.w	r2, r7, #8
 801bc6c:	4610      	mov	r0, r2
 801bc6e:	4619      	mov	r1, r3
 801bc70:	f000 fc80 	bl	801c574 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EEC1EP17UsbConfigXtracter>
		//rcode = pUsb->getConfDescr(bAddress, 0, i, &HexDump);

		//if (rcode)
		//	goto FailGetConfDescr;

		rcode = pUsb->getConfDescr(bAddress, 0, i, &confDescrParser);
 801bc74:	687b      	ldr	r3, [r7, #4]
 801bc76:	68d9      	ldr	r1, [r3, #12]
 801bc78:	687b      	ldr	r3, [r7, #4]
 801bc7a:	7c1a      	ldrb	r2, [r3, #16]
 801bc7c:	f897 3066 	ldrb.w	r3, [r7, #102]	; 0x66
 801bc80:	f107 0008 	add.w	r0, r7, #8
 801bc84:	9000      	str	r0, [sp, #0]
 801bc86:	4608      	mov	r0, r1
 801bc88:	4611      	mov	r1, r2
 801bc8a:	f04f 0200 	mov.w	r2, #0
 801bc8e:	f7f9 ff83 	bl	8015b98 <_ZN3USB12getConfDescrEhhhP13USBReadParser>
 801bc92:	4603      	mov	r3, r0
 801bc94:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67

		if (rcode)
 801bc98:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801bc9c:	2b00      	cmp	r3, #0
 801bc9e:	f040 813f 	bne.w	801bf20 <_ZN4FTDI4InitEhhb+0x550>
			goto FailGetConfDescr;

		if (bNumEP > 1)
 801bca2:	687b      	ldr	r3, [r7, #4]
 801bca4:	7cdb      	ldrb	r3, [r3, #19]
 801bca6:	2b01      	cmp	r3, #1
 801bca8:	d810      	bhi.n	801bccc <_ZN4FTDI4InitEhhb+0x2fc>
	if (rcode)
		goto FailSetDevTblEntry;

	USBTRACE2("NC:", num_of_conf);

	for (uint8_t i = 0; i < num_of_conf; i++) {
 801bcaa:	f897 3066 	ldrb.w	r3, [r7, #102]	; 0x66
 801bcae:	f103 0301 	add.w	r3, r3, #1
 801bcb2:	f887 3066 	strb.w	r3, [r7, #102]	; 0x66
 801bcb6:	f897 2066 	ldrb.w	r2, [r7, #102]	; 0x66
 801bcba:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 801bcbe:	429a      	cmp	r2, r3
 801bcc0:	bf2c      	ite	cs
 801bcc2:	2300      	movcs	r3, #0
 801bcc4:	2301      	movcc	r3, #1
 801bcc6:	b2db      	uxtb	r3, r3
 801bcc8:	2b00      	cmp	r3, #0
 801bcca:	d1ca      	bne.n	801bc62 <_ZN4FTDI4InitEhhb+0x292>

		if (bNumEP > 1)
			break;
	} // for

	if (bNumEP < 2)
 801bccc:	687b      	ldr	r3, [r7, #4]
 801bcce:	7cdb      	ldrb	r3, [r3, #19]
 801bcd0:	2b01      	cmp	r3, #1
 801bcd2:	d802      	bhi.n	801bcda <_ZN4FTDI4InitEhhb+0x30a>
		return USB_DEV_CONFIG_ERROR_DEVICE_NOT_SUPPORTED;
 801bcd4:	f04f 03d1 	mov.w	r3, #209	; 0xd1
 801bcd8:	e140      	b.n	801bf5c <_ZN4FTDI4InitEhhb+0x58c>

	USBTRACE2("NumEP:", bNumEP);
 801bcda:	f64e 70d0 	movw	r0, #61392	; 0xefd0
 801bcde:	f6c0 0001 	movt	r0, #2049	; 0x801
 801bce2:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bce6:	f7fd fb65 	bl	80193b4 <_Z8E_NotifyPKci>
 801bcea:	687b      	ldr	r3, [r7, #4]
 801bcec:	7cdb      	ldrb	r3, [r3, #19]
 801bcee:	4618      	mov	r0, r3
 801bcf0:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bcf4:	f7fa f8c8 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801bcf8:	f64e 70c0 	movw	r0, #61376	; 0xefc0
 801bcfc:	f6c0 0001 	movt	r0, #2049	; 0x801
 801bd00:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bd04:	f7fd fb56 	bl	80193b4 <_Z8E_NotifyPKci>

	// Assign epInfo to epinfo pointer
	rcode = pUsb->setEpInfoEntry(bAddress, bNumEP, epInfo);
 801bd08:	687b      	ldr	r3, [r7, #4]
 801bd0a:	68d8      	ldr	r0, [r3, #12]
 801bd0c:	687b      	ldr	r3, [r7, #4]
 801bd0e:	7c19      	ldrb	r1, [r3, #16]
 801bd10:	687b      	ldr	r3, [r7, #4]
 801bd12:	7cda      	ldrb	r2, [r3, #19]
 801bd14:	687b      	ldr	r3, [r7, #4]
 801bd16:	f103 0320 	add.w	r3, r3, #32
 801bd1a:	f7f8 fc3b 	bl	8014594 <_ZN3USB14setEpInfoEntryEhhP6EpInfo>
 801bd1e:	4603      	mov	r3, r0
 801bd20:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67

	USBTRACE2("Conf:", bConfNum);
 801bd24:	f64e 70d8 	movw	r0, #61400	; 0xefd8
 801bd28:	f6c0 0001 	movt	r0, #2049	; 0x801
 801bd2c:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bd30:	f7fd fb40 	bl	80193b4 <_Z8E_NotifyPKci>
 801bd34:	687b      	ldr	r3, [r7, #4]
 801bd36:	7c5b      	ldrb	r3, [r3, #17]
 801bd38:	4618      	mov	r0, r3
 801bd3a:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bd3e:	f7fa f8a3 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801bd42:	f64e 70c0 	movw	r0, #61376	; 0xefc0
 801bd46:	f6c0 0001 	movt	r0, #2049	; 0x801
 801bd4a:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bd4e:	f7fd fb31 	bl	80193b4 <_Z8E_NotifyPKci>

	// Set Configuration Value
	rcode = pUsb->setConf(bAddress, 0, bConfNum);
 801bd52:	687b      	ldr	r3, [r7, #4]
 801bd54:	68d9      	ldr	r1, [r3, #12]
 801bd56:	687b      	ldr	r3, [r7, #4]
 801bd58:	7c1a      	ldrb	r2, [r3, #16]
 801bd5a:	687b      	ldr	r3, [r7, #4]
 801bd5c:	7c5b      	ldrb	r3, [r3, #17]
 801bd5e:	4608      	mov	r0, r1
 801bd60:	4611      	mov	r1, r2
 801bd62:	f04f 0200 	mov.w	r2, #0
 801bd66:	f7f9 ffdf 	bl	8015d28 <_ZN3USB7setConfEhhh>
 801bd6a:	4603      	mov	r3, r0
 801bd6c:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67

	if (rcode)
 801bd70:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801bd74:	2b00      	cmp	r3, #0
 801bd76:	f040 80d6 	bne.w	801bf26 <_ZN4FTDI4InitEhhb+0x556>
		goto FailSetConfDescr;

	ep_no = usbhost_cb->device_added_cb(bAddress, lowspeed, epInfo[2].bmNakPower, epInfo[2].epAddr, epInfo[2].maxPktSize, eEpTypeBulk, epInfo[1].epAddr, epInfo[1].maxPktSize, eEpTypeBulk);
 801bd7a:	f243 6310 	movw	r3, #13840	; 0x3610
 801bd7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801bd82:	681b      	ldr	r3, [r3, #0]
 801bd84:	695c      	ldr	r4, [r3, #20]
 801bd86:	687b      	ldr	r3, [r7, #4]
 801bd88:	7c18      	ldrb	r0, [r3, #16]
 801bd8a:	7879      	ldrb	r1, [r7, #1]
 801bd8c:	687b      	ldr	r3, [r7, #4]
 801bd8e:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 801bd92:	f3c3 0385 	ubfx	r3, r3, #2, #6
 801bd96:	b2db      	uxtb	r3, r3
 801bd98:	461a      	mov	r2, r3
 801bd9a:	687b      	ldr	r3, [r7, #4]
 801bd9c:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 801bda0:	687d      	ldr	r5, [r7, #4]
 801bda2:	f895 e02b 	ldrb.w	lr, [r5, #43]	; 0x2b
 801bda6:	687d      	ldr	r5, [r7, #4]
 801bda8:	f895 6025 	ldrb.w	r6, [r5, #37]	; 0x25
 801bdac:	687d      	ldr	r5, [r7, #4]
 801bdae:	f895 5026 	ldrb.w	r5, [r5, #38]	; 0x26
 801bdb2:	f8cd e000 	str.w	lr, [sp]
 801bdb6:	f04f 0e02 	mov.w	lr, #2
 801bdba:	f8cd e004 	str.w	lr, [sp, #4]
 801bdbe:	9602      	str	r6, [sp, #8]
 801bdc0:	9503      	str	r5, [sp, #12]
 801bdc2:	f04f 0502 	mov.w	r5, #2
 801bdc6:	9504      	str	r5, [sp, #16]
 801bdc8:	47a0      	blx	r4
 801bdca:	4603      	mov	r3, r0
 801bdcc:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
    epInfo[2].hcNumOut = (ep_no >> 4) & 0xF;	//USBH_Alloc_Channel(pUsb->coreConfig, epInfo[2].epAddr);	//Out, addr = 0x01
 801bdd0:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 801bdd4:	ea4f 1313 	mov.w	r3, r3, lsr #4
 801bdd8:	b2db      	uxtb	r3, r3
 801bdda:	f003 030f 	and.w	r3, r3, #15
 801bdde:	b2d9      	uxtb	r1, r3
 801bde0:	687a      	ldr	r2, [r7, #4]
 801bde2:	f892 302d 	ldrb.w	r3, [r2, #45]	; 0x2d
 801bde6:	f361 1307 	bfi	r3, r1, #4, #4
 801bdea:	f882 302d 	strb.w	r3, [r2, #45]	; 0x2d
    epInfo[1].hcNumIn = ep_no & 0xF;	//USBH_Alloc_Channel(pUsb->coreConfig, epInfo[1].epAddr);		//In, addr = 0x82
 801bdee:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 801bdf2:	f003 030f 	and.w	r3, r3, #15
 801bdf6:	b2d9      	uxtb	r1, r3
 801bdf8:	687a      	ldr	r2, [r7, #4]
 801bdfa:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 801bdfe:	f361 0303 	bfi	r3, r1, #0, #4
 801be02:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    //USBH_Open_Channel(pUsb->coreConfig, epInfo[2].hcNumOut, bAddress,
    //		(lowspeed)?bmLOWSPEED:bmFULLSPEED, EP_TYPE_BULK, epInfo[2].maxPktSize);
    //USBH_Open_Channel(pUsb->coreConfig, epInfo[1].hcNumIn, bAddress,
    //		(lowspeed)?bmLOWSPEED:bmFULLSPEED, EP_TYPE_BULK, epInfo[1].maxPktSize);
    USBTRACE2("\nFTDI Pipe EP2 out = %x, ", epInfo[2].hcNumOut);
 801be06:	f64e 70e0 	movw	r0, #61408	; 0xefe0
 801be0a:	f6c0 0001 	movt	r0, #2049	; 0x801
 801be0e:	f04f 0180 	mov.w	r1, #128	; 0x80
 801be12:	f7fd facf 	bl	80193b4 <_Z8E_NotifyPKci>
 801be16:	687b      	ldr	r3, [r7, #4]
 801be18:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 801be1c:	f3c3 1303 	ubfx	r3, r3, #4, #4
 801be20:	b2db      	uxtb	r3, r3
 801be22:	4618      	mov	r0, r3
 801be24:	f04f 0180 	mov.w	r1, #128	; 0x80
 801be28:	f7fa f82e 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801be2c:	f64e 70c0 	movw	r0, #61376	; 0xefc0
 801be30:	f6c0 0001 	movt	r0, #2049	; 0x801
 801be34:	f04f 0180 	mov.w	r1, #128	; 0x80
 801be38:	f7fd fabc 	bl	80193b4 <_Z8E_NotifyPKci>
    USBTRACE2("addr = 0x%x(0x02)", epInfo[2].epAddr);
 801be3c:	f64e 70fc 	movw	r0, #61436	; 0xeffc
 801be40:	f6c0 0001 	movt	r0, #2049	; 0x801
 801be44:	f04f 0180 	mov.w	r1, #128	; 0x80
 801be48:	f7fd fab4 	bl	80193b4 <_Z8E_NotifyPKci>
 801be4c:	687b      	ldr	r3, [r7, #4]
 801be4e:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 801be52:	4618      	mov	r0, r3
 801be54:	f04f 0180 	mov.w	r1, #128	; 0x80
 801be58:	f7fa f816 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801be5c:	f64e 70c0 	movw	r0, #61376	; 0xefc0
 801be60:	f6c0 0001 	movt	r0, #2049	; 0x801
 801be64:	f04f 0180 	mov.w	r1, #128	; 0x80
 801be68:	f7fd faa4 	bl	80193b4 <_Z8E_NotifyPKci>
    USBTRACE2("\nFTDI Pipe EP1 int = %x, ", epInfo[1].hcNumIn);
 801be6c:	f24f 0010 	movw	r0, #61456	; 0xf010
 801be70:	f6c0 0001 	movt	r0, #2049	; 0x801
 801be74:	f04f 0180 	mov.w	r1, #128	; 0x80
 801be78:	f7fd fa9c 	bl	80193b4 <_Z8E_NotifyPKci>
 801be7c:	687b      	ldr	r3, [r7, #4]
 801be7e:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 801be82:	f3c3 0303 	ubfx	r3, r3, #0, #4
 801be86:	b2db      	uxtb	r3, r3
 801be88:	4618      	mov	r0, r3
 801be8a:	f04f 0180 	mov.w	r1, #128	; 0x80
 801be8e:	f7f9 fffb 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801be92:	f64e 70c0 	movw	r0, #61376	; 0xefc0
 801be96:	f6c0 0001 	movt	r0, #2049	; 0x801
 801be9a:	f04f 0180 	mov.w	r1, #128	; 0x80
 801be9e:	f7fd fa89 	bl	80193b4 <_Z8E_NotifyPKci>
    USBTRACE2("addr = 0x%x(0x81)", epInfo[1].epAddr);
 801bea2:	f24f 002c 	movw	r0, #61484	; 0xf02c
 801bea6:	f6c0 0001 	movt	r0, #2049	; 0x801
 801beaa:	f04f 0180 	mov.w	r1, #128	; 0x80
 801beae:	f7fd fa81 	bl	80193b4 <_Z8E_NotifyPKci>
 801beb2:	687b      	ldr	r3, [r7, #4]
 801beb4:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 801beb8:	4618      	mov	r0, r3
 801beba:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bebe:	f7f9 ffe3 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801bec2:	f64e 70c0 	movw	r0, #61376	; 0xefc0
 801bec6:	f6c0 0001 	movt	r0, #2049	; 0x801
 801beca:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bece:	f7fd fa71 	bl	80193b4 <_Z8E_NotifyPKci>

	rcode = pAsync->OnInit(this);
 801bed2:	687b      	ldr	r3, [r7, #4]
 801bed4:	689b      	ldr	r3, [r3, #8]
 801bed6:	681b      	ldr	r3, [r3, #0]
 801bed8:	681b      	ldr	r3, [r3, #0]
 801beda:	687a      	ldr	r2, [r7, #4]
 801bedc:	6892      	ldr	r2, [r2, #8]
 801bede:	4610      	mov	r0, r2
 801bee0:	6879      	ldr	r1, [r7, #4]
 801bee2:	4798      	blx	r3
 801bee4:	4603      	mov	r3, r0
 801bee6:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67

	if (rcode)
 801beea:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801beee:	2b00      	cmp	r3, #0
 801bef0:	d11d      	bne.n	801bf2e <_ZN4FTDI4InitEhhb+0x55e>
		goto FailOnInit;

	USBTRACE("FTDI configured\r\n");
 801bef2:	f24f 0040 	movw	r0, #61504	; 0xf040
 801bef6:	f6c0 0001 	movt	r0, #2049	; 0x801
 801befa:	f04f 0180 	mov.w	r1, #128	; 0x80
 801befe:	f7fd fa59 	bl	80193b4 <_Z8E_NotifyPKci>

	bPollEnable = true;
 801bf02:	687b      	ldr	r3, [r7, #4]
 801bf04:	f04f 0201 	mov.w	r2, #1
 801bf08:	771a      	strb	r2, [r3, #28]
	return 0;
 801bf0a:	f04f 0300 	mov.w	r3, #0
 801bf0e:	e025      	b.n	801bf5c <_ZN4FTDI4InitEhhb+0x58c>

	// Restore p->epinfo
	p->epinfo = oldep_ptr;

	if (rcode)
		goto FailGetDevDescr;
 801bf10:	bf00      	nop
	bPollEnable = true;
	return 0;

FailGetDevDescr:
#ifdef DEBUG_USB_HOST
	NotifyFailGetDevDescr();
 801bf12:	f7fd fb1d 	bl	8019550 <_Z21NotifyFailGetDevDescrv>
	goto Fail;
 801bf16:	e013      	b.n	801bf40 <_ZN4FTDI4InitEhhb+0x570>

	// Assign epInfo to epinfo pointer
	rcode = pUsb->setEpInfoEntry(bAddress, 1, epInfo);

	if (rcode)
		goto FailSetDevTblEntry;
 801bf18:	bf00      	nop
	goto Fail;
#endif

FailSetDevTblEntry:
#ifdef DEBUG_USB_HOST
	NotifyFailSetDevTblEntry();
 801bf1a:	f7fd fb25 	bl	8019568 <_Z24NotifyFailSetDevTblEntryv>
	goto Fail;
 801bf1e:	e00f      	b.n	801bf40 <_ZN4FTDI4InitEhhb+0x570>
#endif

FailGetConfDescr:
#ifdef DEBUG_USB_HOST
	NotifyFailGetConfDescr();
 801bf20:	f7fd fb2e 	bl	8019580 <_Z22NotifyFailGetConfDescrv>
	goto Fail;
 801bf24:	e00c      	b.n	801bf40 <_ZN4FTDI4InitEhhb+0x570>

	// Set Configuration Value
	rcode = pUsb->setConf(bAddress, 0, bConfNum);

	if (rcode)
		goto FailSetConfDescr;
 801bf26:	bf00      	nop
	goto Fail;
#endif

FailSetConfDescr:
#ifdef DEBUG_USB_HOST
	NotifyFailSetConfDescr();
 801bf28:	f7fd fb36 	bl	8019598 <_Z22NotifyFailSetConfDescrv>
	goto Fail;
 801bf2c:	e008      	b.n	801bf40 <_ZN4FTDI4InitEhhb+0x570>
    USBTRACE2("addr = 0x%x(0x81)", epInfo[1].epAddr);

	rcode = pAsync->OnInit(this);

	if (rcode)
		goto FailOnInit;
 801bf2e:	bf00      	nop
	goto Fail;
#endif

FailOnInit:
#ifdef DEBUG_USB_HOST
	USBTRACE("OnInit:");
 801bf30:	f24f 0054 	movw	r0, #61524	; 0xf054
 801bf34:	f6c0 0001 	movt	r0, #2049	; 0x801
 801bf38:	f04f 0180 	mov.w	r1, #128	; 0x80
 801bf3c:	f7fd fa3a 	bl	80193b4 <_Z8E_NotifyPKci>
#endif

Fail:
#ifdef DEBUG_USB_HOST
	NotifyFail(rcode);
 801bf40:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801bf44:	4618      	mov	r0, r3
 801bf46:	f7fd fb9b 	bl	8019680 <_Z10NotifyFailh>
#endif
	Release();
 801bf4a:	687b      	ldr	r3, [r7, #4]
 801bf4c:	681b      	ldr	r3, [r3, #0]
 801bf4e:	f103 0308 	add.w	r3, r3, #8
 801bf52:	681b      	ldr	r3, [r3, #0]
 801bf54:	6878      	ldr	r0, [r7, #4]
 801bf56:	4798      	blx	r3
	return rcode;
 801bf58:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801bf5c:	e002      	b.n	801bf64 <_ZN4FTDI4InitEhhb+0x594>
 801bf5e:	e7ff      	b.n	801bf60 <_ZN4FTDI4InitEhhb+0x590>
 801bf60:	f000 fd8e 	bl	801ca80 <__cxa_end_cleanup>
}
 801bf64:	4618      	mov	r0, r3
 801bf66:	f107 076c 	add.w	r7, r7, #108	; 0x6c
 801bf6a:	46bd      	mov	sp, r7
 801bf6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801bf6e:	bf00      	nop

0801bf70 <_ZN4FTDI14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR>:

void FTDI::EndpointXtract(uint8_t conf, uint8_t iface, uint8_t alt, uint8_t proto, const USB_ENDPOINT_DESCRIPTOR *pep) {
 801bf70:	b580      	push	{r7, lr}
 801bf72:	b084      	sub	sp, #16
 801bf74:	af00      	add	r7, sp, #0
 801bf76:	6078      	str	r0, [r7, #4]
 801bf78:	70f9      	strb	r1, [r7, #3]
 801bf7a:	70ba      	strb	r2, [r7, #2]
 801bf7c:	707b      	strb	r3, [r7, #1]
        ErrorMessage<uint8_t > (PSTR("Conf.Val"), conf);
 801bf7e:	78fb      	ldrb	r3, [r7, #3]
 801bf80:	f24f 005c 	movw	r0, #61532	; 0xf05c
 801bf84:	f6c0 0001 	movt	r0, #2049	; 0x801
 801bf88:	4619      	mov	r1, r3
 801bf8a:	f7fc ff79 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
        ErrorMessage<uint8_t > (PSTR("Iface Num"), iface);
 801bf8e:	78bb      	ldrb	r3, [r7, #2]
 801bf90:	f24f 0068 	movw	r0, #61544	; 0xf068
 801bf94:	f6c0 0001 	movt	r0, #2049	; 0x801
 801bf98:	4619      	mov	r1, r3
 801bf9a:	f7fc ff71 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>
        ErrorMessage<uint8_t > (PSTR("Alt.Set"), alt);
 801bf9e:	787b      	ldrb	r3, [r7, #1]
 801bfa0:	f24f 0074 	movw	r0, #61556	; 0xf074
 801bfa4:	f6c0 0001 	movt	r0, #2049	; 0x801
 801bfa8:	4619      	mov	r1, r3
 801bfaa:	f7fc ff69 	bl	8018e80 <_Z12ErrorMessageIhEvPKcT_>

        bConfNum = conf;
 801bfae:	687b      	ldr	r3, [r7, #4]
 801bfb0:	78fa      	ldrb	r2, [r7, #3]
 801bfb2:	745a      	strb	r2, [r3, #17]

        uint8_t index;

        if ((pep->bmAttributes & 0x03) == 3 && (pep->bEndpointAddress & 0x80) == 0x80)
 801bfb4:	69fb      	ldr	r3, [r7, #28]
 801bfb6:	78db      	ldrb	r3, [r3, #3]
 801bfb8:	f003 0303 	and.w	r3, r3, #3
 801bfbc:	2b03      	cmp	r3, #3
 801bfbe:	d109      	bne.n	801bfd4 <_ZN4FTDI14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR+0x64>
 801bfc0:	69fb      	ldr	r3, [r7, #28]
 801bfc2:	789b      	ldrb	r3, [r3, #2]
 801bfc4:	b2db      	uxtb	r3, r3
 801bfc6:	b25b      	sxtb	r3, r3
 801bfc8:	2b00      	cmp	r3, #0
 801bfca:	da03      	bge.n	801bfd4 <_ZN4FTDI14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR+0x64>
                index = epInterruptInIndex;
 801bfcc:	f04f 0303 	mov.w	r3, #3
 801bfd0:	73fb      	strb	r3, [r7, #15]
 801bfd2:	e017      	b.n	801c004 <_ZN4FTDI14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR+0x94>
        else
                if ((pep->bmAttributes & 0x02) == 2)
 801bfd4:	69fb      	ldr	r3, [r7, #28]
 801bfd6:	78db      	ldrb	r3, [r3, #3]
 801bfd8:	f003 0302 	and.w	r3, r3, #2
 801bfdc:	2b00      	cmp	r3, #0
 801bfde:	d048      	beq.n	801c072 <_ZN4FTDI14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR+0x102>
                index = ((pep->bEndpointAddress & 0x80) == 0x80) ? epDataInIndex : epDataOutIndex;
 801bfe0:	69fb      	ldr	r3, [r7, #28]
 801bfe2:	789b      	ldrb	r3, [r3, #2]
 801bfe4:	b2db      	uxtb	r3, r3
 801bfe6:	b25b      	sxtb	r3, r3
 801bfe8:	2b00      	cmp	r3, #0
 801bfea:	da05      	bge.n	801bff8 <_ZN4FTDI14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR+0x88>
 801bfec:	f240 73d0 	movw	r3, #2000	; 0x7d0
 801bff0:	f6c0 0302 	movt	r3, #2050	; 0x802
 801bff4:	781b      	ldrb	r3, [r3, #0]
 801bff6:	e004      	b.n	801c002 <_ZN4FTDI14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR+0x92>
 801bff8:	f240 73d1 	movw	r3, #2001	; 0x7d1
 801bffc:	f6c0 0302 	movt	r3, #2050	; 0x802
 801c000:	781b      	ldrb	r3, [r3, #0]
 801c002:	73fb      	strb	r3, [r7, #15]
        else
                return;

        // Fill in the endpoint info structure
        epInfo[index].epAddr = (pep->bEndpointAddress & 0x0F);
 801c004:	7bfa      	ldrb	r2, [r7, #15]
 801c006:	69fb      	ldr	r3, [r7, #28]
 801c008:	789b      	ldrb	r3, [r3, #2]
 801c00a:	f003 030f 	and.w	r3, r3, #15
 801c00e:	b2d9      	uxtb	r1, r3
 801c010:	6878      	ldr	r0, [r7, #4]
 801c012:	4613      	mov	r3, r2
 801c014:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801c018:	189b      	adds	r3, r3, r2
 801c01a:	18c3      	adds	r3, r0, r3
 801c01c:	f103 0320 	add.w	r3, r3, #32
 801c020:	460a      	mov	r2, r1
 801c022:	701a      	strb	r2, [r3, #0]
        epInfo[index].maxPktSize = (uint8_t)pep->wMaxPacketSize;
 801c024:	7bfa      	ldrb	r2, [r7, #15]
 801c026:	69fb      	ldr	r3, [r7, #28]
 801c028:	889b      	ldrh	r3, [r3, #4]
 801c02a:	b29b      	uxth	r3, r3
 801c02c:	b2d9      	uxtb	r1, r3
 801c02e:	6878      	ldr	r0, [r7, #4]
 801c030:	4613      	mov	r3, r2
 801c032:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801c036:	189b      	adds	r3, r3, r2
 801c038:	18c3      	adds	r3, r0, r3
 801c03a:	f103 0320 	add.w	r3, r3, #32
 801c03e:	460a      	mov	r2, r1
 801c040:	705a      	strb	r2, [r3, #1]
        epInfo[index].epAttribs = 0;
 801c042:	7bfa      	ldrb	r2, [r7, #15]
 801c044:	6879      	ldr	r1, [r7, #4]
 801c046:	4613      	mov	r3, r2
 801c048:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801c04c:	189b      	adds	r3, r3, r2
 801c04e:	18cb      	adds	r3, r1, r3
 801c050:	f103 0320 	add.w	r3, r3, #32
 801c054:	f04f 0200 	mov.w	r2, #0
 801c058:	711a      	strb	r2, [r3, #4]

        bNumEP++;
 801c05a:	687b      	ldr	r3, [r7, #4]
 801c05c:	7cdb      	ldrb	r3, [r3, #19]
 801c05e:	f103 0301 	add.w	r3, r3, #1
 801c062:	b2da      	uxtb	r2, r3
 801c064:	687b      	ldr	r3, [r7, #4]
 801c066:	74da      	strb	r2, [r3, #19]

        PrintEndpointDescriptor(pep);
 801c068:	6878      	ldr	r0, [r7, #4]
 801c06a:	69f9      	ldr	r1, [r7, #28]
 801c06c:	f000 fa0e 	bl	801c48c <_ZN4FTDI23PrintEndpointDescriptorEPK23USB_ENDPOINT_DESCRIPTOR>
 801c070:	e000      	b.n	801c074 <_ZN4FTDI14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR+0x104>
                index = epInterruptInIndex;
        else
                if ((pep->bmAttributes & 0x02) == 2)
                index = ((pep->bEndpointAddress & 0x80) == 0x80) ? epDataInIndex : epDataOutIndex;
        else
                return;
 801c072:	bf00      	nop
        epInfo[index].epAttribs = 0;

        bNumEP++;

        PrintEndpointDescriptor(pep);
}
 801c074:	f107 0710 	add.w	r7, r7, #16
 801c078:	46bd      	mov	sp, r7
 801c07a:	bd80      	pop	{r7, pc}

0801c07c <_ZThn4_N4FTDI14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR>:
 801c07c:	f1a0 0004 	sub.w	r0, r0, #4
 801c080:	f7ff bf76 	b.w	801bf70 <_ZN4FTDI14EndpointXtractEhhhhPK23USB_ENDPOINT_DESCRIPTOR>

0801c084 <_ZN4FTDI7ReleaseEv>:

uint8_t FTDI::Release()
{
 801c084:	b580      	push	{r7, lr}
 801c086:	b082      	sub	sp, #8
 801c088:	af00      	add	r7, sp, #0
 801c08a:	6078      	str	r0, [r7, #4]
	if(epInfo[2].hcNumber != 0)
 801c08c:	687b      	ldr	r3, [r7, #4]
 801c08e:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 801c092:	2b00      	cmp	r3, #0
 801c094:	d00d      	beq.n	801c0b2 <_ZN4FTDI7ReleaseEv+0x2e>
	{	// HC0&HC1 are taken by control pipe.
		//USB_OTG_HC_Halt(pUsb->coreConfig, epInfo[2].hcNumOut);
		//USBH_Free_Channel(pUsb->coreConfig, epInfo[2].hcNumOut);
		usbhost_cb->device_removed_cb(epInfo[2].hcNumOut);
 801c096:	f243 6310 	movw	r3, #13840	; 0x3610
 801c09a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c09e:	681b      	ldr	r3, [r3, #0]
 801c0a0:	699b      	ldr	r3, [r3, #24]
 801c0a2:	687a      	ldr	r2, [r7, #4]
 801c0a4:	f892 202d 	ldrb.w	r2, [r2, #45]	; 0x2d
 801c0a8:	f3c2 1203 	ubfx	r2, r2, #4, #4
 801c0ac:	b2d2      	uxtb	r2, r2
 801c0ae:	4610      	mov	r0, r2
 801c0b0:	4798      	blx	r3
	}

	if(epInfo[1].hcNumber != 0)
 801c0b2:	687b      	ldr	r3, [r7, #4]
 801c0b4:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 801c0b8:	2b00      	cmp	r3, #0
 801c0ba:	d00d      	beq.n	801c0d8 <_ZN4FTDI7ReleaseEv+0x54>
	{
		//USB_OTG_HC_Halt(pUsb->coreConfig, epInfo[1].hcNumIn);
		//USBH_Free_Channel(pUsb->coreConfig, epInfo[1].hcNumIn);
		usbhost_cb->device_removed_cb(epInfo[1].hcNumIn);
 801c0bc:	f243 6310 	movw	r3, #13840	; 0x3610
 801c0c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c0c4:	681b      	ldr	r3, [r3, #0]
 801c0c6:	699b      	ldr	r3, [r3, #24]
 801c0c8:	687a      	ldr	r2, [r7, #4]
 801c0ca:	f892 2028 	ldrb.w	r2, [r2, #40]	; 0x28
 801c0ce:	f3c2 0203 	ubfx	r2, r2, #0, #4
 801c0d2:	b2d2      	uxtb	r2, r2
 801c0d4:	4610      	mov	r0, r2
 801c0d6:	4798      	blx	r3
	}

	epInfo[1].hcNumber = 0;
 801c0d8:	687b      	ldr	r3, [r7, #4]
 801c0da:	f04f 0200 	mov.w	r2, #0
 801c0de:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	epInfo[2].hcNumber = 0;
 801c0e2:	687b      	ldr	r3, [r7, #4]
 801c0e4:	f04f 0200 	mov.w	r2, #0
 801c0e8:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

	pUsb->GetAddressPool().FreeAddress(bAddress);
 801c0ec:	687b      	ldr	r3, [r7, #4]
 801c0ee:	68db      	ldr	r3, [r3, #12]
 801c0f0:	4618      	mov	r0, r3
 801c0f2:	f7f8 f991 	bl	8014418 <_ZN3USB14GetAddressPoolEv>
 801c0f6:	4603      	mov	r3, r0
 801c0f8:	681a      	ldr	r2, [r3, #0]
 801c0fa:	f102 0208 	add.w	r2, r2, #8
 801c0fe:	6812      	ldr	r2, [r2, #0]
 801c100:	6879      	ldr	r1, [r7, #4]
 801c102:	7c09      	ldrb	r1, [r1, #16]
 801c104:	4618      	mov	r0, r3
 801c106:	4790      	blx	r2

	bAddress = 0;
 801c108:	687b      	ldr	r3, [r7, #4]
 801c10a:	f04f 0200 	mov.w	r2, #0
 801c10e:	741a      	strb	r2, [r3, #16]
	bNumEP = 1;
 801c110:	687b      	ldr	r3, [r7, #4]
 801c112:	f04f 0201 	mov.w	r2, #1
 801c116:	74da      	strb	r2, [r3, #19]
	ready = false;
 801c118:	687b      	ldr	r3, [r7, #4]
 801c11a:	f04f 0200 	mov.w	r2, #0
 801c11e:	751a      	strb	r2, [r3, #20]
	qNextPollTime = 0;
 801c120:	687b      	ldr	r3, [r7, #4]
 801c122:	f04f 0200 	mov.w	r2, #0
 801c126:	619a      	str	r2, [r3, #24]
	bPollEnable = false;
 801c128:	687b      	ldr	r3, [r7, #4]
 801c12a:	f04f 0200 	mov.w	r2, #0
 801c12e:	771a      	strb	r2, [r3, #28]
	return 0;
 801c130:	f04f 0300 	mov.w	r3, #0
}
 801c134:	4618      	mov	r0, r3
 801c136:	f107 0708 	add.w	r7, r7, #8
 801c13a:	46bd      	mov	sp, r7
 801c13c:	bd80      	pop	{r7, pc}
 801c13e:	bf00      	nop

0801c140 <_ZN4FTDI4PollEv>:

uint8_t FTDI::Poll() {
 801c140:	b480      	push	{r7}
 801c142:	b085      	sub	sp, #20
 801c144:	af00      	add	r7, sp, #0
 801c146:	6078      	str	r0, [r7, #4]
        uint8_t rcode = 0;
 801c148:	f04f 0300 	mov.w	r3, #0
 801c14c:	73fb      	strb	r3, [r7, #15]
        //{
        //	USB_HOST_SERIAL.println(bAddress, HEX);

        //	qNextPollTime = millis() + 100;
        //}
        return rcode;
 801c14e:	7bfb      	ldrb	r3, [r7, #15]
}
 801c150:	4618      	mov	r0, r3
 801c152:	f107 0714 	add.w	r7, r7, #20
 801c156:	46bd      	mov	sp, r7
 801c158:	bc80      	pop	{r7}
 801c15a:	4770      	bx	lr

0801c15c <_ZN4FTDI11SetBaudRateEm>:

uint8_t FTDI::SetBaudRate(uint32_t baud) {
 801c15c:	b590      	push	{r4, r7, lr}
 801c15e:	b08d      	sub	sp, #52	; 0x34
 801c160:	af08      	add	r7, sp, #32
 801c162:	6078      	str	r0, [r7, #4]
 801c164:	6039      	str	r1, [r7, #0]
        uint16_t baud_value, baud_index = 0;
 801c166:	f04f 0300 	mov.w	r3, #0
 801c16a:	81bb      	strh	r3, [r7, #12]
        uint32_t divisor3;

        divisor3 = 48000000 / 2 / baud; // divisor shifted 3 bits to the left
 801c16c:	f44f 5358 	mov.w	r3, #13824	; 0x3600
 801c170:	f2c0 136e 	movt	r3, #366	; 0x16e
 801c174:	683a      	ldr	r2, [r7, #0]
 801c176:	fbb3 f3f2 	udiv	r3, r3, r2
 801c17a:	60bb      	str	r3, [r7, #8]

        if (wFTDIType == FT232AM) {
 801c17c:	687b      	ldr	r3, [r7, #4]
 801c17e:	8bdb      	ldrh	r3, [r3, #30]
 801c180:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801c184:	d132      	bne.n	801c1ec <_ZN4FTDI11SetBaudRateEm+0x90>
                if ((divisor3 & 0x7) == 7)
 801c186:	68bb      	ldr	r3, [r7, #8]
 801c188:	f003 0307 	and.w	r3, r3, #7
 801c18c:	2b07      	cmp	r3, #7
 801c18e:	d103      	bne.n	801c198 <_ZN4FTDI11SetBaudRateEm+0x3c>
                        divisor3++; // round x.7/8 up to x+1
 801c190:	68bb      	ldr	r3, [r7, #8]
 801c192:	f103 0301 	add.w	r3, r3, #1
 801c196:	60bb      	str	r3, [r7, #8]

                baud_value = divisor3 >> 3;
 801c198:	68bb      	ldr	r3, [r7, #8]
 801c19a:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 801c19e:	81fb      	strh	r3, [r7, #14]
                divisor3 &= 0x7;
 801c1a0:	68bb      	ldr	r3, [r7, #8]
 801c1a2:	f003 0307 	and.w	r3, r3, #7
 801c1a6:	60bb      	str	r3, [r7, #8]

                if (divisor3 == 1) baud_value |= 0xc000;
 801c1a8:	68bb      	ldr	r3, [r7, #8]
 801c1aa:	2b01      	cmp	r3, #1
 801c1ac:	d106      	bne.n	801c1bc <_ZN4FTDI11SetBaudRateEm+0x60>
 801c1ae:	89fb      	ldrh	r3, [r7, #14]
 801c1b0:	ea6f 4383 	mvn.w	r3, r3, lsl #18
 801c1b4:	ea6f 4393 	mvn.w	r3, r3, lsr #18
 801c1b8:	81fb      	strh	r3, [r7, #14]
 801c1ba:	e010      	b.n	801c1de <_ZN4FTDI11SetBaudRateEm+0x82>
                else // 0.125
                        if (divisor3 >= 4) baud_value |= 0x4000;
 801c1bc:	68bb      	ldr	r3, [r7, #8]
 801c1be:	2b03      	cmp	r3, #3
 801c1c0:	d904      	bls.n	801c1cc <_ZN4FTDI11SetBaudRateEm+0x70>
 801c1c2:	89fb      	ldrh	r3, [r7, #14]
 801c1c4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 801c1c8:	81fb      	strh	r3, [r7, #14]
 801c1ca:	e008      	b.n	801c1de <_ZN4FTDI11SetBaudRateEm+0x82>
                else // 0.5
                        if (divisor3 != 0) baud_value |= 0x8000; // 0.25
 801c1cc:	68bb      	ldr	r3, [r7, #8]
 801c1ce:	2b00      	cmp	r3, #0
 801c1d0:	d005      	beq.n	801c1de <_ZN4FTDI11SetBaudRateEm+0x82>
 801c1d2:	89fb      	ldrh	r3, [r7, #14]
 801c1d4:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 801c1d8:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 801c1dc:	81fb      	strh	r3, [r7, #14]
                if (baud_value == 1) baud_value = 0; /* special case for maximum baud rate */
 801c1de:	89fb      	ldrh	r3, [r7, #14]
 801c1e0:	2b01      	cmp	r3, #1
 801c1e2:	d12e      	bne.n	801c242 <_ZN4FTDI11SetBaudRateEm+0xe6>
 801c1e4:	f04f 0300 	mov.w	r3, #0
 801c1e8:	81fb      	strh	r3, [r7, #14]
 801c1ea:	e02a      	b.n	801c242 <_ZN4FTDI11SetBaudRateEm+0xe6>
        } else {
                static const unsigned char divfrac [8] = {0, 3, 2, 0, 1, 1, 2, 3};
                static const unsigned char divindex[8] = {0, 0, 0, 1, 0, 1, 1, 1};

                baud_value = divisor3 >> 3;
 801c1ec:	68bb      	ldr	r3, [r7, #8]
 801c1ee:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 801c1f2:	81fb      	strh	r3, [r7, #14]
                baud_value |= divfrac [divisor3 & 0x7] << 14;
 801c1f4:	68bb      	ldr	r3, [r7, #8]
 801c1f6:	f003 0207 	and.w	r2, r3, #7
 801c1fa:	f640 0388 	movw	r3, #2184	; 0x888
 801c1fe:	f6c0 0302 	movt	r3, #2050	; 0x802
 801c202:	5c9b      	ldrb	r3, [r3, r2]
 801c204:	ea4f 3383 	mov.w	r3, r3, lsl #14
 801c208:	b29a      	uxth	r2, r3
 801c20a:	89fb      	ldrh	r3, [r7, #14]
 801c20c:	4313      	orrs	r3, r2
 801c20e:	b29b      	uxth	r3, r3
 801c210:	81fb      	strh	r3, [r7, #14]
                baud_index = divindex[divisor3 & 0x7];
 801c212:	68bb      	ldr	r3, [r7, #8]
 801c214:	f003 0207 	and.w	r2, r3, #7
 801c218:	f640 0390 	movw	r3, #2192	; 0x890
 801c21c:	f6c0 0302 	movt	r3, #2050	; 0x802
 801c220:	5c9b      	ldrb	r3, [r3, r2]
 801c222:	81bb      	strh	r3, [r7, #12]

                /* Deal with special cases for highest baud rates. */
                if (baud_value == 1) baud_value = 0;
 801c224:	89fb      	ldrh	r3, [r7, #14]
 801c226:	2b01      	cmp	r3, #1
 801c228:	d103      	bne.n	801c232 <_ZN4FTDI11SetBaudRateEm+0xd6>
 801c22a:	f04f 0300 	mov.w	r3, #0
 801c22e:	81fb      	strh	r3, [r7, #14]
 801c230:	e007      	b.n	801c242 <_ZN4FTDI11SetBaudRateEm+0xe6>
                else // 1.0
                        if (baud_value == 0x4001) baud_value = 1; // 1.5
 801c232:	89fa      	ldrh	r2, [r7, #14]
 801c234:	f244 0301 	movw	r3, #16385	; 0x4001
 801c238:	429a      	cmp	r2, r3
 801c23a:	d102      	bne.n	801c242 <_ZN4FTDI11SetBaudRateEm+0xe6>
 801c23c:	f04f 0301 	mov.w	r3, #1
 801c240:	81fb      	strh	r3, [r7, #14]
        }
        USBTRACE2("baud_value:", baud_value);
 801c242:	f24f 007c 	movw	r0, #61564	; 0xf07c
 801c246:	f6c0 0001 	movt	r0, #2049	; 0x801
 801c24a:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c24e:	f7fd f8b1 	bl	80193b4 <_Z8E_NotifyPKci>
 801c252:	89fb      	ldrh	r3, [r7, #14]
 801c254:	b2db      	uxtb	r3, r3
 801c256:	4618      	mov	r0, r3
 801c258:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c25c:	f7f9 fe14 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801c260:	f64e 70c0 	movw	r0, #61376	; 0xefc0
 801c264:	f6c0 0001 	movt	r0, #2049	; 0x801
 801c268:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c26c:	f7fd f8a2 	bl	80193b4 <_Z8E_NotifyPKci>
        USBTRACE2("baud_index:", baud_index);
 801c270:	f24f 0088 	movw	r0, #61576	; 0xf088
 801c274:	f6c0 0001 	movt	r0, #2049	; 0x801
 801c278:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c27c:	f7fd f89a 	bl	80193b4 <_Z8E_NotifyPKci>
 801c280:	89bb      	ldrh	r3, [r7, #12]
 801c282:	b2db      	uxtb	r3, r3
 801c284:	4618      	mov	r0, r3
 801c286:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c28a:	f7f9 fdfd 	bl	8015e88 <_Z10D_PrintHexIhEvT_i>
 801c28e:	f64e 70c0 	movw	r0, #61376	; 0xefc0
 801c292:	f6c0 0001 	movt	r0, #2049	; 0x801
 801c296:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c29a:	f7fd f88b 	bl	80193b4 <_Z8E_NotifyPKci>
        return pUsb->ctrlReq(bAddress, 0, bmREQ_FTDI_OUT, FTDI_SIO_SET_BAUD_RATE, baud_value & 0xff, baud_value >> 8, baud_index, 0, 0, NULL, NULL);
 801c29e:	687b      	ldr	r3, [r7, #4]
 801c2a0:	68da      	ldr	r2, [r3, #12]
 801c2a2:	687b      	ldr	r3, [r7, #4]
 801c2a4:	7c1b      	ldrb	r3, [r3, #16]
 801c2a6:	89f9      	ldrh	r1, [r7, #14]
 801c2a8:	b2c8      	uxtb	r0, r1
 801c2aa:	89f9      	ldrh	r1, [r7, #14]
 801c2ac:	ea4f 2121 	mov.w	r1, r1, asr #8
 801c2b0:	b2c9      	uxtb	r1, r1
 801c2b2:	f04f 0403 	mov.w	r4, #3
 801c2b6:	9400      	str	r4, [sp, #0]
 801c2b8:	9001      	str	r0, [sp, #4]
 801c2ba:	9102      	str	r1, [sp, #8]
 801c2bc:	89b9      	ldrh	r1, [r7, #12]
 801c2be:	9103      	str	r1, [sp, #12]
 801c2c0:	f04f 0100 	mov.w	r1, #0
 801c2c4:	9104      	str	r1, [sp, #16]
 801c2c6:	f04f 0100 	mov.w	r1, #0
 801c2ca:	9105      	str	r1, [sp, #20]
 801c2cc:	f04f 0100 	mov.w	r1, #0
 801c2d0:	9106      	str	r1, [sp, #24]
 801c2d2:	f04f 0100 	mov.w	r1, #0
 801c2d6:	9107      	str	r1, [sp, #28]
 801c2d8:	4610      	mov	r0, r2
 801c2da:	4619      	mov	r1, r3
 801c2dc:	f04f 0200 	mov.w	r2, #0
 801c2e0:	f04f 0340 	mov.w	r3, #64	; 0x40
 801c2e4:	f7f8 f9de 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 801c2e8:	4603      	mov	r3, r0
}
 801c2ea:	4618      	mov	r0, r3
 801c2ec:	f107 0714 	add.w	r7, r7, #20
 801c2f0:	46bd      	mov	sp, r7
 801c2f2:	bd90      	pop	{r4, r7, pc}

0801c2f4 <_ZN4FTDI15SetModemControlEt>:

uint8_t FTDI::SetModemControl(uint16_t signal) {
 801c2f4:	b590      	push	{r4, r7, lr}
 801c2f6:	b08b      	sub	sp, #44	; 0x2c
 801c2f8:	af08      	add	r7, sp, #32
 801c2fa:	6078      	str	r0, [r7, #4]
 801c2fc:	460b      	mov	r3, r1
 801c2fe:	807b      	strh	r3, [r7, #2]
        return pUsb->ctrlReq(bAddress, 0, bmREQ_FTDI_OUT, FTDI_SIO_MODEM_CTRL, signal & 0xff, signal >> 8, 0, 0, 0, NULL, NULL);
 801c300:	687b      	ldr	r3, [r7, #4]
 801c302:	68da      	ldr	r2, [r3, #12]
 801c304:	687b      	ldr	r3, [r7, #4]
 801c306:	7c1b      	ldrb	r3, [r3, #16]
 801c308:	8879      	ldrh	r1, [r7, #2]
 801c30a:	b2c8      	uxtb	r0, r1
 801c30c:	8879      	ldrh	r1, [r7, #2]
 801c30e:	ea4f 2121 	mov.w	r1, r1, asr #8
 801c312:	b2c9      	uxtb	r1, r1
 801c314:	f04f 0401 	mov.w	r4, #1
 801c318:	9400      	str	r4, [sp, #0]
 801c31a:	9001      	str	r0, [sp, #4]
 801c31c:	9102      	str	r1, [sp, #8]
 801c31e:	f04f 0100 	mov.w	r1, #0
 801c322:	9103      	str	r1, [sp, #12]
 801c324:	f04f 0100 	mov.w	r1, #0
 801c328:	9104      	str	r1, [sp, #16]
 801c32a:	f04f 0100 	mov.w	r1, #0
 801c32e:	9105      	str	r1, [sp, #20]
 801c330:	f04f 0100 	mov.w	r1, #0
 801c334:	9106      	str	r1, [sp, #24]
 801c336:	f04f 0100 	mov.w	r1, #0
 801c33a:	9107      	str	r1, [sp, #28]
 801c33c:	4610      	mov	r0, r2
 801c33e:	4619      	mov	r1, r3
 801c340:	f04f 0200 	mov.w	r2, #0
 801c344:	f04f 0340 	mov.w	r3, #64	; 0x40
 801c348:	f7f8 f9ac 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 801c34c:	4603      	mov	r3, r0
}
 801c34e:	4618      	mov	r0, r3
 801c350:	f107 070c 	add.w	r7, r7, #12
 801c354:	46bd      	mov	sp, r7
 801c356:	bd90      	pop	{r4, r7, pc}

0801c358 <_ZN4FTDI14SetFlowControlEhhh>:

uint8_t FTDI::SetFlowControl(uint8_t protocol, uint8_t xon, uint8_t xoff) {
 801c358:	b580      	push	{r7, lr}
 801c35a:	b08a      	sub	sp, #40	; 0x28
 801c35c:	af08      	add	r7, sp, #32
 801c35e:	6078      	str	r0, [r7, #4]
 801c360:	70f9      	strb	r1, [r7, #3]
 801c362:	70ba      	strb	r2, [r7, #2]
 801c364:	707b      	strb	r3, [r7, #1]
        return pUsb->ctrlReq(bAddress, 0, bmREQ_FTDI_OUT, FTDI_SIO_SET_FLOW_CTRL, xon, xoff, protocol << 8, 0, 0, NULL, NULL);
 801c366:	687b      	ldr	r3, [r7, #4]
 801c368:	68da      	ldr	r2, [r3, #12]
 801c36a:	687b      	ldr	r3, [r7, #4]
 801c36c:	7c1b      	ldrb	r3, [r3, #16]
 801c36e:	78f9      	ldrb	r1, [r7, #3]
 801c370:	b289      	uxth	r1, r1
 801c372:	ea4f 2101 	mov.w	r1, r1, lsl #8
 801c376:	b289      	uxth	r1, r1
 801c378:	f04f 0002 	mov.w	r0, #2
 801c37c:	9000      	str	r0, [sp, #0]
 801c37e:	78b8      	ldrb	r0, [r7, #2]
 801c380:	9001      	str	r0, [sp, #4]
 801c382:	7878      	ldrb	r0, [r7, #1]
 801c384:	9002      	str	r0, [sp, #8]
 801c386:	9103      	str	r1, [sp, #12]
 801c388:	f04f 0100 	mov.w	r1, #0
 801c38c:	9104      	str	r1, [sp, #16]
 801c38e:	f04f 0100 	mov.w	r1, #0
 801c392:	9105      	str	r1, [sp, #20]
 801c394:	f04f 0100 	mov.w	r1, #0
 801c398:	9106      	str	r1, [sp, #24]
 801c39a:	f04f 0100 	mov.w	r1, #0
 801c39e:	9107      	str	r1, [sp, #28]
 801c3a0:	4610      	mov	r0, r2
 801c3a2:	4619      	mov	r1, r3
 801c3a4:	f04f 0200 	mov.w	r2, #0
 801c3a8:	f04f 0340 	mov.w	r3, #64	; 0x40
 801c3ac:	f7f8 f97a 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 801c3b0:	4603      	mov	r3, r0
}
 801c3b2:	4618      	mov	r0, r3
 801c3b4:	f107 0708 	add.w	r7, r7, #8
 801c3b8:	46bd      	mov	sp, r7
 801c3ba:	bd80      	pop	{r7, pc}

0801c3bc <_ZN4FTDI7SetDataEt>:

uint8_t FTDI::SetData(uint16_t databm) {
 801c3bc:	b590      	push	{r4, r7, lr}
 801c3be:	b08b      	sub	sp, #44	; 0x2c
 801c3c0:	af08      	add	r7, sp, #32
 801c3c2:	6078      	str	r0, [r7, #4]
 801c3c4:	460b      	mov	r3, r1
 801c3c6:	807b      	strh	r3, [r7, #2]
        return pUsb->ctrlReq(bAddress, 0, bmREQ_FTDI_OUT, FTDI_SIO_SET_DATA, databm & 0xff, databm >> 8, 0, 0, 0, NULL, NULL);
 801c3c8:	687b      	ldr	r3, [r7, #4]
 801c3ca:	68da      	ldr	r2, [r3, #12]
 801c3cc:	687b      	ldr	r3, [r7, #4]
 801c3ce:	7c1b      	ldrb	r3, [r3, #16]
 801c3d0:	8879      	ldrh	r1, [r7, #2]
 801c3d2:	b2c8      	uxtb	r0, r1
 801c3d4:	8879      	ldrh	r1, [r7, #2]
 801c3d6:	ea4f 2121 	mov.w	r1, r1, asr #8
 801c3da:	b2c9      	uxtb	r1, r1
 801c3dc:	f04f 0404 	mov.w	r4, #4
 801c3e0:	9400      	str	r4, [sp, #0]
 801c3e2:	9001      	str	r0, [sp, #4]
 801c3e4:	9102      	str	r1, [sp, #8]
 801c3e6:	f04f 0100 	mov.w	r1, #0
 801c3ea:	9103      	str	r1, [sp, #12]
 801c3ec:	f04f 0100 	mov.w	r1, #0
 801c3f0:	9104      	str	r1, [sp, #16]
 801c3f2:	f04f 0100 	mov.w	r1, #0
 801c3f6:	9105      	str	r1, [sp, #20]
 801c3f8:	f04f 0100 	mov.w	r1, #0
 801c3fc:	9106      	str	r1, [sp, #24]
 801c3fe:	f04f 0100 	mov.w	r1, #0
 801c402:	9107      	str	r1, [sp, #28]
 801c404:	4610      	mov	r0, r2
 801c406:	4619      	mov	r1, r3
 801c408:	f04f 0200 	mov.w	r2, #0
 801c40c:	f04f 0340 	mov.w	r3, #64	; 0x40
 801c410:	f7f8 f948 	bl	80146a4 <_ZN3USB7ctrlReqEhhhhhhtttPhP13USBReadParser>
 801c414:	4603      	mov	r3, r0
}
 801c416:	4618      	mov	r0, r3
 801c418:	f107 070c 	add.w	r7, r7, #12
 801c41c:	46bd      	mov	sp, r7
 801c41e:	bd90      	pop	{r4, r7, pc}

0801c420 <_ZN4FTDI7RcvDataEPtPh>:

uint8_t FTDI::RcvData(uint16_t *bytes_rcvd, uint8_t *dataptr) {
 801c420:	b580      	push	{r7, lr}
 801c422:	b086      	sub	sp, #24
 801c424:	af02      	add	r7, sp, #8
 801c426:	60f8      	str	r0, [r7, #12]
 801c428:	60b9      	str	r1, [r7, #8]
 801c42a:	607a      	str	r2, [r7, #4]
        return pUsb->inTransfer(bAddress, epInfo[epDataInIndex].epAddr, bytes_rcvd, dataptr);
 801c42c:	68fb      	ldr	r3, [r7, #12]
 801c42e:	68d9      	ldr	r1, [r3, #12]
 801c430:	68fb      	ldr	r3, [r7, #12]
 801c432:	7c1a      	ldrb	r2, [r3, #16]
 801c434:	68fb      	ldr	r3, [r7, #12]
 801c436:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 801c43a:	6878      	ldr	r0, [r7, #4]
 801c43c:	9000      	str	r0, [sp, #0]
 801c43e:	4608      	mov	r0, r1
 801c440:	4611      	mov	r1, r2
 801c442:	461a      	mov	r2, r3
 801c444:	68bb      	ldr	r3, [r7, #8]
 801c446:	f7f8 fa03 	bl	8014850 <_ZN3USB10inTransferEhhPtPh>
 801c44a:	4603      	mov	r3, r0
}
 801c44c:	4618      	mov	r0, r3
 801c44e:	f107 0710 	add.w	r7, r7, #16
 801c452:	46bd      	mov	sp, r7
 801c454:	bd80      	pop	{r7, pc}
 801c456:	bf00      	nop

0801c458 <_ZN4FTDI7SndDataEtPKh>:

uint8_t FTDI::SndData(uint16_t nbytes, const uint8_t *dataptr) {
 801c458:	b590      	push	{r4, r7, lr}
 801c45a:	b087      	sub	sp, #28
 801c45c:	af02      	add	r7, sp, #8
 801c45e:	60f8      	str	r0, [r7, #12]
 801c460:	460b      	mov	r3, r1
 801c462:	607a      	str	r2, [r7, #4]
 801c464:	817b      	strh	r3, [r7, #10]
        return pUsb->outTransfer(bAddress, epInfo[epDataOutIndex].epAddr, nbytes, dataptr);
 801c466:	68fb      	ldr	r3, [r7, #12]
 801c468:	68d8      	ldr	r0, [r3, #12]
 801c46a:	68fb      	ldr	r3, [r7, #12]
 801c46c:	7c19      	ldrb	r1, [r3, #16]
 801c46e:	68fb      	ldr	r3, [r7, #12]
 801c470:	f893 202a 	ldrb.w	r2, [r3, #42]	; 0x2a
 801c474:	897b      	ldrh	r3, [r7, #10]
 801c476:	687c      	ldr	r4, [r7, #4]
 801c478:	9400      	str	r4, [sp, #0]
 801c47a:	f7f8 fad7 	bl	8014a2c <_ZN3USB11outTransferEhhtPKh>
 801c47e:	4603      	mov	r3, r0
}
 801c480:	4618      	mov	r0, r3
 801c482:	f107 0714 	add.w	r7, r7, #20
 801c486:	46bd      	mov	sp, r7
 801c488:	bd90      	pop	{r4, r7, pc}
 801c48a:	bf00      	nop

0801c48c <_ZN4FTDI23PrintEndpointDescriptorEPK23USB_ENDPOINT_DESCRIPTOR>:

void FTDI::PrintEndpointDescriptor(const USB_ENDPOINT_DESCRIPTOR* ep_ptr) {
 801c48c:	b580      	push	{r7, lr}
 801c48e:	b082      	sub	sp, #8
 801c490:	af00      	add	r7, sp, #0
 801c492:	6078      	str	r0, [r7, #4]
 801c494:	6039      	str	r1, [r7, #0]
        Notify(PSTR("Endpoint descriptor:"), 0x80);
 801c496:	f24f 0094 	movw	r0, #61588	; 0xf094
 801c49a:	f6c0 0001 	movt	r0, #2049	; 0x801
 801c49e:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c4a2:	f7fc ff87 	bl	80193b4 <_Z8E_NotifyPKci>
        Notify(PSTR("\r\nLength:\t\t"), 0x80);
 801c4a6:	f24f 00ac 	movw	r0, #61612	; 0xf0ac
 801c4aa:	f6c0 0001 	movt	r0, #2049	; 0x801
 801c4ae:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c4b2:	f7fc ff7f 	bl	80193b4 <_Z8E_NotifyPKci>
        PrintHex<uint8_t > (ep_ptr->bLength, 0x80);
 801c4b6:	683b      	ldr	r3, [r7, #0]
 801c4b8:	781b      	ldrb	r3, [r3, #0]
 801c4ba:	4618      	mov	r0, r3
 801c4bc:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c4c0:	f7f9 fe72 	bl	80161a8 <_Z8PrintHexIhEvT_i>
        Notify(PSTR("\r\nType:\t\t"), 0x80);
 801c4c4:	f24f 00b8 	movw	r0, #61624	; 0xf0b8
 801c4c8:	f6c0 0001 	movt	r0, #2049	; 0x801
 801c4cc:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c4d0:	f7fc ff70 	bl	80193b4 <_Z8E_NotifyPKci>
        PrintHex<uint8_t > (ep_ptr->bDescriptorType, 0x80);
 801c4d4:	683b      	ldr	r3, [r7, #0]
 801c4d6:	785b      	ldrb	r3, [r3, #1]
 801c4d8:	4618      	mov	r0, r3
 801c4da:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c4de:	f7f9 fe63 	bl	80161a8 <_Z8PrintHexIhEvT_i>
        Notify(PSTR("\r\nAddress:\t"), 0x80);
 801c4e2:	f24f 00c4 	movw	r0, #61636	; 0xf0c4
 801c4e6:	f6c0 0001 	movt	r0, #2049	; 0x801
 801c4ea:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c4ee:	f7fc ff61 	bl	80193b4 <_Z8E_NotifyPKci>
        PrintHex<uint8_t > (ep_ptr->bEndpointAddress, 0x80);
 801c4f2:	683b      	ldr	r3, [r7, #0]
 801c4f4:	789b      	ldrb	r3, [r3, #2]
 801c4f6:	4618      	mov	r0, r3
 801c4f8:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c4fc:	f7f9 fe54 	bl	80161a8 <_Z8PrintHexIhEvT_i>
        Notify(PSTR("\r\nAttributes:\t"), 0x80);
 801c500:	f24f 00d0 	movw	r0, #61648	; 0xf0d0
 801c504:	f6c0 0001 	movt	r0, #2049	; 0x801
 801c508:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c50c:	f7fc ff52 	bl	80193b4 <_Z8E_NotifyPKci>
        PrintHex<uint8_t > (ep_ptr->bmAttributes, 0x80);
 801c510:	683b      	ldr	r3, [r7, #0]
 801c512:	78db      	ldrb	r3, [r3, #3]
 801c514:	4618      	mov	r0, r3
 801c516:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c51a:	f7f9 fe45 	bl	80161a8 <_Z8PrintHexIhEvT_i>
        Notify(PSTR("\r\nMaxPktSize:\t"), 0x80);
 801c51e:	f24f 00e0 	movw	r0, #61664	; 0xf0e0
 801c522:	f6c0 0001 	movt	r0, #2049	; 0x801
 801c526:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c52a:	f7fc ff43 	bl	80193b4 <_Z8E_NotifyPKci>
        PrintHex<uint16_t > (ep_ptr->wMaxPacketSize, 0x80);
 801c52e:	683b      	ldr	r3, [r7, #0]
 801c530:	889b      	ldrh	r3, [r3, #4]
 801c532:	b29b      	uxth	r3, r3
 801c534:	4618      	mov	r0, r3
 801c536:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c53a:	f7fc fd23 	bl	8018f84 <_Z8PrintHexItEvT_i>
        Notify(PSTR("\r\nPoll Intrv:\t"), 0x80);
 801c53e:	f24f 00f0 	movw	r0, #61680	; 0xf0f0
 801c542:	f6c0 0001 	movt	r0, #2049	; 0x801
 801c546:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c54a:	f7fc ff33 	bl	80193b4 <_Z8E_NotifyPKci>
        PrintHex<uint8_t > (ep_ptr->bInterval, 0x80);
 801c54e:	683b      	ldr	r3, [r7, #0]
 801c550:	799b      	ldrb	r3, [r3, #6]
 801c552:	4618      	mov	r0, r3
 801c554:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c558:	f7f9 fe26 	bl	80161a8 <_Z8PrintHexIhEvT_i>
        Notify(PSTR("\r\n"), 0x80);
 801c55c:	f64e 70c0 	movw	r0, #61376	; 0xefc0
 801c560:	f6c0 0001 	movt	r0, #2049	; 0x801
 801c564:	f04f 0180 	mov.w	r1, #128	; 0x80
 801c568:	f7fc ff24 	bl	80193b4 <_Z8E_NotifyPKci>
}
 801c56c:	f107 0708 	add.w	r7, r7, #8
 801c570:	46bd      	mov	sp, r7
 801c572:	bd80      	pop	{r7, pc}

0801c574 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EEC1EP17UsbConfigXtracter>:
        ConfigDescParser(UsbConfigXtracter *xtractor);
        virtual void Parse(const uint16_t len, const uint8_t *pbuf, const uint16_t &offset);
};

template <const uint8_t CLASS_ID, const uint8_t SUBCLASS_ID, const uint8_t PROTOCOL_ID, const uint8_t MASK>
ConfigDescParser<CLASS_ID, SUBCLASS_ID, PROTOCOL_ID, MASK>::ConfigDescParser(UsbConfigXtracter *xtractor) :
 801c574:	b580      	push	{r7, lr}
 801c576:	b082      	sub	sp, #8
 801c578:	af00      	add	r7, sp, #0
 801c57a:	6078      	str	r0, [r7, #4]
 801c57c:	6039      	str	r1, [r7, #0]
theXtractor(xtractor),
stateParseDescr(0),
dscrLen(0),
dscrType(0) {
 801c57e:	687b      	ldr	r3, [r7, #4]
 801c580:	4618      	mov	r0, r3
 801c582:	f7fc fc21 	bl	8018dc8 <_ZN13USBReadParserC1Ev>
 801c586:	687b      	ldr	r3, [r7, #4]
 801c588:	4a1f      	ldr	r2, [pc, #124]	; (801c608 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EEC1EP17UsbConfigXtracter+0x94>)
 801c58a:	601a      	str	r2, [r3, #0]
 801c58c:	687b      	ldr	r3, [r7, #4]
 801c58e:	683a      	ldr	r2, [r7, #0]
 801c590:	605a      	str	r2, [r3, #4]
 801c592:	687b      	ldr	r3, [r7, #4]
 801c594:	f103 0310 	add.w	r3, r3, #16
 801c598:	4618      	mov	r0, r3
 801c59a:	f7f9 ff81 	bl	80164a0 <_ZN20MultiByteValueParserC1Ev>
 801c59e:	687b      	ldr	r3, [r7, #4]
 801c5a0:	f103 0318 	add.w	r3, r3, #24
 801c5a4:	4618      	mov	r0, r3
 801c5a6:	f7f9 ffab 	bl	8016500 <_ZN11ByteSkipperC1Ev>
 801c5aa:	687b      	ldr	r3, [r7, #4]
 801c5ac:	f04f 0200 	mov.w	r2, #0
 801c5b0:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
 801c5b4:	687b      	ldr	r3, [r7, #4]
 801c5b6:	f04f 0200 	mov.w	r2, #0
 801c5ba:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
 801c5be:	687b      	ldr	r3, [r7, #4]
 801c5c0:	f04f 0200 	mov.w	r2, #0
 801c5c4:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
	theBuffer.pValue = varBuffer;
 801c5c8:	687b      	ldr	r3, [r7, #4]
 801c5ca:	f103 0220 	add.w	r2, r3, #32
 801c5ce:	687b      	ldr	r3, [r7, #4]
 801c5d0:	f8c3 2009 	str.w	r2, [r3, #9]
	valParser.Initialize(&theBuffer);
 801c5d4:	687b      	ldr	r3, [r7, #4]
 801c5d6:	f103 0210 	add.w	r2, r3, #16
 801c5da:	687b      	ldr	r3, [r7, #4]
 801c5dc:	f103 0308 	add.w	r3, r3, #8
 801c5e0:	4610      	mov	r0, r2
 801c5e2:	4619      	mov	r1, r3
 801c5e4:	f7f9 ff74 	bl	80164d0 <_ZN20MultiByteValueParser10InitializeEP16MultiValueBuffer>
	theSkipper.Initialize(&theBuffer);
 801c5e8:	687b      	ldr	r3, [r7, #4]
 801c5ea:	f103 0218 	add.w	r2, r3, #24
 801c5ee:	687b      	ldr	r3, [r7, #4]
 801c5f0:	f103 0308 	add.w	r3, r3, #8
 801c5f4:	4610      	mov	r0, r2
 801c5f6:	4619      	mov	r1, r3
 801c5f8:	f7f9 ff9a 	bl	8016530 <_ZN11ByteSkipper10InitializeEP16MultiValueBuffer>
 801c5fc:	687b      	ldr	r3, [r7, #4]
};
 801c5fe:	4618      	mov	r0, r3
 801c600:	f107 0708 	add.w	r7, r7, #8
 801c604:	46bd      	mov	sp, r7
 801c606:	bd80      	pop	{r7, pc}
 801c608:	080207e0 	.word	0x080207e0

0801c60c <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE5ParseEtPKhRKt>:

template <const uint8_t CLASS_ID, const uint8_t SUBCLASS_ID, const uint8_t PROTOCOL_ID, const uint8_t MASK>
void ConfigDescParser<CLASS_ID, SUBCLASS_ID, PROTOCOL_ID, MASK>::Parse(const uint16_t len, const uint8_t *pbuf, const uint16_t &offset) {
 801c60c:	b580      	push	{r7, lr}
 801c60e:	b086      	sub	sp, #24
 801c610:	af00      	add	r7, sp, #0
 801c612:	60f8      	str	r0, [r7, #12]
 801c614:	607a      	str	r2, [r7, #4]
 801c616:	603b      	str	r3, [r7, #0]
 801c618:	460b      	mov	r3, r1
 801c61a:	817b      	strh	r3, [r7, #10]
        uint16_t cntdn = (uint16_t) len;
 801c61c:	897b      	ldrh	r3, [r7, #10]
 801c61e:	82fb      	strh	r3, [r7, #22]
        uint8_t *p = (uint8_t*) pbuf;
 801c620:	687b      	ldr	r3, [r7, #4]
 801c622:	613b      	str	r3, [r7, #16]

        while(cntdn)
 801c624:	e00e      	b.n	801c644 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE5ParseEtPKhRKt+0x38>
			if(!ParseDescriptor(&p, &cntdn))
 801c626:	f107 0210 	add.w	r2, r7, #16
 801c62a:	f107 0316 	add.w	r3, r7, #22
 801c62e:	68f8      	ldr	r0, [r7, #12]
 801c630:	4611      	mov	r1, r2
 801c632:	461a      	mov	r2, r3
 801c634:	f000 f816 	bl	801c664 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt>
 801c638:	4603      	mov	r3, r0
 801c63a:	f083 0301 	eor.w	r3, r3, #1
 801c63e:	b2db      	uxtb	r3, r3
 801c640:	2b00      	cmp	r3, #0
 801c642:	d10a      	bne.n	801c65a <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE5ParseEtPKhRKt+0x4e>
template <const uint8_t CLASS_ID, const uint8_t SUBCLASS_ID, const uint8_t PROTOCOL_ID, const uint8_t MASK>
void ConfigDescParser<CLASS_ID, SUBCLASS_ID, PROTOCOL_ID, MASK>::Parse(const uint16_t len, const uint8_t *pbuf, const uint16_t &offset) {
        uint16_t cntdn = (uint16_t) len;
        uint8_t *p = (uint8_t*) pbuf;

        while(cntdn)
 801c644:	8afb      	ldrh	r3, [r7, #22]
 801c646:	2b00      	cmp	r3, #0
 801c648:	bf0c      	ite	eq
 801c64a:	2300      	moveq	r3, #0
 801c64c:	2301      	movne	r3, #1
 801c64e:	b2db      	uxtb	r3, r3
 801c650:	2b00      	cmp	r3, #0
 801c652:	d1e8      	bne.n	801c626 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE5ParseEtPKhRKt+0x1a>
			if(!ParseDescriptor(&p, &cntdn))
				return;
 801c654:	e001      	b.n	801c65a <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE5ParseEtPKhRKt+0x4e>
 801c656:	f000 fa13 	bl	801ca80 <__cxa_end_cleanup>
 801c65a:	bf00      	nop
}
 801c65c:	f107 0718 	add.w	r7, r7, #24
 801c660:	46bd      	mov	sp, r7
 801c662:	bd80      	pop	{r7, pc}

0801c664 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt>:

/* Parser for the configuration descriptor. Takes values for class, subclass, protocol fields in interface descriptor and
  compare masks for them. When the match is found, calls EndpointXtract passing buffer containing endpoint descriptor */
template <const uint8_t CLASS_ID, const uint8_t SUBCLASS_ID, const uint8_t PROTOCOL_ID, const uint8_t MASK>
bool ConfigDescParser<CLASS_ID, SUBCLASS_ID, PROTOCOL_ID, MASK>::ParseDescriptor(uint8_t **pp, uint16_t *pcntdn) {
 801c664:	b5f0      	push	{r4, r5, r6, r7, lr}
 801c666:	b087      	sub	sp, #28
 801c668:	af02      	add	r7, sp, #8
 801c66a:	60f8      	str	r0, [r7, #12]
 801c66c:	60b9      	str	r1, [r7, #8]
 801c66e:	607a      	str	r2, [r7, #4]
        switch(stateParseDescr) {
 801c670:	68fb      	ldr	r3, [r7, #12]
 801c672:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 801c676:	2b04      	cmp	r3, #4
 801c678:	f200 817e 	bhi.w	801c978 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x314>
 801c67c:	a201      	add	r2, pc, #4	; (adr r2, 801c684 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x20>)
 801c67e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801c682:	bf00      	nop
 801c684:	0801c699 	.word	0x0801c699
 801c688:	0801c6bf 	.word	0x0801c6bf
 801c68c:	0801c707 	.word	0x0801c707
 801c690:	0801c71d 	.word	0x0801c71d
 801c694:	0801c7ff 	.word	0x0801c7ff
                case 0:
                        theBuffer.valueSize = 2;
 801c698:	68fb      	ldr	r3, [r7, #12]
 801c69a:	f04f 0202 	mov.w	r2, #2
 801c69e:	721a      	strb	r2, [r3, #8]
                        valParser.Initialize(&theBuffer);
 801c6a0:	68fb      	ldr	r3, [r7, #12]
 801c6a2:	f103 0210 	add.w	r2, r3, #16
 801c6a6:	68fb      	ldr	r3, [r7, #12]
 801c6a8:	f103 0308 	add.w	r3, r3, #8
 801c6ac:	4610      	mov	r0, r2
 801c6ae:	4619      	mov	r1, r3
 801c6b0:	f7f9 ff0e 	bl	80164d0 <_ZN20MultiByteValueParser10InitializeEP16MultiValueBuffer>
                        stateParseDescr = 1;
 801c6b4:	68fb      	ldr	r3, [r7, #12]
 801c6b6:	f04f 0201 	mov.w	r2, #1
 801c6ba:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
                case 1:
                        if(!valParser.Parse(pp, pcntdn))
 801c6be:	68fb      	ldr	r3, [r7, #12]
 801c6c0:	f103 0310 	add.w	r3, r3, #16
 801c6c4:	4618      	mov	r0, r3
 801c6c6:	68b9      	ldr	r1, [r7, #8]
 801c6c8:	687a      	ldr	r2, [r7, #4]
 801c6ca:	f7fc fff1 	bl	80196b0 <_ZN20MultiByteValueParser5ParseEPPhPt>
 801c6ce:	4603      	mov	r3, r0
 801c6d0:	f083 0301 	eor.w	r3, r3, #1
 801c6d4:	b2db      	uxtb	r3, r3
 801c6d6:	2b00      	cmp	r3, #0
 801c6d8:	d002      	beq.n	801c6e0 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x7c>
                                return false;
 801c6da:	f04f 0300 	mov.w	r3, #0
 801c6de:	e14d      	b.n	801c97c <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x318>
                        dscrLen = *((uint8_t*) theBuffer.pValue);
 801c6e0:	68fb      	ldr	r3, [r7, #12]
 801c6e2:	f8d3 3009 	ldr.w	r3, [r3, #9]
 801c6e6:	781a      	ldrb	r2, [r3, #0]
 801c6e8:	68fb      	ldr	r3, [r7, #12]
 801c6ea:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
                        dscrType = *((uint8_t*) theBuffer.pValue + 1);
 801c6ee:	68fb      	ldr	r3, [r7, #12]
 801c6f0:	f8d3 3009 	ldr.w	r3, [r3, #9]
 801c6f4:	785a      	ldrb	r2, [r3, #1]
 801c6f6:	68fb      	ldr	r3, [r7, #12]
 801c6f8:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
                        stateParseDescr = 2;
 801c6fc:	68fb      	ldr	r3, [r7, #12]
 801c6fe:	f04f 0202 	mov.w	r2, #2
 801c702:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
                        // This is a sort of hack. Assuming that two bytes are all ready in the buffer
                        //	the pointer is positioned two bytes ahead in order for the rest of descriptor
                        //	to be read right after the size and the type fields.
                        // This should be used carefully. varBuffer should be used directly to handle data
                        //	in the buffer.
                        theBuffer.pValue = varBuffer + 2;
 801c706:	68fb      	ldr	r3, [r7, #12]
 801c708:	f103 0222 	add.w	r2, r3, #34	; 0x22
 801c70c:	68fb      	ldr	r3, [r7, #12]
 801c70e:	f8c3 2009 	str.w	r2, [r3, #9]
                        stateParseDescr = 3;
 801c712:	68fb      	ldr	r3, [r7, #12]
 801c714:	f04f 0203 	mov.w	r2, #3
 801c718:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
                case 3:
                        switch(dscrType) {
 801c71c:	68fb      	ldr	r3, [r7, #12]
 801c71e:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 801c722:	f1a3 0302 	sub.w	r3, r3, #2
 801c726:	2b1f      	cmp	r3, #31
 801c728:	d85a      	bhi.n	801c7e0 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x17c>
 801c72a:	a201      	add	r2, pc, #4	; (adr r2, 801c730 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0xcc>)
 801c72c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801c730:	0801c7bb 	.word	0x0801c7bb
 801c734:	0801c7e1 	.word	0x0801c7e1
 801c738:	0801c7b1 	.word	0x0801c7b1
 801c73c:	0801c7c5 	.word	0x0801c7c5
 801c740:	0801c7e1 	.word	0x0801c7e1
 801c744:	0801c7e1 	.word	0x0801c7e1
 801c748:	0801c7e1 	.word	0x0801c7e1
 801c74c:	0801c7e1 	.word	0x0801c7e1
 801c750:	0801c7e1 	.word	0x0801c7e1
 801c754:	0801c7e1 	.word	0x0801c7e1
 801c758:	0801c7e1 	.word	0x0801c7e1
 801c75c:	0801c7e1 	.word	0x0801c7e1
 801c760:	0801c7e1 	.word	0x0801c7e1
 801c764:	0801c7e1 	.word	0x0801c7e1
 801c768:	0801c7e1 	.word	0x0801c7e1
 801c76c:	0801c7e1 	.word	0x0801c7e1
 801c770:	0801c7e1 	.word	0x0801c7e1
 801c774:	0801c7e1 	.word	0x0801c7e1
 801c778:	0801c7e1 	.word	0x0801c7e1
 801c77c:	0801c7e1 	.word	0x0801c7e1
 801c780:	0801c7e1 	.word	0x0801c7e1
 801c784:	0801c7e1 	.word	0x0801c7e1
 801c788:	0801c7e1 	.word	0x0801c7e1
 801c78c:	0801c7e1 	.word	0x0801c7e1
 801c790:	0801c7e1 	.word	0x0801c7e1
 801c794:	0801c7e1 	.word	0x0801c7e1
 801c798:	0801c7e1 	.word	0x0801c7e1
 801c79c:	0801c7e1 	.word	0x0801c7e1
 801c7a0:	0801c7e1 	.word	0x0801c7e1
 801c7a4:	0801c7e1 	.word	0x0801c7e1
 801c7a8:	0801c7e1 	.word	0x0801c7e1
 801c7ac:	0801c7cf 	.word	0x0801c7cf
                                case USB_DESCRIPTOR_INTERFACE:
                                        isGoodInterface = false;
 801c7b0:	68fb      	ldr	r3, [r7, #12]
 801c7b2:	f04f 0200 	mov.w	r2, #0
 801c7b6:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
                                case USB_DESCRIPTOR_CONFIGURATION:
                                        theBuffer.valueSize = sizeof(USB_CONFIGURATION_DESCRIPTOR) - 2;
 801c7ba:	68fb      	ldr	r3, [r7, #12]
 801c7bc:	f04f 0207 	mov.w	r2, #7
 801c7c0:	721a      	strb	r2, [r3, #8]
                                        break;
 801c7c2:	e00d      	b.n	801c7e0 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x17c>
                                case USB_DESCRIPTOR_ENDPOINT:
                                        theBuffer.valueSize = sizeof(USB_ENDPOINT_DESCRIPTOR) - 2;
 801c7c4:	68fb      	ldr	r3, [r7, #12]
 801c7c6:	f04f 0205 	mov.w	r2, #5
 801c7ca:	721a      	strb	r2, [r3, #8]
                                        break;
 801c7cc:	e008      	b.n	801c7e0 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x17c>
                                case HID_DESCRIPTOR_HID:
                                        theBuffer.valueSize = dscrLen - 2;
 801c7ce:	68fb      	ldr	r3, [r7, #12]
 801c7d0:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 801c7d4:	f1a3 0302 	sub.w	r3, r3, #2
 801c7d8:	b2da      	uxtb	r2, r3
 801c7da:	68fb      	ldr	r3, [r7, #12]
 801c7dc:	721a      	strb	r2, [r3, #8]
                                        break;
 801c7de:	bf00      	nop
                        }
                        valParser.Initialize(&theBuffer);
 801c7e0:	68fb      	ldr	r3, [r7, #12]
 801c7e2:	f103 0210 	add.w	r2, r3, #16
 801c7e6:	68fb      	ldr	r3, [r7, #12]
 801c7e8:	f103 0308 	add.w	r3, r3, #8
 801c7ec:	4610      	mov	r0, r2
 801c7ee:	4619      	mov	r1, r3
 801c7f0:	f7f9 fe6e 	bl	80164d0 <_ZN20MultiByteValueParser10InitializeEP16MultiValueBuffer>
                        stateParseDescr = 4;
 801c7f4:	68fb      	ldr	r3, [r7, #12]
 801c7f6:	f04f 0204 	mov.w	r2, #4
 801c7fa:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
                case 4:
					switch(dscrType) {
 801c7fe:	68fb      	ldr	r3, [r7, #12]
 801c800:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 801c804:	2b04      	cmp	r3, #4
 801c806:	d01d      	beq.n	801c844 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x1e0>
 801c808:	2b05      	cmp	r3, #5
 801c80a:	d059      	beq.n	801c8c0 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x25c>
 801c80c:	2b02      	cmp	r3, #2
 801c80e:	f040 808a 	bne.w	801c926 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x2c2>
							case USB_DESCRIPTOR_CONFIGURATION:
								if(!valParser.Parse(pp, pcntdn))
 801c812:	68fb      	ldr	r3, [r7, #12]
 801c814:	f103 0310 	add.w	r3, r3, #16
 801c818:	4618      	mov	r0, r3
 801c81a:	68b9      	ldr	r1, [r7, #8]
 801c81c:	687a      	ldr	r2, [r7, #4]
 801c81e:	f7fc ff47 	bl	80196b0 <_ZN20MultiByteValueParser5ParseEPPhPt>
 801c822:	4603      	mov	r3, r0
 801c824:	f083 0301 	eor.w	r3, r3, #1
 801c828:	b2db      	uxtb	r3, r3
 801c82a:	2b00      	cmp	r3, #0
 801c82c:	d002      	beq.n	801c834 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x1d0>
									return false;
 801c82e:	f04f 0300 	mov.w	r3, #0
 801c832:	e0a3      	b.n	801c97c <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x318>
								confValue = ((USB_CONFIGURATION_DESCRIPTOR*) varBuffer)->bConfigurationValue;
 801c834:	68fb      	ldr	r3, [r7, #12]
 801c836:	f103 0320 	add.w	r3, r3, #32
 801c83a:	795a      	ldrb	r2, [r3, #5]
 801c83c:	68fb      	ldr	r3, [r7, #12]
 801c83e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
								break;
 801c842:	e08e      	b.n	801c962 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x2fe>
							case USB_DESCRIPTOR_INTERFACE:
								if(!valParser.Parse(pp, pcntdn))
 801c844:	68fb      	ldr	r3, [r7, #12]
 801c846:	f103 0310 	add.w	r3, r3, #16
 801c84a:	4618      	mov	r0, r3
 801c84c:	68b9      	ldr	r1, [r7, #8]
 801c84e:	687a      	ldr	r2, [r7, #4]
 801c850:	f7fc ff2e 	bl	80196b0 <_ZN20MultiByteValueParser5ParseEPPhPt>
 801c854:	4603      	mov	r3, r0
 801c856:	f083 0301 	eor.w	r3, r3, #1
 801c85a:	b2db      	uxtb	r3, r3
 801c85c:	2b00      	cmp	r3, #0
 801c85e:	d002      	beq.n	801c866 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x202>
									return false;
 801c860:	f04f 0300 	mov.w	r3, #0
 801c864:	e08a      	b.n	801c97c <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x318>
								if((MASK & CP_MASK_COMPARE_CLASS) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceClass != CLASS_ID)
 801c866:	68fb      	ldr	r3, [r7, #12]
 801c868:	f103 0320 	add.w	r3, r3, #32
 801c86c:	795b      	ldrb	r3, [r3, #5]
 801c86e:	2bff      	cmp	r3, #255	; 0xff
 801c870:	d170      	bne.n	801c954 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x2f0>
									break;
								if((MASK & CP_MASK_COMPARE_SUBCLASS) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceSubClass != SUBCLASS_ID)
 801c872:	68fb      	ldr	r3, [r7, #12]
 801c874:	f103 0320 	add.w	r3, r3, #32
 801c878:	799b      	ldrb	r3, [r3, #6]
 801c87a:	2bff      	cmp	r3, #255	; 0xff
 801c87c:	d16c      	bne.n	801c958 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x2f4>
									break;
								if((MASK & CP_MASK_COMPARE_PROTOCOL) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceProtocol != PROTOCOL_ID)
 801c87e:	68fb      	ldr	r3, [r7, #12]
 801c880:	f103 0320 	add.w	r3, r3, #32
 801c884:	79db      	ldrb	r3, [r3, #7]
 801c886:	2bff      	cmp	r3, #255	; 0xff
 801c888:	d168      	bne.n	801c95c <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x2f8>
									break;

								isGoodInterface = true;
 801c88a:	68fb      	ldr	r3, [r7, #12]
 801c88c:	f04f 0201 	mov.w	r2, #1
 801c890:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
								ifaceNumber = ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceNumber;
 801c894:	68fb      	ldr	r3, [r7, #12]
 801c896:	f103 0320 	add.w	r3, r3, #32
 801c89a:	789a      	ldrb	r2, [r3, #2]
 801c89c:	68fb      	ldr	r3, [r7, #12]
 801c89e:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
								ifaceAltSet = ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bAlternateSetting;
 801c8a2:	68fb      	ldr	r3, [r7, #12]
 801c8a4:	f103 0320 	add.w	r3, r3, #32
 801c8a8:	78da      	ldrb	r2, [r3, #3]
 801c8aa:	68fb      	ldr	r3, [r7, #12]
 801c8ac:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
								protoValue = ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceProtocol;
 801c8b0:	68fb      	ldr	r3, [r7, #12]
 801c8b2:	f103 0320 	add.w	r3, r3, #32
 801c8b6:	79da      	ldrb	r2, [r3, #7]
 801c8b8:	68fb      	ldr	r3, [r7, #12]
 801c8ba:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
								break;
 801c8be:	e050      	b.n	801c962 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x2fe>
							case USB_DESCRIPTOR_ENDPOINT:
								if(!valParser.Parse(pp, pcntdn))
 801c8c0:	68fb      	ldr	r3, [r7, #12]
 801c8c2:	f103 0310 	add.w	r3, r3, #16
 801c8c6:	4618      	mov	r0, r3
 801c8c8:	68b9      	ldr	r1, [r7, #8]
 801c8ca:	687a      	ldr	r2, [r7, #4]
 801c8cc:	f7fc fef0 	bl	80196b0 <_ZN20MultiByteValueParser5ParseEPPhPt>
 801c8d0:	4603      	mov	r3, r0
 801c8d2:	f083 0301 	eor.w	r3, r3, #1
 801c8d6:	b2db      	uxtb	r3, r3
 801c8d8:	2b00      	cmp	r3, #0
 801c8da:	d002      	beq.n	801c8e2 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x27e>
										return false;
 801c8dc:	f04f 0300 	mov.w	r3, #0
 801c8e0:	e04c      	b.n	801c97c <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x318>
								if(isGoodInterface)
 801c8e2:	68fb      	ldr	r3, [r7, #12]
 801c8e4:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
 801c8e8:	2b00      	cmp	r3, #0
 801c8ea:	d039      	beq.n	801c960 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x2fc>
									if(theXtractor)
 801c8ec:	68fb      	ldr	r3, [r7, #12]
 801c8ee:	685b      	ldr	r3, [r3, #4]
 801c8f0:	2b00      	cmp	r3, #0
 801c8f2:	d035      	beq.n	801c960 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x2fc>
										theXtractor->EndpointXtract(confValue, ifaceNumber, ifaceAltSet, protoValue, (USB_ENDPOINT_DESCRIPTOR*) varBuffer);
 801c8f4:	68fb      	ldr	r3, [r7, #12]
 801c8f6:	685b      	ldr	r3, [r3, #4]
 801c8f8:	681b      	ldr	r3, [r3, #0]
 801c8fa:	681c      	ldr	r4, [r3, #0]
 801c8fc:	68fb      	ldr	r3, [r7, #12]
 801c8fe:	6858      	ldr	r0, [r3, #4]
 801c900:	68fb      	ldr	r3, [r7, #12]
 801c902:	f893 1034 	ldrb.w	r1, [r3, #52]	; 0x34
 801c906:	68fb      	ldr	r3, [r7, #12]
 801c908:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
 801c90c:	68fb      	ldr	r3, [r7, #12]
 801c90e:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
 801c912:	68fd      	ldr	r5, [r7, #12]
 801c914:	f895 6035 	ldrb.w	r6, [r5, #53]	; 0x35
 801c918:	68fd      	ldr	r5, [r7, #12]
 801c91a:	f105 0520 	add.w	r5, r5, #32
 801c91e:	9600      	str	r6, [sp, #0]
 801c920:	9501      	str	r5, [sp, #4]
 801c922:	47a0      	blx	r4
								break;
 801c924:	e01c      	b.n	801c960 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x2fc>
								//	if (!valParser.Parse(pp, pcntdn))
								//		return false;
								//	PrintHidDescriptor((const USB_HID_DESCRIPTOR*)varBuffer);
								//	break;
							default:
								if(!theSkipper.Skip(pp, pcntdn, dscrLen - 2))
 801c926:	68fb      	ldr	r3, [r7, #12]
 801c928:	f103 0218 	add.w	r2, r3, #24
 801c92c:	68fb      	ldr	r3, [r7, #12]
 801c92e:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 801c932:	f1a3 0302 	sub.w	r3, r3, #2
 801c936:	b29b      	uxth	r3, r3
 801c938:	4610      	mov	r0, r2
 801c93a:	68b9      	ldr	r1, [r7, #8]
 801c93c:	687a      	ldr	r2, [r7, #4]
 801c93e:	f7f9 fe0b 	bl	8016558 <_ZN11ByteSkipper4SkipEPPhPtt>
 801c942:	4603      	mov	r3, r0
 801c944:	f083 0301 	eor.w	r3, r3, #1
 801c948:	b2db      	uxtb	r3, r3
 801c94a:	2b00      	cmp	r3, #0
 801c94c:	d009      	beq.n	801c962 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x2fe>
									return false;
 801c94e:	f04f 0300 	mov.w	r3, #0
 801c952:	e013      	b.n	801c97c <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x318>
								break;
							case USB_DESCRIPTOR_INTERFACE:
								if(!valParser.Parse(pp, pcntdn))
									return false;
								if((MASK & CP_MASK_COMPARE_CLASS) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceClass != CLASS_ID)
									break;
 801c954:	bf00      	nop
 801c956:	e004      	b.n	801c962 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x2fe>
								if((MASK & CP_MASK_COMPARE_SUBCLASS) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceSubClass != SUBCLASS_ID)
									break;
 801c958:	bf00      	nop
 801c95a:	e002      	b.n	801c962 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x2fe>
								if((MASK & CP_MASK_COMPARE_PROTOCOL) && ((USB_INTERFACE_DESCRIPTOR*) varBuffer)->bInterfaceProtocol != PROTOCOL_ID)
									break;
 801c95c:	bf00      	nop
 801c95e:	e000      	b.n	801c962 <_ZN16ConfigDescParserILh255ELh255ELh255ELh7EE15ParseDescriptorEPPhPt+0x2fe>
								if(!valParser.Parse(pp, pcntdn))
										return false;
								if(isGoodInterface)
									if(theXtractor)
										theXtractor->EndpointXtract(confValue, ifaceNumber, ifaceAltSet, protoValue, (USB_ENDPOINT_DESCRIPTOR*) varBuffer);
								break;
 801c960:	bf00      	nop
								//	break;
							default:
								if(!theSkipper.Skip(pp, pcntdn, dscrLen - 2))
									return false;
					}
					theBuffer.pValue = varBuffer;
 801c962:	68fb      	ldr	r3, [r7, #12]
 801c964:	f103 0220 	add.w	r2, r3, #32
 801c968:	68fb      	ldr	r3, [r7, #12]
 801c96a:	f8c3 2009 	str.w	r2, [r3, #9]
					stateParseDescr = 0;
 801c96e:	68fb      	ldr	r3, [r7, #12]
 801c970:	f04f 0200 	mov.w	r2, #0
 801c974:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
        }
        return true;
 801c978:	f04f 0301 	mov.w	r3, #1
}
 801c97c:	4618      	mov	r0, r3
 801c97e:	f107 0714 	add.w	r7, r7, #20
 801c982:	46bd      	mov	sp, r7
 801c984:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801c986:	bf00      	nop

0801c988 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PPv>:
 801c988:	b570      	push	{r4, r5, r6, lr}
 801c98a:	4615      	mov	r5, r2
 801c98c:	6806      	ldr	r6, [r0, #0]
 801c98e:	b084      	sub	sp, #16
 801c990:	2400      	movs	r4, #0
 801c992:	2210      	movs	r2, #16
 801c994:	466b      	mov	r3, sp
 801c996:	9202      	str	r2, [sp, #8]
 801c998:	9400      	str	r4, [sp, #0]
 801c99a:	f88d 4004 	strb.w	r4, [sp, #4]
 801c99e:	9403      	str	r4, [sp, #12]
 801c9a0:	69b6      	ldr	r6, [r6, #24]
 801c9a2:	682a      	ldr	r2, [r5, #0]
 801c9a4:	47b0      	blx	r6
 801c9a6:	f89d 3004 	ldrb.w	r3, [sp, #4]
 801c9aa:	f003 0306 	and.w	r3, r3, #6
 801c9ae:	2b06      	cmp	r3, #6
 801c9b0:	bf18      	it	ne
 801c9b2:	4620      	movne	r0, r4
 801c9b4:	d102      	bne.n	801c9bc <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PPv+0x34>
 801c9b6:	9b00      	ldr	r3, [sp, #0]
 801c9b8:	2001      	movs	r0, #1
 801c9ba:	602b      	str	r3, [r5, #0]
 801c9bc:	b004      	add	sp, #16
 801c9be:	bd70      	pop	{r4, r5, r6, pc}

0801c9c0 <_ZNK10__cxxabiv117__class_type_info20__do_find_public_srcEiPKvPKS0_S2_>:
 801c9c0:	9800      	ldr	r0, [sp, #0]
 801c9c2:	4290      	cmp	r0, r2
 801c9c4:	bf14      	ite	ne
 801c9c6:	2001      	movne	r0, #1
 801c9c8:	2006      	moveq	r0, #6
 801c9ca:	4770      	bx	lr

0801c9cc <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE>:
 801c9cc:	b538      	push	{r3, r4, r5, lr}
 801c9ce:	4615      	mov	r5, r2
 801c9d0:	461c      	mov	r4, r3
 801c9d2:	f000 fd53 	bl	801d47c <_ZNKSt9type_infoeqERKS_>
 801c9d6:	b128      	cbz	r0, 801c9e4 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE+0x18>
 801c9d8:	2001      	movs	r0, #1
 801c9da:	2308      	movs	r3, #8
 801c9dc:	6025      	str	r5, [r4, #0]
 801c9de:	60e3      	str	r3, [r4, #12]
 801c9e0:	2306      	movs	r3, #6
 801c9e2:	7123      	strb	r3, [r4, #4]
 801c9e4:	bd38      	pop	{r3, r4, r5, pc}
 801c9e6:	bf00      	nop

0801c9e8 <_ZN10__cxxabiv117__class_type_infoD1Ev>:
 801c9e8:	4b03      	ldr	r3, [pc, #12]	; (801c9f8 <_ZN10__cxxabiv117__class_type_infoD1Ev+0x10>)
 801c9ea:	b510      	push	{r4, lr}
 801c9ec:	4604      	mov	r4, r0
 801c9ee:	6003      	str	r3, [r0, #0]
 801c9f0:	f000 fd2e 	bl	801d450 <_ZNSt9type_infoD1Ev>
 801c9f4:	4620      	mov	r0, r4
 801c9f6:	bd10      	pop	{r4, pc}
 801c9f8:	080208a0 	.word	0x080208a0

0801c9fc <_ZN10__cxxabiv117__class_type_infoD0Ev>:
 801c9fc:	b510      	push	{r4, lr}
 801c9fe:	4604      	mov	r4, r0
 801ca00:	f7ff fff2 	bl	801c9e8 <_ZN10__cxxabiv117__class_type_infoD1Ev>
 801ca04:	4620      	mov	r0, r4
 801ca06:	f000 f837 	bl	801ca78 <_ZdlPv>
 801ca0a:	4620      	mov	r0, r4
 801ca0c:	bd10      	pop	{r4, pc}
 801ca0e:	bf00      	nop

0801ca10 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE>:
 801ca10:	b5f0      	push	{r4, r5, r6, r7, lr}
 801ca12:	b083      	sub	sp, #12
 801ca14:	4606      	mov	r6, r0
 801ca16:	4617      	mov	r7, r2
 801ca18:	9c08      	ldr	r4, [sp, #32]
 801ca1a:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 801ca1c:	42ac      	cmp	r4, r5
 801ca1e:	d00c      	beq.n	801ca3a <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x2a>
 801ca20:	4630      	mov	r0, r6
 801ca22:	4619      	mov	r1, r3
 801ca24:	f000 fd2a 	bl	801d47c <_ZNKSt9type_infoeqERKS_>
 801ca28:	b120      	cbz	r0, 801ca34 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x24>
 801ca2a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801ca2c:	2301      	movs	r3, #1
 801ca2e:	6014      	str	r4, [r2, #0]
 801ca30:	7117      	strb	r7, [r2, #4]
 801ca32:	7193      	strb	r3, [r2, #6]
 801ca34:	2000      	movs	r0, #0
 801ca36:	b003      	add	sp, #12
 801ca38:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801ca3a:	9909      	ldr	r1, [sp, #36]	; 0x24
 801ca3c:	9301      	str	r3, [sp, #4]
 801ca3e:	f000 fd1d 	bl	801d47c <_ZNKSt9type_infoeqERKS_>
 801ca42:	9b01      	ldr	r3, [sp, #4]
 801ca44:	2800      	cmp	r0, #0
 801ca46:	d0eb      	beq.n	801ca20 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x10>
 801ca48:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801ca4a:	715f      	strb	r7, [r3, #5]
 801ca4c:	e7f2      	b.n	801ca34 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x24>
 801ca4e:	bf00      	nop

0801ca50 <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj>:
 801ca50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801ca52:	4607      	mov	r7, r0
 801ca54:	460d      	mov	r5, r1
 801ca56:	4616      	mov	r6, r2
 801ca58:	461c      	mov	r4, r3
 801ca5a:	f000 fd0f 	bl	801d47c <_ZNKSt9type_infoeqERKS_>
 801ca5e:	b948      	cbnz	r0, 801ca74 <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj+0x24>
 801ca60:	2c03      	cmp	r4, #3
 801ca62:	d900      	bls.n	801ca66 <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj+0x16>
 801ca64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801ca66:	682b      	ldr	r3, [r5, #0]
 801ca68:	4628      	mov	r0, r5
 801ca6a:	4639      	mov	r1, r7
 801ca6c:	4632      	mov	r2, r6
 801ca6e:	695b      	ldr	r3, [r3, #20]
 801ca70:	4798      	blx	r3
 801ca72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801ca74:	2001      	movs	r0, #1
 801ca76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0801ca78 <_ZdlPv>:
 801ca78:	b108      	cbz	r0, 801ca7e <_ZdlPv+0x6>
 801ca7a:	f7f4 be87 	b.w	801178c <free>
 801ca7e:	4770      	bx	lr

0801ca80 <__cxa_end_cleanup>:
 801ca80:	b41e      	push	{r1, r2, r3, r4}
 801ca82:	f000 f88d 	bl	801cba0 <__gnu_end_cleanup>
 801ca86:	bc1e      	pop	{r1, r2, r3, r4}
 801ca88:	f7f4 f9d6 	bl	8010e38 <_Unwind_Resume>

0801ca8c <__cxa_type_match>:
 801ca8c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801ca8e:	461f      	mov	r7, r3
 801ca90:	7803      	ldrb	r3, [r0, #0]
 801ca92:	b083      	sub	sp, #12
 801ca94:	460e      	mov	r6, r1
 801ca96:	2b47      	cmp	r3, #71	; 0x47
 801ca98:	d01d      	beq.n	801cad6 <__cxa_type_match+0x4a>
 801ca9a:	4c26      	ldr	r4, [pc, #152]	; (801cb34 <__cxa_type_match+0xa8>)
 801ca9c:	2300      	movs	r3, #0
 801ca9e:	9301      	str	r3, [sp, #4]
 801caa0:	6822      	ldr	r2, [r4, #0]
 801caa2:	4620      	mov	r0, r4
 801caa4:	2501      	movs	r5, #1
 801caa6:	6893      	ldr	r3, [r2, #8]
 801caa8:	4798      	blx	r3
 801caaa:	b118      	cbz	r0, 801cab4 <__cxa_type_match+0x28>
 801caac:	9b01      	ldr	r3, [sp, #4]
 801caae:	2502      	movs	r5, #2
 801cab0:	681b      	ldr	r3, [r3, #0]
 801cab2:	9301      	str	r3, [sp, #4]
 801cab4:	f8d6 e000 	ldr.w	lr, [r6]
 801cab8:	4621      	mov	r1, r4
 801caba:	4630      	mov	r0, r6
 801cabc:	aa01      	add	r2, sp, #4
 801cabe:	2301      	movs	r3, #1
 801cac0:	f8de 4010 	ldr.w	r4, [lr, #16]
 801cac4:	47a0      	blx	r4
 801cac6:	b120      	cbz	r0, 801cad2 <__cxa_type_match+0x46>
 801cac8:	9b01      	ldr	r3, [sp, #4]
 801caca:	603b      	str	r3, [r7, #0]
 801cacc:	4628      	mov	r0, r5
 801cace:	b003      	add	sp, #12
 801cad0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801cad2:	4605      	mov	r5, r0
 801cad4:	e7fa      	b.n	801cacc <__cxa_type_match+0x40>
 801cad6:	7843      	ldrb	r3, [r0, #1]
 801cad8:	2b4e      	cmp	r3, #78	; 0x4e
 801cada:	d1de      	bne.n	801ca9a <__cxa_type_match+0xe>
 801cadc:	7883      	ldrb	r3, [r0, #2]
 801cade:	2b55      	cmp	r3, #85	; 0x55
 801cae0:	d1db      	bne.n	801ca9a <__cxa_type_match+0xe>
 801cae2:	78c3      	ldrb	r3, [r0, #3]
 801cae4:	2b43      	cmp	r3, #67	; 0x43
 801cae6:	d1d8      	bne.n	801ca9a <__cxa_type_match+0xe>
 801cae8:	7903      	ldrb	r3, [r0, #4]
 801caea:	2b46      	cmp	r3, #70	; 0x46
 801caec:	d016      	beq.n	801cb1c <__cxa_type_match+0x90>
 801caee:	7903      	ldrb	r3, [r0, #4]
 801caf0:	2b43      	cmp	r3, #67	; 0x43
 801caf2:	d1d2      	bne.n	801ca9a <__cxa_type_match+0xe>
 801caf4:	7943      	ldrb	r3, [r0, #5]
 801caf6:	2b2b      	cmp	r3, #43	; 0x2b
 801caf8:	d1cf      	bne.n	801ca9a <__cxa_type_match+0xe>
 801cafa:	7983      	ldrb	r3, [r0, #6]
 801cafc:	2b2b      	cmp	r3, #43	; 0x2b
 801cafe:	d1cc      	bne.n	801ca9a <__cxa_type_match+0xe>
 801cb00:	79c3      	ldrb	r3, [r0, #7]
 801cb02:	2b01      	cmp	r3, #1
 801cb04:	d8c9      	bhi.n	801ca9a <__cxa_type_match+0xe>
 801cb06:	d004      	beq.n	801cb12 <__cxa_type_match+0x86>
 801cb08:	f850 4c20 	ldr.w	r4, [r0, #-32]
 801cb0c:	3058      	adds	r0, #88	; 0x58
 801cb0e:	9001      	str	r0, [sp, #4]
 801cb10:	e7c6      	b.n	801caa0 <__cxa_type_match+0x14>
 801cb12:	f850 0c20 	ldr.w	r0, [r0, #-32]
 801cb16:	f850 4c78 	ldr.w	r4, [r0, #-120]
 801cb1a:	e7f8      	b.n	801cb0e <__cxa_type_match+0x82>
 801cb1c:	7943      	ldrb	r3, [r0, #5]
 801cb1e:	2b4f      	cmp	r3, #79	; 0x4f
 801cb20:	d1e5      	bne.n	801caee <__cxa_type_match+0x62>
 801cb22:	7983      	ldrb	r3, [r0, #6]
 801cb24:	2b52      	cmp	r3, #82	; 0x52
 801cb26:	d1e2      	bne.n	801caee <__cxa_type_match+0x62>
 801cb28:	79c3      	ldrb	r3, [r0, #7]
 801cb2a:	2b00      	cmp	r3, #0
 801cb2c:	d1df      	bne.n	801caee <__cxa_type_match+0x62>
 801cb2e:	9301      	str	r3, [sp, #4]
 801cb30:	4c01      	ldr	r4, [pc, #4]	; (801cb38 <__cxa_type_match+0xac>)
 801cb32:	e7b5      	b.n	801caa0 <__cxa_type_match+0x14>
 801cb34:	08020994 	.word	0x08020994
 801cb38:	08020928 	.word	0x08020928

0801cb3c <__cxa_begin_cleanup>:
 801cb3c:	b510      	push	{r4, lr}
 801cb3e:	4604      	mov	r4, r0
 801cb40:	f000 f8ba 	bl	801ccb8 <__cxa_get_globals>
 801cb44:	f1a4 0220 	sub.w	r2, r4, #32
 801cb48:	7823      	ldrb	r3, [r4, #0]
 801cb4a:	2b47      	cmp	r3, #71	; 0x47
 801cb4c:	d004      	beq.n	801cb58 <__cxa_begin_cleanup+0x1c>
 801cb4e:	6883      	ldr	r3, [r0, #8]
 801cb50:	bb23      	cbnz	r3, 801cb9c <__cxa_begin_cleanup+0x60>
 801cb52:	6082      	str	r2, [r0, #8]
 801cb54:	2001      	movs	r0, #1
 801cb56:	bd10      	pop	{r4, pc}
 801cb58:	7863      	ldrb	r3, [r4, #1]
 801cb5a:	2b4e      	cmp	r3, #78	; 0x4e
 801cb5c:	d1f7      	bne.n	801cb4e <__cxa_begin_cleanup+0x12>
 801cb5e:	78a3      	ldrb	r3, [r4, #2]
 801cb60:	2b55      	cmp	r3, #85	; 0x55
 801cb62:	d1f4      	bne.n	801cb4e <__cxa_begin_cleanup+0x12>
 801cb64:	78e3      	ldrb	r3, [r4, #3]
 801cb66:	2b43      	cmp	r3, #67	; 0x43
 801cb68:	d1f1      	bne.n	801cb4e <__cxa_begin_cleanup+0x12>
 801cb6a:	7923      	ldrb	r3, [r4, #4]
 801cb6c:	2b43      	cmp	r3, #67	; 0x43
 801cb6e:	d1ee      	bne.n	801cb4e <__cxa_begin_cleanup+0x12>
 801cb70:	7963      	ldrb	r3, [r4, #5]
 801cb72:	2b2b      	cmp	r3, #43	; 0x2b
 801cb74:	d1eb      	bne.n	801cb4e <__cxa_begin_cleanup+0x12>
 801cb76:	79a3      	ldrb	r3, [r4, #6]
 801cb78:	2b2b      	cmp	r3, #43	; 0x2b
 801cb7a:	d1e8      	bne.n	801cb4e <__cxa_begin_cleanup+0x12>
 801cb7c:	79e3      	ldrb	r3, [r4, #7]
 801cb7e:	2b01      	cmp	r3, #1
 801cb80:	d8e5      	bhi.n	801cb4e <__cxa_begin_cleanup+0x12>
 801cb82:	f854 3c04 	ldr.w	r3, [r4, #-4]
 801cb86:	3301      	adds	r3, #1
 801cb88:	f844 3c04 	str.w	r3, [r4, #-4]
 801cb8c:	2b01      	cmp	r3, #1
 801cb8e:	d1e1      	bne.n	801cb54 <__cxa_begin_cleanup+0x18>
 801cb90:	6883      	ldr	r3, [r0, #8]
 801cb92:	f844 3c08 	str.w	r3, [r4, #-8]
 801cb96:	6082      	str	r2, [r0, #8]
 801cb98:	2001      	movs	r0, #1
 801cb9a:	bd10      	pop	{r4, pc}
 801cb9c:	f000 fb7c 	bl	801d298 <_ZSt9terminatev>

0801cba0 <__gnu_end_cleanup>:
 801cba0:	b508      	push	{r3, lr}
 801cba2:	f000 f889 	bl	801ccb8 <__cxa_get_globals>
 801cba6:	6883      	ldr	r3, [r0, #8]
 801cba8:	2b00      	cmp	r3, #0
 801cbaa:	d030      	beq.n	801cc0e <__gnu_end_cleanup+0x6e>
 801cbac:	f893 2020 	ldrb.w	r2, [r3, #32]
 801cbb0:	2a47      	cmp	r2, #71	; 0x47
 801cbb2:	d004      	beq.n	801cbbe <__gnu_end_cleanup+0x1e>
 801cbb4:	2200      	movs	r2, #0
 801cbb6:	6082      	str	r2, [r0, #8]
 801cbb8:	f103 0020 	add.w	r0, r3, #32
 801cbbc:	bd08      	pop	{r3, pc}
 801cbbe:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
 801cbc2:	2a4e      	cmp	r2, #78	; 0x4e
 801cbc4:	d1f6      	bne.n	801cbb4 <__gnu_end_cleanup+0x14>
 801cbc6:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
 801cbca:	2a55      	cmp	r2, #85	; 0x55
 801cbcc:	d1f2      	bne.n	801cbb4 <__gnu_end_cleanup+0x14>
 801cbce:	f893 2023 	ldrb.w	r2, [r3, #35]	; 0x23
 801cbd2:	2a43      	cmp	r2, #67	; 0x43
 801cbd4:	d1ee      	bne.n	801cbb4 <__gnu_end_cleanup+0x14>
 801cbd6:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 801cbda:	2a43      	cmp	r2, #67	; 0x43
 801cbdc:	d1ea      	bne.n	801cbb4 <__gnu_end_cleanup+0x14>
 801cbde:	f893 2025 	ldrb.w	r2, [r3, #37]	; 0x25
 801cbe2:	2a2b      	cmp	r2, #43	; 0x2b
 801cbe4:	d1e6      	bne.n	801cbb4 <__gnu_end_cleanup+0x14>
 801cbe6:	f893 2026 	ldrb.w	r2, [r3, #38]	; 0x26
 801cbea:	2a2b      	cmp	r2, #43	; 0x2b
 801cbec:	d1e2      	bne.n	801cbb4 <__gnu_end_cleanup+0x14>
 801cbee:	f893 2027 	ldrb.w	r2, [r3, #39]	; 0x27
 801cbf2:	2a01      	cmp	r2, #1
 801cbf4:	d8de      	bhi.n	801cbb4 <__gnu_end_cleanup+0x14>
 801cbf6:	69da      	ldr	r2, [r3, #28]
 801cbf8:	3a01      	subs	r2, #1
 801cbfa:	61da      	str	r2, [r3, #28]
 801cbfc:	2a00      	cmp	r2, #0
 801cbfe:	d1db      	bne.n	801cbb8 <__gnu_end_cleanup+0x18>
 801cc00:	699a      	ldr	r2, [r3, #24]
 801cc02:	6082      	str	r2, [r0, #8]
 801cc04:	2200      	movs	r2, #0
 801cc06:	f103 0020 	add.w	r0, r3, #32
 801cc0a:	619a      	str	r2, [r3, #24]
 801cc0c:	bd08      	pop	{r3, pc}
 801cc0e:	f000 fb43 	bl	801d298 <_ZSt9terminatev>
 801cc12:	bf00      	nop

0801cc14 <_ZNSt9exceptionD1Ev>:
 801cc14:	4b01      	ldr	r3, [pc, #4]	; (801cc1c <_ZNSt9exceptionD1Ev+0x8>)
 801cc16:	6003      	str	r3, [r0, #0]
 801cc18:	4770      	bx	lr
 801cc1a:	bf00      	nop
 801cc1c:	08020918 	.word	0x08020918

0801cc20 <_ZNSt13bad_exceptionD1Ev>:
 801cc20:	4b01      	ldr	r3, [pc, #4]	; (801cc28 <_ZNSt13bad_exceptionD1Ev+0x8>)
 801cc22:	6003      	str	r3, [r0, #0]
 801cc24:	4770      	bx	lr
 801cc26:	bf00      	nop
 801cc28:	08020918 	.word	0x08020918

0801cc2c <_ZN10__cxxabiv115__forced_unwindD1Ev>:
 801cc2c:	4b01      	ldr	r3, [pc, #4]	; (801cc34 <_ZN10__cxxabiv115__forced_unwindD1Ev+0x8>)
 801cc2e:	6003      	str	r3, [r0, #0]
 801cc30:	4770      	bx	lr
 801cc32:	bf00      	nop
 801cc34:	08020900 	.word	0x08020900

0801cc38 <_ZN10__cxxabiv119__foreign_exceptionD1Ev>:
 801cc38:	4b01      	ldr	r3, [pc, #4]	; (801cc40 <_ZN10__cxxabiv119__foreign_exceptionD1Ev+0x8>)
 801cc3a:	6003      	str	r3, [r0, #0]
 801cc3c:	4770      	bx	lr
 801cc3e:	bf00      	nop
 801cc40:	080209d0 	.word	0x080209d0

0801cc44 <_ZNKSt9exception4whatEv>:
 801cc44:	f640 104c 	movw	r0, #2380	; 0x94c
 801cc48:	f6c0 0002 	movt	r0, #2050	; 0x802
 801cc4c:	4770      	bx	lr
 801cc4e:	bf00      	nop

0801cc50 <_ZNKSt13bad_exception4whatEv>:
 801cc50:	f640 105c 	movw	r0, #2396	; 0x95c
 801cc54:	f6c0 0002 	movt	r0, #2050	; 0x802
 801cc58:	4770      	bx	lr
 801cc5a:	bf00      	nop

0801cc5c <_ZN10__cxxabiv119__foreign_exceptionD0Ev>:
 801cc5c:	4b03      	ldr	r3, [pc, #12]	; (801cc6c <_ZN10__cxxabiv119__foreign_exceptionD0Ev+0x10>)
 801cc5e:	b510      	push	{r4, lr}
 801cc60:	4604      	mov	r4, r0
 801cc62:	6003      	str	r3, [r0, #0]
 801cc64:	f7ff ff08 	bl	801ca78 <_ZdlPv>
 801cc68:	4620      	mov	r0, r4
 801cc6a:	bd10      	pop	{r4, pc}
 801cc6c:	080209d0 	.word	0x080209d0

0801cc70 <_ZN10__cxxabiv115__forced_unwindD0Ev>:
 801cc70:	4b03      	ldr	r3, [pc, #12]	; (801cc80 <_ZN10__cxxabiv115__forced_unwindD0Ev+0x10>)
 801cc72:	b510      	push	{r4, lr}
 801cc74:	4604      	mov	r4, r0
 801cc76:	6003      	str	r3, [r0, #0]
 801cc78:	f7ff fefe 	bl	801ca78 <_ZdlPv>
 801cc7c:	4620      	mov	r0, r4
 801cc7e:	bd10      	pop	{r4, pc}
 801cc80:	08020900 	.word	0x08020900

0801cc84 <_ZNSt9exceptionD0Ev>:
 801cc84:	4b03      	ldr	r3, [pc, #12]	; (801cc94 <_ZNSt9exceptionD0Ev+0x10>)
 801cc86:	b510      	push	{r4, lr}
 801cc88:	4604      	mov	r4, r0
 801cc8a:	6003      	str	r3, [r0, #0]
 801cc8c:	f7ff fef4 	bl	801ca78 <_ZdlPv>
 801cc90:	4620      	mov	r0, r4
 801cc92:	bd10      	pop	{r4, pc}
 801cc94:	08020918 	.word	0x08020918

0801cc98 <_ZNSt13bad_exceptionD0Ev>:
 801cc98:	4b03      	ldr	r3, [pc, #12]	; (801cca8 <_ZNSt13bad_exceptionD0Ev+0x10>)
 801cc9a:	b510      	push	{r4, lr}
 801cc9c:	4604      	mov	r4, r0
 801cc9e:	6003      	str	r3, [r0, #0]
 801cca0:	f7ff feea 	bl	801ca78 <_ZdlPv>
 801cca4:	4620      	mov	r0, r4
 801cca6:	bd10      	pop	{r4, pc}
 801cca8:	08020918 	.word	0x08020918

0801ccac <__cxa_get_globals_fast>:
 801ccac:	f640 4074 	movw	r0, #3188	; 0xc74
 801ccb0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ccb4:	4770      	bx	lr
 801ccb6:	bf00      	nop

0801ccb8 <__cxa_get_globals>:
 801ccb8:	f640 4074 	movw	r0, #3188	; 0xc74
 801ccbc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ccc0:	4770      	bx	lr
 801ccc2:	bf00      	nop

0801ccc4 <_ZL12read_sleb128PKhPl>:
 801ccc4:	b430      	push	{r4, r5}
 801ccc6:	2400      	movs	r4, #0
 801ccc8:	4623      	mov	r3, r4
 801ccca:	f810 2b01 	ldrb.w	r2, [r0], #1
 801ccce:	f002 057f 	and.w	r5, r2, #127	; 0x7f
 801ccd2:	fa05 f503 	lsl.w	r5, r5, r3
 801ccd6:	3307      	adds	r3, #7
 801ccd8:	f012 0f80 	tst.w	r2, #128	; 0x80
 801ccdc:	ea44 0405 	orr.w	r4, r4, r5
 801cce0:	d1f3      	bne.n	801ccca <_ZL12read_sleb128PKhPl+0x6>
 801cce2:	2b1f      	cmp	r3, #31
 801cce4:	d808      	bhi.n	801ccf8 <_ZL12read_sleb128PKhPl+0x34>
 801cce6:	f002 0240 	and.w	r2, r2, #64	; 0x40
 801ccea:	b2d2      	uxtb	r2, r2
 801ccec:	b122      	cbz	r2, 801ccf8 <_ZL12read_sleb128PKhPl+0x34>
 801ccee:	f04f 32ff 	mov.w	r2, #4294967295
 801ccf2:	fa02 f303 	lsl.w	r3, r2, r3
 801ccf6:	431c      	orrs	r4, r3
 801ccf8:	600c      	str	r4, [r1, #0]
 801ccfa:	bc30      	pop	{r4, r5}
 801ccfc:	4770      	bx	lr
 801ccfe:	bf00      	nop

0801cd00 <_ZL28read_encoded_value_with_basehjPKhPj>:
 801cd00:	2850      	cmp	r0, #80	; 0x50
 801cd02:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801cd06:	4606      	mov	r6, r0
 801cd08:	b084      	sub	sp, #16
 801cd0a:	460f      	mov	r7, r1
 801cd0c:	d048      	beq.n	801cda0 <_ZL28read_encoded_value_with_basehjPKhPj+0xa0>
 801cd0e:	f000 050f 	and.w	r5, r0, #15
 801cd12:	2d0c      	cmp	r5, #12
 801cd14:	d82d      	bhi.n	801cd72 <_ZL28read_encoded_value_with_basehjPKhPj+0x72>
 801cd16:	e8df f005 	tbb	[pc, r5]
 801cd1a:	2e07      	.short	0x2e07
 801cd1c:	2c19073f 	.word	0x2c19073f
 801cd20:	212c2c2c 	.word	0x212c2c2c
 801cd24:	071d      	.short	0x071d
 801cd26:	19          	.byte	0x19
 801cd27:	00          	.byte	0x00
 801cd28:	4614      	mov	r4, r2
 801cd2a:	f854 5b04 	ldr.w	r5, [r4], #4
 801cd2e:	b145      	cbz	r5, 801cd42 <_ZL28read_encoded_value_with_basehjPKhPj+0x42>
 801cd30:	f006 0170 	and.w	r1, r6, #112	; 0x70
 801cd34:	2910      	cmp	r1, #16
 801cd36:	bf08      	it	eq
 801cd38:	4617      	moveq	r7, r2
 801cd3a:	0632      	lsls	r2, r6, #24
 801cd3c:	443d      	add	r5, r7
 801cd3e:	bf48      	it	mi
 801cd40:	682d      	ldrmi	r5, [r5, #0]
 801cd42:	601d      	str	r5, [r3, #0]
 801cd44:	4620      	mov	r0, r4
 801cd46:	b004      	add	sp, #16
 801cd48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801cd4c:	4614      	mov	r4, r2
 801cd4e:	f854 5b08 	ldr.w	r5, [r4], #8
 801cd52:	e7ec      	b.n	801cd2e <_ZL28read_encoded_value_with_basehjPKhPj+0x2e>
 801cd54:	4614      	mov	r4, r2
 801cd56:	f934 5b02 	ldrsh.w	r5, [r4], #2
 801cd5a:	e7e8      	b.n	801cd2e <_ZL28read_encoded_value_with_basehjPKhPj+0x2e>
 801cd5c:	4610      	mov	r0, r2
 801cd5e:	a903      	add	r1, sp, #12
 801cd60:	9201      	str	r2, [sp, #4]
 801cd62:	9300      	str	r3, [sp, #0]
 801cd64:	f7ff ffae 	bl	801ccc4 <_ZL12read_sleb128PKhPl>
 801cd68:	9d03      	ldr	r5, [sp, #12]
 801cd6a:	9a01      	ldr	r2, [sp, #4]
 801cd6c:	9b00      	ldr	r3, [sp, #0]
 801cd6e:	4604      	mov	r4, r0
 801cd70:	e7dd      	b.n	801cd2e <_ZL28read_encoded_value_with_basehjPKhPj+0x2e>
 801cd72:	f7f4 fa7d 	bl	8011270 <abort>
 801cd76:	2500      	movs	r5, #0
 801cd78:	4694      	mov	ip, r2
 801cd7a:	4629      	mov	r1, r5
 801cd7c:	4664      	mov	r4, ip
 801cd7e:	f814 0b01 	ldrb.w	r0, [r4], #1
 801cd82:	f000 087f 	and.w	r8, r0, #127	; 0x7f
 801cd86:	46a4      	mov	ip, r4
 801cd88:	fa08 f801 	lsl.w	r8, r8, r1
 801cd8c:	3107      	adds	r1, #7
 801cd8e:	0600      	lsls	r0, r0, #24
 801cd90:	ea45 0508 	orr.w	r5, r5, r8
 801cd94:	d4f2      	bmi.n	801cd7c <_ZL28read_encoded_value_with_basehjPKhPj+0x7c>
 801cd96:	e7ca      	b.n	801cd2e <_ZL28read_encoded_value_with_basehjPKhPj+0x2e>
 801cd98:	4614      	mov	r4, r2
 801cd9a:	f834 5b02 	ldrh.w	r5, [r4], #2
 801cd9e:	e7c6      	b.n	801cd2e <_ZL28read_encoded_value_with_basehjPKhPj+0x2e>
 801cda0:	1cd4      	adds	r4, r2, #3
 801cda2:	f024 0403 	bic.w	r4, r4, #3
 801cda6:	f854 5b04 	ldr.w	r5, [r4], #4
 801cdaa:	e7ca      	b.n	801cd42 <_ZL28read_encoded_value_with_basehjPKhPj+0x42>

0801cdac <_ZL21base_of_encoded_valuehP15_Unwind_Context>:
 801cdac:	28ff      	cmp	r0, #255	; 0xff
 801cdae:	b508      	push	{r3, lr}
 801cdb0:	d00d      	beq.n	801cdce <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x22>
 801cdb2:	f000 0370 	and.w	r3, r0, #112	; 0x70
 801cdb6:	2b20      	cmp	r3, #32
 801cdb8:	d013      	beq.n	801cde2 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x36>
 801cdba:	d907      	bls.n	801cdcc <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x20>
 801cdbc:	2b40      	cmp	r3, #64	; 0x40
 801cdbe:	d00b      	beq.n	801cdd8 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x2c>
 801cdc0:	2b50      	cmp	r3, #80	; 0x50
 801cdc2:	d004      	beq.n	801cdce <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x22>
 801cdc4:	2b30      	cmp	r3, #48	; 0x30
 801cdc6:	d011      	beq.n	801cdec <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x40>
 801cdc8:	f7f4 fa52 	bl	8011270 <abort>
 801cdcc:	b90b      	cbnz	r3, 801cdd2 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x26>
 801cdce:	2000      	movs	r0, #0
 801cdd0:	bd08      	pop	{r3, pc}
 801cdd2:	2b10      	cmp	r3, #16
 801cdd4:	d1f8      	bne.n	801cdc8 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x1c>
 801cdd6:	e7fa      	b.n	801cdce <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x22>
 801cdd8:	4608      	mov	r0, r1
 801cdda:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 801cdde:	f7f4 ba2f 	b.w	8011240 <_Unwind_GetRegionStart>
 801cde2:	4608      	mov	r0, r1
 801cde4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 801cde8:	f7f4 ba3e 	b.w	8011268 <_Unwind_GetTextRelBase>
 801cdec:	4608      	mov	r0, r1
 801cdee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 801cdf2:	f7f4 ba35 	b.w	8011260 <_Unwind_GetDataRelBase>
 801cdf6:	bf00      	nop

0801cdf8 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info>:
 801cdf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801cdfa:	460c      	mov	r4, r1
 801cdfc:	4616      	mov	r6, r2
 801cdfe:	4607      	mov	r7, r0
 801ce00:	b108      	cbz	r0, 801ce06 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0xe>
 801ce02:	f7f4 fa1d 	bl	8011240 <_Unwind_GetRegionStart>
 801ce06:	6030      	str	r0, [r6, #0]
 801ce08:	f814 5b01 	ldrb.w	r5, [r4], #1
 801ce0c:	2dff      	cmp	r5, #255	; 0xff
 801ce0e:	bf08      	it	eq
 801ce10:	6070      	streq	r0, [r6, #4]
 801ce12:	d00a      	beq.n	801ce2a <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x32>
 801ce14:	4639      	mov	r1, r7
 801ce16:	4628      	mov	r0, r5
 801ce18:	f7ff ffc8 	bl	801cdac <_ZL21base_of_encoded_valuehP15_Unwind_Context>
 801ce1c:	4622      	mov	r2, r4
 801ce1e:	1d33      	adds	r3, r6, #4
 801ce20:	4601      	mov	r1, r0
 801ce22:	4628      	mov	r0, r5
 801ce24:	f7ff ff6c 	bl	801cd00 <_ZL28read_encoded_value_with_basehjPKhPj>
 801ce28:	4604      	mov	r4, r0
 801ce2a:	4620      	mov	r0, r4
 801ce2c:	f810 3b01 	ldrb.w	r3, [r0], #1
 801ce30:	2bff      	cmp	r3, #255	; 0xff
 801ce32:	7533      	strb	r3, [r6, #20]
 801ce34:	d022      	beq.n	801ce7c <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x84>
 801ce36:	2200      	movs	r2, #0
 801ce38:	2110      	movs	r1, #16
 801ce3a:	4613      	mov	r3, r2
 801ce3c:	7531      	strb	r1, [r6, #20]
 801ce3e:	f810 4b01 	ldrb.w	r4, [r0], #1
 801ce42:	f004 017f 	and.w	r1, r4, #127	; 0x7f
 801ce46:	fa01 f103 	lsl.w	r1, r1, r3
 801ce4a:	3307      	adds	r3, #7
 801ce4c:	430a      	orrs	r2, r1
 801ce4e:	0621      	lsls	r1, r4, #24
 801ce50:	d4f5      	bmi.n	801ce3e <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x46>
 801ce52:	1882      	adds	r2, r0, r2
 801ce54:	60f2      	str	r2, [r6, #12]
 801ce56:	2100      	movs	r1, #0
 801ce58:	f810 2b01 	ldrb.w	r2, [r0], #1
 801ce5c:	460b      	mov	r3, r1
 801ce5e:	7572      	strb	r2, [r6, #21]
 801ce60:	f810 4b01 	ldrb.w	r4, [r0], #1
 801ce64:	f004 057f 	and.w	r5, r4, #127	; 0x7f
 801ce68:	fa05 f503 	lsl.w	r5, r5, r3
 801ce6c:	3307      	adds	r3, #7
 801ce6e:	0622      	lsls	r2, r4, #24
 801ce70:	ea41 0105 	orr.w	r1, r1, r5
 801ce74:	d4f4      	bmi.n	801ce60 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x68>
 801ce76:	1841      	adds	r1, r0, r1
 801ce78:	6131      	str	r1, [r6, #16]
 801ce7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801ce7c:	2300      	movs	r3, #0
 801ce7e:	60f3      	str	r3, [r6, #12]
 801ce80:	e7e9      	b.n	801ce56 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x5e>
 801ce82:	bf00      	nop

0801ce84 <__gxx_personality_v0>:
 801ce84:	f000 0303 	and.w	r3, r0, #3
 801ce88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ce8c:	2400      	movs	r4, #0
 801ce8e:	b093      	sub	sp, #76	; 0x4c
 801ce90:	2b01      	cmp	r3, #1
 801ce92:	460e      	mov	r6, r1
 801ce94:	4615      	mov	r5, r2
 801ce96:	9404      	str	r4, [sp, #16]
 801ce98:	f000 80ef 	beq.w	801d07a <__gxx_personality_v0+0x1f6>
 801ce9c:	f080 808e 	bcs.w	801cfbc <__gxx_personality_v0+0x138>
 801cea0:	f000 0008 	and.w	r0, r0, #8
 801cea4:	f04f 0901 	mov.w	r9, #1
 801cea8:	fa5f f880 	uxtb.w	r8, r0
 801ceac:	ac12      	add	r4, sp, #72	; 0x48
 801ceae:	2100      	movs	r1, #0
 801ceb0:	220c      	movs	r2, #12
 801ceb2:	460b      	mov	r3, r1
 801ceb4:	f844 6d2c 	str.w	r6, [r4, #-44]!
 801ceb8:	4628      	mov	r0, r5
 801ceba:	9400      	str	r4, [sp, #0]
 801cebc:	f7f3 fc1e 	bl	80106fc <_Unwind_VRS_Set>
 801cec0:	4628      	mov	r0, r5
 801cec2:	f7f4 f9c3 	bl	801124c <_Unwind_GetLanguageSpecificData>
 801cec6:	4607      	mov	r7, r0
 801cec8:	2800      	cmp	r0, #0
 801ceca:	f000 80cd 	beq.w	801d068 <__gxx_personality_v0+0x1e4>
 801cece:	aa0c      	add	r2, sp, #48	; 0x30
 801ced0:	4601      	mov	r1, r0
 801ced2:	4628      	mov	r0, r5
 801ced4:	ac0b      	add	r4, sp, #44	; 0x2c
 801ced6:	f7ff ff8f 	bl	801cdf8 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info>
 801ceda:	4629      	mov	r1, r5
 801cedc:	ea48 0809 	orr.w	r8, r8, r9
 801cee0:	4682      	mov	sl, r0
 801cee2:	f89d 0044 	ldrb.w	r0, [sp, #68]	; 0x44
 801cee6:	f7ff ff61 	bl	801cdac <_ZL21base_of_encoded_valuehP15_Unwind_Context>
 801ceea:	2100      	movs	r1, #0
 801ceec:	460b      	mov	r3, r1
 801ceee:	9400      	str	r4, [sp, #0]
 801cef0:	220f      	movs	r2, #15
 801cef2:	900e      	str	r0, [sp, #56]	; 0x38
 801cef4:	4628      	mov	r0, r5
 801cef6:	f7f3 fbdd 	bl	80106b4 <_Unwind_VRS_Get>
 801cefa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801cefc:	f023 0301 	bic.w	r3, r3, #1
 801cf00:	f103 39ff 	add.w	r9, r3, #4294967295
 801cf04:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801cf06:	459a      	cmp	sl, r3
 801cf08:	d239      	bcs.n	801cf7e <__gxx_personality_v0+0xfa>
 801cf0a:	f89d b045 	ldrb.w	fp, [sp, #69]	; 0x45
 801cf0e:	2100      	movs	r1, #0
 801cf10:	4658      	mov	r0, fp
 801cf12:	f7ff ff4b 	bl	801cdac <_ZL21base_of_encoded_valuehP15_Unwind_Context>
 801cf16:	4652      	mov	r2, sl
 801cf18:	ab09      	add	r3, sp, #36	; 0x24
 801cf1a:	4601      	mov	r1, r0
 801cf1c:	4658      	mov	r0, fp
 801cf1e:	f7ff feef 	bl	801cd00 <_ZL28read_encoded_value_with_basehjPKhPj>
 801cf22:	f89d a045 	ldrb.w	sl, [sp, #69]	; 0x45
 801cf26:	2100      	movs	r1, #0
 801cf28:	4683      	mov	fp, r0
 801cf2a:	4650      	mov	r0, sl
 801cf2c:	f7ff ff3e 	bl	801cdac <_ZL21base_of_encoded_valuehP15_Unwind_Context>
 801cf30:	465a      	mov	r2, fp
 801cf32:	ab0a      	add	r3, sp, #40	; 0x28
 801cf34:	4601      	mov	r1, r0
 801cf36:	4650      	mov	r0, sl
 801cf38:	f7ff fee2 	bl	801cd00 <_ZL28read_encoded_value_with_basehjPKhPj>
 801cf3c:	f89d a045 	ldrb.w	sl, [sp, #69]	; 0x45
 801cf40:	2100      	movs	r1, #0
 801cf42:	4683      	mov	fp, r0
 801cf44:	4650      	mov	r0, sl
 801cf46:	f7ff ff31 	bl	801cdac <_ZL21base_of_encoded_valuehP15_Unwind_Context>
 801cf4a:	465a      	mov	r2, fp
 801cf4c:	4623      	mov	r3, r4
 801cf4e:	4601      	mov	r1, r0
 801cf50:	4650      	mov	r0, sl
 801cf52:	f7ff fed5 	bl	801cd00 <_ZL28read_encoded_value_with_basehjPKhPj>
 801cf56:	2100      	movs	r1, #0
 801cf58:	468e      	mov	lr, r1
 801cf5a:	f810 3b01 	ldrb.w	r3, [r0], #1
 801cf5e:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 801cf62:	061b      	lsls	r3, r3, #24
 801cf64:	4682      	mov	sl, r0
 801cf66:	fa02 f20e 	lsl.w	r2, r2, lr
 801cf6a:	f10e 0e07 	add.w	lr, lr, #7
 801cf6e:	ea41 0102 	orr.w	r1, r1, r2
 801cf72:	d4f2      	bmi.n	801cf5a <__gxx_personality_v0+0xd6>
 801cf74:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801cf76:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801cf78:	18d3      	adds	r3, r2, r3
 801cf7a:	4599      	cmp	r9, r3
 801cf7c:	d222      	bcs.n	801cfc4 <__gxx_personality_v0+0x140>
 801cf7e:	f04f 0900 	mov.w	r9, #0
 801cf82:	f04f 0a01 	mov.w	sl, #1
 801cf86:	f04f 0b00 	mov.w	fp, #0
 801cf8a:	f018 0f01 	tst.w	r8, #1
 801cf8e:	f000 80a1 	beq.w	801d0d4 <__gxx_personality_v0+0x250>
 801cf92:	f1ba 0f02 	cmp.w	sl, #2
 801cf96:	d067      	beq.n	801d068 <__gxx_personality_v0+0x1e4>
 801cf98:	2100      	movs	r1, #0
 801cf9a:	9400      	str	r4, [sp, #0]
 801cf9c:	460b      	mov	r3, r1
 801cf9e:	4628      	mov	r0, r5
 801cfa0:	220d      	movs	r2, #13
 801cfa2:	9c04      	ldr	r4, [sp, #16]
 801cfa4:	f7f3 fb86 	bl	80106b4 <_Unwind_VRS_Get>
 801cfa8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801cfaa:	f8c6 b028 	str.w	fp, [r6, #40]	; 0x28
 801cfae:	2006      	movs	r0, #6
 801cfb0:	6274      	str	r4, [r6, #36]	; 0x24
 801cfb2:	6233      	str	r3, [r6, #32]
 801cfb4:	62f7      	str	r7, [r6, #44]	; 0x2c
 801cfb6:	f8c6 9030 	str.w	r9, [r6, #48]	; 0x30
 801cfba:	e05b      	b.n	801d074 <__gxx_personality_v0+0x1f0>
 801cfbc:	2b02      	cmp	r3, #2
 801cfbe:	d053      	beq.n	801d068 <__gxx_personality_v0+0x1e4>
 801cfc0:	f7f4 f956 	bl	8011270 <abort>
 801cfc4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801cfc6:	189b      	adds	r3, r3, r2
 801cfc8:	4599      	cmp	r9, r3
 801cfca:	d29b      	bcs.n	801cf04 <__gxx_personality_v0+0x80>
 801cfcc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801cfce:	4699      	mov	r9, r3
 801cfd0:	b113      	cbz	r3, 801cfd8 <__gxx_personality_v0+0x154>
 801cfd2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801cfd4:	eb03 0902 	add.w	r9, r3, r2
 801cfd8:	2900      	cmp	r1, #0
 801cfda:	f000 80dd 	beq.w	801d198 <__gxx_personality_v0+0x314>
 801cfde:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801cfe0:	3901      	subs	r1, #1
 801cfe2:	1858      	adds	r0, r3, r1
 801cfe4:	f1b9 0f00 	cmp.w	r9, #0
 801cfe8:	d03e      	beq.n	801d068 <__gxx_personality_v0+0x1e4>
 801cfea:	2800      	cmp	r0, #0
 801cfec:	f000 80d8 	beq.w	801d1a0 <__gxx_personality_v0+0x31c>
 801cff0:	f018 0108 	ands.w	r1, r8, #8
 801cff4:	9103      	str	r1, [sp, #12]
 801cff6:	f000 8123 	beq.w	801d240 <__gxx_personality_v0+0x3bc>
 801cffa:	2347      	movs	r3, #71	; 0x47
 801cffc:	7033      	strb	r3, [r6, #0]
 801cffe:	234e      	movs	r3, #78	; 0x4e
 801d000:	7073      	strb	r3, [r6, #1]
 801d002:	2355      	movs	r3, #85	; 0x55
 801d004:	70b3      	strb	r3, [r6, #2]
 801d006:	2343      	movs	r3, #67	; 0x43
 801d008:	70f3      	strb	r3, [r6, #3]
 801d00a:	2346      	movs	r3, #70	; 0x46
 801d00c:	7133      	strb	r3, [r6, #4]
 801d00e:	234f      	movs	r3, #79	; 0x4f
 801d010:	7173      	strb	r3, [r6, #5]
 801d012:	2352      	movs	r3, #82	; 0x52
 801d014:	71b3      	strb	r3, [r6, #6]
 801d016:	2300      	movs	r3, #0
 801d018:	71f3      	strb	r3, [r6, #7]
 801d01a:	f04f 0b00 	mov.w	fp, #0
 801d01e:	9502      	str	r5, [sp, #8]
 801d020:	a905      	add	r1, sp, #20
 801d022:	f7ff fe4f 	bl	801ccc4 <_ZL12read_sleb128PKhPl>
 801d026:	a906      	add	r1, sp, #24
 801d028:	4682      	mov	sl, r0
 801d02a:	f7ff fe4b 	bl	801ccc4 <_ZL12read_sleb128PKhPl>
 801d02e:	9a05      	ldr	r2, [sp, #20]
 801d030:	2a00      	cmp	r2, #0
 801d032:	f000 80d6 	beq.w	801d1e2 <__gxx_personality_v0+0x35e>
 801d036:	f340 80dc 	ble.w	801d1f2 <__gxx_personality_v0+0x36e>
 801d03a:	f89d 0044 	ldrb.w	r0, [sp, #68]	; 0x44
 801d03e:	28ff      	cmp	r0, #255	; 0xff
 801d040:	f000 80fb 	beq.w	801d23a <__gxx_personality_v0+0x3b6>
 801d044:	f000 0307 	and.w	r3, r0, #7
 801d048:	2b04      	cmp	r3, #4
 801d04a:	d8b9      	bhi.n	801cfc0 <__gxx_personality_v0+0x13c>
 801d04c:	a101      	add	r1, pc, #4	; (adr r1, 801d054 <__gxx_personality_v0+0x1d0>)
 801d04e:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 801d052:	bf00      	nop
 801d054:	0801d1d7 	.word	0x0801d1d7
 801d058:	0801cfc1 	.word	0x0801cfc1
 801d05c:	0801d1a7 	.word	0x0801d1a7
 801d060:	0801d1d7 	.word	0x0801d1d7
 801d064:	0801d1dd 	.word	0x0801d1dd
 801d068:	4630      	mov	r0, r6
 801d06a:	4629      	mov	r1, r5
 801d06c:	f7f4 f8d2 	bl	8011214 <__gnu_unwind_frame>
 801d070:	b958      	cbnz	r0, 801d08a <__gxx_personality_v0+0x206>
 801d072:	2008      	movs	r0, #8
 801d074:	b013      	add	sp, #76	; 0x4c
 801d076:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801d07a:	f000 0008 	and.w	r0, r0, #8
 801d07e:	f000 08ff 	and.w	r8, r0, #255	; 0xff
 801d082:	b120      	cbz	r0, 801d08e <__gxx_personality_v0+0x20a>
 801d084:	f04f 0902 	mov.w	r9, #2
 801d088:	e710      	b.n	801ceac <__gxx_personality_v0+0x28>
 801d08a:	2009      	movs	r0, #9
 801d08c:	e7f2      	b.n	801d074 <__gxx_personality_v0+0x1f0>
 801d08e:	4610      	mov	r0, r2
 801d090:	4643      	mov	r3, r8
 801d092:	220d      	movs	r2, #13
 801d094:	ac0b      	add	r4, sp, #44	; 0x2c
 801d096:	4641      	mov	r1, r8
 801d098:	9400      	str	r4, [sp, #0]
 801d09a:	6a37      	ldr	r7, [r6, #32]
 801d09c:	f7f3 fb0a 	bl	80106b4 <_Unwind_VRS_Get>
 801d0a0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801d0a2:	429f      	cmp	r7, r3
 801d0a4:	d1ee      	bne.n	801d084 <__gxx_personality_v0+0x200>
 801d0a6:	af12      	add	r7, sp, #72	; 0x48
 801d0a8:	4643      	mov	r3, r8
 801d0aa:	4641      	mov	r1, r8
 801d0ac:	4628      	mov	r0, r5
 801d0ae:	f847 6d2c 	str.w	r6, [r7, #-44]!
 801d0b2:	220c      	movs	r2, #12
 801d0b4:	9700      	str	r7, [sp, #0]
 801d0b6:	f04f 0a03 	mov.w	sl, #3
 801d0ba:	f7f3 fb1f 	bl	80106fc <_Unwind_VRS_Set>
 801d0be:	f106 0328 	add.w	r3, r6, #40	; 0x28
 801d0c2:	e893 0288 	ldmia.w	r3, {r3, r7, r9}
 801d0c6:	469b      	mov	fp, r3
 801d0c8:	f1b9 0f00 	cmp.w	r9, #0
 801d0cc:	d141      	bne.n	801d152 <__gxx_personality_v0+0x2ce>
 801d0ce:	4630      	mov	r0, r6
 801d0d0:	f000 fe06 	bl	801dce0 <__cxa_call_terminate>
 801d0d4:	f018 0f08 	tst.w	r8, #8
 801d0d8:	d038      	beq.n	801d14c <__gxx_personality_v0+0x2c8>
 801d0da:	f1ba 0f01 	cmp.w	sl, #1
 801d0de:	f000 80c5 	beq.w	801d26c <__gxx_personality_v0+0x3e8>
 801d0e2:	f1bb 0f00 	cmp.w	fp, #0
 801d0e6:	f2c0 80bd 	blt.w	801d264 <__gxx_personality_v0+0x3e0>
 801d0ea:	af12      	add	r7, sp, #72	; 0x48
 801d0ec:	2100      	movs	r1, #0
 801d0ee:	460a      	mov	r2, r1
 801d0f0:	460b      	mov	r3, r1
 801d0f2:	f847 6d24 	str.w	r6, [r7, #-36]!
 801d0f6:	4628      	mov	r0, r5
 801d0f8:	9700      	str	r7, [sp, #0]
 801d0fa:	af12      	add	r7, sp, #72	; 0x48
 801d0fc:	f7f3 fafe 	bl	80106fc <_Unwind_VRS_Set>
 801d100:	2100      	movs	r1, #0
 801d102:	2201      	movs	r2, #1
 801d104:	460b      	mov	r3, r1
 801d106:	f847 bd20 	str.w	fp, [r7, #-32]!
 801d10a:	4628      	mov	r0, r5
 801d10c:	9700      	str	r7, [sp, #0]
 801d10e:	f7f3 faf5 	bl	80106fc <_Unwind_VRS_Set>
 801d112:	2100      	movs	r1, #0
 801d114:	460b      	mov	r3, r1
 801d116:	220f      	movs	r2, #15
 801d118:	9400      	str	r4, [sp, #0]
 801d11a:	4628      	mov	r0, r5
 801d11c:	f7f3 faca 	bl	80106b4 <_Unwind_VRS_Get>
 801d120:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801d122:	2100      	movs	r1, #0
 801d124:	9400      	str	r4, [sp, #0]
 801d126:	220f      	movs	r2, #15
 801d128:	f003 0401 	and.w	r4, r3, #1
 801d12c:	4628      	mov	r0, r5
 801d12e:	460b      	mov	r3, r1
 801d130:	ea49 0404 	orr.w	r4, r9, r4
 801d134:	940b      	str	r4, [sp, #44]	; 0x2c
 801d136:	f7f3 fae1 	bl	80106fc <_Unwind_VRS_Set>
 801d13a:	2007      	movs	r0, #7
 801d13c:	f1ba 0f02 	cmp.w	sl, #2
 801d140:	d198      	bne.n	801d074 <__gxx_personality_v0+0x1f0>
 801d142:	4630      	mov	r0, r6
 801d144:	f7ff fcfa 	bl	801cb3c <__cxa_begin_cleanup>
 801d148:	2007      	movs	r0, #7
 801d14a:	e793      	b.n	801d074 <__gxx_personality_v0+0x1f0>
 801d14c:	f1ba 0f01 	cmp.w	sl, #1
 801d150:	d0bd      	beq.n	801d0ce <__gxx_personality_v0+0x24a>
 801d152:	f1bb 0f00 	cmp.w	fp, #0
 801d156:	dac8      	bge.n	801d0ea <__gxx_personality_v0+0x266>
 801d158:	4639      	mov	r1, r7
 801d15a:	aa0c      	add	r2, sp, #48	; 0x30
 801d15c:	4628      	mov	r0, r5
 801d15e:	f7ff fe4b 	bl	801cdf8 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info>
 801d162:	f89d 0044 	ldrb.w	r0, [sp, #68]	; 0x44
 801d166:	4629      	mov	r1, r5
 801d168:	f7ff fe20 	bl	801cdac <_ZL21base_of_encoded_valuehP15_Unwind_Context>
 801d16c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801d16e:	ea6f 020b 	mvn.w	r2, fp
 801d172:	eb03 0782 	add.w	r7, r3, r2, lsl #2
 801d176:	900e      	str	r0, [sp, #56]	; 0x38
 801d178:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801d17c:	b133      	cbz	r3, 801d18c <__gxx_personality_v0+0x308>
 801d17e:	463a      	mov	r2, r7
 801d180:	2300      	movs	r3, #0
 801d182:	f852 1f04 	ldr.w	r1, [r2, #4]!
 801d186:	3301      	adds	r3, #1
 801d188:	2900      	cmp	r1, #0
 801d18a:	d1fa      	bne.n	801d182 <__gxx_personality_v0+0x2fe>
 801d18c:	62b3      	str	r3, [r6, #40]	; 0x28
 801d18e:	2304      	movs	r3, #4
 801d190:	62f0      	str	r0, [r6, #44]	; 0x2c
 801d192:	6333      	str	r3, [r6, #48]	; 0x30
 801d194:	6377      	str	r7, [r6, #52]	; 0x34
 801d196:	e7a8      	b.n	801d0ea <__gxx_personality_v0+0x266>
 801d198:	f1b9 0f00 	cmp.w	r9, #0
 801d19c:	f43f af64 	beq.w	801d068 <__gxx_personality_v0+0x1e4>
 801d1a0:	f04f 0a02 	mov.w	sl, #2
 801d1a4:	e6ef      	b.n	801cf86 <__gxx_personality_v0+0x102>
 801d1a6:	f04f 0e02 	mov.w	lr, #2
 801d1aa:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 801d1ac:	4623      	mov	r3, r4
 801d1ae:	990e      	ldr	r1, [sp, #56]	; 0x38
 801d1b0:	fb02 521e 	mls	r2, r2, lr, r5
 801d1b4:	f7ff fda4 	bl	801cd00 <_ZL28read_encoded_value_with_basehjPKhPj>
 801d1b8:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801d1ba:	b131      	cbz	r1, 801d1ca <__gxx_personality_v0+0x346>
 801d1bc:	b19e      	cbz	r6, 801d1e6 <__gxx_personality_v0+0x362>
 801d1be:	4630      	mov	r0, r6
 801d1c0:	2200      	movs	r2, #0
 801d1c2:	ab04      	add	r3, sp, #16
 801d1c4:	f7ff fc62 	bl	801ca8c <__cxa_type_match>
 801d1c8:	b168      	cbz	r0, 801d1e6 <__gxx_personality_v0+0x362>
 801d1ca:	9d02      	ldr	r5, [sp, #8]
 801d1cc:	9a05      	ldr	r2, [sp, #20]
 801d1ce:	4693      	mov	fp, r2
 801d1d0:	f04f 0a03 	mov.w	sl, #3
 801d1d4:	e6d9      	b.n	801cf8a <__gxx_personality_v0+0x106>
 801d1d6:	f04f 0e04 	mov.w	lr, #4
 801d1da:	e7e6      	b.n	801d1aa <__gxx_personality_v0+0x326>
 801d1dc:	f04f 0e08 	mov.w	lr, #8
 801d1e0:	e7e3      	b.n	801d1aa <__gxx_personality_v0+0x326>
 801d1e2:	f04f 0b01 	mov.w	fp, #1
 801d1e6:	9b06      	ldr	r3, [sp, #24]
 801d1e8:	2b00      	cmp	r3, #0
 801d1ea:	d032      	beq.n	801d252 <__gxx_personality_v0+0x3ce>
 801d1ec:	eb0a 0003 	add.w	r0, sl, r3
 801d1f0:	e716      	b.n	801d020 <__gxx_personality_v0+0x19c>
 801d1f2:	b10e      	cbz	r6, 801d1f8 <__gxx_personality_v0+0x374>
 801d1f4:	9b03      	ldr	r3, [sp, #12]
 801d1f6:	b13b      	cbz	r3, 801d208 <__gxx_personality_v0+0x384>
 801d1f8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801d1fa:	43d1      	mvns	r1, r2
 801d1fc:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 801d200:	2b00      	cmp	r3, #0
 801d202:	d1f0      	bne.n	801d1e6 <__gxx_personality_v0+0x362>
 801d204:	9d02      	ldr	r5, [sp, #8]
 801d206:	e7e2      	b.n	801d1ce <__gxx_personality_v0+0x34a>
 801d208:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801d20a:	43d1      	mvns	r1, r2
 801d20c:	eb03 0c81 	add.w	ip, r3, r1, lsl #2
 801d210:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 801d214:	9b04      	ldr	r3, [sp, #16]
 801d216:	9308      	str	r3, [sp, #32]
 801d218:	2900      	cmp	r1, #0
 801d21a:	d0f3      	beq.n	801d204 <__gxx_personality_v0+0x380>
 801d21c:	4665      	mov	r5, ip
 801d21e:	e003      	b.n	801d228 <__gxx_personality_v0+0x3a4>
 801d220:	f855 1f04 	ldr.w	r1, [r5, #4]!
 801d224:	2900      	cmp	r1, #0
 801d226:	d0d0      	beq.n	801d1ca <__gxx_personality_v0+0x346>
 801d228:	4630      	mov	r0, r6
 801d22a:	1869      	adds	r1, r5, r1
 801d22c:	2200      	movs	r2, #0
 801d22e:	ab08      	add	r3, sp, #32
 801d230:	f7ff fc2c 	bl	801ca8c <__cxa_type_match>
 801d234:	2800      	cmp	r0, #0
 801d236:	d0f3      	beq.n	801d220 <__gxx_personality_v0+0x39c>
 801d238:	e7d5      	b.n	801d1e6 <__gxx_personality_v0+0x362>
 801d23a:	f04f 0e00 	mov.w	lr, #0
 801d23e:	e7b4      	b.n	801d1aa <__gxx_personality_v0+0x326>
 801d240:	79f3      	ldrb	r3, [r6, #7]
 801d242:	2b01      	cmp	r3, #1
 801d244:	bf14      	ite	ne
 801d246:	f106 0358 	addne.w	r3, r6, #88	; 0x58
 801d24a:	f856 3c20 	ldreq.w	r3, [r6, #-32]
 801d24e:	9304      	str	r3, [sp, #16]
 801d250:	e6e3      	b.n	801d01a <__gxx_personality_v0+0x196>
 801d252:	9d02      	ldr	r5, [sp, #8]
 801d254:	f1bb 0f00 	cmp.w	fp, #0
 801d258:	f43f af06 	beq.w	801d068 <__gxx_personality_v0+0x1e4>
 801d25c:	469b      	mov	fp, r3
 801d25e:	f04f 0a02 	mov.w	sl, #2
 801d262:	e692      	b.n	801cf8a <__gxx_personality_v0+0x106>
 801d264:	f000 f824 	bl	801d2b0 <_ZSt10unexpectedv>
 801d268:	f000 fdbe 	bl	801dde8 <__cxa_begin_catch>
 801d26c:	f000 f814 	bl	801d298 <_ZSt9terminatev>

0801d270 <_ZN10__cxxabiv111__terminateEPFvvE>:
 801d270:	b508      	push	{r3, lr}
 801d272:	4780      	blx	r0
 801d274:	f7f3 fffc 	bl	8011270 <abort>
 801d278:	f000 fdb6 	bl	801dde8 <__cxa_begin_catch>
 801d27c:	f7f3 fff8 	bl	8011270 <abort>
 801d280:	460c      	mov	r4, r1
 801d282:	4605      	mov	r5, r0
 801d284:	f000 fdf6 	bl	801de74 <__cxa_end_catch>
 801d288:	3401      	adds	r4, #1
 801d28a:	d001      	beq.n	801d290 <_ZN10__cxxabiv111__terminateEPFvvE+0x20>
 801d28c:	f7ff fbf8 	bl	801ca80 <__cxa_end_cleanup>
 801d290:	4628      	mov	r0, r5
 801d292:	f000 fd35 	bl	801dd00 <__cxa_call_unexpected>
 801d296:	bf00      	nop

0801d298 <_ZSt9terminatev>:
 801d298:	b508      	push	{r3, lr}
 801d29a:	f640 03f8 	movw	r3, #2296	; 0x8f8
 801d29e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d2a2:	6818      	ldr	r0, [r3, #0]
 801d2a4:	f7ff ffe4 	bl	801d270 <_ZN10__cxxabiv111__terminateEPFvvE>

0801d2a8 <_ZN10__cxxabiv112__unexpectedEPFvvE>:
 801d2a8:	b508      	push	{r3, lr}
 801d2aa:	4780      	blx	r0
 801d2ac:	f7ff fff4 	bl	801d298 <_ZSt9terminatev>

0801d2b0 <_ZSt10unexpectedv>:
 801d2b0:	b508      	push	{r3, lr}
 801d2b2:	f640 03fc 	movw	r3, #2300	; 0x8fc
 801d2b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d2ba:	6818      	ldr	r0, [r3, #0]
 801d2bc:	f7ff fff4 	bl	801d2a8 <_ZN10__cxxabiv112__unexpectedEPFvvE>

0801d2c0 <_ZSt13set_terminatePFvvE>:
 801d2c0:	f640 03f8 	movw	r3, #2296	; 0x8f8
 801d2c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d2c8:	681a      	ldr	r2, [r3, #0]
 801d2ca:	6018      	str	r0, [r3, #0]
 801d2cc:	4610      	mov	r0, r2
 801d2ce:	4770      	bx	lr

0801d2d0 <_ZSt14set_unexpectedPFvvE>:
 801d2d0:	f640 03fc 	movw	r3, #2300	; 0x8fc
 801d2d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d2d8:	681a      	ldr	r2, [r3, #0]
 801d2da:	6018      	str	r0, [r3, #0]
 801d2dc:	4610      	mov	r0, r2
 801d2de:	4770      	bx	lr

0801d2e0 <_Znwj>:
 801d2e0:	b538      	push	{r3, r4, r5, lr}
 801d2e2:	2800      	cmp	r0, #0
 801d2e4:	bf14      	ite	ne
 801d2e6:	4604      	movne	r4, r0
 801d2e8:	2401      	moveq	r4, #1
 801d2ea:	4620      	mov	r0, r4
 801d2ec:	f7f4 fa46 	bl	801177c <malloc>
 801d2f0:	b948      	cbnz	r0, 801d306 <_Znwj+0x26>
 801d2f2:	4d0d      	ldr	r5, [pc, #52]	; (801d328 <_Znwj+0x48>)
 801d2f4:	682b      	ldr	r3, [r5, #0]
 801d2f6:	b13b      	cbz	r3, 801d308 <_Znwj+0x28>
 801d2f8:	4798      	blx	r3
 801d2fa:	4620      	mov	r0, r4
 801d2fc:	f7f4 fa3e 	bl	801177c <malloc>
 801d300:	2800      	cmp	r0, #0
 801d302:	d0f7      	beq.n	801d2f4 <_Znwj+0x14>
 801d304:	bd38      	pop	{r3, r4, r5, pc}
 801d306:	bd38      	pop	{r3, r4, r5, pc}
 801d308:	2004      	movs	r0, #4
 801d30a:	f000 fc2b 	bl	801db64 <__cxa_allocate_exception>
 801d30e:	4b07      	ldr	r3, [pc, #28]	; (801d32c <_Znwj+0x4c>)
 801d310:	4907      	ldr	r1, [pc, #28]	; (801d330 <_Znwj+0x50>)
 801d312:	4a08      	ldr	r2, [pc, #32]	; (801d334 <_Znwj+0x54>)
 801d314:	6003      	str	r3, [r0, #0]
 801d316:	f000 fe1d 	bl	801df54 <__cxa_throw>
 801d31a:	3101      	adds	r1, #1
 801d31c:	d001      	beq.n	801d322 <_Znwj+0x42>
 801d31e:	f7ff fbaf 	bl	801ca80 <__cxa_end_cleanup>
 801d322:	f000 fced 	bl	801dd00 <__cxa_call_unexpected>
 801d326:	bf00      	nop
 801d328:	20001670 	.word	0x20001670
 801d32c:	08020bb8 	.word	0x08020bb8
 801d330:	08020bc8 	.word	0x08020bc8
 801d334:	0801db3d 	.word	0x0801db3d

0801d338 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE>:
 801d338:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801d33c:	b086      	sub	sp, #24
 801d33e:	460f      	mov	r7, r1
 801d340:	4619      	mov	r1, r3
 801d342:	461e      	mov	r6, r3
 801d344:	4682      	mov	sl, r0
 801d346:	4691      	mov	r9, r2
 801d348:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 801d34a:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
 801d34e:	9c11      	ldr	r4, [sp, #68]	; 0x44
 801d350:	f000 f894 	bl	801d47c <_ZNKSt9type_infoeqERKS_>
 801d354:	4603      	mov	r3, r0
 801d356:	b178      	cbz	r0, 801d378 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x40>
 801d358:	2f00      	cmp	r7, #0
 801d35a:	6025      	str	r5, [r4, #0]
 801d35c:	f884 9004 	strb.w	r9, [r4, #4]
 801d360:	db1f      	blt.n	801d3a2 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x6a>
 801d362:	19ed      	adds	r5, r5, r7
 801d364:	2000      	movs	r0, #0
 801d366:	45a8      	cmp	r8, r5
 801d368:	bf14      	ite	ne
 801d36a:	f04f 0801 	movne.w	r8, #1
 801d36e:	f04f 0806 	moveq.w	r8, #6
 801d372:	f884 8006 	strb.w	r8, [r4, #6]
 801d376:	e011      	b.n	801d39c <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x64>
 801d378:	4545      	cmp	r5, r8
 801d37a:	d018      	beq.n	801d3ae <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x76>
 801d37c:	f8da e008 	ldr.w	lr, [sl, #8]
 801d380:	4633      	mov	r3, r6
 801d382:	4639      	mov	r1, r7
 801d384:	464a      	mov	r2, r9
 801d386:	4670      	mov	r0, lr
 801d388:	f8de 6000 	ldr.w	r6, [lr]
 801d38c:	9500      	str	r5, [sp, #0]
 801d38e:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 801d390:	f8cd 8008 	str.w	r8, [sp, #8]
 801d394:	9403      	str	r4, [sp, #12]
 801d396:	9501      	str	r5, [sp, #4]
 801d398:	69f4      	ldr	r4, [r6, #28]
 801d39a:	47a0      	blx	r4
 801d39c:	b006      	add	sp, #24
 801d39e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801d3a2:	2000      	movs	r0, #0
 801d3a4:	1cbb      	adds	r3, r7, #2
 801d3a6:	d1f9      	bne.n	801d39c <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x64>
 801d3a8:	2301      	movs	r3, #1
 801d3aa:	71a3      	strb	r3, [r4, #6]
 801d3ac:	e7f6      	b.n	801d39c <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x64>
 801d3ae:	4650      	mov	r0, sl
 801d3b0:	990f      	ldr	r1, [sp, #60]	; 0x3c
 801d3b2:	9305      	str	r3, [sp, #20]
 801d3b4:	f000 f862 	bl	801d47c <_ZNKSt9type_infoeqERKS_>
 801d3b8:	9b05      	ldr	r3, [sp, #20]
 801d3ba:	2800      	cmp	r0, #0
 801d3bc:	d0de      	beq.n	801d37c <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x44>
 801d3be:	4618      	mov	r0, r3
 801d3c0:	f884 9005 	strb.w	r9, [r4, #5]
 801d3c4:	e7ea      	b.n	801d39c <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x64>
 801d3c6:	bf00      	nop

0801d3c8 <_ZN10__cxxabiv120__si_class_type_infoD1Ev>:
 801d3c8:	4b03      	ldr	r3, [pc, #12]	; (801d3d8 <_ZN10__cxxabiv120__si_class_type_infoD1Ev+0x10>)
 801d3ca:	b510      	push	{r4, lr}
 801d3cc:	4604      	mov	r4, r0
 801d3ce:	6003      	str	r3, [r0, #0]
 801d3d0:	f7ff fb0a 	bl	801c9e8 <_ZN10__cxxabiv117__class_type_infoD1Ev>
 801d3d4:	4620      	mov	r0, r4
 801d3d6:	bd10      	pop	{r4, pc}
 801d3d8:	08020a18 	.word	0x08020a18

0801d3dc <_ZN10__cxxabiv120__si_class_type_infoD0Ev>:
 801d3dc:	b510      	push	{r4, lr}
 801d3de:	4604      	mov	r4, r0
 801d3e0:	f7ff fff2 	bl	801d3c8 <_ZN10__cxxabiv120__si_class_type_infoD1Ev>
 801d3e4:	4620      	mov	r0, r4
 801d3e6:	f7ff fb47 	bl	801ca78 <_ZdlPv>
 801d3ea:	4620      	mov	r0, r4
 801d3ec:	bd10      	pop	{r4, pc}
 801d3ee:	bf00      	nop

0801d3f0 <_ZNK10__cxxabiv120__si_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE>:
 801d3f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801d3f2:	4607      	mov	r7, r0
 801d3f4:	460e      	mov	r6, r1
 801d3f6:	4615      	mov	r5, r2
 801d3f8:	461c      	mov	r4, r3
 801d3fa:	f7ff fae7 	bl	801c9cc <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE>
 801d3fe:	b108      	cbz	r0, 801d404 <_ZNK10__cxxabiv120__si_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x14>
 801d400:	2001      	movs	r0, #1
 801d402:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801d404:	68bf      	ldr	r7, [r7, #8]
 801d406:	4623      	mov	r3, r4
 801d408:	4631      	mov	r1, r6
 801d40a:	462a      	mov	r2, r5
 801d40c:	4638      	mov	r0, r7
 801d40e:	683c      	ldr	r4, [r7, #0]
 801d410:	69a4      	ldr	r4, [r4, #24]
 801d412:	47a0      	blx	r4
 801d414:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801d416:	bf00      	nop

0801d418 <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_>:
 801d418:	b570      	push	{r4, r5, r6, lr}
 801d41a:	b084      	sub	sp, #16
 801d41c:	4605      	mov	r5, r0
 801d41e:	460e      	mov	r6, r1
 801d420:	9c08      	ldr	r4, [sp, #32]
 801d422:	4294      	cmp	r4, r2
 801d424:	d008      	beq.n	801d438 <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x20>
 801d426:	68ad      	ldr	r5, [r5, #8]
 801d428:	4631      	mov	r1, r6
 801d42a:	4628      	mov	r0, r5
 801d42c:	682d      	ldr	r5, [r5, #0]
 801d42e:	9400      	str	r4, [sp, #0]
 801d430:	6a2c      	ldr	r4, [r5, #32]
 801d432:	47a0      	blx	r4
 801d434:	b004      	add	sp, #16
 801d436:	bd70      	pop	{r4, r5, r6, pc}
 801d438:	4619      	mov	r1, r3
 801d43a:	9203      	str	r2, [sp, #12]
 801d43c:	9302      	str	r3, [sp, #8]
 801d43e:	f000 f81d 	bl	801d47c <_ZNKSt9type_infoeqERKS_>
 801d442:	9a03      	ldr	r2, [sp, #12]
 801d444:	9b02      	ldr	r3, [sp, #8]
 801d446:	2800      	cmp	r0, #0
 801d448:	d0ed      	beq.n	801d426 <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0xe>
 801d44a:	2006      	movs	r0, #6
 801d44c:	e7f2      	b.n	801d434 <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x1c>
 801d44e:	bf00      	nop

0801d450 <_ZNSt9type_infoD1Ev>:
 801d450:	4b01      	ldr	r3, [pc, #4]	; (801d458 <_ZNSt9type_infoD1Ev+0x8>)
 801d452:	6003      	str	r3, [r0, #0]
 801d454:	4770      	bx	lr
 801d456:	bf00      	nop
 801d458:	08020a98 	.word	0x08020a98

0801d45c <_ZNKSt9type_info14__is_pointer_pEv>:
 801d45c:	2000      	movs	r0, #0
 801d45e:	4770      	bx	lr

0801d460 <_ZNKSt9type_info15__is_function_pEv>:
 801d460:	2000      	movs	r0, #0
 801d462:	4770      	bx	lr

0801d464 <_ZNKSt9type_info11__do_upcastEPKN10__cxxabiv117__class_type_infoEPPv>:
 801d464:	2000      	movs	r0, #0
 801d466:	4770      	bx	lr

0801d468 <_ZNSt9type_infoD0Ev>:
 801d468:	4b03      	ldr	r3, [pc, #12]	; (801d478 <_ZNSt9type_infoD0Ev+0x10>)
 801d46a:	b510      	push	{r4, lr}
 801d46c:	4604      	mov	r4, r0
 801d46e:	6003      	str	r3, [r0, #0]
 801d470:	f7ff fb02 	bl	801ca78 <_ZdlPv>
 801d474:	4620      	mov	r0, r4
 801d476:	bd10      	pop	{r4, pc}
 801d478:	08020a98 	.word	0x08020a98

0801d47c <_ZNKSt9type_infoeqERKS_>:
 801d47c:	4281      	cmp	r1, r0
 801d47e:	b508      	push	{r3, lr}
 801d480:	d00d      	beq.n	801d49e <_ZNKSt9type_infoeqERKS_+0x22>
 801d482:	6840      	ldr	r0, [r0, #4]
 801d484:	7803      	ldrb	r3, [r0, #0]
 801d486:	2b2a      	cmp	r3, #42	; 0x2a
 801d488:	d007      	beq.n	801d49a <_ZNKSt9type_infoeqERKS_+0x1e>
 801d48a:	6849      	ldr	r1, [r1, #4]
 801d48c:	780b      	ldrb	r3, [r1, #0]
 801d48e:	2b2a      	cmp	r3, #42	; 0x2a
 801d490:	bf08      	it	eq
 801d492:	3101      	addeq	r1, #1
 801d494:	f7f5 fa24 	bl	80128e0 <strcmp>
 801d498:	b108      	cbz	r0, 801d49e <_ZNKSt9type_infoeqERKS_+0x22>
 801d49a:	2000      	movs	r0, #0
 801d49c:	bd08      	pop	{r3, pc}
 801d49e:	2001      	movs	r0, #1
 801d4a0:	bd08      	pop	{r3, pc}
 801d4a2:	bf00      	nop

0801d4a4 <_ZNKSt9type_info10__do_catchEPKS_PPvj>:
 801d4a4:	f7ff bfea 	b.w	801d47c <_ZNKSt9type_infoeqERKS_>

0801d4a8 <_ZN10__cxxabiv121__vmi_class_type_infoD1Ev>:
 801d4a8:	4b03      	ldr	r3, [pc, #12]	; (801d4b8 <_ZN10__cxxabiv121__vmi_class_type_infoD1Ev+0x10>)
 801d4aa:	b510      	push	{r4, lr}
 801d4ac:	4604      	mov	r4, r0
 801d4ae:	6003      	str	r3, [r0, #0]
 801d4b0:	f7ff fa9a 	bl	801c9e8 <_ZN10__cxxabiv117__class_type_infoD1Ev>
 801d4b4:	4620      	mov	r0, r4
 801d4b6:	bd10      	pop	{r4, pc}
 801d4b8:	08020af0 	.word	0x08020af0

0801d4bc <_ZN10__cxxabiv121__vmi_class_type_infoD0Ev>:
 801d4bc:	b510      	push	{r4, lr}
 801d4be:	4604      	mov	r4, r0
 801d4c0:	f7ff fff2 	bl	801d4a8 <_ZN10__cxxabiv121__vmi_class_type_infoD1Ev>
 801d4c4:	4620      	mov	r0, r4
 801d4c6:	f7ff fad7 	bl	801ca78 <_ZdlPv>
 801d4ca:	4620      	mov	r0, r4
 801d4cc:	bd10      	pop	{r4, pc}
 801d4ce:	bf00      	nop

0801d4d0 <_ZNK10__cxxabiv121__vmi_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_>:
 801d4d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d4d4:	b083      	sub	sp, #12
 801d4d6:	4693      	mov	fp, r2
 801d4d8:	4607      	mov	r7, r0
 801d4da:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
 801d4de:	4688      	mov	r8, r1
 801d4e0:	4699      	mov	r9, r3
 801d4e2:	4552      	cmp	r2, sl
 801d4e4:	d034      	beq.n	801d550 <_ZNK10__cxxabiv121__vmi_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x80>
 801d4e6:	68fc      	ldr	r4, [r7, #12]
 801d4e8:	1ca6      	adds	r6, r4, #2
 801d4ea:	3c01      	subs	r4, #1
 801d4ec:	eb07 06c6 	add.w	r6, r7, r6, lsl #3
 801d4f0:	1c62      	adds	r2, r4, #1
 801d4f2:	eb07 05c4 	add.w	r5, r7, r4, lsl #3
 801d4f6:	4641      	mov	r1, r8
 801d4f8:	464b      	mov	r3, r9
 801d4fa:	f104 34ff 	add.w	r4, r4, #4294967295
 801d4fe:	d01d      	beq.n	801d53c <_ZNK10__cxxabiv121__vmi_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x6c>
 801d500:	696d      	ldr	r5, [r5, #20]
 801d502:	f015 0f02 	tst.w	r5, #2
 801d506:	ea4f 2225 	mov.w	r2, r5, asr #8
 801d50a:	d015      	beq.n	801d538 <_ZNK10__cxxabiv121__vmi_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x68>
 801d50c:	f015 0501 	ands.w	r5, r5, #1
 801d510:	d005      	beq.n	801d51e <_ZNK10__cxxabiv121__vmi_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x4e>
 801d512:	f118 0f03 	cmn.w	r8, #3
 801d516:	d00f      	beq.n	801d538 <_ZNK10__cxxabiv121__vmi_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x68>
 801d518:	f8db 0000 	ldr.w	r0, [fp]
 801d51c:	5882      	ldr	r2, [r0, r2]
 801d51e:	f856 ec08 	ldr.w	lr, [r6, #-8]
 801d522:	445a      	add	r2, fp
 801d524:	4670      	mov	r0, lr
 801d526:	f8de e000 	ldr.w	lr, [lr]
 801d52a:	f8cd a000 	str.w	sl, [sp]
 801d52e:	f8de c020 	ldr.w	ip, [lr, #32]
 801d532:	47e0      	blx	ip
 801d534:	2803      	cmp	r0, #3
 801d536:	d805      	bhi.n	801d544 <_ZNK10__cxxabiv121__vmi_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x74>
 801d538:	3e08      	subs	r6, #8
 801d53a:	e7d9      	b.n	801d4f0 <_ZNK10__cxxabiv121__vmi_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x20>
 801d53c:	2001      	movs	r0, #1
 801d53e:	b003      	add	sp, #12
 801d540:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801d544:	2d00      	cmp	r5, #0
 801d546:	d0fa      	beq.n	801d53e <_ZNK10__cxxabiv121__vmi_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x6e>
 801d548:	f040 0001 	orr.w	r0, r0, #1
 801d54c:	b2c0      	uxtb	r0, r0
 801d54e:	e7f6      	b.n	801d53e <_ZNK10__cxxabiv121__vmi_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x6e>
 801d550:	4619      	mov	r1, r3
 801d552:	f7ff ff93 	bl	801d47c <_ZNKSt9type_infoeqERKS_>
 801d556:	2800      	cmp	r0, #0
 801d558:	d0c5      	beq.n	801d4e6 <_ZNK10__cxxabiv121__vmi_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x16>
 801d55a:	2006      	movs	r0, #6
 801d55c:	e7ef      	b.n	801d53e <_ZNK10__cxxabiv121__vmi_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x6e>
 801d55e:	bf00      	nop

0801d560 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE>:
 801d560:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d564:	b089      	sub	sp, #36	; 0x24
 801d566:	4683      	mov	fp, r0
 801d568:	4690      	mov	r8, r2
 801d56a:	9102      	str	r1, [sp, #8]
 801d56c:	469a      	mov	sl, r3
 801d56e:	f7ff fa2d 	bl	801c9cc <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE>
 801d572:	2800      	cmp	r0, #0
 801d574:	d17b      	bne.n	801d66e <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x10e>
 801d576:	f8da 7008 	ldr.w	r7, [sl, #8]
 801d57a:	f8db 400c 	ldr.w	r4, [fp, #12]
 801d57e:	06f8      	lsls	r0, r7, #27
 801d580:	9701      	str	r7, [sp, #4]
 801d582:	bf44      	itt	mi
 801d584:	f8db 7008 	ldrmi.w	r7, [fp, #8]
 801d588:	9701      	strmi	r7, [sp, #4]
 801d58a:	1ca6      	adds	r6, r4, #2
 801d58c:	3c01      	subs	r4, #1
 801d58e:	af04      	add	r7, sp, #16
 801d590:	2500      	movs	r5, #0
 801d592:	9700      	str	r7, [sp, #0]
 801d594:	1c61      	adds	r1, r4, #1
 801d596:	9f01      	ldr	r7, [sp, #4]
 801d598:	eb0b 06c6 	add.w	r6, fp, r6, lsl #3
 801d59c:	f007 0701 	and.w	r7, r7, #1
 801d5a0:	9703      	str	r7, [sp, #12]
 801d5a2:	d046      	beq.n	801d632 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0xd2>
 801d5a4:	eb0b 03c4 	add.w	r3, fp, r4, lsl #3
 801d5a8:	9f01      	ldr	r7, [sp, #4]
 801d5aa:	9504      	str	r5, [sp, #16]
 801d5ac:	695a      	ldr	r2, [r3, #20]
 801d5ae:	9706      	str	r7, [sp, #24]
 801d5b0:	f3c2 0740 	ubfx	r7, r2, #1, #1
 801d5b4:	f88d 5014 	strb.w	r5, [sp, #20]
 801d5b8:	9507      	str	r5, [sp, #28]
 801d5ba:	f002 0901 	and.w	r9, r2, #1
 801d5be:	b90f      	cbnz	r7, 801d5c4 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x64>
 801d5c0:	9b03      	ldr	r3, [sp, #12]
 801d5c2:	b393      	cbz	r3, 801d62a <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0xca>
 801d5c4:	f1b8 0f00 	cmp.w	r8, #0
 801d5c8:	d039      	beq.n	801d63e <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0xde>
 801d5ca:	1212      	asrs	r2, r2, #8
 801d5cc:	f1b9 0f00 	cmp.w	r9, #0
 801d5d0:	d002      	beq.n	801d5d8 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x78>
 801d5d2:	f8d8 3000 	ldr.w	r3, [r8]
 801d5d6:	589a      	ldr	r2, [r3, r2]
 801d5d8:	4442      	add	r2, r8
 801d5da:	f856 ec08 	ldr.w	lr, [r6, #-8]
 801d5de:	ab04      	add	r3, sp, #16
 801d5e0:	9902      	ldr	r1, [sp, #8]
 801d5e2:	4670      	mov	r0, lr
 801d5e4:	f8de e000 	ldr.w	lr, [lr]
 801d5e8:	f8de c018 	ldr.w	ip, [lr, #24]
 801d5ec:	47e0      	blx	ip
 801d5ee:	b1e0      	cbz	r0, 801d62a <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0xca>
 801d5f0:	9b07      	ldr	r3, [sp, #28]
 801d5f2:	2b08      	cmp	r3, #8
 801d5f4:	d025      	beq.n	801d642 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0xe2>
 801d5f6:	f89d 3014 	ldrb.w	r3, [sp, #20]
 801d5fa:	2b03      	cmp	r3, #3
 801d5fc:	d904      	bls.n	801d608 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0xa8>
 801d5fe:	b91f      	cbnz	r7, 801d608 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0xa8>
 801d600:	f023 0302 	bic.w	r3, r3, #2
 801d604:	f88d 3014 	strb.w	r3, [sp, #20]
 801d608:	f8da 100c 	ldr.w	r1, [sl, #12]
 801d60c:	b301      	cbz	r1, 801d650 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0xf0>
 801d60e:	f8da 3000 	ldr.w	r3, [sl]
 801d612:	9a04      	ldr	r2, [sp, #16]
 801d614:	4293      	cmp	r3, r2
 801d616:	d144      	bne.n	801d6a2 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x142>
 801d618:	2b00      	cmp	r3, #0
 801d61a:	d02c      	beq.n	801d676 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x116>
 801d61c:	f89a 3004 	ldrb.w	r3, [sl, #4]
 801d620:	f89d 2014 	ldrb.w	r2, [sp, #20]
 801d624:	4313      	orrs	r3, r2
 801d626:	f88a 3004 	strb.w	r3, [sl, #4]
 801d62a:	3c01      	subs	r4, #1
 801d62c:	3e08      	subs	r6, #8
 801d62e:	1c61      	adds	r1, r4, #1
 801d630:	d1b8      	bne.n	801d5a4 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x44>
 801d632:	f89a 0004 	ldrb.w	r0, [sl, #4]
 801d636:	3000      	adds	r0, #0
 801d638:	bf18      	it	ne
 801d63a:	2001      	movne	r0, #1
 801d63c:	e018      	b.n	801d670 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x110>
 801d63e:	4642      	mov	r2, r8
 801d640:	e7cb      	b.n	801d5da <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x7a>
 801d642:	f1b9 0f00 	cmp.w	r9, #0
 801d646:	d0d6      	beq.n	801d5f6 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x96>
 801d648:	f856 3c08 	ldr.w	r3, [r6, #-8]
 801d64c:	9307      	str	r3, [sp, #28]
 801d64e:	e7d2      	b.n	801d5f6 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x96>
 801d650:	9f00      	ldr	r7, [sp, #0]
 801d652:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
 801d656:	e88a 000f 	stmia.w	sl, {r0, r1, r2, r3}
 801d65a:	f89a 3004 	ldrb.w	r3, [sl, #4]
 801d65e:	2b03      	cmp	r3, #3
 801d660:	d905      	bls.n	801d66e <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x10e>
 801d662:	0799      	lsls	r1, r3, #30
 801d664:	d514      	bpl.n	801d690 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x130>
 801d666:	f8db 3008 	ldr.w	r3, [fp, #8]
 801d66a:	07da      	lsls	r2, r3, #31
 801d66c:	d4dd      	bmi.n	801d62a <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0xca>
 801d66e:	2001      	movs	r0, #1
 801d670:	b009      	add	sp, #36	; 0x24
 801d672:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801d676:	9807      	ldr	r0, [sp, #28]
 801d678:	2808      	cmp	r0, #8
 801d67a:	d005      	beq.n	801d688 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x128>
 801d67c:	2908      	cmp	r1, #8
 801d67e:	d003      	beq.n	801d688 <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x128>
 801d680:	f7ff fefc 	bl	801d47c <_ZNKSt9type_infoeqERKS_>
 801d684:	2800      	cmp	r0, #0
 801d686:	d1c9      	bne.n	801d61c <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0xbc>
 801d688:	2302      	movs	r3, #2
 801d68a:	f88a 3004 	strb.w	r3, [sl, #4]
 801d68e:	e7ee      	b.n	801d66e <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x10e>
 801d690:	07db      	lsls	r3, r3, #31
 801d692:	d5ec      	bpl.n	801d66e <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x10e>
 801d694:	f8db 3008 	ldr.w	r3, [fp, #8]
 801d698:	0798      	lsls	r0, r3, #30
 801d69a:	d5e8      	bpl.n	801d66e <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x10e>
 801d69c:	3c01      	subs	r4, #1
 801d69e:	3e08      	subs	r6, #8
 801d6a0:	e7c5      	b.n	801d62e <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0xce>
 801d6a2:	2300      	movs	r3, #0
 801d6a4:	f8ca 3000 	str.w	r3, [sl]
 801d6a8:	2302      	movs	r3, #2
 801d6aa:	f88a 3004 	strb.w	r3, [sl, #4]
 801d6ae:	e7de      	b.n	801d66e <_ZNK10__cxxabiv121__vmi_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x10e>

0801d6b0 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE>:
 801d6b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d6b4:	b091      	sub	sp, #68	; 0x44
 801d6b6:	4683      	mov	fp, r0
 801d6b8:	460e      	mov	r6, r1
 801d6ba:	9c1d      	ldr	r4, [sp, #116]	; 0x74
 801d6bc:	9307      	str	r3, [sp, #28]
 801d6be:	f8dd a068 	ldr.w	sl, [sp, #104]	; 0x68
 801d6c2:	68a3      	ldr	r3, [r4, #8]
 801d6c4:	9f1c      	ldr	r7, [sp, #112]	; 0x70
 801d6c6:	06d8      	lsls	r0, r3, #27
 801d6c8:	9209      	str	r2, [sp, #36]	; 0x24
 801d6ca:	bf44      	itt	mi
 801d6cc:	f8db 3008 	ldrmi.w	r3, [fp, #8]
 801d6d0:	60a3      	strmi	r3, [r4, #8]
 801d6d2:	45ba      	cmp	sl, r7
 801d6d4:	f000 8156 	beq.w	801d984 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x2d4>
 801d6d8:	4658      	mov	r0, fp
 801d6da:	9907      	ldr	r1, [sp, #28]
 801d6dc:	f7ff fece 	bl	801d47c <_ZNKSt9type_infoeqERKS_>
 801d6e0:	2800      	cmp	r0, #0
 801d6e2:	f040 80a7 	bne.w	801d834 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x184>
 801d6e6:	2e00      	cmp	r6, #0
 801d6e8:	4653      	mov	r3, sl
 801d6ea:	bfb8      	it	lt
 801d6ec:	4684      	movlt	ip, r0
 801d6ee:	f8cd b018 	str.w	fp, [sp, #24]
 801d6f2:	bfa8      	it	ge
 801d6f4:	9f1c      	ldrge	r7, [sp, #112]	; 0x70
 801d6f6:	46b3      	mov	fp, r6
 801d6f8:	f04f 0801 	mov.w	r8, #1
 801d6fc:	f8cd 8020 	str.w	r8, [sp, #32]
 801d700:	bfa8      	it	ge
 801d702:	ebc6 0c07 	rsbge	ip, r6, r7
 801d706:	2700      	movs	r7, #0
 801d708:	463d      	mov	r5, r7
 801d70a:	9705      	str	r7, [sp, #20]
 801d70c:	970b      	str	r7, [sp, #44]	; 0x2c
 801d70e:	46e2      	mov	sl, ip
 801d710:	9f09      	ldr	r7, [sp, #36]	; 0x24
 801d712:	469c      	mov	ip, r3
 801d714:	ea47 0708 	orr.w	r7, r7, r8
 801d718:	970a      	str	r7, [sp, #40]	; 0x28
 801d71a:	f8dd 8018 	ldr.w	r8, [sp, #24]
 801d71e:	4663      	mov	r3, ip
 801d720:	46dc      	mov	ip, fp
 801d722:	469b      	mov	fp, r3
 801d724:	f8d8 600c 	ldr.w	r6, [r8, #12]
 801d728:	f106 0902 	add.w	r9, r6, #2
 801d72c:	3e01      	subs	r6, #1
 801d72e:	eb08 09c9 	add.w	r9, r8, r9, lsl #3
 801d732:	1c77      	adds	r7, r6, #1
 801d734:	f000 8116 	beq.w	801d964 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x2b4>
 801d738:	f8dd 8018 	ldr.w	r8, [sp, #24]
 801d73c:	68a1      	ldr	r1, [r4, #8]
 801d73e:	eb08 03c6 	add.w	r3, r8, r6, lsl #3
 801d742:	950d      	str	r5, [sp, #52]	; 0x34
 801d744:	f88d 5038 	strb.w	r5, [sp, #56]	; 0x38
 801d748:	695b      	ldr	r3, [r3, #20]
 801d74a:	910f      	str	r1, [sp, #60]	; 0x3c
 801d74c:	f88d 5039 	strb.w	r5, [sp, #57]	; 0x39
 801d750:	121f      	asrs	r7, r3, #8
 801d752:	07da      	lsls	r2, r3, #31
 801d754:	f88d 503a 	strb.w	r5, [sp, #58]	; 0x3a
 801d758:	bf45      	ittet	mi
 801d75a:	f8db 0000 	ldrmi.w	r0, [fp]
 801d75e:	9a0a      	ldrmi	r2, [sp, #40]	; 0x28
 801d760:	9a09      	ldrpl	r2, [sp, #36]	; 0x24
 801d762:	59c7      	ldrmi	r7, [r0, r7]
 801d764:	445f      	add	r7, fp
 801d766:	f1ba 0f00 	cmp.w	sl, #0
 801d76a:	d008      	beq.n	801d77e <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0xce>
 801d76c:	4557      	cmp	r7, sl
 801d76e:	f8dd 8020 	ldr.w	r8, [sp, #32]
 801d772:	bf94      	ite	ls
 801d774:	2000      	movls	r0, #0
 801d776:	2001      	movhi	r0, #1
 801d778:	4540      	cmp	r0, r8
 801d77a:	f000 80d0 	beq.w	801d91e <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x26e>
 801d77e:	079b      	lsls	r3, r3, #30
 801d780:	d405      	bmi.n	801d78e <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0xde>
 801d782:	f11c 0f02 	cmn.w	ip, #2
 801d786:	f000 80cd 	beq.w	801d924 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x274>
 801d78a:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
 801d78e:	f859 ec08 	ldr.w	lr, [r9, #-8]
 801d792:	4661      	mov	r1, ip
 801d794:	9b07      	ldr	r3, [sp, #28]
 801d796:	4670      	mov	r0, lr
 801d798:	f8de e000 	ldr.w	lr, [lr]
 801d79c:	9700      	str	r7, [sp, #0]
 801d79e:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
 801d7a0:	9701      	str	r7, [sp, #4]
 801d7a2:	9f1c      	ldr	r7, [sp, #112]	; 0x70
 801d7a4:	9702      	str	r7, [sp, #8]
 801d7a6:	af0d      	add	r7, sp, #52	; 0x34
 801d7a8:	9703      	str	r7, [sp, #12]
 801d7aa:	f8de 701c 	ldr.w	r7, [lr, #28]
 801d7ae:	f8cd c010 	str.w	ip, [sp, #16]
 801d7b2:	47b8      	blx	r7
 801d7b4:	f89d 803a 	ldrb.w	r8, [sp, #58]	; 0x3a
 801d7b8:	7962      	ldrb	r2, [r4, #5]
 801d7ba:	f008 03fb 	and.w	r3, r8, #251	; 0xfb
 801d7be:	f89d 1039 	ldrb.w	r1, [sp, #57]	; 0x39
 801d7c2:	2b02      	cmp	r3, #2
 801d7c4:	f8dd c010 	ldr.w	ip, [sp, #16]
 801d7c8:	ea41 0102 	orr.w	r1, r1, r2
 801d7cc:	7161      	strb	r1, [r4, #5]
 801d7ce:	f000 80e5 	beq.w	801d99c <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x2ec>
 801d7d2:	9f05      	ldr	r7, [sp, #20]
 801d7d4:	6822      	ldr	r2, [r4, #0]
 801d7d6:	2f00      	cmp	r7, #0
 801d7d8:	f040 8088 	bne.w	801d8ec <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x23c>
 801d7dc:	2a00      	cmp	r2, #0
 801d7de:	f000 80ae 	beq.w	801d93e <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x28e>
 801d7e2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d7e4:	429a      	cmp	r2, r3
 801d7e6:	f000 80a0 	beq.w	801d92a <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x27a>
 801d7ea:	2b00      	cmp	r3, #0
 801d7ec:	f000 80a3 	beq.w	801d936 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x286>
 801d7f0:	2903      	cmp	r1, #3
 801d7f2:	79a7      	ldrb	r7, [r4, #6]
 801d7f4:	f240 8084 	bls.w	801d900 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x250>
 801d7f8:	07c9      	lsls	r1, r1, #31
 801d7fa:	d502      	bpl.n	801d802 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x152>
 801d7fc:	68a1      	ldr	r1, [r4, #8]
 801d7fe:	0789      	lsls	r1, r1, #30
 801d800:	d47e      	bmi.n	801d900 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x250>
 801d802:	2f00      	cmp	r7, #0
 801d804:	bf08      	it	eq
 801d806:	2701      	moveq	r7, #1
 801d808:	f1b8 0f00 	cmp.w	r8, #0
 801d80c:	d151      	bne.n	801d8b2 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x202>
 801d80e:	f087 0301 	eor.w	r3, r7, #1
 801d812:	b2db      	uxtb	r3, r3
 801d814:	2b03      	cmp	r3, #3
 801d816:	d85c      	bhi.n	801d8d2 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x222>
 801d818:	f04f 0801 	mov.w	r8, #1
 801d81c:	ea07 0708 	and.w	r7, r7, r8
 801d820:	b2ff      	uxtb	r7, r7
 801d822:	2f03      	cmp	r7, #3
 801d824:	f200 80fb 	bhi.w	801da1e <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x36e>
 801d828:	2701      	movs	r7, #1
 801d82a:	2001      	movs	r0, #1
 801d82c:	6025      	str	r5, [r4, #0]
 801d82e:	9705      	str	r7, [sp, #20]
 801d830:	71a0      	strb	r0, [r4, #6]
 801d832:	e054      	b.n	801d8de <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x22e>
 801d834:	9f09      	ldr	r7, [sp, #36]	; 0x24
 801d836:	2e00      	cmp	r6, #0
 801d838:	f8c4 a000 	str.w	sl, [r4]
 801d83c:	7127      	strb	r7, [r4, #4]
 801d83e:	f2c0 80b6 	blt.w	801d9ae <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x2fe>
 801d842:	2700      	movs	r7, #0
 801d844:	9705      	str	r7, [sp, #20]
 801d846:	9f1c      	ldr	r7, [sp, #112]	; 0x70
 801d848:	44b2      	add	sl, r6
 801d84a:	4557      	cmp	r7, sl
 801d84c:	bf14      	ite	ne
 801d84e:	f04f 0a01 	movne.w	sl, #1
 801d852:	f04f 0a06 	moveq.w	sl, #6
 801d856:	f884 a006 	strb.w	sl, [r4, #6]
 801d85a:	9805      	ldr	r0, [sp, #20]
 801d85c:	b011      	add	sp, #68	; 0x44
 801d85e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801d862:	9806      	ldr	r0, [sp, #24]
 801d864:	6881      	ldr	r1, [r0, #8]
 801d866:	078f      	lsls	r7, r1, #30
 801d868:	d552      	bpl.n	801d910 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x260>
 801d86a:	f1bc 0f00 	cmp.w	ip, #0
 801d86e:	f2c0 80c0 	blt.w	801d9f2 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x342>
 801d872:	991c      	ldr	r1, [sp, #112]	; 0x70
 801d874:	4462      	add	r2, ip
 801d876:	4291      	cmp	r1, r2
 801d878:	bf0c      	ite	eq
 801d87a:	2706      	moveq	r7, #6
 801d87c:	2701      	movne	r7, #1
 801d87e:	f1b8 0f00 	cmp.w	r8, #0
 801d882:	d116      	bne.n	801d8b2 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x202>
 801d884:	2f03      	cmp	r7, #3
 801d886:	d907      	bls.n	801d898 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x1e8>
 801d888:	07f9      	lsls	r1, r7, #31
 801d88a:	d5c0      	bpl.n	801d80e <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x15e>
 801d88c:	f8dd 8018 	ldr.w	r8, [sp, #24]
 801d890:	f8d8 3008 	ldr.w	r3, [r8, #8]
 801d894:	079a      	lsls	r2, r3, #30
 801d896:	d5ba      	bpl.n	801d80e <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x15e>
 801d898:	f1bc 0f00 	cmp.w	ip, #0
 801d89c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d89e:	f2c0 808e 	blt.w	801d9be <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x30e>
 801d8a2:	981c      	ldr	r0, [sp, #112]	; 0x70
 801d8a4:	4463      	add	r3, ip
 801d8a6:	4298      	cmp	r0, r3
 801d8a8:	bf14      	ite	ne
 801d8aa:	f04f 0801 	movne.w	r8, #1
 801d8ae:	f04f 0806 	moveq.w	r8, #6
 801d8b2:	ea87 0308 	eor.w	r3, r7, r8
 801d8b6:	b2db      	uxtb	r3, r3
 801d8b8:	2b03      	cmp	r3, #3
 801d8ba:	d9af      	bls.n	801d81c <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x16c>
 801d8bc:	f1b8 0f03 	cmp.w	r8, #3
 801d8c0:	d907      	bls.n	801d8d2 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x222>
 801d8c2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d8c4:	f89d 2038 	ldrb.w	r2, [sp, #56]	; 0x38
 801d8c8:	4647      	mov	r7, r8
 801d8ca:	2000      	movs	r0, #0
 801d8cc:	6023      	str	r3, [r4, #0]
 801d8ce:	9005      	str	r0, [sp, #20]
 801d8d0:	7122      	strb	r2, [r4, #4]
 801d8d2:	07bb      	lsls	r3, r7, #30
 801d8d4:	71a7      	strb	r7, [r4, #6]
 801d8d6:	d45e      	bmi.n	801d996 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x2e6>
 801d8d8:	f017 0701 	ands.w	r7, r7, #1
 801d8dc:	d05c      	beq.n	801d998 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x2e8>
 801d8de:	7961      	ldrb	r1, [r4, #5]
 801d8e0:	2904      	cmp	r1, #4
 801d8e2:	d0ba      	beq.n	801d85a <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x1aa>
 801d8e4:	3e01      	subs	r6, #1
 801d8e6:	f1a9 0908 	sub.w	r9, r9, #8
 801d8ea:	e722      	b.n	801d732 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x82>
 801d8ec:	2a00      	cmp	r2, #0
 801d8ee:	f47f af78 	bne.w	801d7e2 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x132>
 801d8f2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d8f4:	2b00      	cmp	r3, #0
 801d8f6:	d0f3      	beq.n	801d8e0 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x230>
 801d8f8:	2903      	cmp	r1, #3
 801d8fa:	79a7      	ldrb	r7, [r4, #6]
 801d8fc:	f63f af7c 	bhi.w	801d7f8 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x148>
 801d900:	2f00      	cmp	r7, #0
 801d902:	d1bc      	bne.n	801d87e <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x1ce>
 801d904:	f1b8 0f03 	cmp.w	r8, #3
 801d908:	d9af      	bls.n	801d86a <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x1ba>
 801d90a:	f018 0f01 	tst.w	r8, #1
 801d90e:	d1a8      	bne.n	801d862 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x1b2>
 801d910:	f088 0201 	eor.w	r2, r8, #1
 801d914:	b2d2      	uxtb	r2, r2
 801d916:	2a03      	cmp	r2, #3
 801d918:	d8d4      	bhi.n	801d8c4 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x214>
 801d91a:	2701      	movs	r7, #1
 801d91c:	e77e      	b.n	801d81c <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x16c>
 801d91e:	2701      	movs	r7, #1
 801d920:	970b      	str	r7, [sp, #44]	; 0x2c
 801d922:	e7df      	b.n	801d8e4 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x234>
 801d924:	0789      	lsls	r1, r1, #30
 801d926:	d0dd      	beq.n	801d8e4 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x234>
 801d928:	e72f      	b.n	801d78a <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0xda>
 801d92a:	7923      	ldrb	r3, [r4, #4]
 801d92c:	f89d 2038 	ldrb.w	r2, [sp, #56]	; 0x38
 801d930:	4313      	orrs	r3, r2
 801d932:	7123      	strb	r3, [r4, #4]
 801d934:	e7d4      	b.n	801d8e0 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x230>
 801d936:	2800      	cmp	r0, #0
 801d938:	f47f af5a 	bne.w	801d7f0 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x140>
 801d93c:	e7d0      	b.n	801d8e0 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x230>
 801d93e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d940:	f89d 2038 	ldrb.w	r2, [sp, #56]	; 0x38
 801d944:	6023      	str	r3, [r4, #0]
 801d946:	7122      	strb	r2, [r4, #4]
 801d948:	2b00      	cmp	r3, #0
 801d94a:	d066      	beq.n	801da1a <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x36a>
 801d94c:	b141      	cbz	r1, 801d960 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x2b0>
 801d94e:	f8dd 8018 	ldr.w	r8, [sp, #24]
 801d952:	9005      	str	r0, [sp, #20]
 801d954:	f8d8 3008 	ldr.w	r3, [r8, #8]
 801d958:	07db      	lsls	r3, r3, #31
 801d95a:	f57f af7e 	bpl.w	801d85a <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x1aa>
 801d95e:	e7bf      	b.n	801d8e0 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x230>
 801d960:	9005      	str	r0, [sp, #20]
 801d962:	e7bf      	b.n	801d8e4 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x234>
 801d964:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
 801d968:	465b      	mov	r3, fp
 801d96a:	9f08      	ldr	r7, [sp, #32]
 801d96c:	46e3      	mov	fp, ip
 801d96e:	469c      	mov	ip, r3
 801d970:	ea08 0307 	and.w	r3, r8, r7
 801d974:	f04f 0800 	mov.w	r8, #0
 801d978:	f8cd 8020 	str.w	r8, [sp, #32]
 801d97c:	2b00      	cmp	r3, #0
 801d97e:	f47f aecc 	bne.w	801d71a <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x6a>
 801d982:	e76a      	b.n	801d85a <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x1aa>
 801d984:	4658      	mov	r0, fp
 801d986:	991b      	ldr	r1, [sp, #108]	; 0x6c
 801d988:	f7ff fd78 	bl	801d47c <_ZNKSt9type_infoeqERKS_>
 801d98c:	2800      	cmp	r0, #0
 801d98e:	f43f aea3 	beq.w	801d6d8 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x28>
 801d992:	9f09      	ldr	r7, [sp, #36]	; 0x24
 801d994:	7167      	strb	r7, [r4, #5]
 801d996:	2700      	movs	r7, #0
 801d998:	9705      	str	r7, [sp, #20]
 801d99a:	e75e      	b.n	801d85a <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x1aa>
 801d99c:	f89d 2038 	ldrb.w	r2, [sp, #56]	; 0x38
 801d9a0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d9a2:	9005      	str	r0, [sp, #20]
 801d9a4:	f884 8006 	strb.w	r8, [r4, #6]
 801d9a8:	6023      	str	r3, [r4, #0]
 801d9aa:	7122      	strb	r2, [r4, #4]
 801d9ac:	e755      	b.n	801d85a <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x1aa>
 801d9ae:	2700      	movs	r7, #0
 801d9b0:	1cb1      	adds	r1, r6, #2
 801d9b2:	9705      	str	r7, [sp, #20]
 801d9b4:	f47f af51 	bne.w	801d85a <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x1aa>
 801d9b8:	2301      	movs	r3, #1
 801d9ba:	71a3      	strb	r3, [r4, #6]
 801d9bc:	e74d      	b.n	801d85a <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x1aa>
 801d9be:	f11c 0f02 	cmn.w	ip, #2
 801d9c2:	bf08      	it	eq
 801d9c4:	f04f 0801 	moveq.w	r8, #1
 801d9c8:	f43f af73 	beq.w	801d8b2 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x202>
 801d9cc:	f8dd 801c 	ldr.w	r8, [sp, #28]
 801d9d0:	461a      	mov	r2, r3
 801d9d2:	991c      	ldr	r1, [sp, #112]	; 0x70
 801d9d4:	4640      	mov	r0, r8
 801d9d6:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801d9d8:	f8d8 e000 	ldr.w	lr, [r8]
 801d9dc:	9100      	str	r1, [sp, #0]
 801d9de:	4661      	mov	r1, ip
 801d9e0:	f8de 8020 	ldr.w	r8, [lr, #32]
 801d9e4:	f8cd c010 	str.w	ip, [sp, #16]
 801d9e8:	47c0      	blx	r8
 801d9ea:	f8dd c010 	ldr.w	ip, [sp, #16]
 801d9ee:	4680      	mov	r8, r0
 801d9f0:	e75f      	b.n	801d8b2 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x202>
 801d9f2:	2701      	movs	r7, #1
 801d9f4:	f11c 0f02 	cmn.w	ip, #2
 801d9f8:	f43f af41 	beq.w	801d87e <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x1ce>
 801d9fc:	9b07      	ldr	r3, [sp, #28]
 801d9fe:	991c      	ldr	r1, [sp, #112]	; 0x70
 801da00:	4618      	mov	r0, r3
 801da02:	681f      	ldr	r7, [r3, #0]
 801da04:	9100      	str	r1, [sp, #0]
 801da06:	4661      	mov	r1, ip
 801da08:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801da0a:	6a3f      	ldr	r7, [r7, #32]
 801da0c:	f8cd c010 	str.w	ip, [sp, #16]
 801da10:	47b8      	blx	r7
 801da12:	f8dd c010 	ldr.w	ip, [sp, #16]
 801da16:	4607      	mov	r7, r0
 801da18:	e731      	b.n	801d87e <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x1ce>
 801da1a:	9005      	str	r0, [sp, #20]
 801da1c:	e760      	b.n	801d8e0 <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x230>
 801da1e:	2300      	movs	r3, #0
 801da20:	2701      	movs	r7, #1
 801da22:	6023      	str	r3, [r4, #0]
 801da24:	2302      	movs	r3, #2
 801da26:	9705      	str	r7, [sp, #20]
 801da28:	71a3      	strb	r3, [r4, #6]
 801da2a:	e716      	b.n	801d85a <_ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x1aa>

0801da2c <_ZN9__gnu_cxx27__verbose_terminate_handlerEv>:
 801da2c:	4b39      	ldr	r3, [pc, #228]	; (801db14 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0xe8>)
 801da2e:	b570      	push	{r4, r5, r6, lr}
 801da30:	b082      	sub	sp, #8
 801da32:	781a      	ldrb	r2, [r3, #0]
 801da34:	2a00      	cmp	r2, #0
 801da36:	d135      	bne.n	801daa4 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0x78>
 801da38:	2401      	movs	r4, #1
 801da3a:	701c      	strb	r4, [r3, #0]
 801da3c:	f000 fb00 	bl	801e040 <__cxa_current_exception_type>
 801da40:	2800      	cmp	r0, #0
 801da42:	d045      	beq.n	801dad0 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0xa4>
 801da44:	6844      	ldr	r4, [r0, #4]
 801da46:	f04f 30ff 	mov.w	r0, #4294967295
 801da4a:	4d33      	ldr	r5, [pc, #204]	; (801db18 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0xec>)
 801da4c:	7823      	ldrb	r3, [r4, #0]
 801da4e:	2b2a      	cmp	r3, #42	; 0x2a
 801da50:	ab02      	add	r3, sp, #8
 801da52:	bf08      	it	eq
 801da54:	3401      	addeq	r4, #1
 801da56:	2100      	movs	r1, #0
 801da58:	460a      	mov	r2, r1
 801da5a:	f843 0d04 	str.w	r0, [r3, #-4]!
 801da5e:	4620      	mov	r0, r4
 801da60:	f7f2 fbb6 	bl	80101d0 <__cxa_demangle>
 801da64:	682b      	ldr	r3, [r5, #0]
 801da66:	2101      	movs	r1, #1
 801da68:	2230      	movs	r2, #48	; 0x30
 801da6a:	68db      	ldr	r3, [r3, #12]
 801da6c:	4606      	mov	r6, r0
 801da6e:	482b      	ldr	r0, [pc, #172]	; (801db1c <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0xf0>)
 801da70:	f7f3 fe4a 	bl	8011708 <fwrite>
 801da74:	9b01      	ldr	r3, [sp, #4]
 801da76:	b17b      	cbz	r3, 801da98 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0x6c>
 801da78:	682b      	ldr	r3, [r5, #0]
 801da7a:	4620      	mov	r0, r4
 801da7c:	68d9      	ldr	r1, [r3, #12]
 801da7e:	f7f3 fc79 	bl	8011374 <fputs>
 801da82:	682b      	ldr	r3, [r5, #0]
 801da84:	2101      	movs	r1, #1
 801da86:	4826      	ldr	r0, [pc, #152]	; (801db20 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0xf4>)
 801da88:	2202      	movs	r2, #2
 801da8a:	68db      	ldr	r3, [r3, #12]
 801da8c:	f7f3 fe3c 	bl	8011708 <fwrite>
 801da90:	9b01      	ldr	r3, [sp, #4]
 801da92:	b18b      	cbz	r3, 801dab8 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0x8c>
 801da94:	f000 fa9c 	bl	801dfd0 <__cxa_rethrow>
 801da98:	682b      	ldr	r3, [r5, #0]
 801da9a:	4630      	mov	r0, r6
 801da9c:	68d9      	ldr	r1, [r3, #12]
 801da9e:	f7f3 fc69 	bl	8011374 <fputs>
 801daa2:	e7ee      	b.n	801da82 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0x56>
 801daa4:	481f      	ldr	r0, [pc, #124]	; (801db24 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0xf8>)
 801daa6:	2101      	movs	r1, #1
 801daa8:	221d      	movs	r2, #29
 801daaa:	4b1b      	ldr	r3, [pc, #108]	; (801db18 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0xec>)
 801daac:	681b      	ldr	r3, [r3, #0]
 801daae:	68db      	ldr	r3, [r3, #12]
 801dab0:	f7f3 fe2a 	bl	8011708 <fwrite>
 801dab4:	f7f3 fbdc 	bl	8011270 <abort>
 801dab8:	4630      	mov	r0, r6
 801daba:	f7f3 fe67 	bl	801178c <free>
 801dabe:	e7e9      	b.n	801da94 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0x68>
 801dac0:	2901      	cmp	r1, #1
 801dac2:	460c      	mov	r4, r1
 801dac4:	d008      	beq.n	801dad8 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0xac>
 801dac6:	f000 f98f 	bl	801dde8 <__cxa_begin_catch>
 801daca:	f000 f9d3 	bl	801de74 <__cxa_end_catch>
 801dace:	e7f1      	b.n	801dab4 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0x88>
 801dad0:	4621      	mov	r1, r4
 801dad2:	4815      	ldr	r0, [pc, #84]	; (801db28 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0xfc>)
 801dad4:	222d      	movs	r2, #45	; 0x2d
 801dad6:	e7e8      	b.n	801daaa <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0x7e>
 801dad8:	f000 f986 	bl	801dde8 <__cxa_begin_catch>
 801dadc:	6803      	ldr	r3, [r0, #0]
 801dade:	689b      	ldr	r3, [r3, #8]
 801dae0:	4798      	blx	r3
 801dae2:	682b      	ldr	r3, [r5, #0]
 801dae4:	4621      	mov	r1, r4
 801dae6:	220b      	movs	r2, #11
 801dae8:	68db      	ldr	r3, [r3, #12]
 801daea:	4606      	mov	r6, r0
 801daec:	480f      	ldr	r0, [pc, #60]	; (801db2c <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0x100>)
 801daee:	f7f3 fe0b 	bl	8011708 <fwrite>
 801daf2:	682b      	ldr	r3, [r5, #0]
 801daf4:	4630      	mov	r0, r6
 801daf6:	68d9      	ldr	r1, [r3, #12]
 801daf8:	f7f3 fc3c 	bl	8011374 <fputs>
 801dafc:	682b      	ldr	r3, [r5, #0]
 801dafe:	200a      	movs	r0, #10
 801db00:	68d9      	ldr	r1, [r3, #12]
 801db02:	f7f3 fbfb 	bl	80112fc <fputc>
 801db06:	f000 f9b5 	bl	801de74 <__cxa_end_catch>
 801db0a:	e7d3      	b.n	801dab4 <_ZN9__gnu_cxx27__verbose_terminate_handlerEv+0x88>
 801db0c:	f000 f9b2 	bl	801de74 <__cxa_end_catch>
 801db10:	f7fe ffb6 	bl	801ca80 <__cxa_end_cleanup>
 801db14:	20000c80 	.word	0x20000c80
 801db18:	200000b0 	.word	0x200000b0
 801db1c:	08020b38 	.word	0x08020b38
 801db20:	08020b6c 	.word	0x08020b6c
 801db24:	08020b18 	.word	0x08020b18
 801db28:	08020b70 	.word	0x08020b70
 801db2c:	08020ba0 	.word	0x08020ba0

0801db30 <_ZNKSt9bad_alloc4whatEv>:
 801db30:	f640 30d4 	movw	r0, #3028	; 0xbd4
 801db34:	f6c0 0002 	movt	r0, #2050	; 0x802
 801db38:	4770      	bx	lr
 801db3a:	bf00      	nop

0801db3c <_ZNSt9bad_allocD1Ev>:
 801db3c:	4b03      	ldr	r3, [pc, #12]	; (801db4c <_ZNSt9bad_allocD1Ev+0x10>)
 801db3e:	b510      	push	{r4, lr}
 801db40:	4604      	mov	r4, r0
 801db42:	6003      	str	r3, [r0, #0]
 801db44:	f7ff f866 	bl	801cc14 <_ZNSt9exceptionD1Ev>
 801db48:	4620      	mov	r0, r4
 801db4a:	bd10      	pop	{r4, pc}
 801db4c:	08020bb8 	.word	0x08020bb8

0801db50 <_ZNSt9bad_allocD0Ev>:
 801db50:	b510      	push	{r4, lr}
 801db52:	4604      	mov	r4, r0
 801db54:	f7ff fff2 	bl	801db3c <_ZNSt9bad_allocD1Ev>
 801db58:	4620      	mov	r0, r4
 801db5a:	f7fe ff8d 	bl	801ca78 <_ZdlPv>
 801db5e:	4620      	mov	r0, r4
 801db60:	bd10      	pop	{r4, pc}
 801db62:	bf00      	nop

0801db64 <__cxa_allocate_exception>:
 801db64:	b538      	push	{r3, r4, r5, lr}
 801db66:	f100 0580 	add.w	r5, r0, #128	; 0x80
 801db6a:	4628      	mov	r0, r5
 801db6c:	f7f3 fe06 	bl	801177c <malloc>
 801db70:	4604      	mov	r4, r0
 801db72:	b168      	cbz	r0, 801db90 <__cxa_allocate_exception+0x2c>
 801db74:	f7ff f8a0 	bl	801ccb8 <__cxa_get_globals>
 801db78:	2100      	movs	r1, #0
 801db7a:	2280      	movs	r2, #128	; 0x80
 801db7c:	4603      	mov	r3, r0
 801db7e:	4620      	mov	r0, r4
 801db80:	685d      	ldr	r5, [r3, #4]
 801db82:	3501      	adds	r5, #1
 801db84:	605d      	str	r5, [r3, #4]
 801db86:	f7f4 f9e5 	bl	8011f54 <memset>
 801db8a:	f104 0080 	add.w	r0, r4, #128	; 0x80
 801db8e:	bd38      	pop	{r3, r4, r5, pc}
 801db90:	490d      	ldr	r1, [pc, #52]	; (801dbc8 <__cxa_allocate_exception+0x64>)
 801db92:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
 801db96:	bf98      	it	ls
 801db98:	4623      	movls	r3, r4
 801db9a:	6808      	ldr	r0, [r1, #0]
 801db9c:	bf98      	it	ls
 801db9e:	4602      	movls	r2, r0
 801dba0:	d901      	bls.n	801dba6 <__cxa_allocate_exception+0x42>
 801dba2:	f7ff fb79 	bl	801d298 <_ZSt9terminatev>
 801dba6:	07d4      	lsls	r4, r2, #31
 801dba8:	d504      	bpl.n	801dbb4 <__cxa_allocate_exception+0x50>
 801dbaa:	3301      	adds	r3, #1
 801dbac:	0852      	lsrs	r2, r2, #1
 801dbae:	2b04      	cmp	r3, #4
 801dbb0:	d1f9      	bne.n	801dba6 <__cxa_allocate_exception+0x42>
 801dbb2:	e7f6      	b.n	801dba2 <__cxa_allocate_exception+0x3e>
 801dbb4:	4c05      	ldr	r4, [pc, #20]	; (801dbcc <__cxa_allocate_exception+0x68>)
 801dbb6:	2201      	movs	r2, #1
 801dbb8:	eb04 2443 	add.w	r4, r4, r3, lsl #9
 801dbbc:	fa02 f303 	lsl.w	r3, r2, r3
 801dbc0:	4318      	orrs	r0, r3
 801dbc2:	6008      	str	r0, [r1, #0]
 801dbc4:	e7d6      	b.n	801db74 <__cxa_allocate_exception+0x10>
 801dbc6:	bf00      	nop
 801dbc8:	20000e68 	.word	0x20000e68
 801dbcc:	20000e70 	.word	0x20000e70

0801dbd0 <__cxa_free_exception>:
 801dbd0:	4b0a      	ldr	r3, [pc, #40]	; (801dbfc <__cxa_free_exception+0x2c>)
 801dbd2:	4298      	cmp	r0, r3
 801dbd4:	d303      	bcc.n	801dbde <__cxa_free_exception+0xe>
 801dbd6:	f503 6200 	add.w	r2, r3, #2048	; 0x800
 801dbda:	4290      	cmp	r0, r2
 801dbdc:	d302      	bcc.n	801dbe4 <__cxa_free_exception+0x14>
 801dbde:	3880      	subs	r0, #128	; 0x80
 801dbe0:	f7f3 bdd4 	b.w	801178c <free>
 801dbe4:	4a06      	ldr	r2, [pc, #24]	; (801dc00 <__cxa_free_exception+0x30>)
 801dbe6:	1ac3      	subs	r3, r0, r3
 801dbe8:	2001      	movs	r0, #1
 801dbea:	0a5b      	lsrs	r3, r3, #9
 801dbec:	6811      	ldr	r1, [r2, #0]
 801dbee:	fa00 f303 	lsl.w	r3, r0, r3
 801dbf2:	ea21 0103 	bic.w	r1, r1, r3
 801dbf6:	6011      	str	r1, [r2, #0]
 801dbf8:	4770      	bx	lr
 801dbfa:	bf00      	nop
 801dbfc:	20000e70 	.word	0x20000e70
 801dc00:	20000e68 	.word	0x20000e68

0801dc04 <__cxa_allocate_dependent_exception>:
 801dc04:	b538      	push	{r3, r4, r5, lr}
 801dc06:	2078      	movs	r0, #120	; 0x78
 801dc08:	f7f3 fdb8 	bl	801177c <malloc>
 801dc0c:	4604      	mov	r4, r0
 801dc0e:	b160      	cbz	r0, 801dc2a <__cxa_allocate_dependent_exception+0x26>
 801dc10:	f7ff f852 	bl	801ccb8 <__cxa_get_globals>
 801dc14:	2100      	movs	r1, #0
 801dc16:	2278      	movs	r2, #120	; 0x78
 801dc18:	4603      	mov	r3, r0
 801dc1a:	4620      	mov	r0, r4
 801dc1c:	685d      	ldr	r5, [r3, #4]
 801dc1e:	3501      	adds	r5, #1
 801dc20:	605d      	str	r5, [r3, #4]
 801dc22:	f7f4 f997 	bl	8011f54 <memset>
 801dc26:	4620      	mov	r0, r4
 801dc28:	bd38      	pop	{r3, r4, r5, pc}
 801dc2a:	490b      	ldr	r1, [pc, #44]	; (801dc58 <__cxa_allocate_dependent_exception+0x54>)
 801dc2c:	4603      	mov	r3, r0
 801dc2e:	6808      	ldr	r0, [r1, #0]
 801dc30:	4602      	mov	r2, r0
 801dc32:	07d5      	lsls	r5, r2, #31
 801dc34:	d505      	bpl.n	801dc42 <__cxa_allocate_dependent_exception+0x3e>
 801dc36:	3301      	adds	r3, #1
 801dc38:	0852      	lsrs	r2, r2, #1
 801dc3a:	2b04      	cmp	r3, #4
 801dc3c:	d1f9      	bne.n	801dc32 <__cxa_allocate_dependent_exception+0x2e>
 801dc3e:	f7ff fb2b 	bl	801d298 <_ZSt9terminatev>
 801dc42:	ebc3 1403 	rsb	r4, r3, r3, lsl #4
 801dc46:	4a05      	ldr	r2, [pc, #20]	; (801dc5c <__cxa_allocate_dependent_exception+0x58>)
 801dc48:	eb02 04c4 	add.w	r4, r2, r4, lsl #3
 801dc4c:	2201      	movs	r2, #1
 801dc4e:	fa02 f303 	lsl.w	r3, r2, r3
 801dc52:	4318      	orrs	r0, r3
 801dc54:	6008      	str	r0, [r1, #0]
 801dc56:	e7db      	b.n	801dc10 <__cxa_allocate_dependent_exception+0xc>
 801dc58:	20000c84 	.word	0x20000c84
 801dc5c:	20000c88 	.word	0x20000c88

0801dc60 <__cxa_free_dependent_exception>:
 801dc60:	4b0e      	ldr	r3, [pc, #56]	; (801dc9c <__cxa_free_dependent_exception+0x3c>)
 801dc62:	b410      	push	{r4}
 801dc64:	4298      	cmp	r0, r3
 801dc66:	d303      	bcc.n	801dc70 <__cxa_free_dependent_exception+0x10>
 801dc68:	f503 72f0 	add.w	r2, r3, #480	; 0x1e0
 801dc6c:	4290      	cmp	r0, r2
 801dc6e:	d302      	bcc.n	801dc76 <__cxa_free_dependent_exception+0x16>
 801dc70:	bc10      	pop	{r4}
 801dc72:	f7f3 bd8b 	b.w	801178c <free>
 801dc76:	f648 0189 	movw	r1, #34953	; 0x8889
 801dc7a:	1ac0      	subs	r0, r0, r3
 801dc7c:	f6c8 0188 	movt	r1, #34952	; 0x8888
 801dc80:	4a07      	ldr	r2, [pc, #28]	; (801dca0 <__cxa_free_dependent_exception+0x40>)
 801dc82:	fba1 3100 	umull	r3, r1, r1, r0
 801dc86:	2301      	movs	r3, #1
 801dc88:	6814      	ldr	r4, [r2, #0]
 801dc8a:	0989      	lsrs	r1, r1, #6
 801dc8c:	fa03 f101 	lsl.w	r1, r3, r1
 801dc90:	ea24 0401 	bic.w	r4, r4, r1
 801dc94:	6014      	str	r4, [r2, #0]
 801dc96:	bc10      	pop	{r4}
 801dc98:	4770      	bx	lr
 801dc9a:	bf00      	nop
 801dc9c:	20000c88 	.word	0x20000c88
 801dca0:	20000c84 	.word	0x20000c84

0801dca4 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>:
 801dca4:	7803      	ldrb	r3, [r0, #0]
 801dca6:	2b47      	cmp	r3, #71	; 0x47
 801dca8:	d001      	beq.n	801dcae <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0xa>
 801dcaa:	2000      	movs	r0, #0
 801dcac:	4770      	bx	lr
 801dcae:	7843      	ldrb	r3, [r0, #1]
 801dcb0:	2b4e      	cmp	r3, #78	; 0x4e
 801dcb2:	d1fa      	bne.n	801dcaa <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x6>
 801dcb4:	7883      	ldrb	r3, [r0, #2]
 801dcb6:	2b55      	cmp	r3, #85	; 0x55
 801dcb8:	d1f7      	bne.n	801dcaa <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x6>
 801dcba:	78c3      	ldrb	r3, [r0, #3]
 801dcbc:	2b43      	cmp	r3, #67	; 0x43
 801dcbe:	d1f4      	bne.n	801dcaa <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x6>
 801dcc0:	7903      	ldrb	r3, [r0, #4]
 801dcc2:	2b43      	cmp	r3, #67	; 0x43
 801dcc4:	d1f1      	bne.n	801dcaa <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x6>
 801dcc6:	7943      	ldrb	r3, [r0, #5]
 801dcc8:	2b2b      	cmp	r3, #43	; 0x2b
 801dcca:	d1ee      	bne.n	801dcaa <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x6>
 801dccc:	7983      	ldrb	r3, [r0, #6]
 801dcce:	2b2b      	cmp	r3, #43	; 0x2b
 801dcd0:	d1eb      	bne.n	801dcaa <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x6>
 801dcd2:	79c0      	ldrb	r0, [r0, #7]
 801dcd4:	2801      	cmp	r0, #1
 801dcd6:	bf8c      	ite	hi
 801dcd8:	2000      	movhi	r0, #0
 801dcda:	2001      	movls	r0, #1
 801dcdc:	4770      	bx	lr
 801dcde:	bf00      	nop

0801dce0 <__cxa_call_terminate>:
 801dce0:	b510      	push	{r4, lr}
 801dce2:	4604      	mov	r4, r0
 801dce4:	b128      	cbz	r0, 801dcf2 <__cxa_call_terminate+0x12>
 801dce6:	f000 f87f 	bl	801dde8 <__cxa_begin_catch>
 801dcea:	4620      	mov	r0, r4
 801dcec:	f7ff ffda 	bl	801dca4 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 801dcf0:	b908      	cbnz	r0, 801dcf6 <__cxa_call_terminate+0x16>
 801dcf2:	f7ff fad1 	bl	801d298 <_ZSt9terminatev>
 801dcf6:	f854 0c14 	ldr.w	r0, [r4, #-20]
 801dcfa:	f7ff fab9 	bl	801d270 <_ZN10__cxxabiv111__terminateEPFvvE>
 801dcfe:	bf00      	nop

0801dd00 <__cxa_call_unexpected>:
 801dd00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801dd04:	b085      	sub	sp, #20
 801dd06:	4604      	mov	r4, r0
 801dd08:	f7ff ffcc 	bl	801dca4 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 801dd0c:	b168      	cbz	r0, 801dd2a <__cxa_call_unexpected+0x2a>
 801dd0e:	f854 7c18 	ldr.w	r7, [r4, #-24]
 801dd12:	4620      	mov	r0, r4
 801dd14:	f854 5c14 	ldr.w	r5, [r4, #-20]
 801dd18:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 801dd1a:	f8d4 8030 	ldr.w	r8, [r4, #48]	; 0x30
 801dd1e:	6b64      	ldr	r4, [r4, #52]	; 0x34
 801dd20:	f000 f862 	bl	801dde8 <__cxa_begin_catch>
 801dd24:	4638      	mov	r0, r7
 801dd26:	f7ff fabf 	bl	801d2a8 <_ZN10__cxxabiv112__unexpectedEPFvvE>
 801dd2a:	4620      	mov	r0, r4
 801dd2c:	f000 f85c 	bl	801dde8 <__cxa_begin_catch>
 801dd30:	f7ff fabe 	bl	801d2b0 <_ZSt10unexpectedv>
 801dd34:	f000 f858 	bl	801dde8 <__cxa_begin_catch>
 801dd38:	f7ff faae 	bl	801d298 <_ZSt9terminatev>
 801dd3c:	f000 f854 	bl	801dde8 <__cxa_begin_catch>
 801dd40:	f7fe ffb4 	bl	801ccac <__cxa_get_globals_fast>
 801dd44:	6803      	ldr	r3, [r0, #0]
 801dd46:	f893 2027 	ldrb.w	r2, [r3, #39]	; 0x27
 801dd4a:	2a01      	cmp	r2, #1
 801dd4c:	d02b      	beq.n	801dda6 <__cxa_call_unexpected+0xa6>
 801dd4e:	f103 0278 	add.w	r2, r3, #120	; 0x78
 801dd52:	2700      	movs	r7, #0
 801dd54:	f10d 0a10 	add.w	sl, sp, #16
 801dd58:	46b9      	mov	r9, r7
 801dd5a:	f103 0b20 	add.w	fp, r3, #32
 801dd5e:	f028 0803 	bic.w	r8, r8, #3
 801dd62:	f84a 2d04 	str.w	r2, [sl, #-4]!
 801dd66:	f8cd 8004 	str.w	r8, [sp, #4]
 801dd6a:	45b1      	cmp	r9, r6
 801dd6c:	da27      	bge.n	801ddbe <__cxa_call_unexpected+0xbe>
 801dd6e:	6823      	ldr	r3, [r4, #0]
 801dd70:	b31b      	cbz	r3, 801ddba <__cxa_call_unexpected+0xba>
 801dd72:	eb03 0804 	add.w	r8, r3, r4
 801dd76:	4658      	mov	r0, fp
 801dd78:	4641      	mov	r1, r8
 801dd7a:	2200      	movs	r2, #0
 801dd7c:	4653      	mov	r3, sl
 801dd7e:	f7fe fe85 	bl	801ca8c <__cxa_type_match>
 801dd82:	4602      	mov	r2, r0
 801dd84:	b988      	cbnz	r0, 801ddaa <__cxa_call_unexpected+0xaa>
 801dd86:	f8d8 e000 	ldr.w	lr, [r8]
 801dd8a:	4640      	mov	r0, r8
 801dd8c:	4912      	ldr	r1, [pc, #72]	; (801ddd8 <__cxa_call_unexpected+0xd8>)
 801dd8e:	2301      	movs	r3, #1
 801dd90:	f8de c010 	ldr.w	ip, [lr, #16]
 801dd94:	47e0      	blx	ip
 801dd96:	9b01      	ldr	r3, [sp, #4]
 801dd98:	2800      	cmp	r0, #0
 801dd9a:	bf18      	it	ne
 801dd9c:	2701      	movne	r7, #1
 801dd9e:	f109 0901 	add.w	r9, r9, #1
 801dda2:	18e4      	adds	r4, r4, r3
 801dda4:	e7e1      	b.n	801dd6a <__cxa_call_unexpected+0x6a>
 801dda6:	681a      	ldr	r2, [r3, #0]
 801dda8:	e7d3      	b.n	801dd52 <__cxa_call_unexpected+0x52>
 801ddaa:	f000 f911 	bl	801dfd0 <__cxa_rethrow>
 801ddae:	f000 f861 	bl	801de74 <__cxa_end_catch>
 801ddb2:	f000 f85f 	bl	801de74 <__cxa_end_catch>
 801ddb6:	f7fe fe63 	bl	801ca80 <__cxa_end_cleanup>
 801ddba:	4698      	mov	r8, r3
 801ddbc:	e7db      	b.n	801dd76 <__cxa_call_unexpected+0x76>
 801ddbe:	b147      	cbz	r7, 801ddd2 <__cxa_call_unexpected+0xd2>
 801ddc0:	2004      	movs	r0, #4
 801ddc2:	f7ff fecf 	bl	801db64 <__cxa_allocate_exception>
 801ddc6:	4b05      	ldr	r3, [pc, #20]	; (801dddc <__cxa_call_unexpected+0xdc>)
 801ddc8:	4903      	ldr	r1, [pc, #12]	; (801ddd8 <__cxa_call_unexpected+0xd8>)
 801ddca:	4a05      	ldr	r2, [pc, #20]	; (801dde0 <__cxa_call_unexpected+0xe0>)
 801ddcc:	6003      	str	r3, [r0, #0]
 801ddce:	f000 f8c1 	bl	801df54 <__cxa_throw>
 801ddd2:	4628      	mov	r0, r5
 801ddd4:	f7ff fa4c 	bl	801d270 <_ZN10__cxxabiv111__terminateEPFvvE>
 801ddd8:	08020a00 	.word	0x08020a00
 801dddc:	080209a8 	.word	0x080209a8
 801dde0:	0801cc21 	.word	0x0801cc21

0801dde4 <__cxa_get_exception_ptr>:
 801dde4:	6a40      	ldr	r0, [r0, #36]	; 0x24
 801dde6:	4770      	bx	lr

0801dde8 <__cxa_begin_catch>:
 801dde8:	b538      	push	{r3, r4, r5, lr}
 801ddea:	4604      	mov	r4, r0
 801ddec:	f7fe ff64 	bl	801ccb8 <__cxa_get_globals>
 801ddf0:	f1a4 0220 	sub.w	r2, r4, #32
 801ddf4:	7821      	ldrb	r1, [r4, #0]
 801ddf6:	2947      	cmp	r1, #71	; 0x47
 801ddf8:	6803      	ldr	r3, [r0, #0]
 801ddfa:	d005      	beq.n	801de08 <__cxa_begin_catch+0x20>
 801ddfc:	2b00      	cmp	r3, #0
 801ddfe:	d130      	bne.n	801de62 <__cxa_begin_catch+0x7a>
 801de00:	461c      	mov	r4, r3
 801de02:	6002      	str	r2, [r0, #0]
 801de04:	4620      	mov	r0, r4
 801de06:	bd38      	pop	{r3, r4, r5, pc}
 801de08:	7861      	ldrb	r1, [r4, #1]
 801de0a:	294e      	cmp	r1, #78	; 0x4e
 801de0c:	d1f6      	bne.n	801ddfc <__cxa_begin_catch+0x14>
 801de0e:	78a1      	ldrb	r1, [r4, #2]
 801de10:	2955      	cmp	r1, #85	; 0x55
 801de12:	d1f3      	bne.n	801ddfc <__cxa_begin_catch+0x14>
 801de14:	78e1      	ldrb	r1, [r4, #3]
 801de16:	2943      	cmp	r1, #67	; 0x43
 801de18:	d1f0      	bne.n	801ddfc <__cxa_begin_catch+0x14>
 801de1a:	7921      	ldrb	r1, [r4, #4]
 801de1c:	2943      	cmp	r1, #67	; 0x43
 801de1e:	d1ed      	bne.n	801ddfc <__cxa_begin_catch+0x14>
 801de20:	7961      	ldrb	r1, [r4, #5]
 801de22:	292b      	cmp	r1, #43	; 0x2b
 801de24:	d1ea      	bne.n	801ddfc <__cxa_begin_catch+0x14>
 801de26:	79a1      	ldrb	r1, [r4, #6]
 801de28:	292b      	cmp	r1, #43	; 0x2b
 801de2a:	d1e7      	bne.n	801ddfc <__cxa_begin_catch+0x14>
 801de2c:	79e1      	ldrb	r1, [r4, #7]
 801de2e:	2901      	cmp	r1, #1
 801de30:	d8e4      	bhi.n	801ddfc <__cxa_begin_catch+0x14>
 801de32:	f854 5c0c 	ldr.w	r5, [r4, #-12]
 801de36:	2d00      	cmp	r5, #0
 801de38:	db10      	blt.n	801de5c <__cxa_begin_catch+0x74>
 801de3a:	3501      	adds	r5, #1
 801de3c:	6841      	ldr	r1, [r0, #4]
 801de3e:	f844 5c0c 	str.w	r5, [r4, #-12]
 801de42:	3901      	subs	r1, #1
 801de44:	429a      	cmp	r2, r3
 801de46:	6041      	str	r1, [r0, #4]
 801de48:	bf1c      	itt	ne
 801de4a:	f844 3c10 	strne.w	r3, [r4, #-16]
 801de4e:	6002      	strne	r2, [r0, #0]
 801de50:	4620      	mov	r0, r4
 801de52:	6a64      	ldr	r4, [r4, #36]	; 0x24
 801de54:	f7f2 fc24 	bl	80106a0 <_Unwind_Complete>
 801de58:	4620      	mov	r0, r4
 801de5a:	bd38      	pop	{r3, r4, r5, pc}
 801de5c:	f1c5 0501 	rsb	r5, r5, #1
 801de60:	e7ec      	b.n	801de3c <__cxa_begin_catch+0x54>
 801de62:	f7ff fa19 	bl	801d298 <_ZSt9terminatev>
 801de66:	3101      	adds	r1, #1
 801de68:	d001      	beq.n	801de6e <__cxa_begin_catch+0x86>
 801de6a:	f7fe fe09 	bl	801ca80 <__cxa_end_cleanup>
 801de6e:	f7ff ff47 	bl	801dd00 <__cxa_call_unexpected>
 801de72:	bf00      	nop

0801de74 <__cxa_end_catch>:
 801de74:	b508      	push	{r3, lr}
 801de76:	f7fe ff19 	bl	801ccac <__cxa_get_globals_fast>
 801de7a:	4602      	mov	r2, r0
 801de7c:	6800      	ldr	r0, [r0, #0]
 801de7e:	2800      	cmp	r0, #0
 801de80:	d03d      	beq.n	801defe <__cxa_end_catch+0x8a>
 801de82:	f890 1020 	ldrb.w	r1, [r0, #32]
 801de86:	2947      	cmp	r1, #71	; 0x47
 801de88:	d006      	beq.n	801de98 <__cxa_end_catch+0x24>
 801de8a:	2300      	movs	r3, #0
 801de8c:	3020      	adds	r0, #32
 801de8e:	6013      	str	r3, [r2, #0]
 801de90:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 801de94:	f7f2 bc06 	b.w	80106a4 <_Unwind_DeleteException>
 801de98:	f890 1021 	ldrb.w	r1, [r0, #33]	; 0x21
 801de9c:	294e      	cmp	r1, #78	; 0x4e
 801de9e:	d1f4      	bne.n	801de8a <__cxa_end_catch+0x16>
 801dea0:	f890 1022 	ldrb.w	r1, [r0, #34]	; 0x22
 801dea4:	2955      	cmp	r1, #85	; 0x55
 801dea6:	d1f0      	bne.n	801de8a <__cxa_end_catch+0x16>
 801dea8:	f890 1023 	ldrb.w	r1, [r0, #35]	; 0x23
 801deac:	2943      	cmp	r1, #67	; 0x43
 801deae:	d1ec      	bne.n	801de8a <__cxa_end_catch+0x16>
 801deb0:	f890 1024 	ldrb.w	r1, [r0, #36]	; 0x24
 801deb4:	2943      	cmp	r1, #67	; 0x43
 801deb6:	d1e8      	bne.n	801de8a <__cxa_end_catch+0x16>
 801deb8:	f890 1025 	ldrb.w	r1, [r0, #37]	; 0x25
 801debc:	292b      	cmp	r1, #43	; 0x2b
 801debe:	d1e4      	bne.n	801de8a <__cxa_end_catch+0x16>
 801dec0:	f890 1026 	ldrb.w	r1, [r0, #38]	; 0x26
 801dec4:	292b      	cmp	r1, #43	; 0x2b
 801dec6:	d1e0      	bne.n	801de8a <__cxa_end_catch+0x16>
 801dec8:	f890 1027 	ldrb.w	r1, [r0, #39]	; 0x27
 801decc:	2901      	cmp	r1, #1
 801dece:	d8dc      	bhi.n	801de8a <__cxa_end_catch+0x16>
 801ded0:	6941      	ldr	r1, [r0, #20]
 801ded2:	2900      	cmp	r1, #0
 801ded4:	db05      	blt.n	801dee2 <__cxa_end_catch+0x6e>
 801ded6:	3901      	subs	r1, #1
 801ded8:	d008      	beq.n	801deec <__cxa_end_catch+0x78>
 801deda:	1c4b      	adds	r3, r1, #1
 801dedc:	d00d      	beq.n	801defa <__cxa_end_catch+0x86>
 801dede:	6141      	str	r1, [r0, #20]
 801dee0:	bd08      	pop	{r3, pc}
 801dee2:	3101      	adds	r1, #1
 801dee4:	d1fb      	bne.n	801dede <__cxa_end_catch+0x6a>
 801dee6:	6903      	ldr	r3, [r0, #16]
 801dee8:	6013      	str	r3, [r2, #0]
 801deea:	e7f8      	b.n	801dede <__cxa_end_catch+0x6a>
 801deec:	6901      	ldr	r1, [r0, #16]
 801deee:	3020      	adds	r0, #32
 801def0:	6011      	str	r1, [r2, #0]
 801def2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 801def6:	f7f2 bbd5 	b.w	80106a4 <_Unwind_DeleteException>
 801defa:	f7ff f9cd 	bl	801d298 <_ZSt9terminatev>
 801defe:	bd08      	pop	{r3, pc}

0801df00 <_ZSt18uncaught_exceptionv>:
 801df00:	b508      	push	{r3, lr}
 801df02:	f7fe fed9 	bl	801ccb8 <__cxa_get_globals>
 801df06:	6840      	ldr	r0, [r0, #4]
 801df08:	3000      	adds	r0, #0
 801df0a:	bf18      	it	ne
 801df0c:	2001      	movne	r0, #1
 801df0e:	bd08      	pop	{r3, pc}

0801df10 <_ZL23__gxx_exception_cleanup19_Unwind_Reason_CodeP21_Unwind_Control_Block>:
 801df10:	2801      	cmp	r0, #1
 801df12:	b510      	push	{r4, lr}
 801df14:	d81a      	bhi.n	801df4c <_ZL23__gxx_exception_cleanup19_Unwind_Reason_CodeP21_Unwind_Control_Block+0x3c>
 801df16:	f1a1 0328 	sub.w	r3, r1, #40	; 0x28
 801df1a:	f3bf 8f5f 	dmb	sy
 801df1e:	e853 2f00 	ldrex	r2, [r3]
 801df22:	3a01      	subs	r2, #1
 801df24:	e843 2000 	strex	r0, r2, [r3]
 801df28:	2800      	cmp	r0, #0
 801df2a:	d1f8      	bne.n	801df1e <_ZL23__gxx_exception_cleanup19_Unwind_Reason_CodeP21_Unwind_Control_Block+0xe>
 801df2c:	f3bf 8f5f 	dmb	sy
 801df30:	b95a      	cbnz	r2, 801df4a <_ZL23__gxx_exception_cleanup19_Unwind_Reason_CodeP21_Unwind_Control_Block+0x3a>
 801df32:	f851 3c1c 	ldr.w	r3, [r1, #-28]
 801df36:	f101 0458 	add.w	r4, r1, #88	; 0x58
 801df3a:	b10b      	cbz	r3, 801df40 <_ZL23__gxx_exception_cleanup19_Unwind_Reason_CodeP21_Unwind_Control_Block+0x30>
 801df3c:	4620      	mov	r0, r4
 801df3e:	4798      	blx	r3
 801df40:	4620      	mov	r0, r4
 801df42:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801df46:	f7ff be43 	b.w	801dbd0 <__cxa_free_exception>
 801df4a:	bd10      	pop	{r4, pc}
 801df4c:	f851 0c14 	ldr.w	r0, [r1, #-20]
 801df50:	f7ff f98e 	bl	801d270 <_ZN10__cxxabiv111__terminateEPFvvE>

0801df54 <__cxa_throw>:
 801df54:	b570      	push	{r4, r5, r6, lr}
 801df56:	f640 05fc 	movw	r5, #2300	; 0x8fc
 801df5a:	f640 04f8 	movw	r4, #2296	; 0x8f8
 801df5e:	f2c2 0500 	movt	r5, #8192	; 0x2000
 801df62:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801df66:	4603      	mov	r3, r0
 801df68:	6828      	ldr	r0, [r5, #0]
 801df6a:	f1a3 0558 	sub.w	r5, r3, #88	; 0x58
 801df6e:	6826      	ldr	r6, [r4, #0]
 801df70:	2443      	movs	r4, #67	; 0x43
 801df72:	f843 2c74 	str.w	r2, [r3, #-116]
 801df76:	2201      	movs	r2, #1
 801df78:	f843 2c80 	str.w	r2, [r3, #-128]
 801df7c:	2247      	movs	r2, #71	; 0x47
 801df7e:	f803 2c58 	strb.w	r2, [r3, #-88]
 801df82:	224e      	movs	r2, #78	; 0x4e
 801df84:	f803 2c57 	strb.w	r2, [r3, #-87]
 801df88:	f64d 7211 	movw	r2, #57105	; 0xdf11
 801df8c:	f843 1c78 	str.w	r1, [r3, #-120]
 801df90:	f6c0 0201 	movt	r2, #2049	; 0x801
 801df94:	212b      	movs	r1, #43	; 0x2b
 801df96:	f843 0c70 	str.w	r0, [r3, #-112]
 801df9a:	f843 2c50 	str.w	r2, [r3, #-80]
 801df9e:	4628      	mov	r0, r5
 801dfa0:	f843 6c6c 	str.w	r6, [r3, #-108]
 801dfa4:	2255      	movs	r2, #85	; 0x55
 801dfa6:	f803 4c55 	strb.w	r4, [r3, #-85]
 801dfaa:	f803 2c56 	strb.w	r2, [r3, #-86]
 801dfae:	2200      	movs	r2, #0
 801dfb0:	f803 4c54 	strb.w	r4, [r3, #-84]
 801dfb4:	f803 1c53 	strb.w	r1, [r3, #-83]
 801dfb8:	f803 1c52 	strb.w	r1, [r3, #-82]
 801dfbc:	f803 2c51 	strb.w	r2, [r3, #-81]
 801dfc0:	f7f2 ff28 	bl	8010e14 <_Unwind_RaiseException>
 801dfc4:	4628      	mov	r0, r5
 801dfc6:	f7ff ff0f 	bl	801dde8 <__cxa_begin_catch>
 801dfca:	f7ff f965 	bl	801d298 <_ZSt9terminatev>
 801dfce:	bf00      	nop

0801dfd0 <__cxa_rethrow>:
 801dfd0:	b510      	push	{r4, lr}
 801dfd2:	f7fe fe71 	bl	801ccb8 <__cxa_get_globals>
 801dfd6:	6842      	ldr	r2, [r0, #4]
 801dfd8:	6803      	ldr	r3, [r0, #0]
 801dfda:	3201      	adds	r2, #1
 801dfdc:	6042      	str	r2, [r0, #4]
 801dfde:	b16b      	cbz	r3, 801dffc <__cxa_rethrow+0x2c>
 801dfe0:	f893 2020 	ldrb.w	r2, [r3, #32]
 801dfe4:	2a47      	cmp	r2, #71	; 0x47
 801dfe6:	d00b      	beq.n	801e000 <__cxa_rethrow+0x30>
 801dfe8:	2200      	movs	r2, #0
 801dfea:	6002      	str	r2, [r0, #0]
 801dfec:	f103 0420 	add.w	r4, r3, #32
 801dff0:	4620      	mov	r0, r4
 801dff2:	f7f2 ff33 	bl	8010e5c <_Unwind_Resume_or_Rethrow>
 801dff6:	4620      	mov	r0, r4
 801dff8:	f7ff fef6 	bl	801dde8 <__cxa_begin_catch>
 801dffc:	f7ff f94c 	bl	801d298 <_ZSt9terminatev>
 801e000:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
 801e004:	2a4e      	cmp	r2, #78	; 0x4e
 801e006:	d1ef      	bne.n	801dfe8 <__cxa_rethrow+0x18>
 801e008:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
 801e00c:	2a55      	cmp	r2, #85	; 0x55
 801e00e:	d1eb      	bne.n	801dfe8 <__cxa_rethrow+0x18>
 801e010:	f893 2023 	ldrb.w	r2, [r3, #35]	; 0x23
 801e014:	2a43      	cmp	r2, #67	; 0x43
 801e016:	d1e7      	bne.n	801dfe8 <__cxa_rethrow+0x18>
 801e018:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 801e01c:	2a43      	cmp	r2, #67	; 0x43
 801e01e:	d1e3      	bne.n	801dfe8 <__cxa_rethrow+0x18>
 801e020:	f893 2025 	ldrb.w	r2, [r3, #37]	; 0x25
 801e024:	2a2b      	cmp	r2, #43	; 0x2b
 801e026:	d1df      	bne.n	801dfe8 <__cxa_rethrow+0x18>
 801e028:	f893 2026 	ldrb.w	r2, [r3, #38]	; 0x26
 801e02c:	2a2b      	cmp	r2, #43	; 0x2b
 801e02e:	d1db      	bne.n	801dfe8 <__cxa_rethrow+0x18>
 801e030:	f893 2027 	ldrb.w	r2, [r3, #39]	; 0x27
 801e034:	2a01      	cmp	r2, #1
 801e036:	d8d7      	bhi.n	801dfe8 <__cxa_rethrow+0x18>
 801e038:	695a      	ldr	r2, [r3, #20]
 801e03a:	4252      	negs	r2, r2
 801e03c:	615a      	str	r2, [r3, #20]
 801e03e:	e7d5      	b.n	801dfec <__cxa_rethrow+0x1c>

0801e040 <__cxa_current_exception_type>:
 801e040:	b508      	push	{r3, lr}
 801e042:	f7fe fe39 	bl	801ccb8 <__cxa_get_globals>
 801e046:	6800      	ldr	r0, [r0, #0]
 801e048:	b130      	cbz	r0, 801e058 <__cxa_current_exception_type+0x18>
 801e04a:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 801e04e:	2b01      	cmp	r3, #1
 801e050:	bf04      	itt	eq
 801e052:	6800      	ldreq	r0, [r0, #0]
 801e054:	3878      	subeq	r0, #120	; 0x78
 801e056:	6800      	ldr	r0, [r0, #0]
 801e058:	bd08      	pop	{r3, pc}
 801e05a:	bf00      	nop

0801e05c <_ZSt15set_new_handlerPFvvE>:
 801e05c:	f241 6370 	movw	r3, #5744	; 0x1670
 801e060:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e064:	681a      	ldr	r2, [r3, #0]
 801e066:	6018      	str	r0, [r3, #0]
 801e068:	4610      	mov	r0, r2
 801e06a:	4770      	bx	lr

0801e06c <__EH_FRAME_BEGIN__>:
 801e06c:	0000 0000                                   ....

0801e070 <_init>:
 801e070:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801e072:	bf00      	nop
 801e074:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801e076:	bc08      	pop	{r3}
 801e078:	469e      	mov	lr, r3
 801e07a:	4770      	bx	lr

0801e07c <_fini>:
 801e07c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801e07e:	bf00      	nop
 801e080:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801e082:	bc08      	pop	{r3}
 801e084:	469e      	mov	lr, r3
 801e086:	4770      	bx	lr

Disassembly of section .ramfunc:

0801e088 <ff_test_term_timerproc>:
volatile UINT Timer;		/* Performance timer (1kHz increment) */

/* called by a timer interrupt-handler every 1ms */
void ff_test_term_timerproc (void)
{
	Timer++;
 801e088:	4b02      	ldr	r3, [pc, #8]	; (801e094 <_etext+0xc>)
 801e08a:	681a      	ldr	r2, [r3, #0]
 801e08c:	3201      	adds	r2, #1
 801e08e:	601a      	str	r2, [r3, #0]
 801e090:	4770      	bx	lr
 801e092:	bf00      	nop
 801e094:	200021bc 	.word	0x200021bc
